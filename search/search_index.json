{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArchiPy Documentation","text":"<p>ArchiPy is a Python framework designed to provide a standardized, scalable, and maintainable architecture for modern applications. Built with Python 3.13+, it offers a suite of tools, utilities, and best practices to streamline development workflows while adhering to clean architecture principles and modern Python practices.</p>"},{"location":"#goals","title":"Goals","text":"<p>ArchiPy is built with the following objectives in mind:</p> <ol> <li>Database Integration - Provide robust, type-safe database adapters for PostgreSQL, SQLite, and StarRocks</li> <li>Configuration Management - Simplify and standardize configuration handling with validation</li> <li>Service Integration - Offer ready-to-use adapters for common services (Redis, Email, Keycloak, MinIO, Kafka)</li> <li>Data Standardization - Enforce consistency in data modeling with modern type hints</li> <li>Development Efficiency - Provide comprehensive utilities and helpers for common tasks</li> <li>Quality Assurance - Enable robust testing and code quality enforcement</li> </ol>"},{"location":"#features","title":"Features","text":"<ul> <li>Database Integration: Dedicated adapters for PostgreSQL, SQLite, and StarRocks with SQLAlchemy integration</li> <li>Configuration Management: Type-safe configuration with environment variable support</li> <li>Service Adapters: Pre-built adapters for Redis, Email, Keycloak, MinIO, and Kafka</li> <li>Payment Processing: Payment gateway adapters for online transaction processing</li> <li>Data Standardization: Base entities, DTOs, and modern type hints</li> <li>Helper Utilities: Decorators, interceptors, and security utilities</li> <li>Testing &amp; Quality: BDD testing and automated code quality tools</li> <li>Performance &amp; Scalability: Connection pooling, caching, and async support</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Architecture Overview</li> <li>API Reference</li> <li>Examples</li> <li>Contributing</li> </ul>"},{"location":"architecture/","title":"ArchiPy Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>ArchiPy is organized into four main modules, each serving a specific purpose in creating structured, maintainable Python applications:</p> <ol> <li>Adapters: External service integrations</li> <li>Configs: Configuration management</li> <li>Helpers: Utility functions and support classes</li> <li>Models: Core data structures</li> </ol> <p>This architecture follows clean architecture principles, separating concerns and ensuring that dependencies point inward toward the domain core.</p>"},{"location":"architecture/#modules","title":"Modules","text":""},{"location":"architecture/#adapters","title":"Adapters","text":"<p>The <code>adapters</code> module provides implementations for external service integrations, following the Ports and Adapters pattern (Hexagonal Architecture). This module includes:</p> <ul> <li> <p>Base Adapters: Core implementations and interfaces</p> <ul> <li>SQLAlchemy base components</li> <li>Common adapter patterns</li> <li>Base session management</li> </ul> </li> <li> <p>Database Adapters: Database-specific implementations</p> <ul> <li>PostgreSQL</li> <li>SQLite</li> <li>StarRocks</li> <li>Each with their own SQLAlchemy integration</li> </ul> </li> <li> <p>Service Adapters: External service integrations</p> <ul> <li>Email service adapters</li> <li>External API clients</li> <li>File storage adapters (MinIO)</li> <li>Message brokers (Kafka)</li> <li>Caching systems (Redis)</li> </ul> </li> </ul> <p>Each adapter includes both concrete implementations and corresponding mocks for testing.</p>"},{"location":"architecture/#configs","title":"Configs","text":"<p>The <code>configs</code> module manages configuration loading, validation, and injection. It provides:</p> <ul> <li>Environment-based configuration</li> <li>Type-safe configuration through Pydantic models</li> <li>Centralized access to configuration values</li> <li>Support for various configuration sources (environment variables, files, etc.)</li> </ul>"},{"location":"architecture/#helpers","title":"Helpers","text":"<p>The <code>helpers</code> module contains utility functions and classes to simplify common development tasks. It includes several subgroups:</p> <ul> <li>Utils: General utility functions for dates, strings, errors, files, etc.</li> <li>Decorators: Function and class decorators for aspects like logging, timing, and deprecation</li> <li>Interceptors: Classes for cross-cutting concerns like logging, tracing, and validation</li> <li>Validators: Data validation utilities</li> </ul>"},{"location":"architecture/#models","title":"Models","text":"<p>The <code>models</code> module defines the core data structures used throughout the application:</p> <ul> <li>Entities: Domain model objects</li> <li>DTOs: Data Transfer Objects for API input/output</li> <li>Errors: Custom exception classes</li> <li>Types: Type definitions and enumerations</li> </ul>"},{"location":"architecture/#architectural-flow","title":"Architectural Flow","text":"<p>ArchiPy applications follow a clean architecture approach where:</p> <ol> <li>The Models module forms the core domain layer</li> <li>The Helpers module provides supporting functionality</li> <li>The Configs module manages application configuration</li> <li>The Adapters module interfaces with external systems</li> </ol> <p>This modular organization promotes separation of concerns, making ArchiPy applications easier to test, maintain, and extend over time.</p>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":"<p>ArchiPy is designed to standardize and simplify Python application development by providing a flexible set of building blocks that work across different architectural approaches. Rather than enforcing a single architectural pattern, ArchiPy offers components that can be applied to:</p> <ul> <li>Layered Architecture</li> <li>Hexagonal Architecture (Ports &amp; Adapters)</li> <li>Clean Architecture</li> <li>Domain-Driven Design</li> <li>Service-Oriented Architecture</li> <li>And more...</li> </ul> <p>These building blocks help maintain consistency, testability, and maintainability regardless of the specific architectural style chosen for your project.</p>"},{"location":"architecture/#core-building-blocks","title":"Core Building Blocks","text":""},{"location":"architecture/#configuration-management","title":"Configuration Management","text":"<p>ArchiPy provides a standardized way to manage configuration across your application:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    DATABASE = {\n        \"HOST\": \"localhost\",\n        \"PORT\": 5432,\n        \"USERNAME\": \"user\",\n        \"PASSWORD\": \"password\"\n    }\n\n    DEBUG = True\n\n# Set global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"architecture/#adapters-ports","title":"Adapters &amp; Ports","text":"<p>ArchiPy implements the ports and adapters pattern to isolate the application core from external dependencies:</p> <pre><code># Port: defines an interface (contract)\nfrom typing import Protocol\n\nclass UserRepositoryPort(Protocol):\n    def get_by_id(self, user_id: str) -&gt; User: ...\n    def create(self, user: User) -&gt; User: ...\n\n# Adapter: implements the interface for a specific technology\nclass SqlAlchemyUserRepository:\n    def __init__(self, db_adapter: SqlAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n# Application core uses the port, not the adapter\nclass UserService:\n    def __init__(self, repository: UserRepositoryPort):\n        self.repository = repository\n\n    def get_user(self, user_id: str) -&gt; User:\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"architecture/#entity-models","title":"Entity Models","text":"<p>Standardized entity models provide a consistent approach to domain modeling:</p> <pre><code>from sqlalchemy import Column, String\nfrom archipy.models.entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    name = Column(String(100))\n    email = Column(String(255), unique=True)\n</code></pre>"},{"location":"architecture/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>Define consistent data structures for transferring data between layers:</p> <pre><code>from pydantic import BaseModel, EmailStr\nfrom archipy.models.dtos import BaseDTO\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: EmailStr\n\nclass UserResponseDTO(BaseDTO):\n    id: str\n    name: str\n    email: EmailStr\n    created_at: datetime\n</code></pre>"},{"location":"architecture/#example-architectures","title":"Example Architectures","text":""},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":"<p>ArchiPy can be used with a traditional layered architecture approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Presentation      \u2502  API, UI, CLI\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     Application       \u2502  Services, Workflows\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Domain          \u2502  Business Logic, Entities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Infrastructure     \u2502  Adapters, Repositories, External Services\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#clean-architecture","title":"Clean Architecture","text":"<p>ArchiPy supports Clean Architecture principles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Entities                    \u2502\n\u2502     Domain models, business rules            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                  Use Cases                   \u2502\n\u2502     Application services, business workflows \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 Interfaces                   \u2502\n\u2502     Controllers, presenters, gateways        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                Frameworks                    \u2502\n\u2502     External libraries, UI, DB, devices      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#hexagonal-architecture","title":"Hexagonal Architecture","text":"<p>For projects using a Hexagonal (Ports &amp; Adapters) approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                   \u2502\n\u2502                 Application Core                  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2502           Domain Logic / Models             \u2502  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502  Input      \u2502         \u2502  Output Ports       \u2502  \u2502\n\u2502  \u2502  Ports      \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25b2                           \u25b2\n        \u2502                           \u2502\n        \u2502                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  \u2502      \u2502                     \u2502\n\u2502  Input Adapters  \u2502      \u2502  Output Adapters    \u2502\n\u2502  (Controllers)   \u2502      \u2502  (Repositories,     \u2502\n\u2502                  \u2502      \u2502   Clients, etc.)    \u2502\n\u2502                  \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#practical-implementation","title":"Practical Implementation","text":"<p>Let's see how a complete application might be structured using ArchiPy:</p> <pre><code>my_app/\n\u251c\u2500\u2500 configs/\n\u2502   \u2514\u2500\u2500 app_config.py          # Application configuration\n\u251c\u2500\u2500 adapters/\n\u2502   \u251c\u2500\u2500 db/                    # Database adapters\n\u2502   \u2514\u2500\u2500 api/                   # API adapters\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 models/                # Domain models\n\u2502   \u251c\u2500\u2500 ports/                 # Interface definitions\n\u2502   \u2514\u2500\u2500 services/              # Business logic\n\u251c\u2500\u2500 repositories/              # Data access\n\u251c\u2500\u2500 api/                       # API routes\n\u2514\u2500\u2500 main.py                    # Application entry point\n</code></pre>"},{"location":"architecture/#code-example","title":"Code Example","text":"<p>Here's how you might structure a FastAPI application using ArchiPy:</p> <pre><code># adapters/db/user_repository.py\nfrom archipy.adapters.postgres.sqlalchemy.adapters import SQLAlchemyAdapter\nfrom core.models.user import User\n\n\nclass UserRepository:\n    def __init__(self, db_adapter: SQLAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_user_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create_user(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n\n# core/services/user_service.py\nfrom core.models.user import User\nfrom adapters.db.user_repository import UserRepository\n\n\nclass UserService:\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n\n    def register_user(self, name: str, email: str) -&gt; User:\n        # Business logic and validation here\n        user = User(name=name, email=email)\n        return self.user_repository.create_user(user)\n\n\n# api/users.py\nfrom fastapi import APIRouter, Depends\nfrom core.services.user_service import UserService\nfrom archipy.models.dtos import BaseDTO\n\nrouter = APIRouter()\n\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: str\n\n\n@router.post(\"/users/\")\ndef create_user(\n        data: UserCreateDTO,\n        user_service: UserService = Depends(get_user_service)\n):\n    user = user_service.register_user(data.name, data.email)\n    return {\"id\": str(user.test_uuid), \"name\": user.name, \"email\": user.email}\n\n\n# main.py\nfrom fastapi import FastAPI\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\napp.include_router(users_router)\n</code></pre> <p>By providing standardized building blocks rather than enforcing a specific architecture, ArchiPy helps teams maintain consistent development practices while allowing flexibility to choose the architectural pattern that best fits their needs.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to ArchiPy are documented in this changelog, organized by version.</p>"},{"location":"changelog/#321-2025-05-20","title":"[3.2.1] - 2025-05-20","text":""},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#elastic-apm-configuration","title":"Elastic APM Configuration","text":"<ul> <li>Enhanced Elastic APM configuration and integration:<ul> <li>Refactored configuration logic for improved maintainability</li> <li>Updated configuration templates for greater flexibility</li> <li>Improved gRPC tracing interceptor for better observability</li> <li>Refined application utility functions related to APM</li> </ul> </li> </ul>"},{"location":"changelog/#320-2025-05-20","title":"[3.2.0] - 2025-05-20","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#keycloak-integration","title":"Keycloak Integration","text":"<ul> <li>Added and refactored methods for creating realms, clients, and client roles in Keycloak adapters (sync and async)</li> <li>Improved admin credential support and configuration for Keycloak</li> <li>Enhanced type hints and readability in Keycloak step definitions</li> </ul>"},{"location":"changelog/#utilities","title":"Utilities","text":"<ul> <li>Introduced string utility functions for case conversion (snake_case \u2194 camelCase)</li> </ul>"},{"location":"changelog/#configuration","title":"Configuration","text":"<ul> <li>Expanded .env.example with more detailed configuration options for services</li> <li>Improved KeycloakConfig with admin fields for easier testing and setup</li> </ul>"},{"location":"changelog/#documentation-code-quality","title":"Documentation &amp; Code Quality","text":"<ul> <li>Improved and clarified usage examples and step definitions</li> <li>Reformatted Python files to comply with Ruff checks</li> <li>Minor refactoring for better code clarity and maintainability</li> </ul>"},{"location":"changelog/#311-2025-05-17","title":"[3.1.1] - 2025-05-17","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Enhanced project documentation</li> <li>Improved usage examples</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":""},{"location":"changelog/#configuration_1","title":"Configuration","text":"<ul> <li>Updated configuration templates</li> <li>Enhanced Kafka configuration template with improved settings</li> <li>Optimized template structure for better usability</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Resolved merge conflicts</li> <li>Streamlined codebase integration</li> </ul>"},{"location":"changelog/#310-2025-05-15","title":"[3.1.0] - 2025-05-15","text":""},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#payment-gateway","title":"Payment Gateway","text":"<ul> <li>Implemented Parsian Internet Payment Gateway adapter</li> <li>Added comprehensive IPG integration support</li> <li>Enhanced payment processing capabilities</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Updated adapter documentation</li> <li>Improved IPG integration examples</li> <li>Refactored Parsian adapter code structure</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Eliminated redundant error messages</li> <li>Streamlined error handling</li> </ul>"},{"location":"changelog/#301-2025-04-27","title":"[3.0.1] - 2025-04-27","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":""},{"location":"changelog/#code-quality","title":"Code Quality","text":"<ul> <li>Fixed import error in module dependencies</li> </ul>"},{"location":"changelog/#300-2025-04-27","title":"[3.0.0] - 2025-04-27","text":""},{"location":"changelog/#changed_3","title":"Changed","text":""},{"location":"changelog/#database-adapters","title":"Database Adapters","text":"<ul> <li>Refactor StarRocks driver integration</li> <li>Refactor SQLite driver integration</li> <li>Enhanced database adapter support</li> <li>Updated dependencies for StarRocks compatibility</li> </ul>"},{"location":"changelog/#configuration_2","title":"Configuration","text":"<ul> <li>Updated ElasticSearch Config Template</li> <li>Enhanced configuration management</li> <li>Improved dependency handling</li> </ul>"},{"location":"changelog/#code-quality_1","title":"Code Quality","text":"<ul> <li>Improved type safety across adapters</li> <li>Enhanced error handling</li> <li>Optimized connection management</li> </ul>"},{"location":"changelog/#201-2025-04-27","title":"[2.0.1] - 2025-04-27","text":""},{"location":"changelog/#added_2","title":"Added","text":""},{"location":"changelog/#starrocks","title":"StarRocks","text":"<ul> <li>Added StarRocks driver integration</li> <li>Enhanced database adapter support</li> <li>Updated dependencies for StarRocks compatibility</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":""},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Updated poetry.lock with new dependencies</li> <li>Enhanced package compatibility</li> <li>Updated ElasticSearch Config Template</li> </ul>"},{"location":"changelog/#200-2025-04-27","title":"[2.0.0] - 2025-04-27","text":""},{"location":"changelog/#changed_5","title":"Changed","text":""},{"location":"changelog/#models","title":"Models","text":"<ul> <li>Refactored range DTOs for better type safety and validation</li> <li>Enhanced pagination DTO implementation</li> <li>Added time interval unit type support</li> </ul>"},{"location":"changelog/#code-quality_2","title":"Code Quality","text":"<ul> <li>Improved type hints in DTO implementations</li> <li>Enhanced validation in range operations</li> <li>Optimized DTO serialization</li> </ul>"},{"location":"changelog/#103-2025-04-20","title":"[1.0.3] - 2025-04-20","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Updated atomic transaction documentation with detailed examples</li> <li>Enhanced feature documentation with clear scenarios</li> <li>Added comprehensive step definitions for BDD tests</li> </ul>"},{"location":"changelog/#code-quality_3","title":"Code Quality","text":"<ul> <li>Improved SQLAlchemy atomic decorator implementation</li> <li>Enhanced test coverage for atomic transactions</li> <li>Updated BDD test scenarios for better clarity</li> </ul>"},{"location":"changelog/#102-2025-04-20","title":"[1.0.2] - 2025-04-20","text":""},{"location":"changelog/#documentation_3","title":"Documentation","text":""},{"location":"changelog/#api-reference","title":"API Reference","text":"<ul> <li>Updated adapter documentation with new architecture details</li> <li>Enhanced API reference structure and organization</li> <li>Added comprehensive usage examples</li> </ul>"},{"location":"changelog/#general-documentation","title":"General Documentation","text":"<ul> <li>Improved installation guide with detailed setup instructions</li> <li>Enhanced feature documentation with clear examples</li> <li>Updated usage guide with new architecture patterns</li> </ul>"},{"location":"changelog/#code-quality_4","title":"Code Quality","text":"<ul> <li>Updated dependencies in poetry.lock and pyproject.toml</li> <li>Enhanced documentation consistency and clarity</li> </ul>"},{"location":"changelog/#101-2025-04-20","title":"[1.0.1] - 2025-04-20","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":""},{"location":"changelog/#error-handling","title":"Error Handling","text":"<ul> <li>Enhanced exception capture in all scenarios</li> <li>Improved error handling robustness across components</li> <li>Added comprehensive error logging</li> </ul>"},{"location":"changelog/#code-quality_5","title":"Code Quality","text":"<ul> <li>Strengthened error recovery mechanisms</li> <li>Enhanced error reporting and debugging capabilities</li> </ul>"},{"location":"changelog/#100-2025-04-20","title":"[1.0.0] - 2025-04-20","text":""},{"location":"changelog/#architecture","title":"Architecture","text":""},{"location":"changelog/#database-adapters_1","title":"Database Adapters","text":"<ul> <li>Refactored database adapter architecture for better modularity</li> <li>Separated base SQLAlchemy functionality from specific database implementations</li> <li>Introduced dedicated adapters for PostgreSQL, SQLite, and StarRocks</li> <li>Enhanced session management with improved registry system</li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":""},{"location":"changelog/#postgresql-support","title":"PostgreSQL Support","text":"<ul> <li>Implemented dedicated PostgreSQL adapter with optimized connection handling</li> <li>Added PostgreSQL-specific session management</li> <li>Enhanced configuration options for PostgreSQL connections</li> </ul>"},{"location":"changelog/#sqlite-support","title":"SQLite Support","text":"<ul> <li>Added dedicated SQLite adapter with improved transaction handling</li> <li>Implemented SQLite-specific session management</li> <li>Enhanced mock testing capabilities for SQLite</li> </ul>"},{"location":"changelog/#starrocks-support","title":"StarRocks Support","text":"<ul> <li>Introduced StarRocks database adapter</li> <li>Implemented StarRocks-specific session management</li> <li>Added configuration support for StarRocks connections</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":""},{"location":"changelog/#core-architecture","title":"Core Architecture","text":"<ul> <li>Moved base SQLAlchemy functionality to <code>adapters/base/sqlalchemy</code></li> <li>Refactored session management system for better extensibility</li> <li>Improved atomic transaction decorator implementation</li> </ul>"},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>Updated API reference for new adapter structure</li> <li>Enhanced configuration documentation</li> <li>Added examples for new database adapters</li> </ul>"},{"location":"changelog/#code-quality_6","title":"Code Quality","text":"<ul> <li>Improved type safety across database adapters</li> <li>Enhanced error handling in session management</li> <li>Optimized connection pooling implementation</li> </ul>"},{"location":"changelog/#0143-2025-04-26","title":"[0.14.3] - 2025-04-26","text":""},{"location":"changelog/#added_4","title":"Added","text":""},{"location":"changelog/#adapters","title":"Adapters","text":"<ul> <li>Major database adapter refactoring</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix capture exeptrioin in all senario</li> </ul>"},{"location":"changelog/#0142-2025-04-20","title":"[0.14.2] - 2025-04-20","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":""},{"location":"changelog/#keycloak","title":"Keycloak","text":"<ul> <li>Resolved linter errors in Keycloak integration</li> <li>Enhanced code quality in authentication components</li> </ul>"},{"location":"changelog/#code-quality_7","title":"Code Quality","text":"<ul> <li>Improved type safety in Keycloak adapters</li> <li>Enhanced error handling in authentication flows</li> </ul>"},{"location":"changelog/#0141-2025-04-20","title":"[0.14.1] - 2025-04-20","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":""},{"location":"changelog/#database","title":"Database","text":"<ul> <li>Resolved \"DEFAULT\" server_default value issue in BaseEntity timestamps</li> <li>Enhanced timestamp handling in database entities</li> </ul>"},{"location":"changelog/#code-quality_8","title":"Code Quality","text":"<ul> <li>Improved database entity configuration</li> <li>Enhanced type safety in entity definitions</li> </ul>"},{"location":"changelog/#0140-2025-04-16","title":"[0.14.0] - 2025-04-16","text":""},{"location":"changelog/#added_5","title":"Added","text":""},{"location":"changelog/#kafka-integration","title":"Kafka Integration","text":"<ul> <li>Implemented comprehensive Kafka adapter system with ports and adapters</li> <li>Added test suite for Kafka adapters</li> <li>Enhanced Kafka documentation with detailed usage examples</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>Refactored and improved documentation structure</li> <li>Added comprehensive Kafka integration guides</li> <li>Enhanced docstrings for better code understanding</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":""},{"location":"changelog/#code-quality_9","title":"Code Quality","text":"<ul> <li>Resolved linting issues in configuration templates</li> <li>Fixed lint errors in Keycloak adapters and ports</li> </ul>"},{"location":"changelog/#0135-2025-04-16","title":"[0.13.5] - 2025-04-16","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":""},{"location":"changelog/#sqlalchemy","title":"SQLAlchemy","text":"<ul> <li>Resolved sorting functionality in SQLAlchemy mixin</li> <li>Enhanced query sorting capabilities with improved error handling</li> </ul>"},{"location":"changelog/#code-quality_10","title":"Code Quality","text":"<ul> <li>Applied ruff formatter to config_template.py for consistent code style</li> <li>Updated AsyncContextManager to AbstractAsyncContextManager to resolve UP035 lint error</li> </ul>"},{"location":"changelog/#0134-2025-04-15","title":"[0.13.4] - 2025-04-15","text":""},{"location":"changelog/#added_6","title":"Added","text":""},{"location":"changelog/#fastapi-integration","title":"FastAPI Integration","text":"<ul> <li>Implemented lifespan support for FastAPI applications</li> <li>Enhanced application lifecycle management with proper startup and shutdown handlers</li> </ul>"},{"location":"changelog/#database-configuration","title":"Database Configuration","text":"<ul> <li>Added automatic database URL generation with validation in SqlAlchemyConfig</li> <li>Improved database connection configuration with enhanced error handling</li> </ul>"},{"location":"changelog/#code-quality_11","title":"Code Quality","text":"<ul> <li>Integrated new features with comprehensive test coverage</li> <li>Enhanced configuration validation and error reporting</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Update changelogs</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":""},{"location":"changelog/#configs","title":"Configs","text":"<ul> <li>Run ruff format on config_template.py to resolve formatting issues</li> <li>Replace AsyncContextManager with AbstractAsyncContextManager to fix UP035 lint error</li> </ul>"},{"location":"changelog/#0133-2025-04-15","title":"[0.13.3] - 2025-04-15","text":""},{"location":"changelog/#added_7","title":"Added","text":""},{"location":"changelog/#cicd","title":"CI/CD","text":"<ul> <li>Implemented comprehensive linting workflow for improved code quality</li> <li>Enhanced GitHub Actions with updated tj-actions/changed-files for better change tracking</li> </ul>"},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>Added detailed documentation for range DTOs and their usage patterns</li> <li>Improved API reference documentation with new examples</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":""},{"location":"changelog/#models_1","title":"Models","text":"<ul> <li>Enhanced range DTOs with improved type safety and validation</li> <li>Updated range DTOs to support more flexible boundary conditions</li> </ul>"},{"location":"changelog/#code-quality_12","title":"Code Quality","text":"<ul> <li>Integrated automated linting for consistent code style</li> <li>Improved code formatting and documentation standards</li> </ul>"},{"location":"changelog/#0132-2025-04-10","title":"[0.13.2] - 2025-04-10","text":""},{"location":"changelog/#documentation_7","title":"Documentation","text":"<ul> <li>Enhanced Redis adapter documentation with comprehensive docstrings</li> <li>Added MinIO adapter to API reference documentation</li> </ul>"},{"location":"changelog/#code-quality_13","title":"Code Quality","text":"<ul> <li>Improved code quality with linter fixes across Redis adapter and ORM components</li> <li>Fixed file utilities test suite</li> <li>Cleaned up redundant changelog files</li> </ul>"},{"location":"changelog/#0131-2025-04-08","title":"[0.13.1] - 2025-04-08","text":""},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Enhanced cryptographic security by replacing <code>random</code> with <code>secrets</code> module</li> <li>Strengthened TOTP implementation with improved security practices</li> <li>Upgraded password utilities with robust validation and generation</li> </ul>"},{"location":"changelog/#code-quality_14","title":"Code Quality","text":"<ul> <li>Improved type safety with explicit typing and modern type hints</li> <li>Enhanced error handling with domain-specific exception types</li> <li>Standardized parameter naming and module consistency</li> </ul>"},{"location":"changelog/#documentation_8","title":"Documentation","text":"<ul> <li>Added comprehensive docstrings to configuration classes</li> <li>Expanded utility function documentation</li> <li>Improved error handling documentation</li> </ul>"},{"location":"changelog/#0130-2025-04-08","title":"[0.13.0] - 2025-04-08","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>MinIO Integration: Full S3-compatible object storage adapter with:<ul> <li>Comprehensive S3 operation support (12 standardized methods)</li> <li>Built-in TTL caching for performance optimization</li> <li>Flexible configuration with endpoint and credential management</li> <li>Clear cache management through <code>clear_all_caches</code></li> </ul> </li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added complete BDD test suite for MinIO adapter:<ul> <li>Bucket and object operation validation</li> <li>Presigned URL generation testing</li> <li>Bucket policy management verification</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_9","title":"Documentation","text":"<ul> <li>Added extensive MinIO adapter examples and usage guides</li> <li>Improved error handling documentation</li> <li>Updated configuration documentation with new MinIO settings</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code># Initialize the MinIO adapter\nfrom archipy.adapters.minio.adapters import MinioAdapter\n\nminio = MinioAdapter()\n\n# Create a bucket and upload a file\nminio.make_bucket(\"my-bucket\")\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/document.pdf\")\n\n# Generate a presigned URL for temporary access\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\", expires=3600)\n</code></pre>"},{"location":"changelog/#0120-2025-03-29","title":"[0.12.0] - 2025-03-29","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Keycloak Integration: Comprehensive authentication and authorization for FastAPI:<ul> <li>Role-based access control with customizable requirements</li> <li>Resource-based authorization for fine-grained access control</li> <li>Both synchronous and asynchronous authentication flows</li> <li>Token validation and introspection</li> <li>User info extraction capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#code-quality_15","title":"Code Quality","text":"<ul> <li>Improved error handling clarity by renaming <code>ExceptionMessageType</code> to <code>ErrorMessageType</code></li> <li>Enhanced error documentation with detailed descriptions</li> <li>Updated error handling implementation with new message types</li> </ul>"},{"location":"changelog/#usage-example_1","title":"Usage Example","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.keycloak_utils import KeycloakUtils\n\napp = FastAPI()\n\n\n@app.get(\"/api/profile\")\ndef get_profile(user: dict = Depends(KeycloakUtils.fastapi_auth(\n    required_roles={\"user\"},\n    admin_roles={\"admin\"}\n))):\n    return {\n        \"user_id\": user.get(\"sub\"),\n        \"username\": user.get(\"preferred_username\")\n    }\n</code></pre>"},{"location":"changelog/#0112-2025-03-21","title":"[0.11.2] - 2025-03-21","text":""},{"location":"changelog/#error-handling_1","title":"Error Handling","text":"<ul> <li>Enhanced exception management with improved error reporting</li> <li>Streamlined error messaging for better debugging</li> <li>Fixed various error handling edge cases</li> </ul>"},{"location":"changelog/#0111-2025-03-15","title":"[0.11.1] - 2025-03-15","text":""},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>Optimized resource usage across core components</li> <li>Enhanced caching mechanisms for improved performance</li> <li>Improved memory utilization in key operations</li> </ul>"},{"location":"changelog/#0110-2025-03-10","title":"[0.11.0] - 2025-03-10","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Keycloak Adapter: New authentication and authorization system:<ul> <li>Asynchronous operations support</li> <li>Token management and validation</li> <li>User information retrieval</li> <li>Comprehensive security features</li> </ul> </li> </ul>"},{"location":"changelog/#performance_1","title":"Performance","text":"<ul> <li>Added TTL cache decorator for optimized performance</li> <li>Improved Keycloak adapter efficiency</li> </ul>"},{"location":"changelog/#documentation_10","title":"Documentation","text":"<ul> <li>Added detailed Keycloak integration guides</li> <li>Included comprehensive usage examples</li> </ul>"},{"location":"changelog/#usage-example_2","title":"Usage Example","text":"<pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Initialize adapter with configuration from global config\nkeycloak = KeycloakAdapter()\n\n# Authenticate and get access token\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Get user information\nuser_info = keycloak.get_userinfo(token)\n\n# Verify token validity\nis_valid = keycloak.validate_token(token)\n</code></pre>"},{"location":"changelog/#0102-2025-03-05","title":"[0.10.2] - 2025-03-05","text":""},{"location":"changelog/#stability","title":"Stability","text":"<ul> <li>Improved Redis connection pool stability and management</li> <li>Enhanced error recovery mechanisms</li> <li>Fixed various edge cases in Redis operations</li> </ul>"},{"location":"changelog/#0101-2025-03-01","title":"[0.10.1] - 2025-03-01","text":""},{"location":"changelog/#documentation_11","title":"Documentation","text":"<ul> <li>Enhanced Redis and email adapter documentation</li> <li>Added comprehensive API reference</li> <li>Improved usage examples for common operations</li> </ul>"},{"location":"changelog/#0100-2025-02-25","title":"[0.10.0] - 2025-02-25","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li> <p>Redis Integration: New caching and key-value storage system:</p> <ul> <li>Flexible key-value operations</li> <li>Built-in TTL support</li> <li>Connection pooling</li> <li>Comprehensive error handling</li> </ul> </li> <li> <p>Email Service: New email integration system:</p> <ul> <li>Multiple email provider support</li> <li>Template-based email sending</li> <li>Attachment handling</li> <li>Async operation support</li> </ul> </li> </ul>"},{"location":"changelog/#configuration_3","title":"Configuration","text":"<ul> <li>Enhanced configuration management system</li> <li>Added support for Redis and email settings</li> <li>Improved environment variable handling</li> </ul>"},{"location":"changelog/#usage-example_3","title":"Usage Example","text":"<pre><code># Initialize the Redis adapter\nfrom archipy.adapters.redis.adapters import RedisAdapter\n\nredis = RedisAdapter()\n\n# Basic operations\nredis.set(\"user:1:name\", \"John Doe\")\nname = redis.get(\"user:1:name\")\n\n# Using with TTL\nredis.set(\"session:token\", \"abc123\", ttl=3600)  # Expires in 1 hour\n</code></pre>"},{"location":"changelog/#090-2025-02-20","title":"[0.9.0] - 2025-02-20","text":""},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li> <p>TOTP System: Comprehensive Time-based One-Time Password implementation:</p> <ul> <li>Secure token generation and validation</li> <li>Configurable time windows</li> <li>Built-in expiration handling</li> <li>RFC compliance</li> </ul> </li> <li> <p>Multi-Factor Authentication: Enhanced security framework:</p> <ul> <li>Multiple authentication factor support</li> <li>Flexible factor configuration</li> <li>Integration with existing auth systems</li> </ul> </li> </ul>"},{"location":"changelog/#usage-example_4","title":"Usage Example","text":"<pre><code>from archipy.helpers.utils.totp_utils import TOTPUtils\nfrom uuid import uuid4\n\n# Generate a TOTP code\nuser_id = uuid4()\ntotp_code, expires_at = TOTPUtils.generate_totp(user_id)\n\n# Verify a TOTP code\nis_valid = TOTPUtils.verify_totp(user_id, totp_code)\n\n# Generate a secure key for TOTP initialization\nsecret_key = TOTPUtils.generate_secret_key_for_totp()\n</code></pre>"},{"location":"changelog/#080-2025-02-15","title":"[0.8.0] - 2025-02-15","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Redis Integration: Comprehensive key-value store and caching system:<ul> <li>Full Redis API implementation</li> <li>Built-in caching functionality</li> <li>Performance-optimized operations</li> <li>Connection pooling support</li> </ul> </li> </ul>"},{"location":"changelog/#testing_1","title":"Testing","text":"<ul> <li>Mock Redis Implementation:<ul> <li>Complete test coverage for Redis operations</li> <li>Simulated Redis environment for testing</li> <li>Configurable mock behaviors</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_12","title":"Documentation","text":"<ul> <li>Added Redis integration guides</li> <li>Included mock testing examples</li> <li>Updated configuration documentation</li> </ul>"},{"location":"changelog/#072-2025-02-10","title":"[0.7.2] - 2025-02-10","text":""},{"location":"changelog/#database_1","title":"Database","text":"<ul> <li>Enhanced connection pool stability and management</li> <li>Improved transaction isolation and handling</li> <li>Optimized error reporting for database operations</li> <li>Added connection lifecycle management</li> </ul>"},{"location":"changelog/#071-2025-02-05","title":"[0.7.1] - 2025-02-05","text":""},{"location":"changelog/#performance_2","title":"Performance","text":"<ul> <li>Optimized query execution and planning</li> <li>Reduced memory footprint for ORM operations</li> <li>Enhanced connection pool efficiency</li> <li>Improved cache utilization</li> </ul>"},{"location":"changelog/#070-2025-02-01","title":"[0.7.0] - 2025-02-01","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>SQLAlchemy Integration: Complete ORM implementation:<ul> <li>Robust entity model system</li> <li>Transaction management with ACID compliance</li> <li>Connection pooling with configurable settings</li> <li>Comprehensive database operations support</li> </ul> </li> </ul>"},{"location":"changelog/#usage-example_5","title":"Usage Example","text":"<pre><code>from archipy.adapters.postgres.sqlalchemy.adapters import SQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    name = Column(String(100))\n    email = Column(String(100), unique=True)\n\n\n# Use the ORM\norm = SQLAlchemyAdapter()\nwith orm.session() as session:\n    # Create and read operations\n    new_user = User(name=\"John Doe\", email=\"john@example.com\")\n    session.add(new_user)\n    session.commit()\n\n    user = session.query(User).filter_by(email=\"john@example.com\").first()\n</code></pre>"},{"location":"changelog/#061-2025-01-25","title":"[0.6.1] - 2025-01-25","text":""},{"location":"changelog/#stability_1","title":"Stability","text":"<ul> <li>Fixed memory leaks in gRPC interceptors</li> <li>Improved interceptor performance and efficiency</li> <li>Enhanced request/response handling reliability</li> <li>Optimized resource cleanup</li> </ul>"},{"location":"changelog/#060-2025-01-20","title":"[0.6.0] - 2025-01-20","text":""},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>gRPC Integration: Comprehensive interceptor system:<ul> <li>Client and server-side interceptors</li> <li>Request/response monitoring</li> <li>Performance tracing capabilities</li> <li>Enhanced error management</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_13","title":"Documentation","text":"<ul> <li>Added gRPC integration guides</li> <li>Included interceptor configuration examples</li> <li>Updated troubleshooting documentation</li> </ul>"},{"location":"changelog/#051-2025-01-15","title":"[0.5.1] - 2025-01-15","text":""},{"location":"changelog/#stability_2","title":"Stability","text":"<ul> <li>Enhanced FastAPI middleware reliability</li> <li>Improved response processing efficiency</li> <li>Optimized request handling performance</li> <li>Fixed edge cases in error management</li> </ul>"},{"location":"changelog/#050-2025-01-10","title":"[0.5.0] - 2025-01-10","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>FastAPI Integration: Complete web framework support:<ul> <li>Custom middleware components</li> <li>Request/response processors</li> <li>Standardized error handling</li> <li>Response formatting utilities</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_14","title":"Documentation","text":"<ul> <li>Added FastAPI integration guides</li> <li>Included middleware configuration examples</li> <li>Updated API documentation</li> </ul>"},{"location":"changelog/#040-2025-01-05","title":"[0.4.0] - 2025-01-05","text":""},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Configuration System: Flexible environment management:<ul> <li>Environment variable support</li> <li>Type-safe configuration validation</li> <li>Default value management</li> <li>Override capabilities</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_15","title":"Documentation","text":"<ul> <li>Added configuration system guides</li> <li>Included environment setup examples</li> <li>Updated validation documentation</li> </ul>"},{"location":"changelog/#030-2024-12-25","title":"[0.3.0] - 2024-12-25","text":""},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Core Utilities: Comprehensive helper functions:<ul> <li>Date/time manipulation with timezone support</li> <li>String processing and formatting</li> <li>Common development utilities</li> <li>Type conversion helpers</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_16","title":"Documentation","text":"<ul> <li>Added utility function reference</li> <li>Included usage examples</li> <li>Updated API documentation</li> </ul>"},{"location":"changelog/#020-2024-12-20","title":"[0.2.0] - 2024-12-20","text":""},{"location":"changelog/#architecture_1","title":"Architecture","text":"<ul> <li>Hexagonal Architecture: Core implementation:<ul> <li>Ports and adapters pattern</li> <li>Clean architecture principles</li> <li>Domain-driven design</li> <li>Base entity models</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_17","title":"Documentation","text":"<ul> <li>Added architecture overview</li> <li>Included design pattern guides</li> <li>Updated component documentation</li> </ul>"},{"location":"changelog/#010-2025-02-21","title":"[0.1.0] - 2025-02-21","text":""},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>Initial Release: Project foundation:<ul> <li>Core project structure</li> <li>Basic framework components</li> <li>Configuration system</li> <li>CI/CD pipeline with GitHub Actions</li> </ul> </li> </ul>"},{"location":"changelog/#documentation_18","title":"Documentation","text":"<ul> <li>Added initial documentation</li> <li>Included getting started guide</li> <li>Created contribution guidelines</li> </ul>"},{"location":"contributing-docs/","title":"ArchiPy Documentation Guidelines","text":"<p>This document outlines the standards and practices for ArchiPy documentation.</p>"},{"location":"contributing-docs/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - Main configuration file for MkDocs</li> <li><code>docs/</code> - Markdown documentation files<ul> <li><code>index.md</code> - Home page</li> <li><code>api_reference/</code> - API documentation</li> <li><code>examples/</code> - Usage examples</li> <li><code>assets/</code> - Images and other static assets</li> </ul> </li> </ul>"},{"location":"contributing-docs/#writing-documentation","title":"Writing Documentation","text":""},{"location":"contributing-docs/#format-and-style","title":"Format and Style","text":"<ul> <li>Use Markdown syntax for all documentation files</li> <li>Follow the Google Python style for code examples</li> <li>Include type hints in code samples (using Python 3.13 syntax)</li> <li>Include proper exception handling with <code>raise ... from e</code> pattern</li> <li>Group related documentation in directories</li> <li>Link between documentation pages using relative links</li> </ul>"},{"location":"contributing-docs/#code-examples","title":"Code Examples","text":"<p>When including code examples:</p> <ol> <li>Include proper type hints using Python 3.13 syntax (<code>x: list[str]</code> not <code>List[str]</code>)</li> <li>Demonstrate proper error handling with exception chaining</li> <li>Include docstrings with Args, Returns, and Raises sections</li> <li>Show realistic use cases that align with ArchiPy's patterns</li> <li>Keep examples concise but complete enough to understand usage</li> </ol>"},{"location":"contributing-docs/#admonitions","title":"Admonitions","text":"<p>Use Material for MkDocs admonitions to highlight important information:</p> <pre><code>!!! note\n    This is a note.\n\n!!! warning\n    This is a warning.\n\n!!! tip\n    This is a tip.\n</code></pre>"},{"location":"contributing-docs/#building-and-previewing-documentation","title":"Building and Previewing Documentation","text":"<p>Preview the documentation locally: <pre><code>make docs-serve\n</code></pre></p> <p>Build the documentation: <pre><code>make docs-build\n</code></pre></p> <p>Deploy to GitHub Pages: <pre><code>make docs-deploy\n</code></pre></p>"},{"location":"contributing-docs/#documentation-improvement-guidelines","title":"Documentation Improvement Guidelines","text":"<p>When improving documentation:</p> <ol> <li>Ensure clarity and conciseness</li> <li>Include practical, runnable examples</li> <li>Explain \"why\" not just \"how\"</li> <li>Maintain logical navigation</li> <li>Use diagrams for complex concepts</li> <li>Validate that examples match the current API</li> <li>Test code examples to ensure they work correctly</li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Welcome to ArchiPy! We're excited that you're interested in contributing. This document outlines the process for contributing to ArchiPy.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository</li> </ol> <p>Fork the ArchiPy repository on GitHub.</p> <ol> <li>Clone Your Fork</li> </ol> <pre><code>git clone https://github.com/YOUR-USERNAME/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Set Up Development Environment</li> </ol> <pre><code>make setup\nmake install\nmake install-dev\npoetry run pre-commit install\n</code></pre> <ol> <li>Create a Branch</li> </ol> <p>Create a branch for your feature or bugfix:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>ArchiPy follows a strict code style to maintain consistency across the codebase:</p> <ul> <li>Black: For code formatting</li> <li>Ruff: For linting</li> <li>Mypy: For type checking</li> </ul> <p>All code must pass these checks before being merged:</p> <pre><code>make check\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All contributions should include appropriate tests:</p> <ul> <li>Unit Tests: For testing individual components</li> <li>Integration Tests: For testing component interactions</li> <li>BDD Tests: For behavior-driven development</li> </ul> <p>Run the tests to ensure your changes don't break existing functionality:</p> <pre><code>make test\nmake behave\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All new features or changes should be documented:</p> <ul> <li>Docstrings: Update or add docstrings to document functions, classes, and methods</li> <li>Type Annotations: Include type annotations for all functions and methods</li> <li>Documentation Files: Update relevant documentation files if necessary</li> </ul> <p>Building the documentation locally:</p> <pre><code>cd docs\nmake html\n</code></pre>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>ArchiPy follows the Conventional Commits specification for commit messages:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre> <p>Common types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Formatting changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or modifying tests</li> <li><code>chore</code>: Maintenance tasks</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update Your Branch</li> </ol> <p>Before submitting a pull request, make sure your branch is up to date with the main branch:</p> <pre><code>git checkout main\ngit pull origin main\ngit checkout your-branch\ngit rebase main\n</code></pre> <ol> <li>Run All Checks</li> </ol> <p>Ensure all checks pass:</p> <pre><code>make check\nmake test\n</code></pre> <ol> <li>Submit Your Pull Request</li> </ol> <p>Push your branch to your fork and create a pull request:</p> <pre><code>git push origin your-branch\n</code></pre> <ol> <li>Code Review</li> </ol> <p>Your pull request will be reviewed by the maintainers. They may suggest changes or improvements.</p> <ol> <li>Merge</li> </ol> <p>Once your pull request is approved, it will be merged into the main branch.</p>"},{"location":"contributing/#bug-reports-and-feature-requests","title":"Bug Reports and Feature Requests","text":"<p>If you find a bug or have a feature request, please create an issue on the GitHub issues page.</p> <p>When reporting a bug, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the bug</li> <li>Steps to reproduce the bug</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Any relevant logs or error messages</li> </ul> <p>When submitting a feature request, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the feature</li> <li>Any relevant use cases</li> <li>If possible, a sketch of how the feature might be implemented</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that ArchiPy has a code of conduct. By participating in this project, you agree to abide by its terms.</p>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Thank you for contributing to ArchiPy! Your efforts help make the project better for everyone.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#development-environment","title":"Development Environment","text":""},{"location":"development/#set-up","title":"Set Up","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Initialize the project:</li> </ol> <pre><code>make setup\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>make install\nmake install-dev  # For dev tools\npoetry run pre-commit install\n</code></pre>"},{"location":"development/#workflow","title":"Workflow","text":""},{"location":"development/#code-quality","title":"Code Quality","text":"<p>Run checks:</p> <pre><code>make check  # Runs ruff, black, mypy\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>Run tests:</p> <pre><code>make behave    # BDD tests\nmake ci        # Full pipeline\n</code></pre> <p>BDD tests use <code>behave</code> with feature files in <code>features/</code> and steps in <code>features/steps/</code>.</p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Follow Semantic Versioning:</p> <pre><code>make bump-patch  # Bug fixes\nmake bump-minor  # New features\nmake bump-major  # Breaking changes\n</code></pre> <p>Add a message:</p> <pre><code>make bump-minor message=\"Added new utility\"\n</code></pre>"},{"location":"development/#build-docs","title":"Build &amp; Docs","text":"<p>Build the package:</p> <pre><code>make build\nmake clean  # Remove artifacts\n</code></pre> <p>Build docs:</p> <pre><code>cd docs\nmake html\n</code></pre> <p>Update dependencies:</p> <pre><code>make update\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>ArchiPy provides a robust framework for structured Python development, focusing on standardization, testability, and productivity.</p>"},{"location":"features/#database-integration","title":"Database Integration","text":"<ul> <li>Multi-Database Support: Dedicated adapters for PostgreSQL, SQLite, and StarRocks</li> <li>SQLAlchemy Integration: Standardized ORM implementation with:<ul> <li>Base SQLAlchemy components for common functionality</li> <li>Database-specific session management</li> <li>Enhanced transaction handling with atomic decorators</li> <li>Connection pooling and lifecycle management</li> </ul> </li> </ul>"},{"location":"features/#configuration-management","title":"Configuration Management","text":"<ul> <li>Standardized Configs: Use <code>base_config</code> and <code>config_template</code> for consistent setup</li> <li>Injection: Seamlessly inject configurations into components</li> <li>Environment Management: Flexible environment variable handling with validation</li> <li>Type Safety: Configuration validation with Pydantic models</li> </ul>"},{"location":"features/#adapters-mocks","title":"Adapters &amp; Mocks","text":"<ul> <li>Database Adapters: Dedicated implementations for PostgreSQL, SQLite, and StarRocks</li> <li>Service Adapters: Pre-built for Redis, Email, Keycloak, MinIO, and Kafka</li> <li>Mocks: Testable mocks for isolated testing</li> <li>Async Support: Synchronous and asynchronous implementations</li> <li>Ports &amp; Adapters Pattern: Clean architecture with dependency inversion</li> </ul>"},{"location":"features/#data-standardization","title":"Data Standardization","text":"<ul> <li>Base Entities: Standardized SQLAlchemy entities with timestamp handling</li> <li>DTOs: Pydantic-based DTOs for data transfer:<ul> <li>Pagination and sorting</li> <li>Error handling</li> <li>Search and range operations</li> <li>Email and attachment handling</li> </ul> </li> <li>Type Safety: Enforced via Pydantic and modern Python type hints</li> </ul>"},{"location":"features/#helper-utilities","title":"Helper Utilities","text":"<ul> <li>Decorators:<ul> <li>Retry mechanism for resilient operations</li> <li>Singleton pattern implementation</li> <li>SQLAlchemy atomic transactions</li> <li>TTL caching for performance optimization</li> </ul> </li> <li>Interceptors:<ul> <li>FastAPI rate limiting</li> <li>gRPC tracing and monitoring</li> </ul> </li> <li>Security:<ul> <li>Keycloak integration for authentication</li> <li>TOTP implementation</li> <li>Password utilities with secure hashing</li> <li>JWT handling</li> </ul> </li> <li>Type Safety: Consistent type checking and casting</li> </ul>"},{"location":"features/#testing-quality","title":"Testing &amp; Quality","text":"<ul> <li>BDD Testing:<ul> <li>Behave integration for sync/async scenarios</li> <li>Comprehensive feature files</li> <li>Step definitions for common operations</li> </ul> </li> <li>Code Quality:<ul> <li>Automated linting with ruff</li> <li>Type checking with mypy</li> <li>Code formatting with black</li> <li>Pre-commit hooks for quality assurance</li> </ul> </li> </ul>"},{"location":"features/#best-practices-tooling","title":"Best Practices &amp; Tooling","text":"<ul> <li>Poetry: Modern dependency management</li> <li>Pre-commit: Automated code quality checks</li> <li>Clean Architecture: Hexagonal design pattern</li> <li>Modular Design: Optional dependencies for flexibility</li> <li>Comprehensive Documentation: API reference and usage examples</li> </ul>"},{"location":"features/#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Connection Pooling: Optimized database connections</li> <li>Caching: Redis integration for performance</li> <li>Async Support: Non-blocking operations</li> <li>Resource Management: Proper cleanup and lifecycle handling</li> <li>Error Recovery: Robust error handling and retry mechanisms</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.13 or higher</li> </ul> <p>ArchiPy requires Python 3.13+. Check your version with:</p> <pre><code>```bash\npython --version\n```\n</code></pre> <p>If needed, download Python 3.13+.</p> <ul> <li>Poetry (for dependency management)</li> </ul> <p>Poetry manages dependencies and project setup. Install it via the official guide.</p>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>Install the core library:</p> <pre><code>pip install archipy\n</code></pre> <p>With optional dependencies (e.g., database adapters, services):</p> <pre><code>pip install archipy[postgres,sqlite,starrocks,redis,keycloak,minio,kafka]\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using Poetry","text":"<p>Add the core library:</p> <pre><code>poetry add archipy\n</code></pre> <p>With optional dependencies:</p> <pre><code>poetry add \"archipy[postgres,sqlite,starrocks,redis,keycloak,minio,kafka]\"\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>ArchiPy supports modular features through optional dependencies:</p>"},{"location":"installation/#database-adapters","title":"Database Adapters","text":"Feature Installation Command Description PostgreSQL <code>archipy[postgres]</code> PostgreSQL database adapter with SQLAlchemy integration SQLite <code>archipy[sqlite]</code> SQLite database adapter with SQLAlchemy integration StarRocks <code>archipy[starrocks]</code> StarRocks database adapter with SQLAlchemy integration"},{"location":"installation/#service-adapters","title":"Service Adapters","text":"Feature Installation Command Description Redis <code>archipy[redis]</code> Redis caching and key-value storage Keycloak <code>archipy[keycloak]</code> Authentication and authorization services MinIO <code>archipy[minio]</code> S3-compatible object storage Kafka <code>archipy[kafka]</code> Message streaming and event processing"},{"location":"installation/#web-framework-support","title":"Web Framework Support","text":"Feature Installation Command Description FastAPI <code>archipy[fastapi]</code> FastAPI integration with middleware and utilities gRPC <code>archipy[grpc]</code> gRPC integration with interceptors"},{"location":"installation/#additional-features","title":"Additional Features","text":"Feature Installation Command Description JWT <code>archipy[jwt]</code> JSON Web Token utilities Prometheus <code>archipy[prometheus]</code> Metrics and monitoring Sentry <code>archipy[sentry]</code> Error tracking and monitoring Scheduler <code>archipy[scheduler]</code> Task scheduling utilities"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributors:</p> <pre><code># Clone the repository\ngit clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n\n# Set up the project\nmake setup\n\n# Install dependencies\nmake install\n\n# Optional: Install dev tools\nmake install-dev\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If issues arise, verify:</p> <ol> <li>Python version is 3.13+</li> <li><code>pip</code> or <code>poetry</code> is updated (e.g., <code>pip install --upgrade pip</code>)</li> <li>Build tools (<code>setuptools</code>, <code>wheel</code>) are installed</li> <li>Database-specific dependencies are installed if using database adapters</li> </ol> <p>IDE Integration</p> <p>For the best development experience, use an IDE that supports Python type hints, such as PyCharm or VS Code with the Python extension. The project uses modern Python type hints and benefits from IDE support for type checking and autocompletion.</p>"},{"location":"license/","title":"License","text":"<p>ArchiPy is licensed under the terms of the license file included in the repository.</p> <p>For more details, see the LICENSE file.</p>"},{"location":"usage/","title":"Getting Started","text":"<p>This guide will help you start building applications with ArchiPy.</p>"},{"location":"usage/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, initialize your application with a configuration:</li> </ol> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    # Custom configuration\n    pass\n\n# Set as global config\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre> <ol> <li>Define your domain models:</li> </ol> <pre><code>from uuid import uuid4\nfrom sqlalchemy import Column, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n    # Relationships\n    posts = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(BaseEntity):\n    __tablename__ = \"posts\"\n\n    title = Column(String(255))\n    content = Column(String(1000))\n\n    # Foreign keys\n    author_id = Column(UUID, ForeignKey(\"users.test_uuid\"))\n\n    # Relationships\n    author = relationship(\"User\", back_populates=\"posts\")\n</code></pre> <ol> <li>Set up your database adapter:</li> </ol> <pre><code># For PostgreSQL\nfrom archipy.adapters.postgres.sqlalchemy.adapters import PostgresSQLAlchemyAdapter, AsyncPostgresSQLAlchemyAdapter\n\n# For SQLite\nfrom archipy.adapters.sqlite.sqlalchemy.adapters import SQLiteSQLAlchemyAdapter, AsyncSQLiteSQLAlchemyAdapter\n\n# For StarRocks\nfrom archipy.adapters.starrocks.sqlalchemy.adapters import StarrocksSQLAlchemyAdapter, AsyncStarrocksSQLAlchemyAdapter\n\n# Create adapter (uses global config)\ndb_adapter = PostgresSQLAlchemyAdapter()\n\n# Create tables (development only)\nBaseEntity.metadata.create_all(db_adapter.session_manager.engine)\n</code></pre> <ol> <li>Implement your repositories:</li> </ol> <pre><code>from sqlalchemy import select\nfrom archipy.models.dtos.pagination_dto import PaginationDTO\nfrom archipy.models.dtos.sort_dto import SortDTO\n\nclass UserRepository:\n    def __init__(self, db_adapter):\n        self.db_adapter = db_adapter\n\n    def create(self, username, email):\n        user = User(test_uuid=uuid4(), username=username, email=email)\n        return self.db_adapter.create(user)\n\n    def get_by_username(self, username):\n        query = select(User).where(User.username == username)\n        users, _ = self.db_adapter.execute_search_query(User, query)\n        return users[0] if users else None\n\n    def search_users(self, search_term: str | None = None,\n                    pagination: PaginationDTO | None = None,\n                    sort: SortDTO | None = None):\n        query = select(User)\n        if search_term:\n            query = query.where(User.username.ilike(f\"%{search_term}%\"))\n        return self.db_adapter.execute_search_query(User, query, pagination, sort)\n</code></pre> <ol> <li>Implement your business logic:</li> </ol> <pre><code>from archipy.models.errors import AlreadyExistsError\n\nclass UserService:\n    def __init__(self, user_repository):\n        self.user_repository = user_repository\n\n    def register_user(self, username, email):\n        # Check if user exists\n        existing_user = self.user_repository.get_by_username(username)\n        if existing_user:\n            raise AlreadyExistsError(\n                resource_type=\"user\",\n                additional_data={\"username\": username}\n            )\n\n        # Create new user\n        return self.user_repository.create(username, email)\n</code></pre>"},{"location":"usage/#working-with-redis","title":"Working with Redis","text":"<p>For caching or other Redis operations:</p> <pre><code>from archipy.adapters.redis.adapters import RedisAdapter, AsyncRedisAdapter\n\n# Create Redis adapter (uses global config)\nredis_adapter = RedisAdapter()\n\n# Cache user data\ndef cache_user(user):\n    user_data = {\n        \"username\": user.username,\n        \"email\": user.email\n    }\n    redis_adapter.set(f\"user:{user.test_uuid}\", json.dumps(user_data), ex=3600)\n\n# Get cached user\ndef get_cached_user(user_id):\n    data = redis_adapter.get(f\"user:{user_id}\")\n    return json.loads(data) if data else None\n</code></pre>"},{"location":"usage/#working-with-keycloak","title":"Working with Keycloak","text":"<p>For authentication and authorization:</p> <pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter, AsyncKeycloakAdapter\n\n# Create Keycloak adapter (uses global config)\nkeycloak = KeycloakAdapter()\n\n# Authenticate user\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Validate token\nis_valid = keycloak.validate_token(token[\"access_token\"])\n\n# Get user info\nuser_info = keycloak.get_userinfo(token[\"access_token\"])\n</code></pre>"},{"location":"usage/#working-with-minio","title":"Working with MinIO","text":"<p>For object storage operations:</p> <pre><code>from archipy.adapters.minio.adapters import MinioAdapter\n\n# Create MinIO adapter (uses global config)\nminio = MinioAdapter()\n\n# Create bucket\nif not minio.bucket_exists(\"my-bucket\"):\n    minio.make_bucket(\"my-bucket\")\n\n# Upload file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/file.pdf\")\n\n# Generate download URL\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\", expires=3600)\n</code></pre>"},{"location":"api_reference/","title":"API Reference","text":"<p>Welcome to the ArchiPy API reference documentation. This section provides detailed information about all modules, classes, and functions in ArchiPy.</p>"},{"location":"api_reference/#core-modules","title":"Core Modules","text":""},{"location":"api_reference/#adapters","title":"Adapters","text":"<p>The adapters module provides standardized interfaces to external systems:</p> <ul> <li>Adapters Documentation</li> <li>Database Adapters<ul> <li>PostgreSQL</li> <li>SQLite</li> <li>StarRocks</li> </ul> </li> <li>Redis Adapters</li> <li>Email Adapters</li> <li>Keycloak Adapters</li> <li>MinIO Adapters</li> <li>Kafka Adapters</li> <li>Payment Gateway Adapters<ul> <li>Parsian Shaparak</li> </ul> </li> </ul>"},{"location":"api_reference/#configs","title":"Configs","text":"<p>Configuration management and injection tools:</p> <ul> <li>Configs Documentation</li> <li>Base Config</li> <li>Config Templates</li> </ul>"},{"location":"api_reference/#helpers","title":"Helpers","text":"<p>Utility functions and support classes:</p> <ul> <li>Helpers Documentation</li> <li>Decorators</li> <li>Utils</li> <li>Metaclasses</li> <li>Interceptors</li> </ul>"},{"location":"api_reference/#models","title":"Models","text":"<p>Core data structures and types:</p> <ul> <li>Models Documentation</li> <li>Entities</li> <li>DTOs</li> <li>Errors</li> <li>Types</li> </ul>"},{"location":"api_reference/#source-code-organization","title":"Source Code Organization","text":"<p>The ArchiPy source code is organized into the following structure:</p> <pre><code>archipy/\n\u251c\u2500\u2500 adapters/           # External system integrations\n\u2502   \u251c\u2500\u2500 base/          # Base adapter implementations\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # Base SQLAlchemy components\n\u2502   \u251c\u2500\u2500 email/         # Email service adapters\n\u2502   \u251c\u2500\u2500 internet_payment_gateways/ # Payment gateway adapters\n\u2502   \u2502   \u2514\u2500\u2500 ir/        # Country-specific implementations\n\u2502   \u2502       \u2514\u2500\u2500 parsian/  # Parsian Shaparak gateway adapter\n\u2502   \u251c\u2500\u2500 keycloak/      # Keycloak authentication adapters\n\u2502   \u251c\u2500\u2500 kafka/         # Kafka message streaming adapters\n\u2502   \u251c\u2500\u2500 minio/         # MinIO object storage adapters\n\u2502   \u251c\u2500\u2500 postgres/      # PostgreSQL database adapters\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # PostgreSQL SQLAlchemy components\n\u2502   \u251c\u2500\u2500 redis/         # Redis adapters\n\u2502   \u251c\u2500\u2500 sqlite/        # SQLite database adapters\n\u2502   \u2502   \u2514\u2500\u2500 sqlalchemy/  # SQLite SQLAlchemy components\n\u2502   \u2514\u2500\u2500 starrocks/     # StarRocks database adapters\n\u2502       \u2514\u2500\u2500 sqlalchemy/  # StarRocks SQLAlchemy components\n\u251c\u2500\u2500 configs/           # Configuration management\n\u2502   \u251c\u2500\u2500 base_config.py\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 helpers/           # Utility functions\n\u2502   \u251c\u2500\u2500 decorators/\n\u2502   \u251c\u2500\u2500 interceptors/\n\u2502   \u251c\u2500\u2500 metaclasses/\n\u2502   \u2514\u2500\u2500 utils/\n\u2514\u2500\u2500 models/            # Core data structures\n    \u251c\u2500\u2500 dtos/\n    \u251c\u2500\u2500 entities/\n    \u251c\u2500\u2500 errors/\n    \u2514\u2500\u2500 types/\n</code></pre>"},{"location":"api_reference/#api-stability","title":"API Stability","text":"<p>ArchiPy follows semantic versioning and marks API stability as follows:</p> <ul> <li>\ud83d\udfe2 Stable: Production-ready APIs, covered by semantic versioning</li> <li>\ud83d\udfe1 Beta: APIs that are stabilizing but may have breaking changes</li> <li>\ud83d\udd34 Alpha: Experimental APIs that may change significantly</li> </ul> <p>See the Changelog for version history and breaking changes.</p>"},{"location":"api_reference/#contributing","title":"Contributing","text":"<p>For information about contributing to ArchiPy's development, please see:</p> <ul> <li>Contributing Guide</li> <li>Development Guide</li> <li>Documentation Guide</li> </ul>"},{"location":"api_reference/adapters/","title":"Adapters","text":"<p>The <code>adapters</code> module provides standardized interfaces to external systems and services. It follows the ports and adapters pattern (also known as hexagonal architecture) to decouple application logic from external dependencies.</p>"},{"location":"api_reference/adapters/#key-features","title":"Key Features","text":"<ul> <li>Consistent interfaces for all external services</li> <li>Built-in mock implementations for testing</li> <li>Port definitions for dependency inversion</li> <li>Ready-to-use implementations for common services</li> </ul>"},{"location":"api_reference/adapters/#available-adapters","title":"Available Adapters","text":""},{"location":"api_reference/adapters/#database-adapters","title":"Database Adapters","text":"<p>The database adapters provide standardized interfaces for different database systems using SQLAlchemy. Each database type has its own dedicated adapter implementation.</p>"},{"location":"api_reference/adapters/#base-sqlalchemy-components","title":"Base SQLAlchemy Components","text":"<p>The base SQLAlchemy components provide the core functionality used by all database-specific adapters:</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyExceptionHandlerMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyExceptionHandlerMixin</code>","text":"<p>Mixin providing centralized exception handling for SQLAlchemy operations.</p> <p>This mixin provides a standard method for handling database exceptions and converting them to appropriate application-specific exceptions.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemyExceptionHandlerMixin:\n    \"\"\"Mixin providing centralized exception handling for SQLAlchemy operations.\n\n    This mixin provides a standard method for handling database exceptions and\n    converting them to appropriate application-specific exceptions.\n    \"\"\"\n\n    @classmethod\n    def _handle_db_exception(cls, exception: Exception, db_name: str | None = None) -&gt; None:\n        \"\"\"Handle database exceptions and raise appropriate errors.\n\n        Args:\n            exception: The exception to handle.\n            db_name: Optional database name for error context.\n\n        Raises:\n            DatabaseTimeoutError: If a timeout is detected.\n            DatabaseConnectionError: If a connection error is detected.\n            DatabaseTransactionError: If a transaction error is detected.\n            DatabaseIntegrityError: If an integrity violation is detected.\n            DatabaseConstraintError: If a constraint violation is detected.\n            DatabaseQueryError: For other database errors.\n        \"\"\"\n        if \"timeout\" in str(exception).lower():\n            raise DatabaseTimeoutError(database=db_name) from exception\n        if \"integrity\" in str(exception).lower():\n            raise DatabaseIntegrityError(database=db_name) from exception\n        if \"constraint\" in str(exception).lower():\n            raise DatabaseConstraintError(database=db_name) from exception\n        if \"connection\" in str(exception).lower():\n            raise DatabaseConnectionError(database=db_name) from exception\n        if \"transaction\" in str(exception).lower():\n            raise DatabaseTransactionError(database=db_name) from exception\n\n        # Default error if no specific error is detected\n        raise DatabaseQueryError(database=db_name) from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyFilterMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyFilterMixin</code>","text":"<p>Mixin providing filtering capabilities for SQLAlchemy queries.</p> <p>Supports equality, inequality, string operations, list operations, and NULL checks.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemyFilterMixin:\n    \"\"\"Mixin providing filtering capabilities for SQLAlchemy queries.\n\n    Supports equality, inequality, string operations, list operations, and NULL checks.\n    \"\"\"\n\n    @staticmethod\n    def _apply_filter(\n        query: Select | Update | Delete,\n        field: InstrumentedAttribute,\n        value: Any,\n        operation: FilterOperationType,\n    ) -&gt; Select | Update | Delete:\n        \"\"\"Apply a filter to a SQLAlchemy query based on the specified operation.\n\n        Args:\n            query: The SQLAlchemy query to apply the filter to.\n            field: The model attribute/column to filter on.\n            value: The value to compare against.\n            operation: The type of filter operation to apply.\n\n        Returns:\n            The updated query with the filter applied.\n        \"\"\"\n        if value is not None or operation in [FilterOperationType.IS_NULL, FilterOperationType.IS_NOT_NULL]:\n            match operation:\n                case FilterOperationType.EQUAL:\n                    return query.where(field == value)\n                case FilterOperationType.NOT_EQUAL:\n                    return query.where(field != value)\n                case FilterOperationType.LESS_THAN:\n                    return query.where(field &lt; value)\n                case FilterOperationType.LESS_THAN_OR_EQUAL:\n                    return query.where(field &lt;= value)\n                case FilterOperationType.GREATER_THAN:\n                    return query.where(field &gt; value)\n                case FilterOperationType.GREATER_THAN_OR_EQUAL:\n                    return query.where(field &gt;= value)\n                case FilterOperationType.IN_LIST:\n                    return query.where(field.in_(value))\n                case FilterOperationType.NOT_IN_LIST:\n                    return query.where(~field.in_(value))\n                case FilterOperationType.LIKE:\n                    return query.where(field.like(f\"%{value}%\"))\n                case FilterOperationType.ILIKE:\n                    return query.where(field.ilike(f\"%{value}%\"))\n                case FilterOperationType.STARTS_WITH:\n                    return query.where(field.startswith(value))\n                case FilterOperationType.ENDS_WITH:\n                    return query.where(field.endswith(value))\n                case FilterOperationType.CONTAINS:\n                    return query.where(field.contains(value))\n                case FilterOperationType.IS_NULL:\n                    return query.where(field.is_(None))\n                case FilterOperationType.IS_NOT_NULL:\n                    return query.where(field.isnot(None))\n        return query\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyPaginationMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemyPaginationMixin</code>","text":"<p>Mixin providing pagination capabilities for SQLAlchemy queries.</p> <p>Supports limiting results and applying offsets for paginated queries.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemyPaginationMixin:\n    \"\"\"Mixin providing pagination capabilities for SQLAlchemy queries.\n\n    Supports limiting results and applying offsets for paginated queries.\n    \"\"\"\n\n    @staticmethod\n    def _apply_pagination(query: Select, pagination: PaginationDTO | None) -&gt; Select:\n        \"\"\"Apply pagination to a SQLAlchemy query.\n\n        Args:\n            query: The SQLAlchemy query to paginate.\n            pagination: Pagination settings (page size and offset).\n\n        Returns:\n            The paginated query.\n        \"\"\"\n        if pagination is None:\n            return query\n        return query.limit(pagination.page_size).offset(pagination.offset)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.SQLAlchemySortMixin","title":"<code>archipy.adapters.base.sqlalchemy.adapters.SQLAlchemySortMixin</code>","text":"<p>Mixin providing sorting capabilities for SQLAlchemy queries.</p> <p>Supports dynamic column selection and ascending/descending order.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class SQLAlchemySortMixin:\n    \"\"\"Mixin providing sorting capabilities for SQLAlchemy queries.\n\n    Supports dynamic column selection and ascending/descending order.\n    \"\"\"\n\n    @staticmethod\n    def _apply_sorting(entity: type[BaseEntity], query: Select, sort_info: SortDTO | None) -&gt; Select:\n        \"\"\"Apply sorting to a SQLAlchemy query.\n\n        Args:\n            entity: The entity class to query.\n            query: The SQLAlchemy query to sort.\n            sort_info: Sorting information (column and direction).\n\n        Returns:\n            The sorted query.\n\n        Raises:\n            InvalidArgumentError: If the sort order is invalid.\n        \"\"\"\n        if sort_info is None:\n            return query\n        if isinstance(sort_info.column, str):\n            sort_column = getattr(entity, sort_info.column)\n        elif isinstance(sort_info.column, Enum):\n            sort_column = getattr(entity, sort_info.column.name.lower())\n        else:\n            sort_column = sort_info.column\n\n        order_value = sort_info.order.value if isinstance(sort_info.order, Enum) else sort_info.order\n        match order_value:\n            case SortOrderType.ASCENDING.value:\n                return query.order_by(sort_column.asc())\n            case SortOrderType.DESCENDING.value:\n                return query.order_by(sort_column.desc())\n            case _:\n                raise InvalidArgumentError(argument_name=\"sort_info.order\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>SQLAlchemyPort</code>, <code>SQLAlchemyPaginationMixin</code>, <code>SQLAlchemySortMixin</code>, <code>SQLAlchemyFilterMixin</code>, <code>SQLAlchemyExceptionHandlerMixin</code></p> <p>Base synchronous SQLAlchemy adapter for ORM operations.</p> <p>Provides a standardized interface for CRUD operations, pagination, sorting, and filtering. Specific database adapters should inherit from this class and provide their own session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class BaseSQLAlchemyAdapter(\n    SQLAlchemyPort,\n    SQLAlchemyPaginationMixin,\n    SQLAlchemySortMixin,\n    SQLAlchemyFilterMixin,\n    SQLAlchemyExceptionHandlerMixin,\n):\n    \"\"\"Base synchronous SQLAlchemy adapter for ORM operations.\n\n    Provides a standardized interface for CRUD operations, pagination, sorting, and filtering.\n    Specific database adapters should inherit from this class and provide their own session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the base adapter with a session manager.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.session_manager: BaseSQLAlchemySessionManager = self._create_session_manager(configs)\n\n    def _create_session_manager(self, configs: SQLAlchemyConfig) -&gt; BaseSQLAlchemySessionManager:\n        \"\"\"Create a session manager for the specific database.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A session manager instance.\n        \"\"\"\n        return BaseSQLAlchemySessionManager(configs)\n\n    @override\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Execute a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query.\n            query: The SQLAlchemy SELECT query.\n            pagination: Optional pagination settings.\n            sort_info: Optional sorting information.\n\n        Returns:\n            Tuple of the list of entities and the total count.\n\n        Raises:\n            DatabaseQueryError: If the database query fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            sort_info = sort_info or SortDTO.default()\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n            result_set = session.execute(paginated_query)\n            results = list(result_set.scalars().all())\n\n            count_query = select(func.count()).select_from(query.subquery())\n            total_count = session.execute(count_query).scalar_one()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return results, total_count\n\n    @override\n    def get_session(self) -&gt; Session:\n        \"\"\"Get a database session.\n\n        Returns:\n            Session: A SQLAlchemy session.\n\n        Raises:\n            DatabaseConnectionError: If there's an error getting the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        return self.session_manager.get_session()\n\n    @override\n    def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Create a new entity in the database.\n\n        Args:\n            entity: The entity to create.\n\n        Returns:\n            The created entity with updated attributes.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            session.add(entity)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return entity\n\n    @override\n    def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in a single database operation.\n\n        Args:\n            entities: List of entities to create.\n\n        Returns:\n            List of created entities with updated attributes.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            session.add_all(entities)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return entities\n\n    @override\n    def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieve an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve.\n            entity_uuid: The UUID of the entity.\n\n        Returns:\n            The entity if found, None otherwise.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=entity_type.__name__,\n            )\n\n        try:\n            session = self.get_session()\n            result = session.get(entity_type, entity_uuid)\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return result\n\n    @override\n    def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Delete an entity from the database.\n\n        Args:\n            entity: The entity to delete.\n\n        Raises:\n            InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            session.delete(entity)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return ...\n\n    @override\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Delete multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            for entity in entities:\n                session.delete(entity)\n            session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return ...\n\n    @override\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Execute a SQLAlchemy statement.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The result of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = session.execute(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return result\n\n    @override\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The scalar results of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = session.scalars(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the base adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the base adapter with a session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    self.session_manager: BaseSQLAlchemySessionManager = self._create_session_manager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute_search_query(entity, query, pagination=None, sort_info=None)</code>","text":"<p>Execute a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query.</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query.</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings.</p> <code>None</code> <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>Tuple of the list of entities and the total count.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database query fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None = None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Execute a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query.\n        query: The SQLAlchemy SELECT query.\n        pagination: Optional pagination settings.\n        sort_info: Optional sorting information.\n\n    Returns:\n        Tuple of the list of entities and the total count.\n\n    Raises:\n        DatabaseQueryError: If the database query fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        sort_info = sort_info or SortDTO.default()\n        session = self.get_session()\n        sorted_query = self._apply_sorting(entity, query, sort_info)\n        paginated_query = self._apply_pagination(sorted_query, pagination)\n        result_set = session.execute(paginated_query)\n        results = list(result_set.scalars().all())\n\n        count_query = select(func.count()).select_from(query.subquery())\n        total_count = session.execute(count_query).scalar_one()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return results, total_count\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_session","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_session()</code>","text":"<p>Get a database session.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error getting the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; Session:\n    \"\"\"Get a database session.\n\n    Returns:\n        Session: A SQLAlchemy session.\n\n    Raises:\n        DatabaseConnectionError: If there's an error getting the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    return self.session_manager.get_session()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.create(entity)</code>","text":"<p>Create a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create.</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity with updated attributes.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Create a new entity in the database.\n\n    Args:\n        entity: The entity to create.\n\n    Returns:\n        The created entity with updated attributes.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        session.add(entity)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return entity\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_create(entities)</code>","text":"<p>Creates multiple entities in a single database operation.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create.</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>List of created entities with updated attributes.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in a single database operation.\n\n    Args:\n        entities: List of entities to create.\n\n    Returns:\n        List of created entities with updated attributes.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        session.add_all(entities)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return entities\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.get_by_uuid(entity_type, entity_uuid)</code>","text":"<p>Retrieve an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve.</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity.</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieve an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve.\n        entity_uuid: The UUID of the entity.\n\n    Returns:\n        The entity if found, None otherwise.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not issubclass(entity_type, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=entity_type.__name__,\n        )\n\n    try:\n        session = self.get_session()\n        result = session.get(entity_type, entity_uuid)\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.delete(entity)</code>","text":"<p>Delete an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Delete an entity from the database.\n\n    Args:\n        entity: The entity to delete.\n\n    Raises:\n        InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        session.delete(entity)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return ...\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.bulk_delete(entities)</code>","text":"<p>Delete multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Delete multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        for entity in entities:\n            session.delete(entity)\n        session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return ...\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.execute(statement, params=None)</code>","text":"<p>Execute a SQLAlchemy statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The result of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Execute a SQLAlchemy statement.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The result of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = session.execute(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.scalars","title":"<code>archipy.adapters.base.sqlalchemy.adapters.BaseSQLAlchemyAdapter.scalars(statement, params=None)</code>","text":"<p>Execute a SQLAlchemy statement and return scalar results.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar results of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The scalar results of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = session.scalars(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncSQLAlchemyPort</code>, <code>SQLAlchemyPaginationMixin</code>, <code>SQLAlchemySortMixin</code>, <code>SQLAlchemyFilterMixin</code>, <code>SQLAlchemyExceptionHandlerMixin</code></p> <p>Base asynchronous SQLAlchemy adapter for ORM operations.</p> <p>Provides a standardized interface for CRUD operations, pagination, sorting, and filtering. Specific database adapters should inherit from this class and provide their own session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>class AsyncBaseSQLAlchemyAdapter(\n    AsyncSQLAlchemyPort,\n    SQLAlchemyPaginationMixin,\n    SQLAlchemySortMixin,\n    SQLAlchemyFilterMixin,\n    SQLAlchemyExceptionHandlerMixin,\n):\n    \"\"\"Base asynchronous SQLAlchemy adapter for ORM operations.\n\n    Provides a standardized interface for CRUD operations, pagination, sorting, and filtering.\n    Specific database adapters should inherit from this class and provide their own session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the base async adapter with a session manager.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.session_manager: AsyncBaseSQLAlchemySessionManager = self._create_async_session_manager(configs)\n\n    def _create_async_session_manager(self, configs: SQLAlchemyConfig) -&gt; AsyncBaseSQLAlchemySessionManager:\n        \"\"\"Create an async session manager for the specific database.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            An async session manager instance.\n        \"\"\"\n        return AsyncBaseSQLAlchemySessionManager(configs)\n\n    @override\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Execute a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query.\n            query: The SQLAlchemy SELECT query.\n            pagination: Optional pagination settings.\n            sort_info: Optional sorting information.\n\n        Returns:\n            Tuple of the list of entities and the total count.\n\n        Raises:\n            DatabaseQueryError: If the database query fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            sort_info = sort_info or SortDTO.default()\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n            result_set = await session.execute(paginated_query)\n            results = list(result_set.scalars().all())\n\n            count_query = select(func.count()).select_from(query.subquery())\n            total_count = await session.execute(count_query)\n            total_count = total_count.scalar_one()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return results, total_count\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Get a database session.\n\n        Returns:\n            AsyncSession: A SQLAlchemy async session.\n\n        Raises:\n            DatabaseConnectionError: If there's an error getting the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        return self.session_manager.get_session()\n\n    @override\n    async def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Create a new entity in the database.\n\n        Args:\n            entity: The entity to create.\n\n        Returns:\n            The created entity with updated attributes.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            session.add(entity)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return entity\n\n    @override\n    async def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in a single database operation.\n\n        Args:\n            entities: List of entities to create.\n\n        Returns:\n            List of created entities with updated attributes.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            session.add_all(entities)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return entities\n\n    @override\n    async def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; Any | None:\n        \"\"\"Retrieve an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve.\n            entity_uuid: The UUID of the entity.\n\n        Returns:\n            The entity if found, None otherwise.\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=entity_type.__name__,\n            )\n\n        try:\n            session = self.get_session()\n            result = await session.get(entity_type, entity_uuid)\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return result\n\n    @override\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Delete an entity from the database.\n\n        Args:\n            entity: The entity to delete.\n\n        Raises:\n            InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(\n                message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n                expected_type=\"BaseEntity\",\n                actual_type=type(entity).__name__,\n            )\n\n        try:\n            session = self.get_session()\n            await session.delete(entity)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return ...\n\n    @override\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Delete multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete.\n\n        Raises:\n            InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n            DatabaseQueryError: If the database operation fails.\n            DatabaseIntegrityError: If there's an integrity constraint violation.\n            DatabaseConstraintError: If there's a constraint violation.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        if not all(isinstance(entity, BaseEntity) for entity in entities):\n            raise InvalidEntityTypeError(\n                message=\"All entities must be BaseEntity subclasses\",\n                expected_type=\"BaseEntity\",\n                actual_type=\"mixed\",\n            )\n\n        try:\n            session = self.get_session()\n            for entity in entities:\n                await session.delete(entity)\n            await session.flush()\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return ...\n\n    @override\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Execute a SQLAlchemy statement.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The result of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = await session.execute(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return result\n\n    @override\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The scalar results of the execution.\n\n        Raises:\n            DatabaseQueryError: If the database operation fails.\n            DatabaseTimeoutError: If the query times out.\n            DatabaseConnectionError: If there's a connection error.\n            DatabaseTransactionError: If there's a transaction error.\n        \"\"\"\n        try:\n            session = self.get_session()\n            result = await session.scalars(statement, params or {})\n        except Exception as e:\n            self._handle_db_exception(e, self.session_manager._get_database_name())\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the base async adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the base async adapter with a session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    self.session_manager: AsyncBaseSQLAlchemySessionManager = self._create_async_session_manager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute_search_query(entity, query, pagination, sort_info=None)</code>  <code>async</code>","text":"<p>Execute a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query.</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query.</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings.</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>Tuple of the list of entities and the total count.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database query fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Execute a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query.\n        query: The SQLAlchemy SELECT query.\n        pagination: Optional pagination settings.\n        sort_info: Optional sorting information.\n\n    Returns:\n        Tuple of the list of entities and the total count.\n\n    Raises:\n        DatabaseQueryError: If the database query fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        sort_info = sort_info or SortDTO.default()\n        session = self.get_session()\n        sorted_query = self._apply_sorting(entity, query, sort_info)\n        paginated_query = self._apply_pagination(sorted_query, pagination)\n        result_set = await session.execute(paginated_query)\n        results = list(result_set.scalars().all())\n\n        count_query = select(func.count()).select_from(query.subquery())\n        total_count = await session.execute(count_query)\n        total_count = total_count.scalar_one()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return results, total_count\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_session","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_session()</code>","text":"<p>Get a database session.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>A SQLAlchemy async session.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error getting the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Get a database session.\n\n    Returns:\n        AsyncSession: A SQLAlchemy async session.\n\n    Raises:\n        DatabaseConnectionError: If there's an error getting the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    return self.session_manager.get_session()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.create(entity)</code>  <code>async</code>","text":"<p>Create a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create.</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity with updated attributes.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Create a new entity in the database.\n\n    Args:\n        entity: The entity to create.\n\n    Returns:\n        The created entity with updated attributes.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        session.add(entity)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return entity\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_create(entities)</code>  <code>async</code>","text":"<p>Creates multiple entities in a single database operation.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create.</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>List of created entities with updated attributes.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in a single database operation.\n\n    Args:\n        entities: List of entities to create.\n\n    Returns:\n        List of created entities with updated attributes.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        session.add_all(entities)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return entities\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.get_by_uuid(entity_type, entity_uuid)</code>  <code>async</code>","text":"<p>Retrieve an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve.</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity.</p> required <p>Returns:</p> Type Description <code>Any | None</code> <p>The entity if found, None otherwise.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; Any | None:\n    \"\"\"Retrieve an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve.\n        entity_uuid: The UUID of the entity.\n\n    Returns:\n        The entity if found, None otherwise.\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not issubclass(entity_type, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {entity_type.__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=entity_type.__name__,\n        )\n\n    try:\n        session = self.get_session()\n        result = await session.get(entity_type, entity_uuid)\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.delete(entity)</code>  <code>async</code>","text":"<p>Delete an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Delete an entity from the database.\n\n    Args:\n        entity: The entity to delete.\n\n    Raises:\n        InvalidEntityTypeError: If the entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__,\n        )\n\n    try:\n        session = self.get_session()\n        await session.delete(entity)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return ...\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.bulk_delete(entities)</code>  <code>async</code>","text":"<p>Delete multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any entity is not a valid SQLAlchemy model.</p> <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseIntegrityError</code> <p>If there's an integrity constraint violation.</p> <code>DatabaseConstraintError</code> <p>If there's a constraint violation.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Delete multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete.\n\n    Raises:\n        InvalidEntityTypeError: If any entity is not a valid SQLAlchemy model.\n        DatabaseQueryError: If the database operation fails.\n        DatabaseIntegrityError: If there's an integrity constraint violation.\n        DatabaseConstraintError: If there's a constraint violation.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    if not all(isinstance(entity, BaseEntity) for entity in entities):\n        raise InvalidEntityTypeError(\n            message=\"All entities must be BaseEntity subclasses\",\n            expected_type=\"BaseEntity\",\n            actual_type=\"mixed\",\n        )\n\n    try:\n        session = self.get_session()\n        for entity in entities:\n            await session.delete(entity)\n        await session.flush()\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return ...\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.execute(statement, params=None)</code>  <code>async</code>","text":"<p>Execute a SQLAlchemy statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The result of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Execute a SQLAlchemy statement.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The result of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = await session.execute(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.scalars","title":"<code>archipy.adapters.base.sqlalchemy.adapters.AsyncBaseSQLAlchemyAdapter.scalars(statement, params=None)</code>  <code>async</code>","text":"<p>Execute a SQLAlchemy statement and return scalar results.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar results of the execution.</p> <p>Raises:</p> Type Description <code>DatabaseQueryError</code> <p>If the database operation fails.</p> <code>DatabaseTimeoutError</code> <p>If the query times out.</p> <code>DatabaseConnectionError</code> <p>If there's a connection error.</p> <code>DatabaseTransactionError</code> <p>If there's a transaction error.</p> Source code in <code>archipy/adapters/base/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Execute a SQLAlchemy statement and return scalar results.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The scalar results of the execution.\n\n    Raises:\n        DatabaseQueryError: If the database operation fails.\n        DatabaseTimeoutError: If the query times out.\n        DatabaseConnectionError: If there's a connection error.\n        DatabaseTransactionError: If there's a transaction error.\n    \"\"\"\n    try:\n        session = self.get_session()\n        result = await session.scalars(statement, params or {})\n    except Exception as e:\n        self._handle_db_exception(e, self.session_manager._get_database_name())\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort</code>","text":"<p>Abstract interface defining synchronous SQLAlchemy database operations.</p> <p>This interface defines the contract that all synchronous SQLAlchemy adapters must implement, providing standard methods for database operations like create, read, update, delete (CRUD), as well as search and transaction management.</p> <p>Implementations of this interface are responsible for handling the specific details of database interactions and connection management.</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>class SQLAlchemyPort:\n    \"\"\"Abstract interface defining synchronous SQLAlchemy database operations.\n\n    This interface defines the contract that all synchronous SQLAlchemy adapters must\n    implement, providing standard methods for database operations like create,\n    read, update, delete (CRUD), as well as search and transaction management.\n\n    Implementations of this interface are responsible for handling the specific\n    details of database interactions and connection management.\n    \"\"\"\n\n    @abstractmethod\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieves a SQLAlchemy session for database operations.\n\n        Returns:\n            Session: A SQLAlchemy session object\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Executes a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Optional pagination settings\n            sort_info: Optional sorting information\n\n        Returns:\n            A tuple containing the list of entities and the total count\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database.\n\n        Args:\n            entity: The entity to create\n\n        Returns:\n            The created entity (with updated attributes) or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in the database.\n\n        Args:\n            entities: List of entities to create\n\n        Returns:\n            The list of created entities or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve\n            entity_uuid: The UUID of the entity\n\n        Returns:\n            The entity if found, None otherwise\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Deletes an entity from the database.\n\n        Args:\n            entity: The entity to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a raw SQL statement.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The result of the execution\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a statement and returns the scalar result.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The scalar result of the execution\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_session","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_session()</code>  <code>abstractmethod</code>","text":"<p>Retrieves a SQLAlchemy session for database operations.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session object</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieves a SQLAlchemy session for database operations.\n\n    Returns:\n        Session: A SQLAlchemy session object\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute_search_query(entity, query, pagination=None, sort_info=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings</p> <code>None</code> <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing the list of entities and the total count</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None = None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Executes a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Optional pagination settings\n        sort_info: Optional sorting information\n\n    Returns:\n        A tuple containing the list of entities and the total count\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.create","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.create(entity)</code>  <code>abstractmethod</code>","text":"<p>Creates a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity (with updated attributes) or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database.\n\n    Args:\n        entity: The entity to create\n\n    Returns:\n        The created entity (with updated attributes) or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_create(entities)</code>  <code>abstractmethod</code>","text":"<p>Creates multiple entities in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in the database.\n\n    Args:\n        entities: List of entities to create\n\n    Returns:\n        The list of created entities or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.get_by_uuid(entity_type, entity_uuid)</code>  <code>abstractmethod</code>","text":"<p>Retrieves an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve\n        entity_uuid: The UUID of the entity\n\n    Returns:\n        The entity if found, None otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.delete(entity)</code>  <code>abstractmethod</code>","text":"<p>Deletes an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Deletes an entity from the database.\n\n    Args:\n        entity: The entity to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.bulk_delete(entities)</code>  <code>abstractmethod</code>","text":"<p>Deletes multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.execute(statement, params=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a raw SQL statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a raw SQL statement.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.scalars","title":"<code>archipy.adapters.base.sqlalchemy.ports.SQLAlchemyPort.scalars(statement, params=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a statement and returns the scalar result.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The scalar result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a statement and returns the scalar result.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The scalar result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort</code>","text":"<p>Abstract interface defining asynchronous SQLAlchemy database operations.</p> <p>This interface defines the contract that all asynchronous SQLAlchemy adapters must implement, providing standard methods for database operations like create, read, update, delete (CRUD), as well as search and transaction management.</p> <p>Implementations of this interface are responsible for handling the specific details of asynchronous database interactions and connection management.</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>class AsyncSQLAlchemyPort:\n    \"\"\"Abstract interface defining asynchronous SQLAlchemy database operations.\n\n    This interface defines the contract that all asynchronous SQLAlchemy adapters must\n    implement, providing standard methods for database operations like create,\n    read, update, delete (CRUD), as well as search and transaction management.\n\n    Implementations of this interface are responsible for handling the specific\n    details of asynchronous database interactions and connection management.\n    \"\"\"\n\n    @abstractmethod\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Retrieves an asynchronous SQLAlchemy session for database operations.\n\n        Returns:\n            AsyncSession: An asynchronous SQLAlchemy session object\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Executes a search query with pagination and sorting asynchronously.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Optional pagination settings\n            sort_info: Optional sorting information\n\n        Returns:\n            A tuple containing the list of entities and the total count\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database asynchronously.\n\n        Args:\n            entity: The entity to create\n\n        Returns:\n            The created entity (with updated attributes) or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in the database asynchronously.\n\n        Args:\n            entities: List of entities to create\n\n        Returns:\n            The list of created entities or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID asynchronously.\n\n        Args:\n            entity_type: The type of entity to retrieve\n            entity_uuid: The UUID of the entity\n\n        Returns:\n            The entity if found, None otherwise\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Deletes an entity from the database asynchronously.\n\n        Args:\n            entity: The entity to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities from the database asynchronously.\n\n        Args:\n            entities: List of entities to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a raw SQL statement asynchronously.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The result of the execution\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The scalar result of the execution\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_session","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_session()</code>  <code>abstractmethod</code>","text":"<p>Retrieves an asynchronous SQLAlchemy session for database operations.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>An asynchronous SQLAlchemy session object</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Retrieves an asynchronous SQLAlchemy session for database operations.\n\n    Returns:\n        AsyncSession: An asynchronous SQLAlchemy session object\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute_search_query","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute_search_query(entity, query, pagination, sort_info=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a search query with pagination and sorting asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing the list of entities and the total count</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Executes a search query with pagination and sorting asynchronously.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Optional pagination settings\n        sort_info: Optional sorting information\n\n    Returns:\n        A tuple containing the list of entities and the total count\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.create","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.create(entity)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Creates a new entity in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity (with updated attributes) or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database asynchronously.\n\n    Args:\n        entity: The entity to create\n\n    Returns:\n        The created entity (with updated attributes) or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_create","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_create(entities)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Creates multiple entities in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities or None if creation failed</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in the database asynchronously.\n\n    Args:\n        entities: List of entities to create\n\n    Returns:\n        The list of created entities or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_by_uuid","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.get_by_uuid(entity_type, entity_uuid)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves an entity by its UUID asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID asynchronously.\n\n    Args:\n        entity_type: The type of entity to retrieve\n        entity_uuid: The UUID of the entity\n\n    Returns:\n        The entity if found, None otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.delete(entity)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes an entity from the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Deletes an entity from the database asynchronously.\n\n    Args:\n        entity: The entity to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_delete","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.bulk_delete(entities)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes multiple entities from the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete</p> required Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities from the database asynchronously.\n\n    Args:\n        entities: List of entities to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.execute(statement, params=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a raw SQL statement asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a raw SQL statement asynchronously.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.scalars","title":"<code>archipy.adapters.base.sqlalchemy.ports.AsyncSQLAlchemyPort.scalars(statement, params=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a statement and returns the scalar result asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The scalar result of the execution</p> Source code in <code>archipy/adapters/base/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The scalar result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>SessionManagerPort</code></p> <p>Base synchronous SQLAlchemy session manager.</p> <p>Implements the SessionManagerPort interface to provide session management for synchronous database operations. Database-specific session managers should inherit from this class and implement database-specific engine creation.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig</code> <p>SQLAlchemy configuration. Must match the expected config type for the database.</p> required Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>class BaseSQLAlchemySessionManager(SessionManagerPort):\n    \"\"\"Base synchronous SQLAlchemy session manager.\n\n    Implements the SessionManagerPort interface to provide session management for\n    synchronous database operations. Database-specific session managers should inherit\n    from this class and implement database-specific engine creation.\n\n    Args:\n        orm_config: SQLAlchemy configuration. Must match the expected config type for the database.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLAlchemyConfig) -&gt; None:\n        \"\"\"Initialize the base session manager.\n\n        Args:\n            orm_config: SQLAlchemy configuration.\n\n        Raises:\n            InvalidArgumentError: If the configuration type is invalid.\n            DatabaseConnectionError: If there's an error creating the database connection.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        if not isinstance(orm_config, self._expected_config_type()):\n            raise InvalidArgumentError(\n                f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n            )\n        try:\n            self.engine = self._create_engine(orm_config)\n            self._session_generator = self._get_session_generator()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @abstractmethod\n    def _expected_config_type(self) -&gt; type[SQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for the database.\n\n        Returns:\n            The SQLAlchemy configuration class expected by this session manager.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database (e.g., 'postgresql', 'sqlite', 'starrocks').\n        \"\"\"\n        pass\n\n    def _create_engine(self, configs: SQLAlchemyConfig) -&gt; Engine:\n        \"\"\"Create a SQLAlchemy engine with common configuration.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A configured SQLAlchemy engine.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the engine.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            url = self._create_url(configs)\n            return create_engine(\n                url,\n                isolation_level=configs.ISOLATION_LEVEL,\n                echo=configs.ECHO,\n                echo_pool=configs.ECHO_POOL,\n                enable_from_linting=configs.ENABLE_FROM_LINTING,\n                hide_parameters=configs.HIDE_PARAMETERS,\n                pool_pre_ping=configs.POOL_PRE_PING,\n                pool_size=configs.POOL_SIZE,\n                pool_recycle=configs.POOL_RECYCLE_SECONDS,\n                pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n                pool_timeout=configs.POOL_TIMEOUT,\n                pool_use_lifo=configs.POOL_USE_LIFO,\n                query_cache_size=configs.QUERY_CACHE_SIZE,\n                max_overflow=configs.POOL_MAX_OVERFLOW,\n                connect_args=self._get_connect_args(),\n            )\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @abstractmethod\n    def _create_url(self, configs: SQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a database connection URL.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A SQLAlchemy URL object for the database.\n\n        Raises:\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        pass\n\n    def _get_connect_args(self) -&gt; dict:\n        \"\"\"Return additional connection arguments for the engine.\n\n        Returns:\n            A dictionary of connection arguments (default is empty).\n        \"\"\"\n        return {}\n\n    def _get_session_generator(self) -&gt; scoped_session:\n        \"\"\"Create a scoped session factory for synchronous sessions.\n\n        Returns:\n            A scoped_session instance used by `get_session` to provide thread-safe sessions.\n\n        Raises:\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            session_maker = sessionmaker(self.engine)\n            return scoped_session(session_maker)\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieve a thread-safe SQLAlchemy session.\n\n        Returns:\n            Session: A SQLAlchemy session instance for database operations.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            return self._session_generator()  # type: ignore[no-any-return]\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    def remove_session(self) -&gt; None:\n        \"\"\"Remove the current session from the registry.\n\n        Cleans up the session to prevent resource leaks, typically called at the end\n        of a request.\n\n        Raises:\n            DatabaseConnectionError: If there's an error removing the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            self._session_generator.remove()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.__init__(orm_config)</code>","text":"<p>Initialize the base session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig</code> <p>SQLAlchemy configuration.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the configuration type is invalid.</p> <code>DatabaseConnectionError</code> <p>If there's an error creating the database connection.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: SQLAlchemyConfig) -&gt; None:\n    \"\"\"Initialize the base session manager.\n\n    Args:\n        orm_config: SQLAlchemy configuration.\n\n    Raises:\n        InvalidArgumentError: If the configuration type is invalid.\n        DatabaseConnectionError: If there's an error creating the database connection.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    if not isinstance(orm_config, self._expected_config_type()):\n        raise InvalidArgumentError(\n            f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n        )\n    try:\n        self.engine = self._create_engine(orm_config)\n        self._session_generator = self._get_session_generator()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.get_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.get_session()</code>","text":"<p>Retrieve a thread-safe SQLAlchemy session.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session instance for database operations.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error creating the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieve a thread-safe SQLAlchemy session.\n\n    Returns:\n        Session: A SQLAlchemy session instance for database operations.\n\n    Raises:\n        DatabaseConnectionError: If there's an error creating the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        return self._session_generator()  # type: ignore[no-any-return]\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.remove_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.BaseSQLAlchemySessionManager.remove_session()</code>","text":"<p>Remove the current session from the registry.</p> <p>Cleans up the session to prevent resource leaks, typically called at the end of a request.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error removing the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\ndef remove_session(self) -&gt; None:\n    \"\"\"Remove the current session from the registry.\n\n    Cleans up the session to prevent resource leaks, typically called at the end\n    of a request.\n\n    Raises:\n        DatabaseConnectionError: If there's an error removing the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        self._session_generator.remove()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncSessionManagerPort</code></p> <p>Base asynchronous SQLAlchemy session manager.</p> <p>Implements the AsyncSessionManagerPort interface to provide session management for asynchronous database operations. Database-specific session managers should inherit from this class and implement database-specific async engine creation.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig</code> <p>SQLAlchemy configuration. Must match the expected config type for the database.</p> required Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>class AsyncBaseSQLAlchemySessionManager(AsyncSessionManagerPort):\n    \"\"\"Base asynchronous SQLAlchemy session manager.\n\n    Implements the AsyncSessionManagerPort interface to provide session management for\n    asynchronous database operations. Database-specific session managers should inherit\n    from this class and implement database-specific async engine creation.\n\n    Args:\n        orm_config: SQLAlchemy configuration. Must match the expected config type for the database.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLAlchemyConfig) -&gt; None:\n        \"\"\"Initialize the base async session manager.\n\n        Args:\n            orm_config: SQLAlchemy configuration.\n\n        Raises:\n            InvalidArgumentError: If the configuration type is invalid.\n            DatabaseConnectionError: If there's an error creating the database connection.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        if not isinstance(orm_config, self._expected_config_type()):\n            raise InvalidArgumentError(\n                f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n            )\n        try:\n            self.engine = self._create_async_engine(orm_config)\n            self._session_generator = self._get_session_generator()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @abstractmethod\n    def _expected_config_type(self) -&gt; type[SQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for the database.\n\n        Returns:\n            The SQLAlchemy configuration class expected by this session manager.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database (e.g., 'postgresql', 'sqlite', 'starrocks').\n        \"\"\"\n        pass\n\n    def _create_async_engine(self, configs: SQLAlchemyConfig) -&gt; AsyncEngine:\n        \"\"\"Create an async SQLAlchemy engine with common configuration.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A configured async SQLAlchemy engine.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the engine.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            url = self._create_url(configs)\n            return create_async_engine(\n                url,\n                isolation_level=configs.ISOLATION_LEVEL,\n                echo=configs.ECHO,\n                echo_pool=configs.ECHO_POOL,\n                enable_from_linting=configs.ENABLE_FROM_LINTING,\n                hide_parameters=configs.HIDE_PARAMETERS,\n                pool_pre_ping=configs.POOL_PRE_PING,\n                pool_size=configs.POOL_SIZE,\n                pool_recycle=configs.POOL_RECYCLE_SECONDS,\n                pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n                pool_timeout=configs.POOL_TIMEOUT,\n                pool_use_lifo=configs.POOL_USE_LIFO,\n                query_cache_size=configs.QUERY_CACHE_SIZE,\n                max_overflow=configs.POOL_MAX_OVERFLOW,\n                connect_args=self._get_connect_args(),\n            )\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @abstractmethod\n    def _create_url(self, configs: SQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a database connection URL.\n\n        Args:\n            configs: SQLAlchemy configuration.\n\n        Returns:\n            A SQLAlchemy URL object for the database.\n\n        Raises:\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        pass\n\n    def _get_connect_args(self) -&gt; dict:\n        \"\"\"Return additional connection arguments for the engine.\n\n        Returns:\n            A dictionary of connection arguments (default is empty).\n        \"\"\"\n        return {}\n\n    def _get_session_generator(self) -&gt; async_scoped_session:\n        \"\"\"Create an async scoped session factory.\n\n        Returns:\n            An async_scoped_session instance used by `get_session` to provide task-safe sessions.\n\n        Raises:\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            session_maker = async_sessionmaker(self.engine)\n            return async_scoped_session(session_maker, scopefunc=current_task)\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Retrieve a task-safe async SQLAlchemy session.\n\n        Returns:\n            AsyncSession: An async SQLAlchemy session instance for database operations.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            return self._session_generator()  # type: ignore[no-any-return]\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n\n    @override\n    async def remove_session(self) -&gt; None:\n        \"\"\"Remove the current session from the registry.\n\n        Cleans up the session to prevent resource leaks, typically called at the end\n        of a request.\n\n        Raises:\n            DatabaseConnectionError: If there's an error removing the session.\n            DatabaseConfigurationError: If there's an error in the database configuration.\n        \"\"\"\n        try:\n            await self._session_generator.remove()\n        except SQLAlchemyError as e:\n            if \"configuration\" in str(e).lower():\n                raise DatabaseConfigurationError(\n                    database=self._get_database_name(),\n                ) from e\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.__init__(orm_config)</code>","text":"<p>Initialize the base async session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLAlchemyConfig</code> <p>SQLAlchemy configuration.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the configuration type is invalid.</p> <code>DatabaseConnectionError</code> <p>If there's an error creating the database connection.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: SQLAlchemyConfig) -&gt; None:\n    \"\"\"Initialize the base async session manager.\n\n    Args:\n        orm_config: SQLAlchemy configuration.\n\n    Raises:\n        InvalidArgumentError: If the configuration type is invalid.\n        DatabaseConnectionError: If there's an error creating the database connection.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    if not isinstance(orm_config, self._expected_config_type()):\n        raise InvalidArgumentError(\n            f\"Expected {self._expected_config_type().__name__}, got {type(orm_config).__name__}\",\n        )\n    try:\n        self.engine = self._create_async_engine(orm_config)\n        self._session_generator = self._get_session_generator()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.get_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.get_session()</code>","text":"<p>Retrieve a task-safe async SQLAlchemy session.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>An async SQLAlchemy session instance for database operations.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error creating the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Retrieve a task-safe async SQLAlchemy session.\n\n    Returns:\n        AsyncSession: An async SQLAlchemy session instance for database operations.\n\n    Raises:\n        DatabaseConnectionError: If there's an error creating the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        return self._session_generator()  # type: ignore[no-any-return]\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.remove_session","title":"<code>archipy.adapters.base.sqlalchemy.session_managers.AsyncBaseSQLAlchemySessionManager.remove_session()</code>  <code>async</code>","text":"<p>Remove the current session from the registry.</p> <p>Cleans up the session to prevent resource leaks, typically called at the end of a request.</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error removing the session.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_managers.py</code> <pre><code>@override\nasync def remove_session(self) -&gt; None:\n    \"\"\"Remove the current session from the registry.\n\n    Cleans up the session to prevent resource leaks, typically called at the end\n    of a request.\n\n    Raises:\n        DatabaseConnectionError: If there's an error removing the session.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n    \"\"\"\n    try:\n        await self._session_generator.remove()\n    except SQLAlchemyError as e:\n        if \"configuration\" in str(e).lower():\n            raise DatabaseConfigurationError(\n                database=self._get_database_name(),\n            ) from e\n        raise DatabaseConnectionError(\n            database=self._get_database_name(),\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry</code>","text":"<p>Registry for SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous session managers, implementing the Service Locator pattern.</p> <p>Subclasses should override get_sync_manager and get_async_manager to provide concrete session managers, or use set_sync_manager and set_async_manager to register managers manually.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.postgres.sqlalchemy.session_manager_registry import PostgresSessionManagerRegistry\n&gt;&gt;&gt; sync_manager = PostgresSessionManagerRegistry.get_sync_manager()\n&gt;&gt;&gt; session = sync_manager.get_session()\n</code></pre> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>class SessionManagerRegistry:\n    \"\"\"Registry for SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous session managers, implementing the Service Locator pattern.\n\n    Subclasses should override get_sync_manager and get_async_manager to provide\n    concrete session managers, or use set_sync_manager and set_async_manager to\n    register managers manually.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.postgres.sqlalchemy.session_manager_registry import PostgresSessionManagerRegistry\n        &gt;&gt;&gt; sync_manager = PostgresSessionManagerRegistry.get_sync_manager()\n        &gt;&gt;&gt; session = sync_manager.get_session()\n    \"\"\"\n\n    _sync_instance = None\n    _async_instance = None\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous session manager instance.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            InternalError: If no synchronous session manager is set\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            raise InternalError(\"Synchronous session manager not initialized\")\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom synchronous session manager.\n\n        Args:\n            manager: An instance implementing SessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"Session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n        if not isinstance(manager, SessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous session manager instance.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            InternalError: If no asynchronous session manager is set\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            raise InternalError(\"Asynchronous session manager not initialized\")\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom asynchronous session manager.\n\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"Session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n        if not isinstance(manager, AsyncSessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous session manager instance.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If no synchronous session manager is set</p> <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous session manager instance.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        InternalError: If no synchronous session manager is set\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        raise InternalError(\"Synchronous session manager not initialized\")\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>An instance implementing SessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement SessionManagerPort</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom synchronous session manager.\n\n    Args:\n        manager: An instance implementing SessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"Session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n    if not isinstance(manager, SessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous session manager instance.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If no asynchronous session manager is set</p> <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous session manager instance.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        InternalError: If no asynchronous session manager is set\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        raise InternalError(\"Asynchronous session manager not initialized\")\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>An instance implementing AsyncSessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement AsyncSessionManagerPort</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom asynchronous session manager.\n\n    Args:\n        manager: An instance implementing AsyncSessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"Session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n    if not isinstance(manager, AsyncSessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.reset","title":"<code>archipy.adapters.base.sqlalchemy.session_manager_registry.SessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/base/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#postgresql","title":"PostgreSQL","text":"<p>PostgreSQL database adapter with SQLAlchemy integration.</p> <pre><code>from archipy.adapters.postgres.sqlalchemy.adapters import PostgresSQLAlchemyAdapter, AsyncPostgresSQLAlchemyAdapter\n\n# Create an ORM adapter (uses global config)\norm_adapter = PostgresSQLAlchemyAdapter()\n\n# Use the adapter\nusers = orm_adapter.query(User).filter(User.active == True).all()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>BaseSQLAlchemyAdapter</code></p> <p>Synchronous SQLAlchemy adapter for PostgreSQL.</p> <p>Inherits from BaseSQLAlchemyAdapter to provide PostgreSQL-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>class PostgresSQLAlchemyAdapter(BaseSQLAlchemyAdapter):\n    \"\"\"Synchronous SQLAlchemy adapter for PostgreSQL.\n\n    Inherits from BaseSQLAlchemyAdapter to provide PostgreSQL-specific session management\n    and database operations.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the PostgreSQL adapter with a session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_session_manager(self, configs: PostgresSQLAlchemyConfig) -&gt; PostgresSQlAlchemySessionManager:\n        \"\"\"Create a PostgreSQL-specific session manager.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            A PostgreSQL session manager instance.\n        \"\"\"\n        return PostgresSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.PostgresSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the PostgreSQL adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the PostgreSQL adapter with a session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemyAdapter</code></p> <p>Asynchronous SQLAlchemy adapter for PostgreSQL.</p> <p>Inherits from AsyncBaseSQLAlchemyAdapter to provide async PostgreSQL-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>class AsyncPostgresSQLAlchemyAdapter(AsyncBaseSQLAlchemyAdapter):\n    \"\"\"Asynchronous SQLAlchemy adapter for PostgreSQL.\n\n    Inherits from AsyncBaseSQLAlchemyAdapter to provide async PostgreSQL-specific session\n    management and database operations.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async PostgreSQL adapter with a session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_async_session_manager(self, configs: PostgresSQLAlchemyConfig) -&gt; AsyncPostgresSQlAlchemySessionManager:\n        \"\"\"Create an async PostgreSQL-specific session manager.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            An async PostgreSQL session manager instance.\n        \"\"\"\n        return AsyncPostgresSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.adapters.AsyncPostgresSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the async PostgreSQL adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async PostgreSQL adapter with a session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>BaseSQLAlchemySessionManager</code></p> <p>Synchronous SQLAlchemy session manager for PostgreSQL.</p> <p>Inherits from BaseSQLAlchemySessionManager to provide PostgreSQL-specific session management, including connection URL creation and engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>class PostgresSQlAlchemySessionManager(BaseSQLAlchemySessionManager, metaclass=Singleton):\n    \"\"\"Synchronous SQLAlchemy session manager for PostgreSQL.\n\n    Inherits from BaseSQLAlchemySessionManager to provide PostgreSQL-specific session\n    management, including connection URL creation and engine configuration.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the PostgreSQL session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[PostgresSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for PostgreSQL.\n\n        Returns:\n            The PostgresSQLAlchemyConfig class.\n        \"\"\"\n        return PostgresSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('postgresql').\n        \"\"\"\n        return \"postgresql\"\n\n    @override\n    def _create_url(self, configs: PostgresSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a PostgreSQL connection URL.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            A SQLAlchemy URL object for PostgreSQL.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.PostgresSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the PostgreSQL session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the PostgreSQL session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemySessionManager</code></p> <p>Asynchronous SQLAlchemy session manager for PostgreSQL.</p> <p>Inherits from AsyncBaseSQLAlchemySessionManager to provide async PostgreSQL-specific session management, including connection URL creation and async engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>class AsyncPostgresSQlAlchemySessionManager(AsyncBaseSQLAlchemySessionManager, metaclass=Singleton):\n    \"\"\"Asynchronous SQLAlchemy session manager for PostgreSQL.\n\n    Inherits from AsyncBaseSQLAlchemySessionManager to provide async PostgreSQL-specific\n    session management, including connection URL creation and async engine configuration.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async PostgreSQL session manager.\n\n        Args:\n            orm_config: PostgreSQL-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[PostgresSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for PostgreSQL.\n\n        Returns:\n            The PostgresSQLAlchemyConfig class.\n        \"\"\"\n        return PostgresSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('postgresql').\n        \"\"\"\n        return \"postgresql\"\n\n    @override\n    def _create_url(self, configs: PostgresSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create an async PostgreSQL connection URL.\n\n        Args:\n            configs: PostgreSQL configuration.\n\n        Returns:\n            A SQLAlchemy URL object for PostgreSQL.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.postgres.sqlalchemy.session_managers.AsyncPostgresSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the async PostgreSQL session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>PostgresSQLAlchemyConfig | None</code> <p>PostgreSQL-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: PostgresSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async PostgreSQL session manager.\n\n    Args:\n        orm_config: PostgreSQL-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().POSTGRES_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry</code>","text":"<p>               Bases: <code>SessionManagerRegistry</code></p> <p>Registry for PostgreSQL SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous PostgreSQL session managers, implementing the Service Locator pattern. It lazily initializes the appropriate session manager when first requested.</p> <p>The registry maintains singleton instances of: - A synchronous session manager (PostgresSQlAlchemySessionManager) - An asynchronous session manager (AsyncPostgresSQlAlchemySessionManager)</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>class PostgresSessionManagerRegistry(SessionManagerRegistry, metaclass=Singleton):\n    \"\"\"Registry for PostgreSQL SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous PostgreSQL session managers, implementing the Service Locator pattern.\n    It lazily initializes the appropriate session manager when first requested.\n\n    The registry maintains singleton instances of:\n    - A synchronous session manager (PostgresSQlAlchemySessionManager)\n    - An asynchronous session manager (AsyncPostgresSQlAlchemySessionManager)\n    \"\"\"\n\n    _sync_instance: \"SessionManagerPort | None\" = None\n    _async_instance: \"AsyncSessionManagerPort | None\" = None\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous PostgreSQL session manager instance.\n\n        Lazily initializes a default PostgresSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            try:\n                from archipy.adapters.postgres.sqlalchemy.session_managers import PostgresSQlAlchemySessionManager\n\n                cls._sync_instance = PostgresSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"postgresql\",\n                ) from e\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom synchronous session manager.\n\n        Args:\n            manager: An instance implementing SessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"PostgreSQL session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n        if not isinstance(manager, SessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous PostgreSQL session manager instance.\n\n        Lazily initializes a default AsyncPostgresSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            try:\n                from archipy.adapters.postgres.sqlalchemy.session_managers import AsyncPostgresSQlAlchemySessionManager\n\n                cls._async_instance = AsyncPostgresSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"postgresql\",\n                ) from e\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom asynchronous session manager.\n\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"PostgreSQL async session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n        if not isinstance(manager, AsyncSessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous PostgreSQL session manager instance.</p> <p>Lazily initializes a default PostgresSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous PostgreSQL session manager instance.\n\n    Lazily initializes a default PostgresSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        try:\n            from archipy.adapters.postgres.sqlalchemy.session_managers import PostgresSQlAlchemySessionManager\n\n            cls._sync_instance = PostgresSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"postgresql\",\n            ) from e\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>An instance implementing SessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement SessionManagerPort</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom synchronous session manager.\n\n    Args:\n        manager: An instance implementing SessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"PostgreSQL session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n    if not isinstance(manager, SessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous PostgreSQL session manager instance.</p> <p>Lazily initializes a default AsyncPostgresSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous PostgreSQL session manager instance.\n\n    Lazily initializes a default AsyncPostgresSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        try:\n            from archipy.adapters.postgres.sqlalchemy.session_managers import AsyncPostgresSQlAlchemySessionManager\n\n            cls._async_instance = AsyncPostgresSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"postgresql\",\n            ) from e\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>An instance implementing AsyncSessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement AsyncSessionManagerPort</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom asynchronous session manager.\n\n    Args:\n        manager: An instance implementing AsyncSessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"PostgreSQL async session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n    if not isinstance(manager, AsyncSessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.reset","title":"<code>archipy.adapters.postgres.sqlalchemy.session_manager_registry.PostgresSessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/postgres/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#sqlite","title":"SQLite","text":"<p>SQLite database adapter with SQLAlchemy integration.</p> <pre><code>from archipy.adapters.sqlite.sqlalchemy.adapters import SQLiteSQLAlchemyAdapter, AsyncSQLiteSQLAlchemyAdapter\n\n# Create an ORM adapter (uses global config)\norm_adapter = SQLiteSQLAlchemyAdapter()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>BaseSQLAlchemyAdapter</code></p> <p>Synchronous SQLAlchemy adapter for SQLite.</p> <p>Inherits from BaseSQLAlchemyAdapter to provide SQLite-specific session management and database operations, typically used for in-memory testing.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>class SQLiteSQLAlchemyAdapter(BaseSQLAlchemyAdapter):\n    \"\"\"Synchronous SQLAlchemy adapter for SQLite.\n\n    Inherits from BaseSQLAlchemyAdapter to provide SQLite-specific session management\n    and database operations, typically used for in-memory testing.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the SQLite adapter with a session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_session_manager(self, configs: SQLiteSQLAlchemyConfig) -&gt; SQLiteSQLAlchemySessionManager:\n        \"\"\"Create a SQLite-specific session manager.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            A SQLite session manager instance.\n        \"\"\"\n        return SQLiteSQLAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.SQLiteSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the SQLite adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the SQLite adapter with a session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemyAdapter</code></p> <p>Asynchronous SQLAlchemy adapter for SQLite.</p> <p>Inherits from AsyncBaseSQLAlchemyAdapter to provide async SQLite-specific session management and database operations, typically used for in-memory testing.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>class AsyncSQLiteSQLAlchemyAdapter(AsyncBaseSQLAlchemyAdapter):\n    \"\"\"Asynchronous SQLAlchemy adapter for SQLite.\n\n    Inherits from AsyncBaseSQLAlchemyAdapter to provide async SQLite-specific session\n    management and database operations, typically used for in-memory testing.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async SQLite adapter with a session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_async_session_manager(self, configs: SQLiteSQLAlchemyConfig) -&gt; AsyncSQLiteSQLAlchemySessionManager:\n        \"\"\"Create an async SQLite-specific session manager.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            An async SQLite session manager instance.\n        \"\"\"\n        return AsyncSQLiteSQLAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.adapters.AsyncSQLiteSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the async SQLite adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async SQLite adapter with a session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>BaseSQLAlchemySessionManager</code></p> <p>Synchronous SQLAlchemy session manager for SQLite.</p> <p>Inherits from BaseSQLAlchemySessionManager to provide SQLite-specific session management, including connection URL creation and engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>class SQLiteSQLAlchemySessionManager(BaseSQLAlchemySessionManager, metaclass=Singleton):\n    \"\"\"Synchronous SQLAlchemy session manager for SQLite.\n\n    Inherits from BaseSQLAlchemySessionManager to provide SQLite-specific session\n    management, including connection URL creation and engine configuration.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the SQLite session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[SQLiteSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for SQLite.\n\n        Returns:\n            The SQLiteSQLAlchemyConfig class.\n        \"\"\"\n        return SQLiteSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('sqlite').\n        \"\"\"\n        return \"sqlite\"\n\n    @override\n    def _create_url(self, configs: SQLiteSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a SQLite connection URL.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            A SQLAlchemy URL object for SQLite.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.SQLiteSQLAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the SQLite session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the SQLite session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemySessionManager</code></p> <p>Asynchronous SQLAlchemy session manager for SQLite.</p> <p>Inherits from AsyncBaseSQLAlchemySessionManager to provide async SQLite-specific session management, including connection URL creation and async engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>class AsyncSQLiteSQLAlchemySessionManager(AsyncBaseSQLAlchemySessionManager, metaclass=Singleton):\n    \"\"\"Asynchronous SQLAlchemy session manager for SQLite.\n\n    Inherits from AsyncBaseSQLAlchemySessionManager to provide async SQLite-specific\n    session management, including connection URL creation and async engine configuration.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async SQLite session manager.\n\n        Args:\n            orm_config: SQLite-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[SQLiteSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for SQLite.\n\n        Returns:\n            The SQLiteSQLAlchemyConfig class.\n        \"\"\"\n        return SQLiteSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('sqlite').\n        \"\"\"\n        return \"sqlite\"\n\n    @override\n    def _create_url(self, configs: SQLiteSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create an async SQLite connection URL.\n\n        Args:\n            configs: SQLite configuration.\n\n        Returns:\n            A SQLAlchemy URL object for SQLite.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager.__init__","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_managers.AsyncSQLiteSQLAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the async SQLite session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SQLiteSQLAlchemyConfig | None</code> <p>SQLite-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: SQLiteSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async SQLite session manager.\n\n    Args:\n        orm_config: SQLite-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLITE_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry</code>","text":"<p>               Bases: <code>SessionManagerRegistry</code></p> <p>Registry for SQLite SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous SQLite session managers, implementing the Service Locator pattern. It lazily initializes the appropriate session manager when first requested.</p> <p>The registry maintains singleton instances of: - A synchronous session manager (SQLiteSQLAlchemySessionManager) - An asynchronous session manager (AsyncSQLiteSQLAlchemySessionManager)</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>class SQLiteSessionManagerRegistry(SessionManagerRegistry, metaclass=Singleton):\n    \"\"\"Registry for SQLite SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous SQLite session managers, implementing the Service Locator pattern.\n    It lazily initializes the appropriate session manager when first requested.\n\n    The registry maintains singleton instances of:\n    - A synchronous session manager (SQLiteSQLAlchemySessionManager)\n    - An asynchronous session manager (AsyncSQLiteSQLAlchemySessionManager)\n    \"\"\"\n\n    _sync_instance: ClassVar[Optional[\"SessionManagerPort\"]] = None\n    _async_instance: ClassVar[Optional[\"AsyncSessionManagerPort\"]] = None\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous SQLite session manager instance.\n\n        Lazily initializes a default SQLiteSQLAlchemySessionManager if none has been set.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            try:\n                from archipy.adapters.sqlite.sqlalchemy.session_managers import SQLiteSQLAlchemySessionManager\n\n                cls._sync_instance = SQLiteSQLAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"sqlite\",\n                ) from e\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Register a synchronous session manager.\n\n        Args:\n            manager: The session manager to register\n        \"\"\"\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous SQLite session manager instance.\n\n        Lazily initializes a default AsyncSQLiteSQLAlchemySessionManager if none has been set.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            try:\n                from archipy.adapters.sqlite.sqlalchemy.session_managers import AsyncSQLiteSQLAlchemySessionManager\n\n                cls._async_instance = AsyncSQLiteSQLAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"sqlite\",\n                ) from e\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Register an asynchronous session manager.\n\n        Args:\n            manager: The async session manager to register\n        \"\"\"\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous SQLite session manager instance.</p> <p>Lazily initializes a default SQLiteSQLAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous SQLite session manager instance.\n\n    Lazily initializes a default SQLiteSQLAlchemySessionManager if none has been set.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        try:\n            from archipy.adapters.sqlite.sqlalchemy.session_managers import SQLiteSQLAlchemySessionManager\n\n            cls._sync_instance = SQLiteSQLAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"sqlite\",\n            ) from e\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Register a synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>The session manager to register</p> required Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Register a synchronous session manager.\n\n    Args:\n        manager: The session manager to register\n    \"\"\"\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous SQLite session manager instance.</p> <p>Lazily initializes a default AsyncSQLiteSQLAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous SQLite session manager instance.\n\n    Lazily initializes a default AsyncSQLiteSQLAlchemySessionManager if none has been set.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        try:\n            from archipy.adapters.sqlite.sqlalchemy.session_managers import AsyncSQLiteSQLAlchemySessionManager\n\n            cls._async_instance = AsyncSQLiteSQLAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"sqlite\",\n            ) from e\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Register an asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>The async session manager to register</p> required Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Register an asynchronous session manager.\n\n    Args:\n        manager: The async session manager to register\n    \"\"\"\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.reset","title":"<code>archipy.adapters.sqlite.sqlalchemy.session_manager_registry.SQLiteSessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/sqlite/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#starrocks","title":"StarRocks","text":"<p>StarRocks database adapter with SQLAlchemy integration.</p> <pre><code>from archipy.adapters.starrocks.sqlalchemy.adapters import StarrocksSQLAlchemyAdapter, AsyncStarrocksSQLAlchemyAdapter\n\n# Create an ORM adapter (uses global config)\norm_adapter = StarrocksSQLAlchemyAdapter()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>BaseSQLAlchemyAdapter</code></p> <p>Synchronous SQLAlchemy adapter for Starrocks.</p> <p>Inherits from BaseSQLAlchemyAdapter to provide Starrocks-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>class StarrocksSQLAlchemyAdapter(BaseSQLAlchemyAdapter):\n    \"\"\"Synchronous SQLAlchemy adapter for Starrocks.\n\n    Inherits from BaseSQLAlchemyAdapter to provide Starrocks-specific session management\n    and database operations.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the Starrocks adapter with a session manager.\n\n        Args:\n            orm_config: Starrocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_session_manager(self, configs: StarRocksSQLAlchemyConfig) -&gt; StarRocksSQlAlchemySessionManager:\n        \"\"\"Create a Starrocks-specific session manager.\n\n        Args:\n            configs: Starrocks configuration.\n\n        Returns:\n            A Starrocks session manager instance.\n        \"\"\"\n        return StarRocksSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.StarrocksSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the Starrocks adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the Starrocks adapter with a session manager.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemyAdapter</code></p> <p>Asynchronous SQLAlchemy adapter for Starrocks.</p> <p>Inherits from AsyncBaseSQLAlchemyAdapter to provide async Starrocks-specific session management and database operations.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>class AsyncStarrocksSQLAlchemyAdapter(AsyncBaseSQLAlchemyAdapter):\n    \"\"\"Asynchronous SQLAlchemy adapter for Starrocks.\n\n    Inherits from AsyncBaseSQLAlchemyAdapter to provide async Starrocks-specific session\n    management and database operations.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async Starrocks adapter with a session manager.\n\n        Args:\n            orm_config: Starrocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _create_async_session_manager(\n        self,\n        configs: StarRocksSQLAlchemyConfig,\n    ) -&gt; AsyncStarRocksSQlAlchemySessionManager:\n        \"\"\"Create an async Starrocks-specific session manager.\n\n        Args:\n            configs: Starrocks configuration.\n\n        Returns:\n            An async Starrocks session manager instance.\n        \"\"\"\n        return AsyncStarRocksSQlAlchemySessionManager(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.adapters.AsyncStarrocksSQLAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initialize the async Starrocks adapter with a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>Starrocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async Starrocks adapter with a session manager.\n\n    Args:\n        orm_config: Starrocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>BaseSQLAlchemySessionManager</code></p> <p>Synchronous SQLAlchemy session manager for StarRocks.</p> <p>Inherits from BaseSQLAlchemySessionManager to provide StarRocks-specific session management, including connection URL creation and engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>class StarRocksSQlAlchemySessionManager(BaseSQLAlchemySessionManager, metaclass=Singleton):\n    \"\"\"Synchronous SQLAlchemy session manager for StarRocks.\n\n    Inherits from BaseSQLAlchemySessionManager to provide StarRocks-specific session\n    management, including connection URL creation and engine configuration.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the StarRocks session manager.\n\n        Args:\n            orm_config: StarRocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[StarRocksSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for StarRocks.\n\n        Returns:\n            The StarRocksSQLAlchemyConfig class.\n        \"\"\"\n        return StarRocksSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('starrocks').\n        \"\"\"\n        return \"starrocks\"\n\n    @override\n    def _create_url(self, configs: StarRocksSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create a StarRocks connection URL.\n\n        Args:\n            configs: StarRocks configuration.\n\n        Returns:\n            A SQLAlchemy URL object for StarRocks.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.StarRocksSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the StarRocks session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the StarRocks session manager.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager</code>","text":"<p>               Bases: <code>AsyncBaseSQLAlchemySessionManager</code></p> <p>Asynchronous SQLAlchemy session manager for StarRocks.</p> <p>Inherits from AsyncBaseSQLAlchemySessionManager to provide async StarRocks-specific session management, including connection URL creation and async engine configuration.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>class AsyncStarRocksSQlAlchemySessionManager(AsyncBaseSQLAlchemySessionManager, metaclass=Singleton):\n    \"\"\"Asynchronous SQLAlchemy session manager for StarRocks.\n\n    Inherits from AsyncBaseSQLAlchemySessionManager to provide async StarRocks-specific\n    session management, including connection URL creation and async engine configuration.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n\n    def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initialize the async StarRocks session manager.\n\n        Args:\n            orm_config: StarRocks-specific configuration. If None, uses global config.\n        \"\"\"\n        configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n        super().__init__(configs)\n\n    @override\n    def _expected_config_type(self) -&gt; type[StarRocksSQLAlchemyConfig]:\n        \"\"\"Return the expected configuration type for StarRocks.\n\n        Returns:\n            The StarRocksSQLAlchemyConfig class.\n        \"\"\"\n        return StarRocksSQLAlchemyConfig\n\n    @override\n    def _get_database_name(self) -&gt; str:\n        \"\"\"Return the name of the database being used.\n\n        Returns:\n            str: The name of the database ('starrocks').\n        \"\"\"\n        return \"starrocks\"\n\n    @override\n    def _create_url(self, configs: StarRocksSQLAlchemyConfig) -&gt; URL:\n        \"\"\"Create an async StarRocks connection URL.\n\n        Args:\n            configs: StarRocks configuration.\n\n        Returns:\n            A SQLAlchemy URL object for StarRocks.\n\n        Raises:\n            DatabaseConnectionError: If there's an error creating the URL.\n        \"\"\"\n        try:\n            return URL.create(\n                drivername=configs.DRIVER_NAME,\n                username=configs.USERNAME,\n                password=configs.PASSWORD,\n                host=configs.HOST,\n                port=configs.PORT,\n                database=configs.DATABASE,\n            )\n        except SQLAlchemyError as e:\n            raise DatabaseConnectionError(\n                database=self._get_database_name(),\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager.__init__","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_managers.AsyncStarRocksSQlAlchemySessionManager.__init__(orm_config=None)</code>","text":"<p>Initialize the async StarRocks session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>StarRocksSQLAlchemyConfig | None</code> <p>StarRocks-specific configuration. If None, uses global config.</p> <code>None</code> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_managers.py</code> <pre><code>def __init__(self, orm_config: StarRocksSQLAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initialize the async StarRocks session manager.\n\n    Args:\n        orm_config: StarRocks-specific configuration. If None, uses global config.\n    \"\"\"\n    configs = BaseConfig.global_config().STARROCKS_SQLALCHEMY if orm_config is None else orm_config\n    super().__init__(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry</code>","text":"<p>               Bases: <code>SessionManagerRegistry</code></p> <p>Registry for StarRocks SQLAlchemy session managers.</p> <p>This registry provides a centralized access point for both synchronous and asynchronous StarRocks session managers, implementing the Service Locator pattern. It lazily initializes the appropriate session manager when first requested.</p> <p>The registry maintains singleton instances of: - A synchronous session manager (StarRocksSQlAlchemySessionManager) - An asynchronous session manager (AsyncStarRocksSQlAlchemySessionManager)</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>class StarRocksSessionManagerRegistry(SessionManagerRegistry, metaclass=Singleton):\n    \"\"\"Registry for StarRocks SQLAlchemy session managers.\n\n    This registry provides a centralized access point for both synchronous and\n    asynchronous StarRocks session managers, implementing the Service Locator pattern.\n    It lazily initializes the appropriate session manager when first requested.\n\n    The registry maintains singleton instances of:\n    - A synchronous session manager (StarRocksSQlAlchemySessionManager)\n    - An asynchronous session manager (AsyncStarRocksSQlAlchemySessionManager)\n    \"\"\"\n\n    _sync_instance: \"SessionManagerPort | None\" = None\n    _async_instance: \"AsyncSessionManagerPort | None\" = None\n\n    @classmethod\n    def get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n        \"\"\"Get the synchronous StarRocks session manager instance.\n\n        Lazily initializes a default StarRocksSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._sync_instance is None:\n            try:\n                from archipy.adapters.starrocks.sqlalchemy.session_managers import StarRocksSQlAlchemySessionManager\n\n                cls._sync_instance = StarRocksSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"starrocks\",\n                ) from e\n        return cls._sync_instance\n\n    @classmethod\n    def set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom synchronous session manager.\n\n        Args:\n            manager: An instance implementing SessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"StarRocks session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n        if not isinstance(manager, SessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n        cls._sync_instance = manager\n\n    @classmethod\n    def get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n        \"\"\"Get the asynchronous StarRocks session manager instance.\n\n        Lazily initializes a default AsyncStarRocksSQlAlchemySessionManager if none has been set.\n\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n\n        Raises:\n            DatabaseConnectionError: If there's an error initializing the session manager\n        \"\"\"\n        if cls._async_instance is None:\n            try:\n                from archipy.adapters.starrocks.sqlalchemy.session_managers import (\n                    AsyncStarRocksSQlAlchemySessionManager,\n                )\n\n                cls._async_instance = AsyncStarRocksSQlAlchemySessionManager()\n            except Exception as e:\n                raise DatabaseConnectionError(\n                    database=\"starrocks\",\n                ) from e\n        return cls._async_instance\n\n    @classmethod\n    def set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n        \"\"\"Set a custom asynchronous session manager.\n\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        \"\"\"\n        if manager is None:\n            raise InvalidArgumentError(\"StarRocks async session manager cannot be None\")\n        from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n        if not isinstance(manager, AsyncSessionManagerPort):\n            raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n        cls._async_instance = manager\n\n    @classmethod\n    def reset(cls) -&gt; None:\n        \"\"\"Reset the registry to its initial state.\n\n        This method clears both registered managers, useful for testing.\n        \"\"\"\n        cls._sync_instance = None\n        cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_sync_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_sync_manager()</code>  <code>classmethod</code>","text":"<p>Get the synchronous StarRocks session manager instance.</p> <p>Lazily initializes a default StarRocksSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>SessionManagerPort</code> <code>SessionManagerPort</code> <p>The registered synchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_sync_manager(cls) -&gt; \"SessionManagerPort\":\n    \"\"\"Get the synchronous StarRocks session manager instance.\n\n    Lazily initializes a default StarRocksSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        SessionManagerPort: The registered synchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._sync_instance is None:\n        try:\n            from archipy.adapters.starrocks.sqlalchemy.session_managers import StarRocksSQlAlchemySessionManager\n\n            cls._sync_instance = StarRocksSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"starrocks\",\n            ) from e\n    return cls._sync_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_sync_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_sync_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom synchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>SessionManagerPort</code> <p>An instance implementing SessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement SessionManagerPort</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_sync_manager(cls, manager: \"SessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom synchronous session manager.\n\n    Args:\n        manager: An instance implementing SessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"StarRocks session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import SessionManagerPort\n\n    if not isinstance(manager, SessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement SessionManagerPort, got {type(manager).__name__}\")\n    cls._sync_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_async_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.get_async_manager()</code>  <code>classmethod</code>","text":"<p>Get the asynchronous StarRocks session manager instance.</p> <p>Lazily initializes a default AsyncStarRocksSQlAlchemySessionManager if none has been set.</p> <p>Returns:</p> Name Type Description <code>AsyncSessionManagerPort</code> <code>AsyncSessionManagerPort</code> <p>The registered asynchronous session manager</p> <p>Raises:</p> Type Description <code>DatabaseConnectionError</code> <p>If there's an error initializing the session manager</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef get_async_manager(cls) -&gt; \"AsyncSessionManagerPort\":\n    \"\"\"Get the asynchronous StarRocks session manager instance.\n\n    Lazily initializes a default AsyncStarRocksSQlAlchemySessionManager if none has been set.\n\n    Returns:\n        AsyncSessionManagerPort: The registered asynchronous session manager\n\n    Raises:\n        DatabaseConnectionError: If there's an error initializing the session manager\n    \"\"\"\n    if cls._async_instance is None:\n        try:\n            from archipy.adapters.starrocks.sqlalchemy.session_managers import (\n                AsyncStarRocksSQlAlchemySessionManager,\n            )\n\n            cls._async_instance = AsyncStarRocksSQlAlchemySessionManager()\n        except Exception as e:\n            raise DatabaseConnectionError(\n                database=\"starrocks\",\n            ) from e\n    return cls._async_instance\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_async_manager","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.set_async_manager(manager)</code>  <code>classmethod</code>","text":"<p>Set a custom asynchronous session manager.</p> <p>Parameters:</p> Name Type Description Default <code>manager</code> <code>AsyncSessionManagerPort</code> <p>An instance implementing AsyncSessionManagerPort</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the manager is None or doesn't implement AsyncSessionManagerPort</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef set_async_manager(cls, manager: \"AsyncSessionManagerPort\") -&gt; None:\n    \"\"\"Set a custom asynchronous session manager.\n\n    Args:\n        manager: An instance implementing AsyncSessionManagerPort\n\n    Raises:\n        InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n    \"\"\"\n    if manager is None:\n        raise InvalidArgumentError(\"StarRocks async session manager cannot be None\")\n    from archipy.adapters.base.sqlalchemy.session_manager_ports import AsyncSessionManagerPort\n\n    if not isinstance(manager, AsyncSessionManagerPort):\n        raise InvalidArgumentError(f\"Manager must implement AsyncSessionManagerPort, got {type(manager).__name__}\")\n    cls._async_instance = manager\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.reset","title":"<code>archipy.adapters.starrocks.sqlalchemy.session_manager_registry.StarRocksSessionManagerRegistry.reset()</code>  <code>classmethod</code>","text":"<p>Reset the registry to its initial state.</p> <p>This method clears both registered managers, useful for testing.</p> Source code in <code>archipy/adapters/starrocks/sqlalchemy/session_manager_registry.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Reset the registry to its initial state.\n\n    This method clears both registered managers, useful for testing.\n    \"\"\"\n    cls._sync_instance = None\n    cls._async_instance = None\n</code></pre>"},{"location":"api_reference/adapters/#email","title":"Email","text":"<p>Email sending functionality with standardized interface.</p> <pre><code>from archipy.adapters.email import EmailAdapter, EmailPort\n\n# Configure email adapter\nemail_adapter = EmailAdapter(host=\"smtp.example.com\", port=587, username=\"user\", password=\"pass\")\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email\",\n    recipients=[\"recipient@example.com\"],\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler","title":"<code>archipy.adapters.email.adapters.AttachmentHandler</code>","text":"<p>Enhanced attachment handler with better type safety and validation</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class AttachmentHandler:\n    \"\"\"Enhanced attachment handler with better type safety and validation\"\"\"\n\n    @staticmethod\n    def create_attachment(\n        source: str | bytes | BinaryIO | HttpUrl,\n        filename: str,\n        attachment_type: EmailAttachmentType,\n        content_type: str | None = None,\n        content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n        content_id: str | None = None,\n        max_size: int | None = None,\n    ) -&gt; EmailAttachmentDTO:\n        \"\"\"Create an attachment with validation\"\"\"\n        if max_size is None:\n            max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n        try:\n            processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n            return EmailAttachmentDTO(\n                content=processed_content,\n                filename=filename,\n                content_type=content_type,\n                content_disposition=content_disposition,\n                content_id=content_id,\n                attachment_type=attachment_type,\n                max_size=max_size,\n            )\n        except Exception as exception:\n            raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n\n    @staticmethod\n    def _process_source(source: str | bytes | BinaryIO | HttpUrl, attachment_type: EmailAttachmentType) -&gt; bytes:\n        \"\"\"Process different types of attachment sources\"\"\"\n        if attachment_type == EmailAttachmentType.FILE:\n            with open(source, \"rb\") as f:\n                return f.read()\n        elif attachment_type == EmailAttachmentType.BASE64:\n            return base64.b64decode(source)\n        elif attachment_type == EmailAttachmentType.URL:\n            response = requests.get(source)\n            response.raise_for_status()\n            return response.content\n        elif attachment_type == EmailAttachmentType.BINARY:\n            if isinstance(source, bytes):\n                return source\n            if hasattr(source, \"read\"):\n                return source.read()\n            raise ValueError(f\"Invalid binary source type: {type(source)}\")\n        raise ValueError(f\"Unsupported attachment type: {attachment_type}\")\n\n    @staticmethod\n    def process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n        \"\"\"Process and attach the attachment to the email message\"\"\"\n        content = AttachmentHandler._get_content(attachment)\n        part = AttachmentHandler._create_mime_part(content, attachment)\n\n        # Add headers\n        part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n        if attachment.content_id:\n            part.add_header(\"Content-ID\", attachment.content_id)\n\n        msg.attach(part)\n\n    @staticmethod\n    def _get_content(attachment: EmailAttachmentDTO) -&gt; bytes:\n        \"\"\"Get content as bytes from attachment\"\"\"\n        if isinstance(attachment.content, (str, bytes)):\n            return attachment.content if isinstance(attachment.content, bytes) else attachment.content.encode()\n        return attachment.content.read()\n\n    @staticmethod\n    def _create_mime_part(\n        content: bytes,\n        attachment: EmailAttachmentDTO,\n    ) -&gt; MIMEText | MIMEImage | MIMEAudio | MIMEBase:\n        \"\"\"Create appropriate MIME part based on content type\"\"\"\n        main_type, sub_type = attachment.content_type.split(\"/\", 1)\n\n        if main_type == \"text\":\n            return MIMEText(content.decode(), sub_type)\n        if main_type == \"image\":\n            return MIMEImage(content, _subtype=sub_type)\n        if main_type == \"audio\":\n            return MIMEAudio(content, _subtype=sub_type)\n        part = MIMEBase(main_type, sub_type)\n        part.set_payload(content)\n        encoders.encode_base64(part)\n        return part\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.create_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.create_attachment(source, filename, attachment_type, content_type=None, content_disposition=EmailAttachmentDispositionType.ATTACHMENT, content_id=None, max_size=None)</code>  <code>staticmethod</code>","text":"<p>Create an attachment with validation</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef create_attachment(\n    source: str | bytes | BinaryIO | HttpUrl,\n    filename: str,\n    attachment_type: EmailAttachmentType,\n    content_type: str | None = None,\n    content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n    content_id: str | None = None,\n    max_size: int | None = None,\n) -&gt; EmailAttachmentDTO:\n    \"\"\"Create an attachment with validation\"\"\"\n    if max_size is None:\n        max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n    try:\n        processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n        return EmailAttachmentDTO(\n            content=processed_content,\n            filename=filename,\n            content_type=content_type,\n            content_disposition=content_disposition,\n            content_id=content_id,\n            attachment_type=attachment_type,\n            max_size=max_size,\n        )\n    except Exception as exception:\n        raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.process_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.process_attachment(msg, attachment)</code>  <code>staticmethod</code>","text":"<p>Process and attach the attachment to the email message</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n    \"\"\"Process and attach the attachment to the email message\"\"\"\n    content = AttachmentHandler._get_content(attachment)\n    part = AttachmentHandler._create_mime_part(content, attachment)\n\n    # Add headers\n    part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n    if attachment.content_id:\n        part.add_header(\"Content-ID\", attachment.content_id)\n\n    msg.attach(part)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter","title":"<code>archipy.adapters.email.adapters.EmailAdapter</code>","text":"<p>               Bases: <code>EmailPort</code></p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class EmailAdapter(EmailPort):\n    def __init__(self, config: EmailConfig = None):\n        self.config = config or BaseConfig.global_config().EMAIL\n        self.connection_pool = EmailConnectionPool(self.config)\n\n    @override\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send email with advanced features and connection pooling\"\"\"\n        connection = None\n        try:\n            connection = self.connection_pool.get_connection()\n            msg = self._create_message(\n                to_email=to_email,\n                subject=subject,\n                body=body,\n                cc=cc,\n                bcc=bcc,\n                attachments=attachments,\n                html=html,\n                template=template,\n                template_vars=template_vars,\n            )\n\n            recipients = self._get_all_recipients(to_email, cc, bcc)\n\n            for attempt in range(self.config.MAX_RETRIES):\n                try:\n                    if connection.smtp_connection:\n                        connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                        logging.debug(f\"Email sent successfully to {to_email}\")\n                        return\n                    connection.connect()\n                except Exception as e:\n                    if attempt == self.config.MAX_RETRIES - 1:\n                        BaseUtils.capture_exception(e)\n                    connection.connect()  # Retry with fresh connection\n\n        except Exception as e:\n            BaseUtils.capture_exception(e)\n        finally:\n            if connection:\n                self.connection_pool.return_connection(connection)\n\n    def _create_message(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; MIMEMultipart:\n        msg = MIMEMultipart()\n        msg[\"From\"] = self.config.EMAIL_USERNAME\n        msg[\"To\"] = to_email if isinstance(to_email, str) else \", \".join(to_email)\n        msg[\"Subject\"] = subject\n\n        if cc:\n            msg[\"Cc\"] = cc if isinstance(cc, str) else \", \".join(cc)\n        if bcc:\n            msg[\"Bcc\"] = bcc if isinstance(bcc, str) else \", \".join(bcc)\n\n        if template:\n            body = Template(template).render(**(template_vars or {}))\n\n        msg.attach(MIMEText(body, \"html\" if html else \"plain\"))\n\n        if attachments:\n            for attachment in attachments:\n                if isinstance(attachment, str):\n                    # Treat as file path\n                    attachment_obj = AttachmentHandler.create_attachment(\n                        source=attachment,\n                        filename=os.path.basename(attachment),\n                        attachment_type=EmailAttachmentType.FILE,\n                    )\n                else:\n                    attachment_obj = attachment\n                AttachmentHandler.process_attachment(msg, attachment_obj)\n\n        return msg\n\n    @staticmethod\n    def _get_all_recipients(\n        to_email: EmailStr | list[EmailStr],\n        cc: EmailStr | list[EmailStr] | None,\n        bcc: EmailStr | list[EmailStr] | None,\n    ) -&gt; list[str]:\n        \"\"\"Get list of all recipients\"\"\"\n        recipients = []\n\n        # Add primary recipients\n        if isinstance(to_email, str):\n            recipients.append(to_email)\n        else:\n            recipients.extend(to_email)\n\n        # Add CC recipients\n        if cc:\n            if isinstance(cc, str):\n                recipients.append(cc)\n            else:\n                recipients.extend(cc)\n\n        # Add BCC recipients\n        if bcc:\n            if isinstance(bcc, str):\n                recipients.append(bcc)\n            else:\n                recipients.extend(bcc)\n\n        return recipients\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter.send_email","title":"<code>archipy.adapters.email.adapters.EmailAdapter.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>","text":"<p>Send email with advanced features and connection pooling</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@override\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send email with advanced features and connection pooling\"\"\"\n    connection = None\n    try:\n        connection = self.connection_pool.get_connection()\n        msg = self._create_message(\n            to_email=to_email,\n            subject=subject,\n            body=body,\n            cc=cc,\n            bcc=bcc,\n            attachments=attachments,\n            html=html,\n            template=template,\n            template_vars=template_vars,\n        )\n\n        recipients = self._get_all_recipients(to_email, cc, bcc)\n\n        for attempt in range(self.config.MAX_RETRIES):\n            try:\n                if connection.smtp_connection:\n                    connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                    logging.debug(f\"Email sent successfully to {to_email}\")\n                    return\n                connection.connect()\n            except Exception as e:\n                if attempt == self.config.MAX_RETRIES - 1:\n                    BaseUtils.capture_exception(e)\n                connection.connect()  # Retry with fresh connection\n\n    except Exception as e:\n        BaseUtils.capture_exception(e)\n    finally:\n        if connection:\n            self.connection_pool.return_connection(connection)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort","title":"<code>archipy.adapters.email.ports.EmailPort</code>","text":"<p>Interface for email sending operations.</p> <p>This interface defines the contract for email adapters, ensuring a consistent approach to sending emails across different implementations. It provides a comprehensive set of features including support for:</p> <ul> <li>Multiple recipients (To, CC, BCC)</li> <li>HTML and plain text content</li> <li>File and in-memory attachments</li> <li>Template-based email rendering</li> </ul> <p>Implementing classes should handle the details of connecting to an email service, managing connections, and ensuring reliable delivery.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n...     def __init__(self, config):\n...         self.config = config\n...\n...     def send_email(\n...         self,\n...         to_email,\n...         subject,\n...         body,\n...         cc=None,\n...         bcc=None,\n...         attachments=None,\n...         html=False,\n...         template=None,\n...         template_vars=None\n...     ):\n...         # Implementation details...\n...         pass\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>class EmailPort:\n    \"\"\"Interface for email sending operations.\n\n    This interface defines the contract for email adapters, ensuring\n    a consistent approach to sending emails across different implementations.\n    It provides a comprehensive set of features including support for:\n\n    - Multiple recipients (To, CC, BCC)\n    - HTML and plain text content\n    - File and in-memory attachments\n    - Template-based email rendering\n\n    Implementing classes should handle the details of connecting to an\n    email service, managing connections, and ensuring reliable delivery.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n        ...     def __init__(self, config):\n        ...         self.config = config\n        ...\n        ...     def send_email(\n        ...         self,\n        ...         to_email,\n        ...         subject,\n        ...         body,\n        ...         cc=None,\n        ...         bcc=None,\n        ...         attachments=None,\n        ...         html=False,\n        ...         template=None,\n        ...         template_vars=None\n        ...     ):\n        ...         # Implementation details...\n        ...         pass\n    \"\"\"\n\n    @abstractmethod\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send an email with various options and features.\n\n        This method handles the composition and delivery of an email with\n        support for multiple recipients, HTML content, templates, and attachments.\n\n        Args:\n            to_email: Primary recipient(s) of the email\n            subject: Email subject line\n            body: Email body content (either plain text or HTML)\n            cc: Carbon copy recipient(s)\n            bcc: Blind carbon copy recipient(s)\n            attachments: List of file paths or EmailAttachmentDTO objects\n            html: If True, treats body as HTML content, otherwise plain text\n            template: A template string to render using template_vars\n            template_vars: Variables to use when rendering the template\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; # Simple text email\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Hello\",\n            ...     body=\"This is a test email\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # HTML email with attachment\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n            ...     subject=\"Report\",\n            ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n            ...     html=True,\n            ...     attachments=[\"path/to/report.pdf\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Template-based email\n            &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Account Expiration\",\n            ...     body=\"\",  # Body will be rendered from template\n            ...     template=template,\n            ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n            ... )\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort.send_email","title":"<code>archipy.adapters.email.ports.EmailPort.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>  <code>abstractmethod</code>","text":"<p>Send an email with various options and features.</p> <p>This method handles the composition and delivery of an email with support for multiple recipients, HTML content, templates, and attachments.</p> <p>Parameters:</p> Name Type Description Default <code>to_email</code> <code>EmailStr | list[EmailStr]</code> <p>Primary recipient(s) of the email</p> required <code>subject</code> <code>str</code> <p>Email subject line</p> required <code>body</code> <code>str</code> <p>Email body content (either plain text or HTML)</p> required <code>cc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Carbon copy recipient(s)</p> <code>None</code> <code>bcc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Blind carbon copy recipient(s)</p> <code>None</code> <code>attachments</code> <code>list[str | EmailAttachmentDTO] | None</code> <p>List of file paths or EmailAttachmentDTO objects</p> <code>None</code> <code>html</code> <code>bool</code> <p>If True, treats body as HTML content, otherwise plain text</p> <code>False</code> <code>template</code> <code>str | None</code> <p>A template string to render using template_vars</p> <code>None</code> <code>template_vars</code> <code>dict | None</code> <p>Variables to use when rendering the template</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Simple text email\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Hello\",\n...     body=\"This is a test email\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # HTML email with attachment\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n...     subject=\"Report\",\n...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n...     html=True,\n...     attachments=[\"path/to/report.pdf\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Template-based email\n&gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Account Expiration\",\n...     body=\"\",  # Body will be rendered from template\n...     template=template,\n...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n... )\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>@abstractmethod\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send an email with various options and features.\n\n    This method handles the composition and delivery of an email with\n    support for multiple recipients, HTML content, templates, and attachments.\n\n    Args:\n        to_email: Primary recipient(s) of the email\n        subject: Email subject line\n        body: Email body content (either plain text or HTML)\n        cc: Carbon copy recipient(s)\n        bcc: Blind carbon copy recipient(s)\n        attachments: List of file paths or EmailAttachmentDTO objects\n        html: If True, treats body as HTML content, otherwise plain text\n        template: A template string to render using template_vars\n        template_vars: Variables to use when rendering the template\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; # Simple text email\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Hello\",\n        ...     body=\"This is a test email\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # HTML email with attachment\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n        ...     subject=\"Report\",\n        ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n        ...     html=True,\n        ...     attachments=[\"path/to/report.pdf\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Template-based email\n        &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Account Expiration\",\n        ...     body=\"\",  # Body will be rendered from template\n        ...     template=template,\n        ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n        ... )\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#keycloak","title":"Keycloak","text":"<p>Keycloak integration for authentication and authorization services.</p> <pre><code>from archipy.adapters.keycloak import KeycloakAdapter, AsyncKeycloakAdapter\n\n# Create a Keycloak adapter (synchronous)\nkeycloak = KeycloakAdapter()  # Uses global config by default\n\n# Authenticate a user\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Validate token\nis_valid = keycloak.validate_token(token[\"access_token\"])\n\n# Check user roles\nhas_admin = keycloak.has_role(token[\"access_token\"], \"admin\")\n\n# Async usage example\nimport asyncio\n\nasync def auth_example():\n    # Create async Keycloak adapter\n    async_keycloak = AsyncKeycloakAdapter()\n\n    # Get token asynchronously\n    token = await async_keycloak.get_token(\"username\", \"password\")\n\n    # Get user info\n    user_info = await async_keycloak.get_userinfo(token[\"access_token\"])\n    return user_info\n\n# Run the async example\nuser_info = asyncio.run(auth_example())\n</code></pre> <p>For detailed examples and usage guidelines, see the Keycloak Adapter Examples.</p> <p>options: show_root_heading: true show_source: true</p> <p>Keycloak port definitions for ArchiPy.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter</code>","text":"<p>               Bases: <code>KeycloakPort</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class KeycloakAdapter(KeycloakPort):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self._openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter = None\n        self._admin_token_expiry = 0\n\n        # Initialize admin client with service account if client_secret is provided\n        # or with admin credentials if provided\n        if self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD):\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Check if admin credentials are available\n            if self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD:\n                # Create admin client using admin credentials\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    username=self.configs.ADMIN_USERNAME,\n                    password=self.configs.ADMIN_PASSWORD,\n                    realm_name=self.configs.REALM_NAME,\n                    user_realm_name=self.configs.ADMIN_REALM_NAME,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                # Since we're using direct credentials, set a long expiry time\n                self._admin_token_expiry = time.time() + 3600  # 1 hour\n                logger.debug(\"Admin client initialized with admin credentials\")\n\n            elif self.configs.CLIENT_SECRET_KEY:\n                # Get token using client credentials\n                token = self._openid_adapter.token(grant_type=\"client_credentials\")\n\n                # Set token expiry time (current time + expires_in - buffer)\n                # Using a 30-second buffer to ensure we refresh before expiration\n                self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    realm_name=self.configs.REALM_NAME,\n                    token=token,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                logger.debug(\"Admin client initialized with client credentials\")\n\n            else:\n                raise UnauthenticatedError(\n                    additional_data={\"detail\": \"Neither admin credentials nor client secret provided\"}\n                )\n\n        except KeycloakAuthenticationError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise UnauthenticatedError(\n                additional_data={\"detail\": \"Failed to authenticate with Keycloak service account\"}\n            ) from e\n        except KeycloakConnectionError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise ConnectionTimeoutError(\"Failed to connect to Keycloak server\") from e\n        except KeycloakError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            UnauthenticatedError: If admin client is not available due to authentication issues\n            UnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        if not (self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)):\n            raise UnauthenticatedError(additional_data={\"data\": \"Neither admin credentials nor client secret provided\"})\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise UnavailableError(\"Keycloak admin client is not available\")\n\n        return self._admin_adapter\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n\n        Raises:\n            ServiceUnavailableError: If Keycloak service is unavailable\n            InternalError: If there's an internal error processing the public key\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = self._openid_adapter.public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except KeycloakError as e:\n            raise ServiceUnavailableError(\"Failed to retrieve public key from Keycloak\") from e\n        except Exception as e:\n            raise InternalError(\"Failed to process Keycloak public key\") from e\n\n    @override\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidCredentialsError: If username or password is invalid\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return self._openid_adapter.token(grant_type=\"password\", username=username, password=password)\n        except KeycloakAuthenticationError as e:\n            raise InvalidCredentialsError(\"Invalid username or password\") from e\n        except KeycloakError as e:\n            raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n\n    @override\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidTokenError: If refresh token is invalid or expired\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return self._openid_adapter.refresh_token(refresh_token)\n        except KeycloakAuthenticationError as e:\n            raise InvalidTokenError(\"Invalid or expired refresh token\") from e\n        except KeycloakError as e:\n            raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n\n    @override\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            self._openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n        else:\n            return True\n\n    @override\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not self.validate_token(token):\n            raise InvalidTokenError()\n        try:\n            return self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=100)  # Cache for 30 seconds\n    def _get_userinfo_cached(self, token: str) -&gt; KeycloakUserType:\n        return self._openid_adapter.userinfo(token)\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            raise InternalError() from e\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = self.admin_adapter.create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n        else:\n            return user_id\n\n    @override\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Assign role to user\n            self.admin_adapter.assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Remove role from user\n            self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = self.admin_adapter.get_client_id(client_id)\n            # Get role representation\n            role = self.admin_adapter.get_client_role(client, role_name)\n            # Assign role to user\n            self.admin_adapter.assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            self.admin_adapter.create_realm_role(role_data)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            return self.admin_adapter.get_realm_role(role_name)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def create_client_role(self, client_id: str, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new client role.\n\n        Args:\n            client_id: Client ID or client name\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            client_id = self.admin_adapter.get_client_id(client_id)\n\n            # Prepare role data\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            # Create client role\n            self.admin_adapter.create_client_role(client_id, role_data)\n\n            # Clear related caches if they exist\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n            # Return created role\n            return self.admin_adapter.get_client_role(client_id, role_name)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = self.get_client_id(self.configs.CLIENT_ID)\n            return self.admin_adapter.get_client_service_account_user(client_id).get(\"id\")\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return self._openid_adapter.well_known()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return self._openid_adapter.certs()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return self._openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n        except KeycloakError as e:\n            raise InvalidTokenError() from e\n\n    @override\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return self._openid_adapter.token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            raise UnauthenticatedError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_id(client_name)\n        except KeycloakError as e:\n            raise NotFoundError(resource_type=\"client\") from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_role(role_name)\n        except KeycloakError as e:\n            raise NotFoundError(resource_type=\"role\") from e\n\n    @override\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client_id(client_id)\n            role = self.admin_adapter.get_client_role(client, role_name)\n            self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            self.admin_adapter.user_logout(user_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            self._openid_adapter.logout(refresh_token)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return self._openid_adapter.introspect(token)\n        except KeycloakError as e:\n            raise InvalidTokenError() from e\n\n    @override\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return self._openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n        except KeycloakError as e:\n            raise InvalidTokenError() from e\n\n    @override\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            self.admin_adapter.delete_user(user_id=user_id)\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except Exception as e:\n            raise InternalError() from e\n\n    @override\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = client.get(\"roles\", [])\n                if role_name in client_roles:\n                    return True\n\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(roles):\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = set(client.get(\"roles\", []))\n                if role_names.intersection(client_roles):\n                    return True\n\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                all_roles.update(client.get(\"roles\", []))\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = self._openid_adapter.uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception:\n            return False\n        else:\n            return False\n\n    @override\n    def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any]:\n        \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n        :param realm_name: The realm identifier (required)\n        :param skip_exists: Skip creation if realm already exists\n        :param kwargs: Additional optional configurations for the realm\n        :return: Dictionary with realm information and status\n        \"\"\"\n        payload = {\n            \"realm\": realm_name,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"displayName\": kwargs.get(\"display_name\", realm_name),\n        }\n\n        # Add any additional parameters from kwargs\n        for key, value in kwargs.items():\n            # Skip display_name as it's already handled\n            if key == \"display_name\":\n                continue\n\n            # Convert Python snake_case to Keycloak camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        try:\n            self.admin_adapter.create_realm(payload=payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create realm: {e!s}\")\n            raise InternalError() from e\n        else:\n            return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n\n    @override\n    def create_client(\n        self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n        :param client_id: The client identifier (required)\n        :param realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n        :param skip_exists: Skip creation if client already exists\n        :param kwargs: Additional optional configurations for the client\n        :return: Dictionary with client information\n        \"\"\"\n        original_realm = self.admin_adapter.connection.realm_name\n\n        try:\n            # Set the target realm if provided\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = realm\n\n            public_client = kwargs.get(\"public_client\", False)\n\n            # Prepare the minimal client payload\n            payload = {\n                \"clientId\": client_id,\n                \"enabled\": kwargs.get(\"enabled\", True),\n                \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n                \"name\": kwargs.get(\"name\", client_id),\n                \"publicClient\": public_client,\n            }\n\n            # Enable service accounts for confidential clients by default\n            if not public_client:\n                payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n                payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n            for key, value in kwargs.items():\n                if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                    continue\n\n                # Convert snake_case to camelCase\n                camel_key = StringUtils.snake_to_camel_case(key)\n                payload[camel_key] = value\n\n            try:\n                internal_client_id = self.admin_adapter.create_client(payload, skip_exists=skip_exists)\n            except KeycloakError as e:\n                logger.debug(f\"Failed to create client: {e!s}\")\n                raise InternalError() from e\n\n            return {\n                \"client_id\": client_id,\n                \"internal_client_id\": internal_client_id,\n                \"realm\": self.admin_adapter.connection.realm_name,\n            }\n\n        finally:\n            # Always restore the original realm\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = original_realm\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>UnauthenticatedError</code> <p>If admin client is not available due to authentication issues</p> <code>UnavailableError</code> <p>If Keycloak service is unavailable</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self._openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter = None\n    self._admin_token_expiry = 0\n\n    # Initialize admin client with service account if client_secret is provided\n    # or with admin credentials if provided\n    if self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD):\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key()</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>PublicKeyType</code> <p>JWK key object used to verify signatures</p> <p>Raises:</p> Type Description <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> <code>InternalError</code> <p>If there's an internal error processing the public key</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\ndef get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n\n    Raises:\n        ServiceUnavailableError: If Keycloak service is unavailable\n        InternalError: If there's an internal error processing the public key\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = self._openid_adapter.public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except KeycloakError as e:\n        raise ServiceUnavailableError(\"Failed to retrieve public key from Keycloak\") from e\n    except Exception as e:\n        raise InternalError(\"Failed to process Keycloak public key\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token(username, password)</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>If username or password is invalid</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidCredentialsError: If username or password is invalid\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return self._openid_adapter.token(grant_type=\"password\", username=username, password=password)\n    except KeycloakAuthenticationError as e:\n        raise InvalidCredentialsError(\"Invalid username or password\") from e\n    except KeycloakError as e:\n        raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token(refresh_token)</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidTokenError</code> <p>If refresh token is invalid or expired</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidTokenError: If refresh token is invalid or expired\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return self._openid_adapter.refresh_token(refresh_token)\n    except KeycloakAuthenticationError as e:\n        raise InvalidTokenError(\"Invalid or expired refresh token\") from e\n    except KeycloakError as e:\n        raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token(token)</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        self._openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo(token)</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not self.validate_token(token):\n        raise InvalidTokenError()\n    try:\n        return self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id(user_id)</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        raise InternalError() from e\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username(username)</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email(email)</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles(user_id)</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user(user_data)</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = self.admin_adapter.create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n    else:\n        return user_id\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user(user_id, user_data)</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password(user_id, password, temporary=False)</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role(user_id, role_name)</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Assign role to user\n        self.admin_adapter.assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role(user_id, role_name)</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Remove role from user\n        self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = self.admin_adapter.get_client_id(client_id)\n        # Get role representation\n        role = self.admin_adapter.get_client_role(client, role_name)\n        # Assign role to user\n        self.admin_adapter.assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role(role_name, description=None)</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        self.admin_adapter.create_realm_role(role_data)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        return self.admin_adapter.get_realm_role(role_name)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client_role(client_id, role_name, description=None)</code>","text":"<p>Create a new client role.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID or client name</p> required <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_client_role(self, client_id: str, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new client role.\n\n    Args:\n        client_id: Client ID or client name\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        client_id = self.admin_adapter.get_client_id(client_id)\n\n        # Prepare role data\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        # Create client role\n        self.admin_adapter.create_client_role(client_id, role_data)\n\n        # Clear related caches if they exist\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n        # Return created role\n        return self.admin_adapter.get_client_role(client_id, role_name)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role(role_name)</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id()</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = self.get_client_id(self.configs.CLIENT_ID)\n        return self.admin_adapter.get_client_service_account_user(client_id).get(\"id\")\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config()</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return self._openid_adapter.well_known()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs()</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return self._openid_adapter.certs()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code(code, redirect_uri)</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return self._openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n    except KeycloakError as e:\n        raise InvalidTokenError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token()</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return self._openid_adapter.token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        raise UnauthenticatedError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users(query, max_results=100)</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType]</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret(client_id)</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id(client_name)</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_id(client_name)\n    except KeycloakError as e:\n        raise NotFoundError(resource_type=\"client\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles()</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role(role_name)</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_role(role_name)\n    except KeycloakError as e:\n        raise NotFoundError(resource_type=\"role\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client_id(client_id)\n        role = self.admin_adapter.get_client_role(client, role_name)\n        self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions(user_id)</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        self.admin_adapter.user_logout(user_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.logout(refresh_token)</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        self._openid_adapter.logout(refresh_token)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token(token)</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return self._openid_adapter.introspect(token)\n    except KeycloakError as e:\n        raise InvalidTokenError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info(token)</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return self._openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n    except KeycloakError as e:\n        raise InvalidTokenError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user(user_id)</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        self.admin_adapter.delete_user(user_id=user_id)\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except Exception as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role(token, role_name)</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = client.get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles(token, role_names)</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(roles):\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = set(client.get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles(token, role_names)</code>","text":"<p>Check if a user has all of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            all_roles.update(client.get(\"roles\", []))\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions(token, resource, scope)</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = self._openid_adapter.uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception:\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm(realm_name, skip_exists=True, **kwargs)</code>","text":"<p>Create a Keycloak realm with minimum required fields and optional additional config.</p> <p>:param realm_name: The realm identifier (required) :param skip_exists: Skip creation if realm already exists :param kwargs: Additional optional configurations for the realm :return: Dictionary with realm information and status</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n    :param realm_name: The realm identifier (required)\n    :param skip_exists: Skip creation if realm already exists\n    :param kwargs: Additional optional configurations for the realm\n    :return: Dictionary with realm information and status\n    \"\"\"\n    payload = {\n        \"realm\": realm_name,\n        \"enabled\": kwargs.get(\"enabled\", True),\n        \"displayName\": kwargs.get(\"display_name\", realm_name),\n    }\n\n    # Add any additional parameters from kwargs\n    for key, value in kwargs.items():\n        # Skip display_name as it's already handled\n        if key == \"display_name\":\n            continue\n\n        # Convert Python snake_case to Keycloak camelCase\n        camel_key = StringUtils.snake_to_camel_case(key)\n        payload[camel_key] = value\n\n    try:\n        self.admin_adapter.create_realm(payload=payload, skip_exists=skip_exists)\n    except KeycloakError as e:\n        logger.debug(f\"Failed to create realm: {e!s}\")\n        raise InternalError() from e\n    else:\n        return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>","text":"<p>Create a Keycloak client with minimum required fields and optional additional config.</p> <p>:param client_id: The client identifier (required) :param realm: Target realm name (uses the current realm in KeycloakAdmin if not specified) :param skip_exists: Skip creation if client already exists :param kwargs: Additional optional configurations for the client :return: Dictionary with client information</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_client(\n    self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n    :param client_id: The client identifier (required)\n    :param realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n    :param skip_exists: Skip creation if client already exists\n    :param kwargs: Additional optional configurations for the client\n    :return: Dictionary with client information\n    \"\"\"\n    original_realm = self.admin_adapter.connection.realm_name\n\n    try:\n        # Set the target realm if provided\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = realm\n\n        public_client = kwargs.get(\"public_client\", False)\n\n        # Prepare the minimal client payload\n        payload = {\n            \"clientId\": client_id,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n            \"name\": kwargs.get(\"name\", client_id),\n            \"publicClient\": public_client,\n        }\n\n        # Enable service accounts for confidential clients by default\n        if not public_client:\n            payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n            payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n        for key, value in kwargs.items():\n            if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                continue\n\n            # Convert snake_case to camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        try:\n            internal_client_id = self.admin_adapter.create_client(payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create client: {e!s}\")\n            raise InternalError() from e\n\n        return {\n            \"client_id\": client_id,\n            \"internal_client_id\": internal_client_id,\n            \"realm\": self.admin_adapter.connection.realm_name,\n        }\n\n    finally:\n        # Always restore the original realm\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = original_realm\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter</code>","text":"<p>               Bases: <code>AsyncKeycloakPort</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class AsyncKeycloakAdapter(AsyncKeycloakPort):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self.openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter = None\n        self._admin_token_expiry = 0\n\n        # Initialize admin client with service account if client_secret is provided\n        # or with admin credentials if provided\n        if self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD):\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Check if admin credentials are available\n            if self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD:\n                # Create admin client using admin credentials\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    username=self.configs.ADMIN_USERNAME,\n                    password=self.configs.ADMIN_PASSWORD,\n                    realm_name=self.configs.REALM_NAME,\n                    user_realm_name=self.configs.ADMIN_REALM_NAME,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                # Since we're using direct credentials, set a long expiry time\n                self._admin_token_expiry = time.time() + 3600  # 1 hour\n                logger.debug(\"Admin client initialized with admin credentials\")\n            elif self.configs.CLIENT_SECRET_KEY:\n                # Get token using client credentials\n                token = self.openid_adapter.token(grant_type=\"client_credentials\")\n\n                # Set token expiry time (current time + expires_in - buffer)\n                # Using a 30-second buffer to ensure we refresh before expiration\n                self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n                # Create admin client with the token\n                self._admin_adapter = KeycloakAdmin(\n                    server_url=self.configs.SERVER_URL,\n                    realm_name=self.configs.REALM_NAME,\n                    token=token,\n                    verify=self.configs.VERIFY_SSL,\n                    timeout=self.configs.TIMEOUT,\n                )\n                logger.debug(\"Admin client initialized with client credentials\")\n            else:\n                raise UnauthenticatedError(\n                    additional_data={\"detail\": \"Neither admin credentials nor client secret provided\"}\n                )\n\n        except KeycloakAuthenticationError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise UnauthenticatedError(\n                additional_data={\"detail\": \"Failed to authenticate with Keycloak service account\"}\n            ) from e\n        except KeycloakConnectionError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise ConnectionTimeoutError(\"Failed to connect to Keycloak server\") from e\n        except KeycloakError as e:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n            raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            UnauthenticatedError: If admin client is not available due to authentication issues\n            UnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        if not (self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD)):\n            raise UnauthenticatedError(\n                additional_data={\"detail\": \"Neither admin credentials nor client secret provided\"}\n            )\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise UnavailableError(\"Keycloak admin client is not available\")\n\n        return self._admin_adapter\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    async def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n\n        Raises:\n            ServiceUnavailableError: If Keycloak service is unavailable\n            InternalError: If there's an internal error processing the public key\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = await self.openid_adapter.a_public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except KeycloakError as e:\n            raise ServiceUnavailableError(\"Failed to retrieve public key from Keycloak\") from e\n        except Exception as e:\n            raise InternalError(\"Failed to process Keycloak public key\") from e\n\n    @override\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidCredentialsError: If username or password is invalid\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n        except KeycloakAuthenticationError as e:\n            raise InvalidCredentialsError(\"Invalid username or password\") from e\n        except KeycloakError as e:\n            raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n\n    @override\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            InvalidTokenError: If refresh token is invalid or expired\n            ServiceUnavailableError: If Keycloak service is unavailable\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_refresh_token(refresh_token)\n        except KeycloakAuthenticationError as e:\n            raise InvalidTokenError(\"Invalid or expired refresh token\") from e\n        except KeycloakError as e:\n            raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n\n    @override\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n        else:\n            return True\n\n    @override\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not await self.validate_token(token):\n            raise InvalidTokenError()\n        try:\n            return await self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @alru_cache(ttl=30, maxsize=100)  # Cache for 30 seconds\n    async def _get_userinfo_cached(self, token: str) -&gt; KeycloakUserType:\n        return await self.openid_adapter.a_userinfo(token)\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            raise InternalError() from e\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = await self.admin_adapter.a_create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n        except KeycloakError as e:\n            raise InternalError() from e\n        else:\n            return user_id\n\n    @override\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Remove role from user\n            await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to\tnew-test-realm assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            # Get role representation\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            await self.admin_adapter.a_create_realm_role(role_data)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            created_role = await self.admin_adapter.a_get_realm_role(role_name)\n        except KeycloakError as e:\n            raise InternalError() from e\n        else:\n            return created_role\n\n    @override\n    async def create_client_role(\n        self, client_id: str, role_name: str, description: str | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a new client role.\n\n        Args:\n            client_id: Client ID or client name\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            client_id = await self.admin_adapter.a_get_client_id(client_id)\n\n            # Prepare role data\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            # Create client role\n            await self.admin_adapter.a_create_client_role(client_id, role_data)\n\n            # Clear related caches if they exist\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n            # Return created role\n            return await self.admin_adapter.a_get_client_role(client_id, role_name)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = await self.get_client_id(self.configs.CLIENT_ID)\n            service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n            return service_account.get(\"id\")\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_well_known()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_certs()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return await self.openid_adapter.a_token(\n                grant_type=\"authorization_code\",\n                code=code,\n                redirect_uri=redirect_uri,\n            )\n        except KeycloakError as e:\n            raise InvalidTokenError() from e\n\n    @override\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            raise UnauthenticatedError() from e\n\n    @override\n    @alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_id(client_name)\n        except KeycloakError as e:\n            raise NotFoundError(resource_type=\"client\") from e\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_role(role_name)\n        except KeycloakError as e:\n            raise NotFoundError(resource_type=\"role\") from e\n\n    @override\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_user_logout(user_id)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            await self.openid_adapter.a_logout(refresh_token)\n        except KeycloakError as e:\n            raise InternalError() from e\n\n    @override\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_introspect(token)\n        except KeycloakError as e:\n            raise InvalidTokenError() from e\n\n    @override\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n        except KeycloakError as e:\n            raise InvalidTokenError() from e\n\n    @override\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_delete_user(user_id=user_id)\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except Exception as e:\n            raise InternalError() from e\n\n    @override\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = client.get(\"roles\", [])\n                if role_name in client_roles:\n                    return True\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    async def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(roles):\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = set(client.get(\"roles\", []))\n                if role_names.intersection(client_roles):\n                    return True\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n        else:\n            return False\n\n    @override\n    async def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                all_roles.update(client.get(\"roles\", []))\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = await self.openid_adapter.a_uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception:\n            return False\n        else:\n            return False\n\n    @override\n    async def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n        Args:\n            realm_name: The realm identifier (required)\n            skip_exists: Skip creation if realm already exists\n            kwargs: Additional optional configurations for the realm\n\n        Returns:\n            Dictionary with realm information and status\n\n        Raises:\n            InternalError: If realm creation fails\n        \"\"\"\n        payload = {\n            \"realm\": realm_name,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"displayName\": kwargs.get(\"display_name\", realm_name),\n        }\n\n        # Add any additional parameters from kwargs\n        for key, value in kwargs.items():\n            # Skip display_name as it's already handled\n            if key == \"display_name\":\n                continue\n\n            # Convert Python snake_case to Keycloak camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        try:\n            await self.admin_adapter.a_create_realm(payload=payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create realm: {e!s}\")\n            raise InternalError() from e\n        else:\n            return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n\n    @override\n    async def create_client(\n        self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n        Args:\n            client_id: The client identifier (required)\n            realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n            skip_exists: Skip creation if client already exists\n            kwargs: Additional optional configurations for the client\n\n        Returns:\n            Dictionary with client information\n\n        Raises:\n            InternalError: If client creation fails\n        \"\"\"\n        original_realm = self.admin_adapter.connection.realm_name\n\n        try:\n            # Set the target realm if provided\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = realm\n\n            public_client = kwargs.get(\"public_client\", False)\n\n            # Prepare the minimal client payload\n            payload = {\n                \"clientId\": client_id,\n                \"enabled\": kwargs.get(\"enabled\", True),\n                \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n                \"name\": kwargs.get(\"name\", client_id),\n                \"publicClient\": public_client,\n            }\n\n            # Enable service accounts for confidential clients by default\n            if not public_client:\n                payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n                payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n            for key, value in kwargs.items():\n                if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                    continue\n\n                # Convert snake_case to camelCase\n                camel_key = StringUtils.snake_to_camel_case(key)\n                payload[camel_key] = value\n\n            try:\n                internal_client_id = await self.admin_adapter.a_create_client(payload, skip_exists=skip_exists)\n            except KeycloakError as e:\n                logger.debug(f\"Failed to create client: {e!s}\")\n                raise InternalError() from e\n\n            return {\n                \"client_id\": client_id,\n                \"internal_client_id\": internal_client_id,\n                \"realm\": self.admin_adapter.connection.realm_name,\n            }\n\n        finally:\n            # Always restore the original realm\n            if realm and realm != original_realm:\n                self.admin_adapter.connection.realm_name = original_realm\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>UnauthenticatedError</code> <p>If admin client is not available due to authentication issues</p> <code>UnavailableError</code> <p>If Keycloak service is unavailable</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self.openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter = None\n    self._admin_token_expiry = 0\n\n    # Initialize admin client with service account if client_secret is provided\n    # or with admin credentials if provided\n    if self.configs.CLIENT_SECRET_KEY or (self.configs.ADMIN_USERNAME and self.configs.ADMIN_PASSWORD):\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key()</code>  <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>PublicKeyType</code> <p>JWK key object used to verify signatures</p> <p>Raises:</p> Type Description <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> <code>InternalError</code> <p>If there's an internal error processing the public key</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\nasync def get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n\n    Raises:\n        ServiceUnavailableError: If Keycloak service is unavailable\n        InternalError: If there's an internal error processing the public key\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = await self.openid_adapter.a_public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except KeycloakError as e:\n        raise ServiceUnavailableError(\"Failed to retrieve public key from Keycloak\") from e\n    except Exception as e:\n        raise InternalError(\"Failed to process Keycloak public key\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token(username, password)</code>  <code>async</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidCredentialsError</code> <p>If username or password is invalid</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidCredentialsError: If username or password is invalid\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n    except KeycloakAuthenticationError as e:\n        raise InvalidCredentialsError(\"Invalid username or password\") from e\n    except KeycloakError as e:\n        raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token(refresh_token)</code>  <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>InvalidTokenError</code> <p>If refresh token is invalid or expired</p> <code>ServiceUnavailableError</code> <p>If Keycloak service is unavailable</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        InvalidTokenError: If refresh token is invalid or expired\n        ServiceUnavailableError: If Keycloak service is unavailable\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_refresh_token(refresh_token)\n    except KeycloakAuthenticationError as e:\n        raise InvalidTokenError(\"Invalid or expired refresh token\") from e\n    except KeycloakError as e:\n        raise ServiceUnavailableError(\"Keycloak service is currently unavailable\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token(token)</code>  <code>async</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo(token)</code>  <code>async</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not await self.validate_token(token):\n        raise InvalidTokenError()\n    try:\n        return await self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id(user_id)</code>  <code>async</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        raise InternalError() from e\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username(username)</code>  <code>async</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email(email)</code>  <code>async</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles(user_id)</code>  <code>async</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>  <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user(user_data)</code>  <code>async</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = await self.admin_adapter.a_create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n    except KeycloakError as e:\n        raise InternalError() from e\n    else:\n        return user_id\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user(user_id, user_data)</code>  <code>async</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password(user_id, password, temporary=False)</code>  <code>async</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Remove role from user\n        await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to     new-test-realm assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to\tnew-test-realm assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        # Get role representation\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role(role_name, description=None)</code>  <code>async</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        await self.admin_adapter.a_create_realm_role(role_data)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        created_role = await self.admin_adapter.a_get_realm_role(role_name)\n    except KeycloakError as e:\n        raise InternalError() from e\n    else:\n        return created_role\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client_role(client_id, role_name, description=None)</code>  <code>async</code>","text":"<p>Create a new client role.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID or client name</p> required <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_client_role(\n    self, client_id: str, role_name: str, description: str | None = None\n) -&gt; dict[str, Any]:\n    \"\"\"Create a new client role.\n\n    Args:\n        client_id: Client ID or client name\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        client_id = await self.admin_adapter.a_get_client_id(client_id)\n\n        # Prepare role data\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        # Create client role\n        await self.admin_adapter.a_create_client_role(client_id, role_data)\n\n        # Clear related caches if they exist\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n        # Return created role\n        return await self.admin_adapter.a_get_client_role(client_id, role_name)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role(role_name)</code>  <code>async</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id()</code>  <code>async</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = await self.get_client_id(self.configs.CLIENT_ID)\n        service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n        return service_account.get(\"id\")\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config()</code>  <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_well_known()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs()</code>  <code>async</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_certs()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code(code, redirect_uri)</code>  <code>async</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return await self.openid_adapter.a_token(\n            grant_type=\"authorization_code\",\n            code=code,\n            redirect_uri=redirect_uri,\n        )\n    except KeycloakError as e:\n        raise InvalidTokenError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token()</code>  <code>async</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        raise UnauthenticatedError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users(query, max_results=100)</code>  <code>async</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType]</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret(client_id)</code>  <code>async</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id(client_name)</code>  <code>async</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_id(client_name)\n    except KeycloakError as e:\n        raise NotFoundError(resource_type=\"client\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles()</code>  <code>async</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role(role_name)</code>  <code>async</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_role(role_name)\n    except KeycloakError as e:\n        raise NotFoundError(resource_type=\"role\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_user_logout(user_id)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout(refresh_token)</code>  <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        await self.openid_adapter.a_logout(refresh_token)\n    except KeycloakError as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token(token)</code>  <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_introspect(token)\n    except KeycloakError as e:\n        raise InvalidTokenError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info(token)</code>  <code>async</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n    except KeycloakError as e:\n        raise InvalidTokenError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user(user_id)</code>  <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_delete_user(user_id=user_id)\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except Exception as e:\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role(token, role_name)</code>  <code>async</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = client.get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(roles):\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = set(client.get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>frozenset[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            all_roles.update(client.get(\"roles\", []))\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions(token, resource, scope)</code>  <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = await self.openid_adapter.a_uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception:\n        return False\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm(realm_name, skip_exists=True, **kwargs)</code>  <code>async</code>","text":"<p>Create a Keycloak realm with minimum required fields and optional additional config.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>The realm identifier (required)</p> required <code>skip_exists</code> <code>bool</code> <p>Skip creation if realm already exists</p> <code>True</code> <code>kwargs</code> <p>Additional optional configurations for the realm</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with realm information and status</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If realm creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak realm with minimum required fields and optional additional config.\n\n    Args:\n        realm_name: The realm identifier (required)\n        skip_exists: Skip creation if realm already exists\n        kwargs: Additional optional configurations for the realm\n\n    Returns:\n        Dictionary with realm information and status\n\n    Raises:\n        InternalError: If realm creation fails\n    \"\"\"\n    payload = {\n        \"realm\": realm_name,\n        \"enabled\": kwargs.get(\"enabled\", True),\n        \"displayName\": kwargs.get(\"display_name\", realm_name),\n    }\n\n    # Add any additional parameters from kwargs\n    for key, value in kwargs.items():\n        # Skip display_name as it's already handled\n        if key == \"display_name\":\n            continue\n\n        # Convert Python snake_case to Keycloak camelCase\n        camel_key = StringUtils.snake_to_camel_case(key)\n        payload[camel_key] = value\n\n    try:\n        await self.admin_adapter.a_create_realm(payload=payload, skip_exists=skip_exists)\n    except KeycloakError as e:\n        logger.debug(f\"Failed to create realm: {e!s}\")\n        raise InternalError() from e\n    else:\n        return {\"realm\": realm_name, \"status\": \"created\", \"config\": payload}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>  <code>async</code>","text":"<p>Create a Keycloak client with minimum required fields and optional additional config.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client identifier (required)</p> required <code>realm</code> <code>str | None</code> <p>Target realm name (uses the current realm in KeycloakAdmin if not specified)</p> <code>None</code> <code>skip_exists</code> <code>bool</code> <p>Skip creation if client already exists</p> <code>True</code> <code>kwargs</code> <p>Additional optional configurations for the client</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with client information</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If client creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_client(\n    self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a Keycloak client with minimum required fields and optional additional config.\n\n    Args:\n        client_id: The client identifier (required)\n        realm: Target realm name (uses the current realm in KeycloakAdmin if not specified)\n        skip_exists: Skip creation if client already exists\n        kwargs: Additional optional configurations for the client\n\n    Returns:\n        Dictionary with client information\n\n    Raises:\n        InternalError: If client creation fails\n    \"\"\"\n    original_realm = self.admin_adapter.connection.realm_name\n\n    try:\n        # Set the target realm if provided\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = realm\n\n        public_client = kwargs.get(\"public_client\", False)\n\n        # Prepare the minimal client payload\n        payload = {\n            \"clientId\": client_id,\n            \"enabled\": kwargs.get(\"enabled\", True),\n            \"protocol\": kwargs.get(\"protocol\", \"openid-connect\"),\n            \"name\": kwargs.get(\"name\", client_id),\n            \"publicClient\": public_client,\n        }\n\n        # Enable service accounts for confidential clients by default\n        if not public_client:\n            payload[\"serviceAccountsEnabled\"] = kwargs.get(\"service_account_enabled\", True)\n            payload[\"clientAuthenticatorType\"] = \"client-secret\"\n\n        for key, value in kwargs.items():\n            if key in [\"enabled\", \"protocol\", \"name\", \"public_client\", \"service_account_enabled\"]:\n                continue\n\n            # Convert snake_case to camelCase\n            camel_key = StringUtils.snake_to_camel_case(key)\n            payload[camel_key] = value\n\n        try:\n            internal_client_id = await self.admin_adapter.a_create_client(payload, skip_exists=skip_exists)\n        except KeycloakError as e:\n            logger.debug(f\"Failed to create client: {e!s}\")\n            raise InternalError() from e\n\n        return {\n            \"client_id\": client_id,\n            \"internal_client_id\": internal_client_id,\n            \"realm\": self.admin_adapter.connection.realm_name,\n        }\n\n    finally:\n        # Always restore the original realm\n        if realm and realm != original_realm:\n            self.admin_adapter.connection.realm_name = original_realm\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort</code>","text":"<p>Interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class KeycloakPort:\n    \"\"\"Interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_client_role(self, client_id: str, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new client role.\"\"\"\n        raise NotImplementedError\n\n    def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any]:\n        \"\"\"Create a new Keycloak realm.\"\"\"\n        raise NotImplementedError\n\n    def create_client(\n        self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new client in the specified realm.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.validate_token(token)</code>  <code>abstractmethod</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_public_key()</code>  <code>abstractmethod</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_certs()</code>  <code>abstractmethod</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_client_role(client_id, role_name, description=None)</code>  <code>abstractmethod</code>","text":"<p>Create a new client role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_client_role(self, client_id: str, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new client role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_realm","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_realm(realm_name, skip_exists=True, **kwargs)</code>","text":"<p>Create a new Keycloak realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"Create a new Keycloak realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_client","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>","text":"<p>Create a new client in the specified realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>def create_client(\n    self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new client in the specified realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort</code>","text":"<p>Asynchronous interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for async Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class AsyncKeycloakPort:\n    \"\"\"Asynchronous interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for async Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    async def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_client_role(\n        self, client_id: str, role_name: str, description: str | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a new client role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new Keycloak realm.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_client(\n        self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Create a new client in the specified realm.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_any_of_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_all_roles(self, token: str, role_names: frozenset[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client_role(client_id, role_name, description=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new client role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_client_role(\n    self, client_id: str, role_name: str, description: str | None = None\n) -&gt; dict[str, Any]:\n    \"\"\"Create a new client role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm(realm_name, skip_exists=True, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new Keycloak realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_realm(self, realm_name: str, skip_exists: bool = True, **kwargs) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new Keycloak realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_client(client_id, realm=None, skip_exists=True, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new client in the specified realm.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_client(\n    self, client_id: str, realm: str | None = None, skip_exists: bool = True, **kwargs\n) -&gt; dict[str, Any] | None:\n    \"\"\"Create a new client in the specified realm.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#minio","title":"MinIO","text":"<p>MinIO integration for S3-compatible object storage operations.</p> <pre><code>from archipy.adapters.minio import MinioAdapter\n\n# Create a MinIO adapter\nminio = MinioAdapter()  # Uses global config by default\n\n# Create a bucket\nif not minio.bucket_exists(\"my-bucket\"):\n    minio.make_bucket(\"my-bucket\")\n\n# Upload a file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/local/file.pdf\")\n\n# Generate a download URL (valid for 1 hour)\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\")\n</code></pre> <p>For detailed examples and usage guidelines, see the MinIO Adapter Examples.</p> <p>options: show_root_heading: true show_source: true</p> <p>MinIO port definitions for ArchiPy.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioExceptionHandlerMixin","title":"<code>archipy.adapters.minio.adapters.MinioExceptionHandlerMixin</code>","text":"<p>Mixin class to handle MinIO/S3 exceptions in a consistent way.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>class MinioExceptionHandlerMixin:\n    \"\"\"Mixin class to handle MinIO/S3 exceptions in a consistent way.\"\"\"\n\n    @classmethod\n    def _handle_s3_exception(cls, exception: S3Error, operation: str) -&gt; None:\n        \"\"\"Handle S3Error exceptions and map them to appropriate application errors.\n\n        Args:\n            exception: The original S3Error exception\n            operation: The name of the operation that failed\n\n        Raises:\n            Various application-specific errors based on the exception type/content\n        \"\"\"\n        error_msg = str(exception).lower()\n\n        # Bucket existence errors\n        if \"NoSuchBucket\" in str(exception):\n            raise NotFoundError(resource_type=\"bucket\") from exception\n\n        # Object existence errors\n        if \"NoSuchKey\" in str(exception):\n            raise NotFoundError(resource_type=\"object\") from exception\n\n        # Bucket ownership/existence errors\n        if \"BucketAlreadyOwnedByYou\" in str(exception) or \"BucketAlreadyExists\" in str(exception):\n            raise AlreadyExistsError(resource_type=\"bucket\") from exception\n\n        # Permission errors\n        if \"AccessDenied\" in str(exception):\n            raise PermissionDeniedError(\n                additional_data={\"details\": f\"Permission denied for operation: {operation}\"},\n            ) from exception\n\n        # Resource limit errors\n        if \"quota\" in error_msg or \"limit\" in error_msg or \"exceeded\" in error_msg:\n            raise ResourceExhaustedError(resource_type=\"storage\") from exception\n\n        # Connection/availability errors\n        if \"timeout\" in error_msg:\n            raise ConnectionTimeoutError(service=\"MinIO\") from exception\n\n        if \"unavailable\" in error_msg or \"connection\" in error_msg:\n            raise ServiceUnavailableError(service=\"MinIO\") from exception\n\n        # Default: general storage error\n        raise StorageError(additional_data={\"operation\": operation}) from exception\n\n    @classmethod\n    def _handle_general_exception(cls, exception: Exception, component: str) -&gt; None:\n        \"\"\"Handle general exceptions by converting them to appropriate application errors.\n\n        Args:\n            exception: The original exception\n            component: The component/operation name for context\n\n        Raises:\n            InternalError: A wrapped version of the original exception\n        \"\"\"\n        raise InternalError(additional_data={\"component\": component}) from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter","title":"<code>archipy.adapters.minio.adapters.MinioAdapter</code>","text":"<p>               Bases: <code>MinioPort</code>, <code>MinioExceptionHandlerMixin</code></p> <p>Concrete implementation of the MinioPort interface using the minio library.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>class MinioAdapter(MinioPort, MinioExceptionHandlerMixin):\n    \"\"\"Concrete implementation of the MinioPort interface using the minio library.\"\"\"\n\n    def __init__(self, minio_configs: MinioConfig | None = None) -&gt; None:\n        \"\"\"Initialize MinioAdapter with configuration.\n\n        Args:\n            minio_configs: Optional MinIO configuration. If None, global config is used.\n\n        Raises:\n            ConfigurationError: If there is an error in the MinIO configuration.\n            InvalidArgumentError: If required parameters are missing.\n            NetworkError: If there are network errors connecting to MinIO server.\n        \"\"\"\n        try:\n            # Determine config source (explicit or from global config)\n            if minio_configs is not None:\n                self.configs = minio_configs\n            else:\n                # First get global config, then extract MINIO config\n                global_config: Any = BaseConfig.global_config()\n                if not hasattr(global_config, \"MINIO\"):\n                    raise InvalidArgumentError(argument_name=\"MINIO\")\n                self.configs = cast(MinioConfig, global_config.MINIO)\n\n            # Ensure we have a valid endpoint value\n            endpoint = str(self.configs.ENDPOINT or \"\")\n            if not endpoint:\n                raise InvalidArgumentError(argument_name=\"endpoint\")\n\n            self._adapter = Minio(\n                endpoint,\n                access_key=self.configs.ACCESS_KEY,\n                secret_key=self.configs.SECRET_KEY,\n                session_token=self.configs.SESSION_TOKEN,\n                secure=self.configs.SECURE,\n                region=self.configs.REGION,\n            )\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            error_msg = str(e).lower()\n            if \"configuration\" in error_msg:\n                raise ConfigurationError(config_key=\"minio\") from e\n            elif \"connection\" in error_msg:\n                raise NetworkError(service=\"MinIO\") from e\n            else:\n                raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n        except Exception as e:\n            raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def bucket_exists(self, bucket_name: str) -&gt; bool:\n        \"\"\"Check if a bucket exists.\n\n        Args:\n            bucket_name: Name of the bucket to check.\n\n        Returns:\n            bool: True if bucket exists, False otherwise.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            result = self._adapter.bucket_exists(bucket_name)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                return False\n            self._handle_s3_exception(e, \"bucket_exists\")\n        except Exception as e:\n            self._handle_general_exception(e, \"bucket_exists\")\n        else:\n            return result\n\n    @override\n    def make_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Create a new bucket.\n\n        Args:\n            bucket_name: Name of the bucket to create.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            AlreadyExistsError: If the bucket already exists.\n            PermissionDeniedError: If permission to create bucket is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            self._adapter.make_bucket(bucket_name)\n            self.clear_all_caches()  # Clear cache since bucket list changed\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"make_bucket\")\n        except Exception as e:\n            self._handle_general_exception(e, \"make_bucket\")\n\n    @override\n    def remove_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Remove a bucket.\n\n        Args:\n            bucket_name: Name of the bucket to remove.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to delete bucket is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            self._adapter.remove_bucket(bucket_name)\n            self.clear_all_caches()  # Clear cache since bucket list changed\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"remove_bucket\")\n        except Exception as e:\n            self._handle_general_exception(e, \"remove_bucket\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def list_buckets(self) -&gt; list[MinioBucketType]:\n        \"\"\"List all buckets.\n\n        Returns:\n            list: List of buckets and their creation dates.\n\n        Raises:\n            PermissionDeniedError: If permission to list buckets is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            buckets = self._adapter.list_buckets()\n        except S3Error as e:\n            self._handle_s3_exception(e, \"list_buckets\")\n        except Exception as e:\n            self._handle_general_exception(e, \"list_buckets\")\n        else:\n            return [{\"name\": b.name, \"creation_date\": b.creation_date} for b in buckets]\n\n    @override\n    def put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Upload a file to a bucket.\n\n        Args:\n            bucket_name: Destination bucket name.\n            object_name: Object name in the bucket.\n            file_path: Local file path to upload.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to upload is denied.\n            ResourceExhaustedError: If storage limits are exceeded.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name or not file_path:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name, object_name or file_path\"\n                        if not all([bucket_name, object_name, file_path])\n                        else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                    ),\n                )\n            self._adapter.fput_object(bucket_name, object_name, file_path)\n            if hasattr(self.list_objects, \"clear_cache\"):\n                self.list_objects.clear_cache()  # Clear object list cache\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"put_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"put_object\")\n\n    @override\n    def get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Download an object to a file.\n\n        Args:\n            bucket_name: Source bucket name.\n            object_name: Object name in the bucket.\n            file_path: Local file path to save the object.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to download is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name or not file_path:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name, object_name or file_path\"\n                        if not all([bucket_name, object_name, file_path])\n                        else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                    ),\n                )\n            self._adapter.fget_object(bucket_name, object_name, file_path)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"get_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"get_object\")\n\n    @override\n    def remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n        \"\"\"Remove an object from a bucket.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to remove.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to remove is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            self._adapter.remove_object(bucket_name, object_name)\n            if hasattr(self.list_objects, \"clear_cache\"):\n                self.list_objects.clear_cache()  # Clear object list cache\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"remove_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"remove_object\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def list_objects(\n        self,\n        bucket_name: str,\n        prefix: str = \"\",\n        *,\n        recursive: bool = False,\n    ) -&gt; list[MinioObjectType]:\n        \"\"\"List objects in a bucket.\n\n        Args:\n            bucket_name: Bucket name.\n            prefix: Optional prefix to filter objects.\n            recursive: Whether to list objects recursively.\n\n        Returns:\n            list: List of objects with metadata.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to list objects is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            objects = self._adapter.list_objects(bucket_name, prefix=prefix, recursive=recursive)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"list_objects\")\n        except Exception as e:\n            self._handle_general_exception(e, \"list_objects\")\n        else:\n            return [\n                {\"object_name\": obj.object_name, \"size\": obj.size, \"last_modified\": obj.last_modified}\n                for obj in objects\n            ]\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n        \"\"\"Get object metadata.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to get stats for.\n\n        Returns:\n            dict: Object metadata including name, size, last modified date, etc.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to get stats is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            obj = self._adapter.stat_object(bucket_name, object_name)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"stat_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"stat_object\")\n        else:\n            return {\n                \"object_name\": obj.object_name,\n                \"size\": obj.size,\n                \"last_modified\": obj.last_modified,\n                \"content_type\": obj.content_type,\n                \"etag\": obj.etag,\n            }\n\n    @override\n    def presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for downloading an object.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to generate URL for.\n            expires: URL expiry time in seconds.\n\n        Returns:\n            str: Presigned URL for downloading the object.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket or object does not exist.\n            PermissionDeniedError: If permission to generate URL is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            url = self._adapter.presigned_get_object(\n                bucket_name=bucket_name,\n                object_name=object_name,\n                expires=timedelta(seconds=expires),\n            )\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"presigned_get_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"presigned_get_object\")\n        else:\n            return url\n\n    @override\n    def presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for uploading an object.\n\n        Args:\n            bucket_name: Bucket name.\n            object_name: Object name to generate URL for.\n            expires: URL expiry time in seconds.\n\n        Returns:\n            str: Presigned URL for uploading the object.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to generate URL is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            url = self._adapter.presigned_put_object(\n                bucket_name=bucket_name,\n                object_name=object_name,\n                expires=timedelta(seconds=expires),\n            )\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"presigned_put_object\")\n        except Exception as e:\n            self._handle_general_exception(e, \"presigned_put_object\")\n        else:\n            return url\n\n    @override\n    def set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n        \"\"\"Set bucket policy.\n\n        Args:\n            bucket_name: Bucket name.\n            policy: JSON policy string.\n\n        Raises:\n            InvalidArgumentError: If any required parameter is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to set policy is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name or not policy:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or policy\"\n                        if not all([bucket_name, policy])\n                        else \"bucket_name\" if not bucket_name else \"policy\"\n                    ),\n                )\n            self._adapter.set_bucket_policy(bucket_name, policy)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"set_bucket_policy\")\n        except Exception as e:\n            self._handle_general_exception(e, \"set_bucket_policy\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n        \"\"\"Get bucket policy.\n\n        Args:\n            bucket_name: Bucket name.\n\n        Returns:\n            dict: Bucket policy information.\n\n        Raises:\n            InvalidArgumentError: If bucket_name is empty.\n            NotFoundError: If the bucket does not exist.\n            PermissionDeniedError: If permission to get policy is denied.\n            ServiceUnavailableError: If the MinIO service is unavailable.\n            StorageError: If there's a storage-related error.\n        \"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            policy = self._adapter.get_bucket_policy(bucket_name)\n        except InvalidArgumentError:\n            # Pass through our custom errors\n            raise\n        except S3Error as e:\n            self._handle_s3_exception(e, \"get_bucket_policy\")\n        except Exception as e:\n            self._handle_general_exception(e, \"get_bucket_policy\")\n        else:\n            return {\"policy\": policy}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.__init__","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.__init__(minio_configs=None)</code>","text":"<p>Initialize MinioAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>minio_configs</code> <code>MinioConfig | None</code> <p>Optional MinIO configuration. If None, global config is used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If there is an error in the MinIO configuration.</p> <code>InvalidArgumentError</code> <p>If required parameters are missing.</p> <code>NetworkError</code> <p>If there are network errors connecting to MinIO server.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>def __init__(self, minio_configs: MinioConfig | None = None) -&gt; None:\n    \"\"\"Initialize MinioAdapter with configuration.\n\n    Args:\n        minio_configs: Optional MinIO configuration. If None, global config is used.\n\n    Raises:\n        ConfigurationError: If there is an error in the MinIO configuration.\n        InvalidArgumentError: If required parameters are missing.\n        NetworkError: If there are network errors connecting to MinIO server.\n    \"\"\"\n    try:\n        # Determine config source (explicit or from global config)\n        if minio_configs is not None:\n            self.configs = minio_configs\n        else:\n            # First get global config, then extract MINIO config\n            global_config: Any = BaseConfig.global_config()\n            if not hasattr(global_config, \"MINIO\"):\n                raise InvalidArgumentError(argument_name=\"MINIO\")\n            self.configs = cast(MinioConfig, global_config.MINIO)\n\n        # Ensure we have a valid endpoint value\n        endpoint = str(self.configs.ENDPOINT or \"\")\n        if not endpoint:\n            raise InvalidArgumentError(argument_name=\"endpoint\")\n\n        self._adapter = Minio(\n            endpoint,\n            access_key=self.configs.ACCESS_KEY,\n            secret_key=self.configs.SECRET_KEY,\n            session_token=self.configs.SESSION_TOKEN,\n            secure=self.configs.SECURE,\n            region=self.configs.REGION,\n        )\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        error_msg = str(e).lower()\n        if \"configuration\" in error_msg:\n            raise ConfigurationError(config_key=\"minio\") from e\n        elif \"connection\" in error_msg:\n            raise NetworkError(service=\"MinIO\") from e\n        else:\n            raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n    except Exception as e:\n        raise InternalError(additional_data={\"component\": \"MinIO\"}) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.clear_all_caches","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.bucket_exists","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.bucket_exists(bucket_name)</code>","text":"<p>Check if a bucket exists.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Name of the bucket to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if bucket exists, False otherwise.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef bucket_exists(self, bucket_name: str) -&gt; bool:\n    \"\"\"Check if a bucket exists.\n\n    Args:\n        bucket_name: Name of the bucket to check.\n\n    Returns:\n        bool: True if bucket exists, False otherwise.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        result = self._adapter.bucket_exists(bucket_name)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            return False\n        self._handle_s3_exception(e, \"bucket_exists\")\n    except Exception as e:\n        self._handle_general_exception(e, \"bucket_exists\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.make_bucket","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.make_bucket(bucket_name)</code>","text":"<p>Create a new bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Name of the bucket to create.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>AlreadyExistsError</code> <p>If the bucket already exists.</p> <code>PermissionDeniedError</code> <p>If permission to create bucket is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef make_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Create a new bucket.\n\n    Args:\n        bucket_name: Name of the bucket to create.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        AlreadyExistsError: If the bucket already exists.\n        PermissionDeniedError: If permission to create bucket is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        self._adapter.make_bucket(bucket_name)\n        self.clear_all_caches()  # Clear cache since bucket list changed\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"make_bucket\")\n    except Exception as e:\n        self._handle_general_exception(e, \"make_bucket\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.remove_bucket","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.remove_bucket(bucket_name)</code>","text":"<p>Remove a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Name of the bucket to remove.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to delete bucket is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef remove_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Remove a bucket.\n\n    Args:\n        bucket_name: Name of the bucket to remove.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to delete bucket is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        self._adapter.remove_bucket(bucket_name)\n        self.clear_all_caches()  # Clear cache since bucket list changed\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"remove_bucket\")\n    except Exception as e:\n        self._handle_general_exception(e, \"remove_bucket\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.list_buckets","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.list_buckets()</code>","text":"<p>List all buckets.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[MinioBucketType]</code> <p>List of buckets and their creation dates.</p> <p>Raises:</p> Type Description <code>PermissionDeniedError</code> <p>If permission to list buckets is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef list_buckets(self) -&gt; list[MinioBucketType]:\n    \"\"\"List all buckets.\n\n    Returns:\n        list: List of buckets and their creation dates.\n\n    Raises:\n        PermissionDeniedError: If permission to list buckets is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        buckets = self._adapter.list_buckets()\n    except S3Error as e:\n        self._handle_s3_exception(e, \"list_buckets\")\n    except Exception as e:\n        self._handle_general_exception(e, \"list_buckets\")\n    else:\n        return [{\"name\": b.name, \"creation_date\": b.creation_date} for b in buckets]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.put_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.put_object(bucket_name, object_name, file_path)</code>","text":"<p>Upload a file to a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Destination bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name in the bucket.</p> required <code>file_path</code> <code>str</code> <p>Local file path to upload.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to upload is denied.</p> <code>ResourceExhaustedError</code> <p>If storage limits are exceeded.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Upload a file to a bucket.\n\n    Args:\n        bucket_name: Destination bucket name.\n        object_name: Object name in the bucket.\n        file_path: Local file path to upload.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to upload is denied.\n        ResourceExhaustedError: If storage limits are exceeded.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name or not file_path:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name, object_name or file_path\"\n                    if not all([bucket_name, object_name, file_path])\n                    else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                ),\n            )\n        self._adapter.fput_object(bucket_name, object_name, file_path)\n        if hasattr(self.list_objects, \"clear_cache\"):\n            self.list_objects.clear_cache()  # Clear object list cache\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"put_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"put_object\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.get_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.get_object(bucket_name, object_name, file_path)</code>","text":"<p>Download an object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Source bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name in the bucket.</p> required <code>file_path</code> <code>str</code> <p>Local file path to save the object.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to download is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Download an object to a file.\n\n    Args:\n        bucket_name: Source bucket name.\n        object_name: Object name in the bucket.\n        file_path: Local file path to save the object.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to download is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name or not file_path:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name, object_name or file_path\"\n                    if not all([bucket_name, object_name, file_path])\n                    else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                ),\n            )\n        self._adapter.fget_object(bucket_name, object_name, file_path)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"get_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"get_object\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.remove_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.remove_object(bucket_name, object_name)</code>","text":"<p>Remove an object from a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to remove.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to remove is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n    \"\"\"Remove an object from a bucket.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to remove.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to remove is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        self._adapter.remove_object(bucket_name, object_name)\n        if hasattr(self.list_objects, \"clear_cache\"):\n            self.list_objects.clear_cache()  # Clear object list cache\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"remove_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"remove_object\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.list_objects","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.list_objects(bucket_name, prefix='', *, recursive=False)</code>","text":"<p>List objects in a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>prefix</code> <code>str</code> <p>Optional prefix to filter objects.</p> <code>''</code> <code>recursive</code> <code>bool</code> <p>Whether to list objects recursively.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[MinioObjectType]</code> <p>List of objects with metadata.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to list objects is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef list_objects(\n    self,\n    bucket_name: str,\n    prefix: str = \"\",\n    *,\n    recursive: bool = False,\n) -&gt; list[MinioObjectType]:\n    \"\"\"List objects in a bucket.\n\n    Args:\n        bucket_name: Bucket name.\n        prefix: Optional prefix to filter objects.\n        recursive: Whether to list objects recursively.\n\n    Returns:\n        list: List of objects with metadata.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to list objects is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        objects = self._adapter.list_objects(bucket_name, prefix=prefix, recursive=recursive)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"list_objects\")\n    except Exception as e:\n        self._handle_general_exception(e, \"list_objects\")\n    else:\n        return [\n            {\"object_name\": obj.object_name, \"size\": obj.size, \"last_modified\": obj.last_modified}\n            for obj in objects\n        ]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.stat_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.stat_object(bucket_name, object_name)</code>","text":"<p>Get object metadata.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to get stats for.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>MinioObjectType</code> <p>Object metadata including name, size, last modified date, etc.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to get stats is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n    \"\"\"Get object metadata.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to get stats for.\n\n    Returns:\n        dict: Object metadata including name, size, last modified date, etc.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to get stats is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        obj = self._adapter.stat_object(bucket_name, object_name)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"stat_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"stat_object\")\n    else:\n        return {\n            \"object_name\": obj.object_name,\n            \"size\": obj.size,\n            \"last_modified\": obj.last_modified,\n            \"content_type\": obj.content_type,\n            \"etag\": obj.etag,\n        }\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.presigned_get_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.presigned_get_object(bucket_name, object_name, expires=3600)</code>","text":"<p>Generate a presigned URL for downloading an object.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to generate URL for.</p> required <code>expires</code> <code>int</code> <p>URL expiry time in seconds.</p> <code>3600</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Presigned URL for downloading the object.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket or object does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to generate URL is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for downloading an object.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to generate URL for.\n        expires: URL expiry time in seconds.\n\n    Returns:\n        str: Presigned URL for downloading the object.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket or object does not exist.\n        PermissionDeniedError: If permission to generate URL is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        url = self._adapter.presigned_get_object(\n            bucket_name=bucket_name,\n            object_name=object_name,\n            expires=timedelta(seconds=expires),\n        )\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"presigned_get_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"presigned_get_object\")\n    else:\n        return url\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.presigned_put_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.presigned_put_object(bucket_name, object_name, expires=3600)</code>","text":"<p>Generate a presigned URL for uploading an object.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>object_name</code> <code>str</code> <p>Object name to generate URL for.</p> required <code>expires</code> <code>int</code> <p>URL expiry time in seconds.</p> <code>3600</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Presigned URL for uploading the object.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to generate URL is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for uploading an object.\n\n    Args:\n        bucket_name: Bucket name.\n        object_name: Object name to generate URL for.\n        expires: URL expiry time in seconds.\n\n    Returns:\n        str: Presigned URL for uploading the object.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to generate URL is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        url = self._adapter.presigned_put_object(\n            bucket_name=bucket_name,\n            object_name=object_name,\n            expires=timedelta(seconds=expires),\n        )\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"presigned_put_object\")\n    except Exception as e:\n        self._handle_general_exception(e, \"presigned_put_object\")\n    else:\n        return url\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.set_bucket_policy","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.set_bucket_policy(bucket_name, policy)</code>","text":"<p>Set bucket policy.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <code>policy</code> <code>str</code> <p>JSON policy string.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If any required parameter is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to set policy is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n    \"\"\"Set bucket policy.\n\n    Args:\n        bucket_name: Bucket name.\n        policy: JSON policy string.\n\n    Raises:\n        InvalidArgumentError: If any required parameter is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to set policy is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name or not policy:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or policy\"\n                    if not all([bucket_name, policy])\n                    else \"bucket_name\" if not bucket_name else \"policy\"\n                ),\n            )\n        self._adapter.set_bucket_policy(bucket_name, policy)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"set_bucket_policy\")\n    except Exception as e:\n        self._handle_general_exception(e, \"set_bucket_policy\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.get_bucket_policy","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.get_bucket_policy(bucket_name)</code>","text":"<p>Get bucket policy.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Bucket name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>MinioPolicyType</code> <p>Bucket policy information.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If bucket_name is empty.</p> <code>NotFoundError</code> <p>If the bucket does not exist.</p> <code>PermissionDeniedError</code> <p>If permission to get policy is denied.</p> <code>ServiceUnavailableError</code> <p>If the MinIO service is unavailable.</p> <code>StorageError</code> <p>If there's a storage-related error.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n    \"\"\"Get bucket policy.\n\n    Args:\n        bucket_name: Bucket name.\n\n    Returns:\n        dict: Bucket policy information.\n\n    Raises:\n        InvalidArgumentError: If bucket_name is empty.\n        NotFoundError: If the bucket does not exist.\n        PermissionDeniedError: If permission to get policy is denied.\n        ServiceUnavailableError: If the MinIO service is unavailable.\n        StorageError: If there's a storage-related error.\n    \"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        policy = self._adapter.get_bucket_policy(bucket_name)\n    except InvalidArgumentError:\n        # Pass through our custom errors\n        raise\n    except S3Error as e:\n        self._handle_s3_exception(e, \"get_bucket_policy\")\n    except Exception as e:\n        self._handle_general_exception(e, \"get_bucket_policy\")\n    else:\n        return {\"policy\": policy}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort","title":"<code>archipy.adapters.minio.ports.MinioPort</code>","text":"<p>Interface for MinIO operations providing a standardized access pattern.</p> <p>This interface defines the contract for MinIO adapters, ensuring consistent implementation of object storage operations across different adapters.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>class MinioPort:\n    \"\"\"Interface for MinIO operations providing a standardized access pattern.\n\n    This interface defines the contract for MinIO adapters, ensuring consistent\n    implementation of object storage operations across different adapters.\n    \"\"\"\n\n    # Bucket Operations\n    @abstractmethod\n    def bucket_exists(self, bucket_name: str) -&gt; bool:\n        \"\"\"Check if a bucket exists.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def make_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Create a new bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Remove a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_buckets(self) -&gt; list[MinioBucketType]:\n        \"\"\"List all buckets.\"\"\"\n        raise NotImplementedError\n\n    # Object Operations\n    @abstractmethod\n    def put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Upload a file to a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Download an object to a file.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n        \"\"\"Remove an object from a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_objects(\n        self,\n        bucket_name: str,\n        prefix: str = \"\",\n        *,  # Force recursive to be keyword-only to avoid boolean flag issues\n        recursive: bool = False,\n    ) -&gt; list[MinioObjectType]:\n        \"\"\"List objects in a bucket.\n\n        Args:\n            bucket_name: The name of the bucket to list objects from\n            prefix: Optional prefix to filter objects by\n            recursive: Whether to list objects recursively (include sub-directories)\n\n        Returns:\n            A list of MinioObjectType objects\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n        \"\"\"Get object metadata.\"\"\"\n        raise NotImplementedError\n\n    # Presigned URL Operations\n    @abstractmethod\n    def presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n        raise NotImplementedError\n\n    # Policy Operations\n    @abstractmethod\n    def set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n        \"\"\"Set bucket policy.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n        \"\"\"Get bucket policy.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.bucket_exists","title":"<code>archipy.adapters.minio.ports.MinioPort.bucket_exists(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a bucket exists.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef bucket_exists(self, bucket_name: str) -&gt; bool:\n    \"\"\"Check if a bucket exists.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.make_bucket","title":"<code>archipy.adapters.minio.ports.MinioPort.make_bucket(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Create a new bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef make_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Create a new bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.remove_bucket","title":"<code>archipy.adapters.minio.ports.MinioPort.remove_bucket(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef remove_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Remove a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.list_buckets","title":"<code>archipy.adapters.minio.ports.MinioPort.list_buckets()</code>  <code>abstractmethod</code>","text":"<p>List all buckets.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef list_buckets(self) -&gt; list[MinioBucketType]:\n    \"\"\"List all buckets.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.put_object","title":"<code>archipy.adapters.minio.ports.MinioPort.put_object(bucket_name, object_name, file_path)</code>  <code>abstractmethod</code>","text":"<p>Upload a file to a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Upload a file to a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.get_object","title":"<code>archipy.adapters.minio.ports.MinioPort.get_object(bucket_name, object_name, file_path)</code>  <code>abstractmethod</code>","text":"<p>Download an object to a file.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Download an object to a file.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.remove_object","title":"<code>archipy.adapters.minio.ports.MinioPort.remove_object(bucket_name, object_name)</code>  <code>abstractmethod</code>","text":"<p>Remove an object from a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n    \"\"\"Remove an object from a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.list_objects","title":"<code>archipy.adapters.minio.ports.MinioPort.list_objects(bucket_name, prefix='', *, recursive=False)</code>  <code>abstractmethod</code>","text":"<p>List objects in a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the bucket to list objects from</p> required <code>prefix</code> <code>str</code> <p>Optional prefix to filter objects by</p> <code>''</code> <code>recursive</code> <code>bool</code> <p>Whether to list objects recursively (include sub-directories)</p> <code>False</code> <p>Returns:</p> Type Description <code>list[MinioObjectType]</code> <p>A list of MinioObjectType objects</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef list_objects(\n    self,\n    bucket_name: str,\n    prefix: str = \"\",\n    *,  # Force recursive to be keyword-only to avoid boolean flag issues\n    recursive: bool = False,\n) -&gt; list[MinioObjectType]:\n    \"\"\"List objects in a bucket.\n\n    Args:\n        bucket_name: The name of the bucket to list objects from\n        prefix: Optional prefix to filter objects by\n        recursive: Whether to list objects recursively (include sub-directories)\n\n    Returns:\n        A list of MinioObjectType objects\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.stat_object","title":"<code>archipy.adapters.minio.ports.MinioPort.stat_object(bucket_name, object_name)</code>  <code>abstractmethod</code>","text":"<p>Get object metadata.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n    \"\"\"Get object metadata.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.presigned_get_object","title":"<code>archipy.adapters.minio.ports.MinioPort.presigned_get_object(bucket_name, object_name, expires=3600)</code>  <code>abstractmethod</code>","text":"<p>Generate a presigned URL for downloading an object.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.presigned_put_object","title":"<code>archipy.adapters.minio.ports.MinioPort.presigned_put_object(bucket_name, object_name, expires=3600)</code>  <code>abstractmethod</code>","text":"<p>Generate a presigned URL for uploading an object.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.set_bucket_policy","title":"<code>archipy.adapters.minio.ports.MinioPort.set_bucket_policy(bucket_name, policy)</code>  <code>abstractmethod</code>","text":"<p>Set bucket policy.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n    \"\"\"Set bucket policy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.get_bucket_policy","title":"<code>archipy.adapters.minio.ports.MinioPort.get_bucket_policy(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Get bucket policy.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n    \"\"\"Get bucket policy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#redis","title":"Redis","text":"<p>Redis integration for caching and key-value storage.</p> <pre><code>from archipy.adapters.redis import RedisAdapter, AsyncRedisAdapter\n\n# Create a Redis adapter (uses global config)\nredis = RedisAdapter()\n</code></pre> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter</code>","text":"<p>               Bases: <code>RedisPort</code></p> <p>Adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the RedisPort interface to provide a consistent way to interact with Redis, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class RedisAdapter(RedisPort):\n    \"\"\"Adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the RedisPort interface to provide a consistent\n    way to interact with Redis, abstracting the underlying Redis client\n    implementation. It supports all common Redis operations including key-value\n    operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        \"\"\"Initialize the RedisAdapter with configuration settings.\n\n        Args:\n            redis_config (RedisConfig, optional): Configuration settings for Redis.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        \"\"\"Set up Redis clients for master and slave connections.\n\n        Args:\n            configs (RedisConfig): Configuration settings for Redis.\n        \"\"\"\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: Redis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: Redis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; Redis:\n        \"\"\"Create a Redis client with the specified configuration.\n\n        Args:\n            host (str): Redis host address.\n            configs (RedisConfig): Configuration settings for Redis.\n\n        Returns:\n            Redis: Configured Redis client instance.\n        \"\"\"\n        return Redis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in milliseconds for a key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in milliseconds.\n        \"\"\"\n        return self.read_only_client.pttl(name)\n\n    @override\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increment the integer value of a key by the given amount.\n\n        Args:\n            name (RedisKeyType): The key name.\n            amount (int): Amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after increment.\n        \"\"\"\n        return self.client.incrby(name, amount)\n\n    @override\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key with optional expiration and conditions.\n\n        Args:\n            name (RedisKeyType): The key name.\n            value (RedisSetType): The value to set.\n            ex (RedisExpiryType | None): Expire time in seconds.\n            px (RedisExpiryType | None): Expire time in milliseconds.\n            nx (bool): Only set if key doesn't exist.\n            xx (bool): Only set if key exists.\n            keepttl (bool): Retain the TTL from the previous value.\n            get (bool): Return the old value.\n            exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n            pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n        Returns:\n            RedisResponseType: Result of the operation.\n        \"\"\"\n        return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key.\n\n        Args:\n            key (str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None if not exists.\n        \"\"\"\n        return self.read_only_client.get(key)\n\n    @override\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get the values of multiple keys.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: List of values.\n        \"\"\"\n        return self.read_only_client.mget(keys, *args)\n\n    @override\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Set multiple keys to their respective values.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n        Returns:\n            RedisResponseType: Always returns 'OK'.\n        \"\"\"\n        return self.client.mset(mapping)\n\n    @override\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Find all keys matching the given pattern.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of matching keys.\n        \"\"\"\n        return self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key and return its old value.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The new value.\n\n        Returns:\n            RedisResponseType: The previous value or None.\n        \"\"\"\n        return self.client.getset(key, value)\n\n    @override\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key and delete it.\n\n        Args:\n            key (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None.\n        \"\"\"\n        return self.client.getdel(key)\n\n    @override\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Check if one or more keys exist.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys that exist.\n        \"\"\"\n        return self.read_only_client.exists(*names)\n\n    @override\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Delete one or more keys.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys deleted.\n        \"\"\"\n        return self.client.delete(*names)\n\n    @override\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Append a value to a key.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: Length of the string after append.\n        \"\"\"\n        return self.client.append(key, value)\n\n    @override\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in seconds for a key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in seconds.\n        \"\"\"\n        return self.read_only_client.ttl(name)\n\n    @override\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determine the type stored at key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Type of the key's value.\n        \"\"\"\n        return self.read_only_client.type(name)\n\n    @override\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the length of a list.\n\n        Args:\n            name (str): The key name of the list.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list.\n        \"\"\"\n        return self.read_only_client.llen(name)\n\n    @override\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from the left of a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return self.client.lpop(name, count)\n\n    @override\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to the left of a list.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return self.client.lpush(name, *values)\n\n    @override\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Get a range of elements from a list.\n\n        Args:\n            name (str): The key name of the list.\n            start (int): Start index.\n            end (int): End index.\n\n        Returns:\n            RedisListResponseType: List of elements in the specified range.\n        \"\"\"\n        return self.read_only_client.lrange(name, start, end)\n\n    @override\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove elements from a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int): Number of occurrences to remove.\n            value (str): Value to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements removed.\n        \"\"\"\n        return self.client.lrem(name, count, value)\n\n    @override\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Set the value of an element in a list by its index.\n\n        Args:\n            name (str): The key name of the list.\n            index (int): Index of the element.\n            value (str): New value.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        return bool(self.client.lset(name, index, value))\n\n    @override\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from the right of a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return self.client.rpop(name, count)\n\n    @override\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to the right of a list.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return self.client.rpush(name, *values)\n\n    @override\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan keys in the database incrementally.\n\n        Args:\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys to return. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of keys.\n        \"\"\"\n        return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Iterate over keys in the database.\n\n        Args:\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys to return. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            Iterator: Iterator over matching keys.\n        \"\"\"\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan members of a set incrementally.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of members.\n        \"\"\"\n        return self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Iterate over members of a set.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            Iterator: Iterator over set members.\n        \"\"\"\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Add members to a set.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements added.\n        \"\"\"\n        return self.client.sadd(name, *values)\n\n    @override\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the number of members in a set.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of members.\n        \"\"\"\n        return self.client.scard(name)\n\n    @override\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if a value is a member of a set.\n\n        Args:\n            name (str): The set key name.\n            value (str): Value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if value is a member, False otherwise.\n        \"\"\"\n        result = self.read_only_client.sismember(name, value)\n        return result\n\n    @override\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Get all members of a set.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisSetResponseType: Set of all members.\n        \"\"\"\n        return self.read_only_client.smembers(name)\n\n    @override\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Remove and return random members from a set.\n\n        Args:\n            name (str): The set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            bytes | float | int | str | list | None: Popped member(s) or None.\n        \"\"\"\n        return self.client.spop(name, count)\n\n    @override\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove members from a set.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of members removed.\n        \"\"\"\n        return self.client.srem(name, *values)\n\n    @override\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Get the union of multiple sets.\n\n        Args:\n            keys (RedisKeyType): First set key.\n            *args (bytes | str): Additional set keys.\n\n        Returns:\n            RedisSetResponseType: Set containing union of all sets.\n        \"\"\"\n        result = self.client.sunion(keys, *args)\n        return set(result) if result else set()\n\n    @override\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Add members to a sorted set with scores.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n            nx (bool): Only add new elements. Defaults to False.\n            xx (bool): Only update existing elements. Defaults to False.\n            ch (bool): Return number of changed elements. Defaults to False.\n            incr (bool): Increment existing scores. Defaults to False.\n            gt (bool): Only update if score is greater. Defaults to False.\n            lt (bool): Only update if score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: Number of elements added or modified.\n        \"\"\"\n        return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the number of members in a sorted set.\n\n        Args:\n            name (bytes | str): The sorted set key name.\n\n        Returns:\n            RedisResponseType: Number of members.\n        \"\"\"\n        return self.client.zcard(name)\n\n    @override\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Count members in a sorted set with scores in range.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n\n        Returns:\n            RedisResponseType: Number of members in range.\n        \"\"\"\n        return self.client.zcount(name, min, max)\n\n    @override\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Remove and return members with highest scores from sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return self.client.zpopmax(name, count)\n\n    @override\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Remove and return members with lowest scores from sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return self.client.zpopmin(name, count)\n\n    @override\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get a range of members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index or score.\n            end (int): End index or score.\n            desc (bool): Sort in descending order. Defaults to False.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): Range by score. Defaults to False.\n            bylex (bool): Range by lexicographical order. Defaults to False.\n            offset (int | None): Offset for byscore/bylex. Defaults to None.\n            num (int | None): Count for byscore/bylex. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get a range of members from a sorted set in reverse order.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index.\n            end (int): End index.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get members from a sorted set by score range.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n            start (int | None): Offset. Defaults to None.\n            num (int | None): Count. Defaults to None.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get the rank of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to find rank for.\n\n        Returns:\n            RedisResponseType: Rank of the member or None if not found.\n        \"\"\"\n        return self.client.zrank(name, value)\n\n    @override\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Remove members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: Number of members removed.\n        \"\"\"\n        return self.client.zrem(name, *values)\n\n    @override\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to get score for.\n\n        Returns:\n            RedisResponseType: Score of the member or None if not found.\n        \"\"\"\n        return self.client.zscore(name, value)\n\n    @override\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Delete fields from a hash.\n\n        Args:\n            name (str): The hash key name.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields deleted.\n        \"\"\"\n        return self.client.hdel(name, *keys)\n\n    @override\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if a field exists in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if field exists, False otherwise.\n        \"\"\"\n        return self.read_only_client.hexists(name, key)\n\n    @override\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Get the value of a field in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: Value of the field or None.\n        \"\"\"\n        return self.read_only_client.hget(name, key)\n\n    @override\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Get all fields and values in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            Awaitable[dict] | dict: Dictionary of field-value pairs.\n        \"\"\"\n        return self.read_only_client.hgetall(name)\n\n    @override\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of field names.\n        \"\"\"\n        return self.read_only_client.hkeys(name)\n\n    @override\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the number of fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields.\n        \"\"\"\n        return self.read_only_client.hlen(name)\n\n    @override\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Set fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str | bytes | None): Single field name. Defaults to None.\n            value (str | bytes | None): Single field value. Defaults to None.\n            mapping (dict | None): Dictionary of field-value pairs. Defaults to None.\n            items (list | None): List of field-value pairs. Defaults to None.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields set.\n        \"\"\"\n        return self.client.hset(name, key, value, mapping, items)\n\n    @override\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Get values of multiple fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n            keys (list): List of field names.\n            *args (str | bytes): Additional field names.\n\n        Returns:\n            RedisListResponseType: List of field values.\n        \"\"\"\n        return self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all values in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of values.\n        \"\"\"\n        return self.read_only_client.hvals(name)\n\n    @override\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publish a message to a channel.\n\n        Args:\n            channel (RedisKeyType): Channel name.\n            message (bytes | str): Message to publish.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Number of subscribers that received the message.\n        \"\"\"\n        return self.client.publish(channel, message, **kwargs)\n\n    @override\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"List active channels matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of channel names.\n        \"\"\"\n        return self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increment the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            amount (float): Amount to increment by.\n            value (bytes | str | float): Member to increment.\n\n        Returns:\n            RedisResponseType: New score of the member.\n        \"\"\"\n        return self.client.zincrby(name, amount, value)\n\n    @override\n    def pubsub(self, **kwargs: Any) -&gt; PubSub:\n        \"\"\"Get a PubSub object for subscribing to channels.\n\n        Args:\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            PubSub: PubSub object.\n        \"\"\"\n        return self.client.pubsub(**kwargs)\n\n    @override\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n        \"\"\"Get a pipeline object for executing multiple commands.\n\n        Args:\n            transaction (Any): Whether to use transactions. Defaults to True.\n            shard_hint (Any): Hint for sharding. Defaults to None.\n\n        Returns:\n            Pipeline: Pipeline object.\n        \"\"\"\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    def ping(self) -&gt; RedisResponseType:\n        \"\"\"Ping the Redis server.\n\n        Returns:\n            RedisResponseType: 'PONG' if successful.\n        \"\"\"\n        return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.__init__","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.__init__(redis_config=None)</code>","text":"<p>Initialize the RedisAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n    \"\"\"Initialize the RedisAdapter with configuration settings.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n    self._set_clients(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pttl","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pttl(name)</code>","text":"<p>Get the time to live in milliseconds for a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in milliseconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in milliseconds for a key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in milliseconds.\n    \"\"\"\n    return self.read_only_client.pttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.incrby","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.incrby(name, amount=1)</code>","text":"<p>Increment the integer value of a key by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>amount</code> <code>int</code> <p>Amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after increment.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increment the integer value of a key by the given amount.\n\n    Args:\n        name (RedisKeyType): The key name.\n        amount (int): Amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after increment.\n    \"\"\"\n    return self.client.incrby(name, amount)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.set","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>","text":"<p>Set the value of a key with optional expiration and conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set.</p> required <code>ex</code> <code>RedisExpiryType | None</code> <p>Expire time in seconds.</p> <code>None</code> <code>px</code> <code>RedisExpiryType | None</code> <p>Expire time in milliseconds.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>Only set if key doesn't exist.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only set if key exists.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>Retain the TTL from the previous value.</p> <code>False</code> <code>get</code> <code>bool</code> <p>Return the old value.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in seconds.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in milliseconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Result of the operation.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key with optional expiration and conditions.\n\n    Args:\n        name (RedisKeyType): The key name.\n        value (RedisSetType): The value to set.\n        ex (RedisExpiryType | None): Expire time in seconds.\n        px (RedisExpiryType | None): Expire time in milliseconds.\n        nx (bool): Only set if key doesn't exist.\n        xx (bool): Only set if key exists.\n        keepttl (bool): Retain the TTL from the previous value.\n        get (bool): Return the old value.\n        exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n        pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n    Returns:\n        RedisResponseType: Result of the operation.\n    \"\"\"\n    return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.get","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.get(key)</code>","text":"<p>Get the value of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None if not exists.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key.\n\n    Args:\n        key (str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None if not exists.\n    \"\"\"\n    return self.read_only_client.get(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.mget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.mget(keys, *args)</code>","text":"<p>Get the values of multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>Single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Get the values of multiple keys.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: List of values.\n    \"\"\"\n    return self.read_only_client.mget(keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.mset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.mset(mapping)</code>","text":"<p>Set multiple keys to their respective values.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Dictionary of key-value pairs.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Always returns 'OK'.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Set multiple keys to their respective values.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n    Returns:\n        RedisResponseType: Always returns 'OK'.\n    \"\"\"\n    return self.client.mset(mapping)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.keys","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.keys(pattern='*', **kwargs)</code>","text":"<p>Find all keys matching the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Find all keys matching the given pattern.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of matching keys.\n    \"\"\"\n    return self.read_only_client.keys(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.getset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.getset(key, value)</code>","text":"<p>Set the value of a key and return its old value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The previous value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key and return its old value.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The new value.\n\n    Returns:\n        RedisResponseType: The previous value or None.\n    \"\"\"\n    return self.client.getset(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.getdel","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.getdel(key)</code>","text":"<p>Get the value of a key and delete it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key and delete it.\n\n    Args:\n        key (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None.\n    \"\"\"\n    return self.client.getdel(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.exists","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.exists(*names)</code>","text":"<p>Check if one or more keys exist.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys that exist.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Check if one or more keys exist.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys that exist.\n    \"\"\"\n    return self.read_only_client.exists(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.delete","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.delete(*names)</code>","text":"<p>Delete one or more keys.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Delete one or more keys.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys deleted.\n    \"\"\"\n    return self.client.delete(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.append","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.append(key, value)</code>","text":"<p>Append a value to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Length of the string after append.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Append a value to a key.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: Length of the string after append.\n    \"\"\"\n    return self.client.append(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.ttl","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.ttl(name)</code>","text":"<p>Get the time to live in seconds for a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in seconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in seconds for a key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in seconds.\n    \"\"\"\n    return self.read_only_client.ttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.type","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.type(name)</code>","text":"<p>Determine the type stored at key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Type of the key's value.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determine the type stored at key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Type of the key's value.\n    \"\"\"\n    return self.read_only_client.type(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.llen","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.llen(name)</code>","text":"<p>Get the length of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the length of a list.\n\n    Args:\n        name (str): The key name of the list.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list.\n    \"\"\"\n    return self.read_only_client.llen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lpop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lpop(name, count=None)</code>","text":"<p>Remove and return elements from the left of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from the left of a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return self.client.lpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lpush","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lpush(name, *values)</code>","text":"<p>Push elements to the left of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to the left of a list.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return self.client.lpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lrange(name, start, end)</code>","text":"<p>Get a range of elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of elements in the specified range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Get a range of elements from a list.\n\n    Args:\n        name (str): The key name of the list.\n        start (int): Start index.\n        end (int): End index.\n\n    Returns:\n        RedisListResponseType: List of elements in the specified range.\n    \"\"\"\n    return self.read_only_client.lrange(name, start, end)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lrem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lrem(name, count, value)</code>","text":"<p>Remove elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove.</p> required <code>value</code> <code>str</code> <p>Value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove elements from a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int): Number of occurrences to remove.\n        value (str): Value to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements removed.\n    \"\"\"\n    return self.client.lrem(name, count, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lset(name, index, value)</code>","text":"<p>Set the value of an element in a list by its index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>index</code> <code>int</code> <p>Index of the element.</p> required <code>value</code> <code>str</code> <p>New value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Set the value of an element in a list by its index.\n\n    Args:\n        name (str): The key name of the list.\n        index (int): Index of the element.\n        value (str): New value.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    return bool(self.client.lset(name, index, value))\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.rpop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.rpop(name, count=None)</code>","text":"<p>Remove and return elements from the right of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from the right of a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return self.client.rpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.rpush","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.rpush(name, *values)</code>","text":"<p>Push elements to the right of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to the right of a list.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return self.client.rpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scan","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>","text":"<p>Scan keys in the database incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys to return. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Scan keys in the database incrementally.\n\n    Args:\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys to return. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of keys.\n    \"\"\"\n    return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scan_iter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scan_iter(match=None, count=None, _type=None, **kwargs)</code>","text":"<p>Iterate over keys in the database.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys to return. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>Iterator over matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Iterate over keys in the database.\n\n    Args:\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys to return. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        Iterator: Iterator over matching keys.\n    \"\"\"\n    return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sscan","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sscan(name, cursor=0, match=None, count=None)</code>","text":"<p>Scan members of a set incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Scan members of a set incrementally.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of members.\n    \"\"\"\n    return self.read_only_client.sscan(name, cursor, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sscan_iter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sscan_iter(name, match=None, count=None)</code>","text":"<p>Iterate over members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>Iterator over set members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Iterate over members of a set.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        Iterator: Iterator over set members.\n    \"\"\"\n    return self.read_only_client.sscan_iter(name, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sadd","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sadd(name, *values)</code>","text":"<p>Add members to a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements added.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Add members to a set.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements added.\n    \"\"\"\n    return self.client.sadd(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scard","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scard(name)</code>","text":"<p>Get the number of members in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the number of members in a set.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of members.\n    \"\"\"\n    return self.client.scard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sismember","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sismember(name, value)</code>","text":"<p>Check if a value is a member of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>value</code> <code>str</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if value is a member, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if a value is a member of a set.\n\n    Args:\n        name (str): The set key name.\n        value (str): Value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if value is a member, False otherwise.\n    \"\"\"\n    result = self.read_only_client.sismember(name, value)\n    return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.smembers","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.smembers(name)</code>","text":"<p>Get all members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set of all members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Get all members of a set.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisSetResponseType: Set of all members.\n    \"\"\"\n    return self.read_only_client.smembers(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.spop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.spop(name, count=None)</code>","text":"<p>Remove and return random members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: Popped member(s) or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Remove and return random members from a set.\n\n    Args:\n        name (str): The set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        bytes | float | int | str | list | None: Popped member(s) or None.\n    \"\"\"\n    return self.client.spop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.srem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.srem(name, *values)</code>","text":"<p>Remove members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove members from a set.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of members removed.\n    \"\"\"\n    return self.client.srem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sunion","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sunion(keys, *args)</code>","text":"<p>Get the union of multiple sets.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>First set key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional set keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set containing union of all sets.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Get the union of multiple sets.\n\n    Args:\n        keys (RedisKeyType): First set key.\n        *args (bytes | str): Additional set keys.\n\n    Returns:\n        RedisSetResponseType: Set containing union of all sets.\n    \"\"\"\n    result = self.client.sunion(keys, *args)\n    return set(result) if result else set()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zadd","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>","text":"<p>Add members to a sorted set with scores.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Member-score pairs.</p> required <code>nx</code> <code>bool</code> <p>Only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>Return number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>Increment existing scores. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>Only update if score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>Only update if score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of elements added or modified.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Add members to a sorted set with scores.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n        nx (bool): Only add new elements. Defaults to False.\n        xx (bool): Only update existing elements. Defaults to False.\n        ch (bool): Return number of changed elements. Defaults to False.\n        incr (bool): Increment existing scores. Defaults to False.\n        gt (bool): Only update if score is greater. Defaults to False.\n        lt (bool): Only update if score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: Number of elements added or modified.\n    \"\"\"\n    return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zcard","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zcard(name)</code>","text":"<p>Get the number of members in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The sorted set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the number of members in a sorted set.\n\n    Args:\n        name (bytes | str): The sorted set key name.\n\n    Returns:\n        RedisResponseType: Number of members.\n    \"\"\"\n    return self.client.zcard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zcount","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zcount(name, min, max)</code>","text":"<p>Count members in a sorted set with scores in range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Count members in a sorted set with scores in range.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n\n    Returns:\n        RedisResponseType: Number of members in range.\n    \"\"\"\n    return self.client.zcount(name, min, max)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zpopmax","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zpopmax(name, count=None)</code>","text":"<p>Remove and return members with highest scores from sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Remove and return members with highest scores from sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return self.client.zpopmax(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zpopmin","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zpopmin(name, count=None)</code>","text":"<p>Remove and return members with lowest scores from sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Remove and return members with lowest scores from sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return self.client.zpopmin(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>","text":"<p>Get a range of members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index or score.</p> required <code>end</code> <code>int</code> <p>End index or score.</p> required <code>desc</code> <code>bool</code> <p>Sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>Range by score. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>Range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int | None</code> <p>Offset for byscore/bylex. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count for byscore/bylex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Get a range of members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index or score.\n        end (int): End index or score.\n        desc (bool): Sort in descending order. Defaults to False.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): Range by score. Defaults to False.\n        bylex (bool): Range by lexicographical order. Defaults to False.\n        offset (int | None): Offset for byscore/bylex. Defaults to None.\n        num (int | None): Count for byscore/bylex. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrange(\n        name,\n        start,\n        end,\n        desc,\n        withscores,\n        score_cast_func,\n        byscore,\n        bylex,\n        offset,\n        num,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrevrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>","text":"<p>Get a range of members from a sorted set in reverse order.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get a range of members from a sorted set in reverse order.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index.\n        end (int): End index.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrevrange(name, start, end, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrangebyscore","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>","text":"<p>Get members from a sorted set by score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <code>start</code> <code>int | None</code> <p>Offset. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count. Defaults to None.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get members from a sorted set by score range.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n        start (int | None): Offset. Defaults to None.\n        num (int | None): Count. Defaults to None.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrank","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrank(name, value)</code>","text":"<p>Get the rank of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to find rank for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Rank of the member or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get the rank of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to find rank for.\n\n    Returns:\n        RedisResponseType: Rank of the member or None if not found.\n    \"\"\"\n    return self.client.zrank(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrem(name, *values)</code>","text":"<p>Remove members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Remove members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: Number of members removed.\n    \"\"\"\n    return self.client.zrem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zscore","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zscore(name, value)</code>","text":"<p>Get the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to get score for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Score of the member or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to get score for.\n\n    Returns:\n        RedisResponseType: Score of the member or None if not found.\n    \"\"\"\n    return self.client.zscore(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hdel","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hdel(name, *keys)</code>","text":"<p>Delete fields from a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Delete fields from a hash.\n\n    Args:\n        name (str): The hash key name.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields deleted.\n    \"\"\"\n    return self.client.hdel(name, *keys)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hexists","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hexists(name, key)</code>","text":"<p>Check if a field exists in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if field exists, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if a field exists in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if field exists, False otherwise.\n    \"\"\"\n    return self.read_only_client.hexists(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hget(name, key)</code>","text":"<p>Get the value of a field in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: Value of the field or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Get the value of a field in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: Value of the field or None.\n    \"\"\"\n    return self.read_only_client.hget(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hgetall","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hgetall(name)</code>","text":"<p>Get all fields and values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: Dictionary of field-value pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Get all fields and values in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        Awaitable[dict] | dict: Dictionary of field-value pairs.\n    \"\"\"\n    return self.read_only_client.hgetall(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hkeys","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hkeys(name)</code>","text":"<p>Get all fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of field names.\n    \"\"\"\n    return self.read_only_client.hkeys(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hlen","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hlen(name)</code>","text":"<p>Get the number of fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the number of fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields.\n    \"\"\"\n    return self.read_only_client.hlen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hset(name, key=None, value=None, mapping=None, items=None)</code>","text":"<p>Set fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str | bytes | None</code> <p>Single field name. Defaults to None.</p> <code>None</code> <code>value</code> <code>str | bytes | None</code> <p>Single field value. Defaults to None.</p> <code>None</code> <code>mapping</code> <code>dict | None</code> <p>Dictionary of field-value pairs. Defaults to None.</p> <code>None</code> <code>items</code> <code>list | None</code> <p>List of field-value pairs. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields set.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Set fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str | bytes | None): Single field name. Defaults to None.\n        value (str | bytes | None): Single field value. Defaults to None.\n        mapping (dict | None): Dictionary of field-value pairs. Defaults to None.\n        items (list | None): List of field-value pairs. Defaults to None.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields set.\n    \"\"\"\n    return self.client.hset(name, key, value, mapping, items)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hmget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hmget(name, keys, *args)</code>","text":"<p>Get values of multiple fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>keys</code> <code>list</code> <p>List of field names.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional field names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Get values of multiple fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n        keys (list): List of field names.\n        *args (str | bytes): Additional field names.\n\n    Returns:\n        RedisListResponseType: List of field values.\n    \"\"\"\n    return self.read_only_client.hmget(name, keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hvals","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hvals(name)</code>","text":"<p>Get all values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all values in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of values.\n    \"\"\"\n    return self.read_only_client.hvals(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.publish","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.publish(channel, message, **kwargs)</code>","text":"<p>Publish a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>Channel name.</p> required <code>message</code> <code>bytes | str</code> <p>Message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of subscribers that received the message.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publish a message to a channel.\n\n    Args:\n        channel (RedisKeyType): Channel name.\n        message (bytes | str): Message to publish.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Number of subscribers that received the message.\n    \"\"\"\n    return self.client.publish(channel, message, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pubsub_channels","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pubsub_channels(pattern='*', **kwargs)</code>","text":"<p>List active channels matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of channel names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"List active channels matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of channel names.\n    \"\"\"\n    return self.client.pubsub_channels(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zincrby","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zincrby(name, amount, value)</code>","text":"<p>Increment the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>amount</code> <code>float</code> <p>Amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>New score of the member.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increment the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        amount (float): Amount to increment by.\n        value (bytes | str | float): Member to increment.\n\n    Returns:\n        RedisResponseType: New score of the member.\n    \"\"\"\n    return self.client.zincrby(name, amount, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pubsub","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pubsub(**kwargs)</code>","text":"<p>Get a PubSub object for subscribing to channels.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>PubSub</code> <code>PubSub</code> <p>PubSub object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pubsub(self, **kwargs: Any) -&gt; PubSub:\n    \"\"\"Get a PubSub object for subscribing to channels.\n\n    Args:\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        PubSub: PubSub object.\n    \"\"\"\n    return self.client.pubsub(**kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.get_pipeline","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.get_pipeline(transaction=True, shard_hint=None)</code>","text":"<p>Get a pipeline object for executing multiple commands.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>Whether to use transactions. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Pipeline</code> <code>Pipeline</code> <p>Pipeline object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n    \"\"\"Get a pipeline object for executing multiple commands.\n\n    Args:\n        transaction (Any): Whether to use transactions. Defaults to True.\n        shard_hint (Any): Hint for sharding. Defaults to None.\n\n    Returns:\n        Pipeline: Pipeline object.\n    \"\"\"\n    return self.client.pipeline(transaction, shard_hint)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.ping","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.ping()</code>","text":"<p>Ping the Redis server.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>'PONG' if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef ping(self) -&gt; RedisResponseType:\n    \"\"\"Ping the Redis server.\n\n    Returns:\n        RedisResponseType: 'PONG' if successful.\n    \"\"\"\n    return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter</code>","text":"<p>               Bases: <code>AsyncRedisPort</code></p> <p>Async adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the AsyncRedisPort interface to provide a consistent way to interact with Redis asynchronously, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class AsyncRedisAdapter(AsyncRedisPort):\n    \"\"\"Async adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the AsyncRedisPort interface to provide a consistent\n    way to interact with Redis asynchronously, abstracting the underlying Redis\n    client implementation. It supports all common Redis operations including\n    key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        \"\"\"Initialize the AsyncRedisAdapter with configuration settings.\n\n        Args:\n            redis_config (RedisConfig, optional): Configuration settings for Redis.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        \"\"\"Set up async Redis clients for master and slave connections.\n\n        Args:\n            configs (RedisConfig): Configuration settings for Redis.\n        \"\"\"\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: AsyncRedis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: AsyncRedis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; AsyncRedis:\n        \"\"\"Create an async Redis client with the specified configuration.\n\n        Args:\n            host (str): Redis host address.\n            configs (RedisConfig): Configuration settings for Redis.\n\n        Returns:\n            AsyncRedis: Configured async Redis client instance.\n        \"\"\"\n        return AsyncRedis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    async def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in milliseconds for a key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in milliseconds.\n        \"\"\"\n        return await self.read_only_client.pttl(name)\n\n    @override\n    async def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increment the integer value of a key by the given amount asynchronously.\n\n        Args:\n            name (RedisKeyType): The key name.\n            amount (int): Amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after increment.\n        \"\"\"\n        return await self.client.incrby(name, amount)\n\n    @override\n    async def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key with optional expiration asynchronously.\n\n        Args:\n            name (RedisKeyType): The key name.\n            value (RedisSetType): The value to set.\n            ex (RedisExpiryType | None): Expire time in seconds.\n            px (RedisExpiryType | None): Expire time in milliseconds.\n            nx (bool): Only set if key doesn't exist.\n            xx (bool): Only set if key exists.\n            keepttl (bool): Retain the TTL from the previous value.\n            get (bool): Return the old value.\n            exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n            pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n        Returns:\n            RedisResponseType: Result of the operation.\n        \"\"\"\n        return await self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    async def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key asynchronously.\n\n        Args:\n            key (str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None if not exists.\n        \"\"\"\n        return await self.read_only_client.get(key)\n\n    @override\n    async def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get the values of multiple keys asynchronously.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: List of values.\n        \"\"\"\n        return await self.read_only_client.mget(keys, *args)\n\n    @override\n    async def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Set multiple keys to their values asynchronously.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n        Returns:\n            RedisResponseType: Always returns 'OK'.\n        \"\"\"\n        return await self.client.mset(mapping)\n\n    @override\n    async def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Find all keys matching the pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of matching keys.\n        \"\"\"\n        return await self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    async def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Set a key's value and return its old value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The new value.\n\n        Returns:\n            RedisResponseType: The previous value or None.\n        \"\"\"\n        return await self.client.getset(key, value)\n\n    @override\n    async def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get a key's value and delete it asynchronously.\n\n        Args:\n            key (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None.\n        \"\"\"\n        return await self.client.getdel(key)\n\n    @override\n    async def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Check if keys exist asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys that exist.\n        \"\"\"\n        return await self.read_only_client.exists(*names)\n\n    @override\n    async def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Delete keys asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys deleted.\n        \"\"\"\n        return await self.client.delete(*names)\n\n    @override\n    async def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Append a value to a key asynchronously.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: Length of the string after append.\n        \"\"\"\n        return await self.client.append(key, value)\n\n    @override\n    async def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in seconds for a key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in seconds.\n        \"\"\"\n        return await self.read_only_client.ttl(name)\n\n    @override\n    async def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determine the type stored at key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Type of the key's value.\n        \"\"\"\n        return await self.read_only_client.type(name)\n\n    @override\n    async def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the length of a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list.\n        \"\"\"\n        return await self.read_only_client.llen(name)\n\n    @override\n    async def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from list left asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return await self.client.lpop(name, count)\n\n    @override\n    async def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to list left asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return await self.client.lpush(name, *values)\n\n    @override\n    async def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Get a range of elements from a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            start (int): Start index.\n            end (int): End index.\n\n        Returns:\n            RedisListResponseType: List of elements in range.\n        \"\"\"\n        return await self.read_only_client.lrange(name, start, end)\n\n    @override\n    async def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove elements from a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int): Number of occurrences to remove.\n            value (str): Value to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements removed.\n        \"\"\"\n        return await self.client.lrem(name, count, value)\n\n    @override\n    async def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Set list element by index asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            index (int): Index of the element.\n            value (str): New value.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        result = await self.client.lset(name, index, value)\n        return bool(result)\n\n    @override\n    async def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from list right asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return await self.client.rpop(name, count)\n\n    @override\n    async def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to list right asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return await self.client.rpush(name, *values)\n\n    @override\n    async def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan keys in database incrementally asynchronously.\n\n        Args:\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of keys.\n        \"\"\"\n        return await self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    async def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator[Any]:\n        \"\"\"Iterate over keys in database asynchronously.\n\n        Args:\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            Iterator[Any]: Iterator over matching keys.\n        \"\"\"\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    async def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan set members incrementally asynchronously.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of members.\n        \"\"\"\n        return await self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    async def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator[Any]:\n        \"\"\"Iterate over set members asynchronously.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            Iterator[Any]: Iterator over set members.\n        \"\"\"\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    async def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Add members to a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements added.\n        \"\"\"\n        return await self.client.sadd(name, *values)\n\n    @override\n    async def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get number of members in a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of members.\n        \"\"\"\n        return await self.client.scard(name)\n\n    @override\n    async def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if value is in set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            value (str): Value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if value is member, False otherwise.\n        \"\"\"\n        result = await self.read_only_client.sismember(name, value)\n        return result\n\n    @override\n    async def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Get all members of a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisSetResponseType: Set of all members.\n        \"\"\"\n        return await self.read_only_client.smembers(name)\n\n    @override\n    async def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Remove and return random set members asynchronously.\n\n        Args:\n            name (str): The set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            bytes | float | int | str | list | None: Popped member(s) or None.\n        \"\"\"\n        return await self.client.spop(name, count)\n\n    @override\n    async def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove members from a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of members removed.\n        \"\"\"\n        return await self.client.srem(name, *values)\n\n    @override\n    async def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Get union of multiple sets asynchronously.\n\n        Args:\n            keys (RedisKeyType): First set key.\n            *args (bytes | str): Additional set keys.\n\n        Returns:\n            RedisSetResponseType: Set containing union of all sets.\n        \"\"\"\n        result = await self.client.sunion(keys, *args)\n        return set(result) if result else set()\n\n    @override\n    async def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Add members to sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n            nx (bool): Only add new elements. Defaults to False.\n            xx (bool): Only update existing. Defaults to False.\n            ch (bool): Return changed count. Defaults to False.\n            incr (bool): Increment scores. Defaults to False.\n            gt (bool): Only if greater. Defaults to False.\n            lt (bool): Only if less. Defaults to False.\n\n        Returns:\n            RedisResponseType: Number of elements added or modified.\n        \"\"\"\n        return await self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    async def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get number of members in sorted set asynchronously.\n\n        Args:\n            name (bytes | str): The sorted set key name.\n\n        Returns:\n            RedisResponseType: Number of members.\n        \"\"\"\n        return await self.client.zcard(name)\n\n    @override\n    async def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Count members in score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n\n        Returns:\n            RedisResponseType: Number of members in range.\n        \"\"\"\n        return await self.client.zcount(name, min, max)\n\n    @override\n    async def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Pop highest scored members asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return await self.client.zpopmax(name, count)\n\n    @override\n    async def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Pop lowest scored members asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return await self.client.zpopmin(name, count)\n\n    @override\n    async def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get range from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index or score.\n            end (int): End index or score.\n            desc (bool): Descending order. Defaults to False.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n            byscore (bool): Range by score. Defaults to False.\n            bylex (bool): Range by lex. Defaults to False.\n            offset (int | None): Offset for byscore/bylex. Defaults to None.\n            num (int | None): Count for byscore/bylex. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    async def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get reverse range from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index.\n            end (int): End index.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    async def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get members by score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n            start (int | None): Offset. Defaults to None.\n            num (int | None): Count. Defaults to None.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    async def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get rank of member in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to find rank for.\n\n        Returns:\n            RedisResponseType: Rank or None if not found.\n        \"\"\"\n        return await self.client.zrank(name, value)\n\n    @override\n    async def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Remove members from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: Number of members removed.\n        \"\"\"\n        return await self.client.zrem(name, *values)\n\n    @override\n    async def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get score of member in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to get score for.\n\n        Returns:\n            RedisResponseType: Score or None if not found.\n        \"\"\"\n        return await self.client.zscore(name, value)\n\n    @override\n    async def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Delete fields from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields deleted.\n        \"\"\"\n        return await self.client.hdel(name, *keys)\n\n    @override\n    async def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if field exists in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if exists, False otherwise.\n        \"\"\"\n        return await self.read_only_client.hexists(name, key)\n\n    @override\n    async def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Get field value from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: Value or None.\n        \"\"\"\n        return await self.read_only_client.hget(name, key)\n\n    @override\n    async def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Get all fields and values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            Awaitable[dict] | dict: Dictionary of field-value pairs.\n        \"\"\"\n        return await self.read_only_client.hgetall(name)\n\n    @override\n    async def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all fields from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of field names.\n        \"\"\"\n        return await self.read_only_client.hkeys(name)\n\n    @override\n    async def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get number of fields in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields.\n        \"\"\"\n        return await self.read_only_client.hlen(name)\n\n    @override\n    async def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Set fields in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str | bytes | None): Single field name. Defaults to None.\n            value (str | bytes | None): Single field value. Defaults to None.\n            mapping (dict | None): Field-value pairs dict. Defaults to None.\n            items (list | None): Field-value pairs list. Defaults to None.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields set.\n        \"\"\"\n        return await self.client.hset(name, key, value, mapping, items)\n\n    @override\n    async def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Get multiple field values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            keys (list): List of field names.\n            *args (str | bytes): Additional field names.\n\n        Returns:\n            RedisListResponseType: List of field values.\n        \"\"\"\n        return await self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    async def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of values.\n        \"\"\"\n        return await self.read_only_client.hvals(name)\n\n    @override\n    async def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publish message to channel asynchronously.\n\n        Args:\n            channel (RedisKeyType): Channel name.\n            message (bytes | str): Message to publish.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Number of subscribers received message.\n        \"\"\"\n        return await self.client.publish(channel, message, **kwargs)\n\n    @override\n    async def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"List active channels matching pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of channel names.\n        \"\"\"\n        return await self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    async def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increment member score in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            amount (float): Amount to increment by.\n            value (bytes | str | float): Member to increment.\n\n        Returns:\n            RedisResponseType: New score of the member.\n        \"\"\"\n        return await self.client.zincrby(name, amount, value)\n\n    @override\n    async def pubsub(self, **kwargs: Any) -&gt; AsyncPubSub:\n        \"\"\"Get PubSub object for channel subscription asynchronously.\n\n        Args:\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            AsyncPubSub: PubSub object.\n        \"\"\"\n        return self.client.pubsub(**kwargs)\n\n    @override\n    async def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; AsyncPipeline:\n        \"\"\"Get pipeline for multiple commands asynchronously.\n\n        Args:\n            transaction (Any): Use transactions. Defaults to True.\n            shard_hint (Any): Sharding hint. Defaults to None.\n\n        Returns:\n            AsyncPipeline: Pipeline object.\n        \"\"\"\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    async def ping(self) -&gt; RedisResponseType:\n        \"\"\"Ping the Redis server asynchronously.\n\n        Returns:\n            RedisResponseType: 'PONG' if successful.\n        \"\"\"\n        return await self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.__init__","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.__init__(redis_config=None)</code>","text":"<p>Initialize the AsyncRedisAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n    \"\"\"Initialize the AsyncRedisAdapter with configuration settings.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n    self._set_clients(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pttl","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pttl(name)</code>  <code>async</code>","text":"<p>Get the time to live in milliseconds for a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in milliseconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in milliseconds for a key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in milliseconds.\n    \"\"\"\n    return await self.read_only_client.pttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.incrby","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.incrby(name, amount=1)</code>  <code>async</code>","text":"<p>Increment the integer value of a key by the given amount asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>amount</code> <code>int</code> <p>Amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after increment.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increment the integer value of a key by the given amount asynchronously.\n\n    Args:\n        name (RedisKeyType): The key name.\n        amount (int): Amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after increment.\n    \"\"\"\n    return await self.client.incrby(name, amount)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.set","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>async</code>","text":"<p>Set the value of a key with optional expiration asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set.</p> required <code>ex</code> <code>RedisExpiryType | None</code> <p>Expire time in seconds.</p> <code>None</code> <code>px</code> <code>RedisExpiryType | None</code> <p>Expire time in milliseconds.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>Only set if key doesn't exist.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only set if key exists.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>Retain the TTL from the previous value.</p> <code>False</code> <code>get</code> <code>bool</code> <p>Return the old value.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in seconds.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in milliseconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Result of the operation.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key with optional expiration asynchronously.\n\n    Args:\n        name (RedisKeyType): The key name.\n        value (RedisSetType): The value to set.\n        ex (RedisExpiryType | None): Expire time in seconds.\n        px (RedisExpiryType | None): Expire time in milliseconds.\n        nx (bool): Only set if key doesn't exist.\n        xx (bool): Only set if key exists.\n        keepttl (bool): Retain the TTL from the previous value.\n        get (bool): Return the old value.\n        exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n        pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n    Returns:\n        RedisResponseType: Result of the operation.\n    \"\"\"\n    return await self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.get","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.get(key)</code>  <code>async</code>","text":"<p>Get the value of a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None if not exists.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key asynchronously.\n\n    Args:\n        key (str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None if not exists.\n    \"\"\"\n    return await self.read_only_client.get(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.mget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.mget(keys, *args)</code>  <code>async</code>","text":"<p>Get the values of multiple keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>Single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Get the values of multiple keys asynchronously.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: List of values.\n    \"\"\"\n    return await self.read_only_client.mget(keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.mset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.mset(mapping)</code>  <code>async</code>","text":"<p>Set multiple keys to their values asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Dictionary of key-value pairs.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Always returns 'OK'.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Set multiple keys to their values asynchronously.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n    Returns:\n        RedisResponseType: Always returns 'OK'.\n    \"\"\"\n    return await self.client.mset(mapping)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.keys","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.keys(pattern='*', **kwargs)</code>  <code>async</code>","text":"<p>Find all keys matching the pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Find all keys matching the pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of matching keys.\n    \"\"\"\n    return await self.read_only_client.keys(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.getset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.getset(key, value)</code>  <code>async</code>","text":"<p>Set a key's value and return its old value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The previous value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Set a key's value and return its old value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The new value.\n\n    Returns:\n        RedisResponseType: The previous value or None.\n    \"\"\"\n    return await self.client.getset(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.getdel","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.getdel(key)</code>  <code>async</code>","text":"<p>Get a key's value and delete it asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get a key's value and delete it asynchronously.\n\n    Args:\n        key (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None.\n    \"\"\"\n    return await self.client.getdel(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.exists","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.exists(*names)</code>  <code>async</code>","text":"<p>Check if keys exist asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys that exist.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Check if keys exist asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys that exist.\n    \"\"\"\n    return await self.read_only_client.exists(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.delete","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.delete(*names)</code>  <code>async</code>","text":"<p>Delete keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Delete keys asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys deleted.\n    \"\"\"\n    return await self.client.delete(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.append","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.append(key, value)</code>  <code>async</code>","text":"<p>Append a value to a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Length of the string after append.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Append a value to a key asynchronously.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: Length of the string after append.\n    \"\"\"\n    return await self.client.append(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.ttl","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.ttl(name)</code>  <code>async</code>","text":"<p>Get the time to live in seconds for a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in seconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in seconds for a key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in seconds.\n    \"\"\"\n    return await self.read_only_client.ttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.type","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.type(name)</code>  <code>async</code>","text":"<p>Determine the type stored at key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Type of the key's value.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determine the type stored at key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Type of the key's value.\n    \"\"\"\n    return await self.read_only_client.type(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.llen","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.llen(name)</code>  <code>async</code>","text":"<p>Get the length of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the length of a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list.\n    \"\"\"\n    return await self.read_only_client.llen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lpop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lpop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return elements from list left asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from list left asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return await self.client.lpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lpush","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lpush(name, *values)</code>  <code>async</code>","text":"<p>Push elements to list left asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to list left asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return await self.client.lpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lrange(name, start, end)</code>  <code>async</code>","text":"<p>Get a range of elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of elements in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Get a range of elements from a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        start (int): Start index.\n        end (int): End index.\n\n    Returns:\n        RedisListResponseType: List of elements in range.\n    \"\"\"\n    return await self.read_only_client.lrange(name, start, end)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lrem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lrem(name, count, value)</code>  <code>async</code>","text":"<p>Remove elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove.</p> required <code>value</code> <code>str</code> <p>Value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove elements from a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int): Number of occurrences to remove.\n        value (str): Value to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements removed.\n    \"\"\"\n    return await self.client.lrem(name, count, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lset(name, index, value)</code>  <code>async</code>","text":"<p>Set list element by index asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>index</code> <code>int</code> <p>Index of the element.</p> required <code>value</code> <code>str</code> <p>New value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Set list element by index asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        index (int): Index of the element.\n        value (str): New value.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    result = await self.client.lset(name, index, value)\n    return bool(result)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.rpop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.rpop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return elements from list right asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from list right asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return await self.client.rpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.rpush","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.rpush(name, *values)</code>  <code>async</code>","text":"<p>Push elements to list right asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to list right asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return await self.client.rpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scan","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>async</code>","text":"<p>Scan keys in database incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Scan keys in database incrementally asynchronously.\n\n    Args:\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of keys.\n    \"\"\"\n    return await self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scan_iter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>async</code>","text":"<p>Iterate over keys in database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterator[Any]</code> <p>Iterator[Any]: Iterator over matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[Any]:\n    \"\"\"Iterate over keys in database asynchronously.\n\n    Args:\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        Iterator[Any]: Iterator over matching keys.\n    \"\"\"\n    return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan(name, cursor=0, match=None, count=None)</code>  <code>async</code>","text":"<p>Scan set members incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Scan set members incrementally asynchronously.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of members.\n    \"\"\"\n    return await self.read_only_client.sscan(name, cursor, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan_iter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan_iter(name, match=None, count=None)</code>  <code>async</code>","text":"<p>Iterate over set members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Any]</code> <p>Iterator[Any]: Iterator over set members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator[Any]:\n    \"\"\"Iterate over set members asynchronously.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        Iterator[Any]: Iterator over set members.\n    \"\"\"\n    return self.read_only_client.sscan_iter(name, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sadd","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sadd(name, *values)</code>  <code>async</code>","text":"<p>Add members to a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements added.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Add members to a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements added.\n    \"\"\"\n    return await self.client.sadd(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scard","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scard(name)</code>  <code>async</code>","text":"<p>Get number of members in a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get number of members in a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of members.\n    \"\"\"\n    return await self.client.scard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sismember","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sismember(name, value)</code>  <code>async</code>","text":"<p>Check if value is in set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>value</code> <code>str</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if value is member, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if value is in set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        value (str): Value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if value is member, False otherwise.\n    \"\"\"\n    result = await self.read_only_client.sismember(name, value)\n    return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.smembers","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.smembers(name)</code>  <code>async</code>","text":"<p>Get all members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set of all members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Get all members of a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisSetResponseType: Set of all members.\n    \"\"\"\n    return await self.read_only_client.smembers(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.spop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.spop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return random set members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: Popped member(s) or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Remove and return random set members asynchronously.\n\n    Args:\n        name (str): The set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        bytes | float | int | str | list | None: Popped member(s) or None.\n    \"\"\"\n    return await self.client.spop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.srem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.srem(name, *values)</code>  <code>async</code>","text":"<p>Remove members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove members from a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of members removed.\n    \"\"\"\n    return await self.client.srem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sunion","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sunion(keys, *args)</code>  <code>async</code>","text":"<p>Get union of multiple sets asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>First set key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional set keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set containing union of all sets.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Get union of multiple sets asynchronously.\n\n    Args:\n        keys (RedisKeyType): First set key.\n        *args (bytes | str): Additional set keys.\n\n    Returns:\n        RedisSetResponseType: Set containing union of all sets.\n    \"\"\"\n    result = await self.client.sunion(keys, *args)\n    return set(result) if result else set()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zadd","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>async</code>","text":"<p>Add members to sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Member-score pairs.</p> required <code>nx</code> <code>bool</code> <p>Only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only update existing. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>Return changed count. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>Increment scores. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>Only if greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>Only if less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of elements added or modified.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Add members to sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n        nx (bool): Only add new elements. Defaults to False.\n        xx (bool): Only update existing. Defaults to False.\n        ch (bool): Return changed count. Defaults to False.\n        incr (bool): Increment scores. Defaults to False.\n        gt (bool): Only if greater. Defaults to False.\n        lt (bool): Only if less. Defaults to False.\n\n    Returns:\n        RedisResponseType: Number of elements added or modified.\n    \"\"\"\n    return await self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zcard","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zcard(name)</code>  <code>async</code>","text":"<p>Get number of members in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The sorted set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get number of members in sorted set asynchronously.\n\n    Args:\n        name (bytes | str): The sorted set key name.\n\n    Returns:\n        RedisResponseType: Number of members.\n    \"\"\"\n    return await self.client.zcard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zcount","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zcount(name, min, max)</code>  <code>async</code>","text":"<p>Count members in score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Count members in score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n\n    Returns:\n        RedisResponseType: Number of members in range.\n    \"\"\"\n    return await self.client.zcount(name, min, max)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmax","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmax(name, count=None)</code>  <code>async</code>","text":"<p>Pop highest scored members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Pop highest scored members asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return await self.client.zpopmax(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmin","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmin(name, count=None)</code>  <code>async</code>","text":"<p>Pop lowest scored members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Pop lowest scored members asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return await self.client.zpopmin(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>async</code>","text":"<p>Get range from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index or score.</p> required <code>end</code> <code>int</code> <p>End index or score.</p> required <code>desc</code> <code>bool</code> <p>Descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>Range by score. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>Range by lex. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int | None</code> <p>Offset for byscore/bylex. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count for byscore/bylex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Get range from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index or score.\n        end (int): End index or score.\n        desc (bool): Descending order. Defaults to False.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n        byscore (bool): Range by score. Defaults to False.\n        bylex (bool): Range by lex. Defaults to False.\n        offset (int | None): Offset for byscore/bylex. Defaults to None.\n        num (int | None): Count for byscore/bylex. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrange(\n        name,\n        start,\n        end,\n        desc,\n        withscores,\n        score_cast_func,\n        byscore,\n        bylex,\n        offset,\n        num,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrevrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>async</code>","text":"<p>Get reverse range from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get reverse range from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index.\n        end (int): End index.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrevrange(name, start, end, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrangebyscore","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>async</code>","text":"<p>Get members by score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <code>start</code> <code>int | None</code> <p>Offset. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count. Defaults to None.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get members by score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n        start (int | None): Offset. Defaults to None.\n        num (int | None): Count. Defaults to None.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrank","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrank(name, value)</code>  <code>async</code>","text":"<p>Get rank of member in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to find rank for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Rank or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get rank of member in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to find rank for.\n\n    Returns:\n        RedisResponseType: Rank or None if not found.\n    \"\"\"\n    return await self.client.zrank(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrem(name, *values)</code>  <code>async</code>","text":"<p>Remove members from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Remove members from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: Number of members removed.\n    \"\"\"\n    return await self.client.zrem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zscore","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zscore(name, value)</code>  <code>async</code>","text":"<p>Get score of member in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to get score for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Score or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get score of member in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to get score for.\n\n    Returns:\n        RedisResponseType: Score or None if not found.\n    \"\"\"\n    return await self.client.zscore(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hdel","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hdel(name, *keys)</code>  <code>async</code>","text":"<p>Delete fields from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Delete fields from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields deleted.\n    \"\"\"\n    return await self.client.hdel(name, *keys)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hexists","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hexists(name, key)</code>  <code>async</code>","text":"<p>Check if field exists in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if exists, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if field exists in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if exists, False otherwise.\n    \"\"\"\n    return await self.read_only_client.hexists(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hget(name, key)</code>  <code>async</code>","text":"<p>Get field value from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: Value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Get field value from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: Value or None.\n    \"\"\"\n    return await self.read_only_client.hget(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hgetall","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hgetall(name)</code>  <code>async</code>","text":"<p>Get all fields and values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: Dictionary of field-value pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Get all fields and values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        Awaitable[dict] | dict: Dictionary of field-value pairs.\n    \"\"\"\n    return await self.read_only_client.hgetall(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hkeys","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hkeys(name)</code>  <code>async</code>","text":"<p>Get all fields from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all fields from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of field names.\n    \"\"\"\n    return await self.read_only_client.hkeys(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hlen","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hlen(name)</code>  <code>async</code>","text":"<p>Get number of fields in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get number of fields in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields.\n    \"\"\"\n    return await self.read_only_client.hlen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>async</code>","text":"<p>Set fields in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str | bytes | None</code> <p>Single field name. Defaults to None.</p> <code>None</code> <code>value</code> <code>str | bytes | None</code> <p>Single field value. Defaults to None.</p> <code>None</code> <code>mapping</code> <code>dict | None</code> <p>Field-value pairs dict. Defaults to None.</p> <code>None</code> <code>items</code> <code>list | None</code> <p>Field-value pairs list. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields set.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Set fields in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str | bytes | None): Single field name. Defaults to None.\n        value (str | bytes | None): Single field value. Defaults to None.\n        mapping (dict | None): Field-value pairs dict. Defaults to None.\n        items (list | None): Field-value pairs list. Defaults to None.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields set.\n    \"\"\"\n    return await self.client.hset(name, key, value, mapping, items)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hmget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hmget(name, keys, *args)</code>  <code>async</code>","text":"<p>Get multiple field values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>keys</code> <code>list</code> <p>List of field names.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional field names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Get multiple field values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        keys (list): List of field names.\n        *args (str | bytes): Additional field names.\n\n    Returns:\n        RedisListResponseType: List of field values.\n    \"\"\"\n    return await self.read_only_client.hmget(name, keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hvals","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hvals(name)</code>  <code>async</code>","text":"<p>Get all values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of values.\n    \"\"\"\n    return await self.read_only_client.hvals(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.publish","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.publish(channel, message, **kwargs)</code>  <code>async</code>","text":"<p>Publish message to channel asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>Channel name.</p> required <code>message</code> <code>bytes | str</code> <p>Message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of subscribers received message.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publish message to channel asynchronously.\n\n    Args:\n        channel (RedisKeyType): Channel name.\n        message (bytes | str): Message to publish.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Number of subscribers received message.\n    \"\"\"\n    return await self.client.publish(channel, message, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub_channels","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub_channels(pattern='*', **kwargs)</code>  <code>async</code>","text":"<p>List active channels matching pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of channel names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"List active channels matching pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of channel names.\n    \"\"\"\n    return await self.client.pubsub_channels(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zincrby","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zincrby(name, amount, value)</code>  <code>async</code>","text":"<p>Increment member score in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>amount</code> <code>float</code> <p>Amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>New score of the member.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increment member score in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        amount (float): Amount to increment by.\n        value (bytes | str | float): Member to increment.\n\n    Returns:\n        RedisResponseType: New score of the member.\n    \"\"\"\n    return await self.client.zincrby(name, amount, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub(**kwargs)</code>  <code>async</code>","text":"<p>Get PubSub object for channel subscription asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>AsyncPubSub</code> <code>PubSub</code> <p>PubSub object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pubsub(self, **kwargs: Any) -&gt; AsyncPubSub:\n    \"\"\"Get PubSub object for channel subscription asynchronously.\n\n    Args:\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        AsyncPubSub: PubSub object.\n    \"\"\"\n    return self.client.pubsub(**kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.get_pipeline","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.get_pipeline(transaction=True, shard_hint=None)</code>  <code>async</code>","text":"<p>Get pipeline for multiple commands asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>Use transactions. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Sharding hint. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AsyncPipeline</code> <code>Pipeline</code> <p>Pipeline object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; AsyncPipeline:\n    \"\"\"Get pipeline for multiple commands asynchronously.\n\n    Args:\n        transaction (Any): Use transactions. Defaults to True.\n        shard_hint (Any): Sharding hint. Defaults to None.\n\n    Returns:\n        AsyncPipeline: Pipeline object.\n    \"\"\"\n    return self.client.pipeline(transaction, shard_hint)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.ping","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.ping()</code>  <code>async</code>","text":"<p>Ping the Redis server asynchronously.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>'PONG' if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def ping(self) -&gt; RedisResponseType:\n    \"\"\"Ping the Redis server asynchronously.\n\n    Returns:\n        RedisResponseType: 'PONG' if successful.\n    \"\"\"\n    return await self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort","title":"<code>archipy.adapters.redis.ports.RedisPort</code>","text":"<p>Interface for Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping a Redis client library.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class RedisPort:\n    \"\"\"Interface for Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping a Redis client library.\n    \"\"\"\n\n    @abstractmethod\n    def ping(self) -&gt; RedisResponseType:\n        \"\"\"Tests the connection to the Redis server.\n\n        Returns:\n            RedisResponseType: The response from the server, typically \"PONG\".\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in milliseconds.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increments the integer value of a key by the given amount.\n\n        Args:\n            name (RedisKeyType): The key to increment.\n            amount (int): The amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after incrementing.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value with optional expiration and conditions.\n\n        Args:\n            name (RedisKeyType): The key to set.\n            value (RedisSetType): The value to set for the key.\n            ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n            px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n            nx (bool): If True, set only if the key does not exist. Defaults to False.\n            xx (bool): If True, set only if the key already exists. Defaults to False.\n            keepttl (bool): If True, retain the existing TTL. Defaults to False.\n            get (bool): If True, return the old value before setting. Defaults to False.\n            exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n            pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n        Returns:\n            RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Retrieves the value of a key.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets the values of multiple keys.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: A list of values corresponding to the keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Sets multiple keys to their respective values.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n        Returns:\n            RedisResponseType: Typically \"OK\" on success.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Returns all keys matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of matching keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value and returns its old value.\n\n        Args:\n            key (RedisKeyType): The key to set.\n            value (bytes | str | float): The new value to set.\n\n        Returns:\n            RedisResponseType: The old value of the key, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the value of a key and deletes it.\n\n        Args:\n            key (bytes | str): The key to get and delete.\n\n        Returns:\n            RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Checks if one or more keys exist.\n\n        Args:\n            *names (bytes | str): Variable number of keys to check.\n\n        Returns:\n            RedisResponseType: The number of keys that exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Deletes one or more keys.\n\n        Args:\n            *names (bytes | str): Variable number of keys to delete.\n\n        Returns:\n            RedisResponseType: The number of keys deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Appends a value to a key's string value.\n\n        Args:\n            key (RedisKeyType): The key to append to.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: The length of the string after appending.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in seconds.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determines the type of value stored at a key.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the length of a list.\n\n        Args:\n            name (str): The key of the list.\n\n        Returns:\n            RedisIntegerResponseType: The number of items in the list.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the first element(s) of a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the start of a list.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Gets a range of elements from a list.\n\n        Args:\n            name (str): The key of the list.\n            start (int): The starting index (inclusive).\n            end (int): The ending index (inclusive).\n\n        Returns:\n            RedisListResponseType: A list of elements in the specified range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes occurrences of a value from a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int): Number of occurrences to remove (0 for all).\n            value (str): The value to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of elements removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Sets the value of an element in a list by index.\n\n        Args:\n            name (str): The key of the list.\n            index (int): The index to set.\n            value (str): The new value.\n\n        Returns:\n            bool: True if successful.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the last element(s) of a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the end of a list.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over keys in the database incrementally.\n\n        Args:\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over keys in the database.\n\n        Args:\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Iterator: An iterator yielding keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over members of a set incrementally.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over members of a set.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            Iterator: An iterator yielding set members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Adds one or more members to a set.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of members in a set.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisIntegerResponseType: The cardinality (size) of the set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a value is a member of a set.\n\n        Args:\n            name (str): The key of the set.\n            value (str): The value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Gets all members of a set.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisSetResponseType: A set of all members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Removes and returns one or more random members from a set.\n\n        Args:\n            name (str): The key of the set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes one or more members from a set.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Gets the union of multiple sets.\n\n        Args:\n            keys (RedisKeyType): Name of the first key.\n            *args (bytes | str): Additional key names.\n\n        Returns:\n            RedisSetResponseType: A set containing members of the resulting union.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Adds members with scores to a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n            nx (bool): If True, only add new elements. Defaults to False.\n            xx (bool): If True, only update existing elements. Defaults to False.\n            ch (bool): If True, return the number of changed elements. Defaults to False.\n            incr (bool): If True, increment scores instead of setting. Defaults to False.\n            gt (bool): If True, only update if new score is greater. Defaults to False.\n            lt (bool): If True, only update if new score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: The number of elements added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the number of members in a sorted set.\n\n        Args:\n            name (bytes | str): The key of the sorted set.\n\n        Returns:\n            RedisResponseType: The cardinality (size) of the sorted set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Counts members in a sorted set within a score range.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n\n        Returns:\n            RedisResponseType: The number of members within the score range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the highest scores from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the lowest scores from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index or score (depending on byscore).\n            end (int): The ending index or score (depending on byscore).\n            desc (bool): If True, sort in descending order. Defaults to False.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): If True, range by score instead of rank. Defaults to False.\n            bylex (bool): If True, range by lexicographical order. Defaults to False.\n            offset (int, optional): Offset for byscore or bylex.\n            num (int, optional): Number of elements for byscore or bylex.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set in reverse order.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index.\n            end (int): The ending index.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets members from a sorted set by score range.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n            start (int, optional): Starting offset.\n            num (int, optional): Number of elements to return.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the rank of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to find.\n\n        Returns:\n            RedisResponseType: The rank (index) of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Removes one or more members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to check.\n\n        Returns:\n            RedisResponseType: The score of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Deletes one or more fields from a hash.\n\n        Args:\n            name (str): The key of the hash.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a field exists in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Gets the value of a field in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Gets all fields and values in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Sets one or more fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str | bytes, optional): A single field to set.\n            value (str | bytes, optional): The value for the single field.\n            mapping (dict, optional): A dictionary of field/value pairs.\n            items (list, optional): A list of field/value pairs.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Gets the values of multiple fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            keys (list): A list of fields to get.\n            *args (str | bytes): Additional fields to get.\n\n        Returns:\n            RedisListResponseType: A list of values for the specified fields.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all values in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of values in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publishes a message to a channel.\n\n        Args:\n            channel (RedisKeyType): The channel to publish to.\n            message (bytes | str): The message to publish.\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: The number of subscribers that received the message.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Lists active channels matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of active channels.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increments the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            amount (float): The amount to increment by.\n            value (bytes | str | float): The member to increment.\n\n        Returns:\n            RedisResponseType: The new score of the member.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Returns a pub/sub object for subscribing to channels.\n\n        Args:\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Any: A pub/sub object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        \"\"\"Returns a pipeline object for batching commands.\n\n        Args:\n            transaction (Any): If True, execute commands in a transaction. Defaults to True.\n            shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n        Returns:\n            Any: A pipeline object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.ping","title":"<code>archipy.adapters.redis.ports.RedisPort.ping()</code>  <code>abstractmethod</code>","text":"<p>Tests the connection to the Redis server.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The response from the server, typically \"PONG\".</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef ping(self) -&gt; RedisResponseType:\n    \"\"\"Tests the connection to the Redis server.\n\n    Returns:\n        RedisResponseType: The response from the server, typically \"PONG\".\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pttl","title":"<code>archipy.adapters.redis.ports.RedisPort.pttl(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the remaining time to live of a key in milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in milliseconds.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.incrby","title":"<code>archipy.adapters.redis.ports.RedisPort.incrby(name, amount=1)</code>  <code>abstractmethod</code>","text":"<p>Increments the integer value of a key by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to increment.</p> required <code>amount</code> <code>int</code> <p>The amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after incrementing.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increments the integer value of a key by the given amount.\n\n    Args:\n        name (RedisKeyType): The key to increment.\n        amount (int): The amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after incrementing.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.set","title":"<code>archipy.adapters.redis.ports.RedisPort.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>abstractmethod</code>","text":"<p>Sets a key to a value with optional expiration and conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set for the key.</p> required <code>ex</code> <code>RedisExpiryType</code> <p>Expiration time in seconds or timedelta.</p> <code>None</code> <code>px</code> <code>RedisExpiryType</code> <p>Expiration time in milliseconds or timedelta.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>If True, set only if the key does not exist. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, set only if the key already exists. Defaults to False.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>If True, retain the existing TTL. Defaults to False.</p> <code>False</code> <code>get</code> <code>bool</code> <p>If True, return the old value before setting. Defaults to False.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time as Unix timestamp or datetime.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time in milliseconds or datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The result of the operation, often \"OK\" or the old value if get=True.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value with optional expiration and conditions.\n\n    Args:\n        name (RedisKeyType): The key to set.\n        value (RedisSetType): The value to set for the key.\n        ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n        px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n        nx (bool): If True, set only if the key does not exist. Defaults to False.\n        xx (bool): If True, set only if the key already exists. Defaults to False.\n        keepttl (bool): If True, retain the existing TTL. Defaults to False.\n        get (bool): If True, return the old value before setting. Defaults to False.\n        exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n        pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n    Returns:\n        RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.get","title":"<code>archipy.adapters.redis.ports.RedisPort.get(key)</code>  <code>abstractmethod</code>","text":"<p>Retrieves the value of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value associated with the key, or None if the key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Retrieves the value of a key.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.mget","title":"<code>archipy.adapters.redis.ports.RedisPort.mget(keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the values of multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>A single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of values corresponding to the keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Gets the values of multiple keys.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: A list of values corresponding to the keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.mset","title":"<code>archipy.adapters.redis.ports.RedisPort.mset(mapping)</code>  <code>abstractmethod</code>","text":"<p>Sets multiple keys to their respective values.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of keys to values.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Typically \"OK\" on success.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Sets multiple keys to their respective values.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n    Returns:\n        RedisResponseType: Typically \"OK\" on success.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.keys","title":"<code>archipy.adapters.redis.ports.RedisPort.keys(pattern='*', **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns all keys matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of matching keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Returns all keys matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of matching keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.getset","title":"<code>archipy.adapters.redis.ports.RedisPort.getset(key, value)</code>  <code>abstractmethod</code>","text":"<p>Sets a key to a value and returns its old value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value to set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The old value of the key, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value and returns its old value.\n\n    Args:\n        key (RedisKeyType): The key to set.\n        value (bytes | str | float): The new value to set.\n\n    Returns:\n        RedisResponseType: The old value of the key, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.getdel","title":"<code>archipy.adapters.redis.ports.RedisPort.getdel(key)</code>  <code>abstractmethod</code>","text":"<p>Gets the value of a key and deletes it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to get and delete.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key before deletion, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the value of a key and deletes it.\n\n    Args:\n        key (bytes | str): The key to get and delete.\n\n    Returns:\n        RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.exists","title":"<code>archipy.adapters.redis.ports.RedisPort.exists(*names)</code>  <code>abstractmethod</code>","text":"<p>Checks if one or more keys exist.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to check.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys that exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Checks if one or more keys exist.\n\n    Args:\n        *names (bytes | str): Variable number of keys to check.\n\n    Returns:\n        RedisResponseType: The number of keys that exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.delete","title":"<code>archipy.adapters.redis.ports.RedisPort.delete(*names)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more keys.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Deletes one or more keys.\n\n    Args:\n        *names (bytes | str): Variable number of keys to delete.\n\n    Returns:\n        RedisResponseType: The number of keys deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.append","title":"<code>archipy.adapters.redis.ports.RedisPort.append(key, value)</code>  <code>abstractmethod</code>","text":"<p>Appends a value to a key's string value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to append to.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The length of the string after appending.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Appends a value to a key's string value.\n\n    Args:\n        key (RedisKeyType): The key to append to.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: The length of the string after appending.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.ttl","title":"<code>archipy.adapters.redis.ports.RedisPort.ttl(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the remaining time to live of a key in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in seconds.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.type","title":"<code>archipy.adapters.redis.ports.RedisPort.type(name)</code>  <code>abstractmethod</code>","text":"<p>Determines the type of value stored at a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The type of the key's value (e.g., \"string\", \"list\", etc.).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determines the type of value stored at a key.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.llen","title":"<code>archipy.adapters.redis.ports.RedisPort.llen(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the length of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of items in the list.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the length of a list.\n\n    Args:\n        name (str): The key of the list.\n\n    Returns:\n        RedisIntegerResponseType: The number of items in the list.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lpop","title":"<code>archipy.adapters.redis.ports.RedisPort.lpop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns the first element(s) of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the first element(s) of a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lpush","title":"<code>archipy.adapters.redis.ports.RedisPort.lpush(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Pushes one or more values to the start of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the start of a list.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lrange","title":"<code>archipy.adapters.redis.ports.RedisPort.lrange(name, start, end)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting index (inclusive).</p> required <code>end</code> <code>int</code> <p>The ending index (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of elements in the specified range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Gets a range of elements from a list.\n\n    Args:\n        name (str): The key of the list.\n        start (int): The starting index (inclusive).\n        end (int): The ending index (inclusive).\n\n    Returns:\n        RedisListResponseType: A list of elements in the specified range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lrem","title":"<code>archipy.adapters.redis.ports.RedisPort.lrem(name, count, value)</code>  <code>abstractmethod</code>","text":"<p>Removes occurrences of a value from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove (0 for all).</p> required <code>value</code> <code>str</code> <p>The value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of elements removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes occurrences of a value from a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int): Number of occurrences to remove (0 for all).\n        value (str): The value to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of elements removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lset","title":"<code>archipy.adapters.redis.ports.RedisPort.lset(name, index, value)</code>  <code>abstractmethod</code>","text":"<p>Sets the value of an element in a list by index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index to set.</p> required <code>value</code> <code>str</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Sets the value of an element in a list by index.\n\n    Args:\n        name (str): The key of the list.\n        index (int): The index to set.\n        value (str): The new value.\n\n    Returns:\n        bool: True if successful.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.rpop","title":"<code>archipy.adapters.redis.ports.RedisPort.rpop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns the last element(s) of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the last element(s) of a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.rpush","title":"<code>archipy.adapters.redis.ports.RedisPort.rpush(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Pushes one or more values to the end of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the end of a list.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scan","title":"<code>archipy.adapters.redis.ports.RedisPort.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Iterates over keys in the database incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_keys).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over keys in the database incrementally.\n\n    Args:\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scan_iter","title":"<code>archipy.adapters.redis.ports.RedisPort.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Provides an iterator over keys in the database.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over keys in the database.\n\n    Args:\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Iterator: An iterator yielding keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sscan","title":"<code>archipy.adapters.redis.ports.RedisPort.sscan(name, cursor=0, match=None, count=None)</code>  <code>abstractmethod</code>","text":"<p>Iterates over members of a set incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_members).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over members of a set incrementally.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sscan_iter","title":"<code>archipy.adapters.redis.ports.RedisPort.sscan_iter(name, match=None, count=None)</code>  <code>abstractmethod</code>","text":"<p>Provides an iterator over members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding set members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over members of a set.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        Iterator: An iterator yielding set members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sadd","title":"<code>archipy.adapters.redis.ports.RedisPort.sadd(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Adds one or more members to a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members added (excluding duplicates).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Adds one or more members to a set.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scard","title":"<code>archipy.adapters.redis.ports.RedisPort.scard(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of members in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The cardinality (size) of the set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of members in a set.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisIntegerResponseType: The cardinality (size) of the set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sismember","title":"<code>archipy.adapters.redis.ports.RedisPort.sismember(name, value)</code>  <code>abstractmethod</code>","text":"<p>Checks if a value is a member of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the value is a member, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a value is a member of a set.\n\n    Args:\n        name (str): The key of the set.\n        value (str): The value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.smembers","title":"<code>archipy.adapters.redis.ports.RedisPort.smembers(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set of all members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Gets all members of a set.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisSetResponseType: A set of all members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.spop","title":"<code>archipy.adapters.redis.ports.RedisPort.spop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns one or more random members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Removes and returns one or more random members from a set.\n\n    Args:\n        name (str): The key of the set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.srem","title":"<code>archipy.adapters.redis.ports.RedisPort.srem(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Removes one or more members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes one or more members from a set.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sunion","title":"<code>archipy.adapters.redis.ports.RedisPort.sunion(keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the union of multiple sets.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>Name of the first key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set containing members of the resulting union.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Gets the union of multiple sets.\n\n    Args:\n        keys (RedisKeyType): Name of the first key.\n        *args (bytes | str): Additional key names.\n\n    Returns:\n        RedisSetResponseType: A set containing members of the resulting union.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zadd","title":"<code>archipy.adapters.redis.ports.RedisPort.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>abstractmethod</code>","text":"<p>Adds members with scores to a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of members to scores.</p> required <code>nx</code> <code>bool</code> <p>If True, only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>If True, return the number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>If True, increment scores instead of setting. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>If True, only update if new score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>If True, only update if new score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of elements added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Adds members with scores to a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n        nx (bool): If True, only add new elements. Defaults to False.\n        xx (bool): If True, only update existing elements. Defaults to False.\n        ch (bool): If True, return the number of changed elements. Defaults to False.\n        incr (bool): If True, increment scores instead of setting. Defaults to False.\n        gt (bool): If True, only update if new score is greater. Defaults to False.\n        lt (bool): If True, only update if new score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: The number of elements added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zcard","title":"<code>archipy.adapters.redis.ports.RedisPort.zcard(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of members in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The cardinality (size) of the sorted set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the number of members in a sorted set.\n\n    Args:\n        name (bytes | str): The key of the sorted set.\n\n    Returns:\n        RedisResponseType: The cardinality (size) of the sorted set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zcount","title":"<code>archipy.adapters.redis.ports.RedisPort.zcount(name, min, max)</code>  <code>abstractmethod</code>","text":"<p>Counts members in a sorted set within a score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members within the score range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Counts members in a sorted set within a score range.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n\n    Returns:\n        RedisResponseType: The number of members within the score range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zpopmax","title":"<code>archipy.adapters.redis.ports.RedisPort.zpopmax(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns members with the highest scores from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the highest scores from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zpopmin","title":"<code>archipy.adapters.redis.ports.RedisPort.zpopmin(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns members with the lowest scores from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the lowest scores from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrange","title":"<code>archipy.adapters.redis.ports.RedisPort.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index or score (depending on byscore).</p> required <code>end</code> <code>int</code> <p>The ending index or score (depending on byscore).</p> required <code>desc</code> <code>bool</code> <p>If True, sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>If True, range by score instead of rank. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>If True, range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int</code> <p>Offset for byscore or bylex.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements for byscore or bylex.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index or score (depending on byscore).\n        end (int): The ending index or score (depending on byscore).\n        desc (bool): If True, sort in descending order. Defaults to False.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): If True, range by score instead of rank. Defaults to False.\n        bylex (bool): If True, range by lexicographical order. Defaults to False.\n        offset (int, optional): Offset for byscore or bylex.\n        num (int, optional): Number of elements for byscore or bylex.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrevrange","title":"<code>archipy.adapters.redis.ports.RedisPort.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of members from a sorted set in reverse order.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set in reverse order.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index.\n        end (int): The ending index.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrangebyscore","title":"<code>archipy.adapters.redis.ports.RedisPort.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code>","text":"<p>Gets members from a sorted set by score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <code>start</code> <code>int</code> <p>Starting offset.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements to return.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets members from a sorted set by score range.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n        start (int, optional): Starting offset.\n        num (int, optional): Number of elements to return.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrank","title":"<code>archipy.adapters.redis.ports.RedisPort.zrank(name, value)</code>  <code>abstractmethod</code>","text":"<p>Gets the rank of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to find.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The rank (index) of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the rank of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to find.\n\n    Returns:\n        RedisResponseType: The rank (index) of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrem","title":"<code>archipy.adapters.redis.ports.RedisPort.zrem(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Removes one or more members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Removes one or more members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zscore","title":"<code>archipy.adapters.redis.ports.RedisPort.zscore(name, value)</code>  <code>abstractmethod</code>","text":"<p>Gets the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The score of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to check.\n\n    Returns:\n        RedisResponseType: The score of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hdel","title":"<code>archipy.adapters.redis.ports.RedisPort.hdel(name, *keys)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more fields from a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Deletes one or more fields from a hash.\n\n    Args:\n        name (str): The key of the hash.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hexists","title":"<code>archipy.adapters.redis.ports.RedisPort.hexists(name, key)</code>  <code>abstractmethod</code>","text":"<p>Checks if a field exists in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the field exists, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a field exists in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hget","title":"<code>archipy.adapters.redis.ports.RedisPort.hget(name, key)</code>  <code>abstractmethod</code>","text":"<p>Gets the value of a field in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: The value of the field, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Gets the value of a field in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hgetall","title":"<code>archipy.adapters.redis.ports.RedisPort.hgetall(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all fields and values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: A dictionary of field/value pairs.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Gets all fields and values in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hkeys","title":"<code>archipy.adapters.redis.ports.RedisPort.hkeys(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hlen","title":"<code>archipy.adapters.redis.ports.RedisPort.hlen(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hset","title":"<code>archipy.adapters.redis.ports.RedisPort.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>abstractmethod</code>","text":"<p>Sets one or more fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str | bytes</code> <p>A single field to set.</p> <code>None</code> <code>value</code> <code>str | bytes</code> <p>The value for the single field.</p> <code>None</code> <code>mapping</code> <code>dict</code> <p>A dictionary of field/value pairs.</p> <code>None</code> <code>items</code> <code>list</code> <p>A list of field/value pairs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Sets one or more fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str | bytes, optional): A single field to set.\n        value (str | bytes, optional): The value for the single field.\n        mapping (dict, optional): A dictionary of field/value pairs.\n        items (list, optional): A list of field/value pairs.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hmget","title":"<code>archipy.adapters.redis.ports.RedisPort.hmget(name, keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the values of multiple fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>keys</code> <code>list</code> <p>A list of fields to get.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional fields to get.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values for the specified fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Gets the values of multiple fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        keys (list): A list of fields to get.\n        *args (str | bytes): Additional fields to get.\n\n    Returns:\n        RedisListResponseType: A list of values for the specified fields.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hvals","title":"<code>archipy.adapters.redis.ports.RedisPort.hvals(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all values in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of values in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.publish","title":"<code>archipy.adapters.redis.ports.RedisPort.publish(channel, message, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Publishes a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>The channel to publish to.</p> required <code>message</code> <code>bytes | str</code> <p>The message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of subscribers that received the message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publishes a message to a channel.\n\n    Args:\n        channel (RedisKeyType): The channel to publish to.\n        message (bytes | str): The message to publish.\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: The number of subscribers that received the message.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pubsub_channels","title":"<code>archipy.adapters.redis.ports.RedisPort.pubsub_channels(pattern='*', **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Lists active channels matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of active channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Lists active channels matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of active channels.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zincrby","title":"<code>archipy.adapters.redis.ports.RedisPort.zincrby(name, amount, value)</code>  <code>abstractmethod</code>","text":"<p>Increments the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>amount</code> <code>float</code> <p>The amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new score of the member.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increments the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        amount (float): The amount to increment by.\n        value (bytes | str | float): The member to increment.\n\n    Returns:\n        RedisResponseType: The new score of the member.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pubsub","title":"<code>archipy.adapters.redis.ports.RedisPort.pubsub(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns a pub/sub object for subscribing to channels.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pub/sub object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pubsub(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns a pub/sub object for subscribing to channels.\n\n    Args:\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Any: A pub/sub object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.get_pipeline","title":"<code>archipy.adapters.redis.ports.RedisPort.get_pipeline(transaction=True, shard_hint=None)</code>  <code>abstractmethod</code>","text":"<p>Returns a pipeline object for batching commands.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>If True, execute commands in a transaction. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding in clustered Redis.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pipeline object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n    \"\"\"Returns a pipeline object for batching commands.\n\n    Args:\n        transaction (Any): If True, execute commands in a transaction. Defaults to True.\n        shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n    Returns:\n        Any: A pipeline object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort</code>","text":"<p>Interface for asynchronous Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for asynchronous Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping an asynchronous Redis client library.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class AsyncRedisPort:\n    \"\"\"Interface for asynchronous Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for asynchronous Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping an asynchronous Redis client library.\n    \"\"\"\n\n    @abstractmethod\n    async def ping(self) -&gt; RedisResponseType:\n        \"\"\"Tests the connection to the Redis server asynchronously.\n\n        Returns:\n            RedisResponseType: The response from the server, typically \"PONG\".\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in milliseconds asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increments the integer value of a key by the given amount asynchronously.\n\n        Args:\n            name (RedisKeyType): The key to increment.\n            amount (int): The amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after incrementing.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value with optional expiration and conditions asynchronously.\n\n        Args:\n            name (RedisKeyType): The key to set.\n            value (RedisSetType): The value to set for the key.\n            ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n            px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n            nx (bool): If True, set only if the key does not exist. Defaults to False.\n            xx (bool): If True, set only if the key already exists. Defaults to False.\n            keepttl (bool): If True, retain the existing TTL. Defaults to False.\n            get (bool): If True, return the old value before setting. Defaults to False.\n            exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n            pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n        Returns:\n            RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Retrieves the value of a key asynchronously.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets the values of multiple keys asynchronously.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: A list of values corresponding to the keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Sets multiple keys to their respective values asynchronously.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n        Returns:\n            RedisResponseType: Typically \"OK\" on success.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Returns all keys matching a pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of matching keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value and returns its old value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key to set.\n            value (bytes | str | float): The new value to set.\n\n        Returns:\n            RedisResponseType: The old value of the key, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the value of a key and deletes it asynchronously.\n\n        Args:\n            key (bytes | str): The key to get and delete.\n\n        Returns:\n            RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Checks if one or more keys exist asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of keys to check.\n\n        Returns:\n            RedisResponseType: The number of keys that exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Deletes one or more keys asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of keys to delete.\n\n        Returns:\n            RedisResponseType: The number of keys deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Appends a value to a key's string value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key to append to.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: The length of the string after appending.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in seconds asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determines the type of value stored at a key asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the length of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n\n        Returns:\n            RedisIntegerResponseType: The number of items in the list.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the first element(s) of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the start of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Gets a range of elements from a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            start (int): The starting index (inclusive).\n            end (int): The ending index (inclusive).\n\n        Returns:\n            RedisListResponseType: A list of elements in the specified range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes occurrences of a value from a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int): Number of occurrences to remove (0 for all).\n            value (str): The value to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of elements removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Sets the value of an element in a list by index asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            index (int): The index to set.\n            value (str): The new value.\n\n        Returns:\n            bool: True if successful.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the last element(s) of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the end of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over keys in the database incrementally asynchronously.\n\n        Args:\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over keys in the database asynchronously.\n\n        Args:\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Iterator: An iterator yielding keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over members of a set incrementally asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over members of a set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            Iterator: An iterator yielding set members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Adds one or more members to a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of members in a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisIntegerResponseType: The cardinality (size) of the set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a value is a member of a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            value (str): The value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Gets all members of a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisSetResponseType: A set of all members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Removes and returns one or more random members from a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes one or more members from a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Gets the union of multiple sets asynchronously.\n\n        Args:\n            keys (RedisKeyType): Name of the first key.\n            *args (bytes | str): Additional key names.\n\n        Returns:\n            RedisSetResponseType: A set containing members of the resulting union.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Adds members with scores to a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n            nx (bool): If True, only add new elements. Defaults to False.\n            xx (bool): If True, only update existing elements. Defaults to False.\n            ch (bool): If True, return the number of changed elements. Defaults to False.\n            incr (bool): If True, increment scores instead of setting. Defaults to False.\n            gt (bool): If True, only update if new score is greater. Defaults to False.\n            lt (bool): If True, only update if new score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: The number of elements added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the number of members in a sorted set asynchronously.\n\n        Args:\n            name (bytes | str): The key of the sorted set.\n\n        Returns:\n            RedisResponseType: The cardinality (size) of the sorted set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Counts members in a sorted set within a score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n\n        Returns:\n            RedisResponseType: The number of members within the score range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the highest scores from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the lowest scores from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index or score (depending on byscore).\n            end (int): The ending index or score (depending on byscore).\n            desc (bool): If True, sort in descending order. Defaults to False.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): If True, range by score instead of rank. Defaults to False.\n            bylex (bool): If True, range by lexicographical order. Defaults to False.\n            offset (int, optional): Offset for byscore or bylex.\n            num (int, optional): Number of elements for byscore or bylex.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set in reverse order asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index.\n            end (int): The ending index.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets members from a sorted set by score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n            start (int, optional): Starting offset.\n            num (int, optional): Number of elements to return.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the rank of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to find.\n\n        Returns:\n            RedisResponseType: The rank (index) of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Removes one or more members from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the score of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to check.\n\n        Returns:\n            RedisResponseType: The score of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Deletes one or more fields from a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a field exists in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Gets the value of a field in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Gets all fields and values in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Sets one or more fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str | bytes, optional): A single field to set.\n            value (str | bytes, optional): The value for the single field.\n            mapping (dict, optional): A dictionary of field/value pairs.\n            items (list, optional): A list of field/value pairs.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Gets the values of multiple fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            keys (list): A list of fields to get.\n            *args (str | bytes): Additional fields to get.\n\n        Returns:\n            RedisListResponseType: A list of values for the specified fields.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all values in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of values in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publishes a message to a channel asynchronously.\n\n        Args:\n            channel (RedisKeyType): The channel to publish to.\n            message (bytes | str): The message to publish.\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: The number of subscribers that received the message.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Lists active channels matching a pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of active channels.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increments the score of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            amount (float): The amount to increment by.\n            value (bytes | str | float): The member to increment.\n\n        Returns:\n            RedisResponseType: The new score of the member.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pubsub(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Returns a pub/sub object for subscribing to channels asynchronously.\n\n        Args:\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Any: A pub/sub object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        \"\"\"Returns a pipeline object for batching commands asynchronously.\n\n        Args:\n            transaction (Any): If True, execute commands in a transaction. Defaults to True.\n            shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n        Returns:\n            Any: A pipeline object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.ping","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.ping()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Tests the connection to the Redis server asynchronously.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The response from the server, typically \"PONG\".</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def ping(self) -&gt; RedisResponseType:\n    \"\"\"Tests the connection to the Redis server asynchronously.\n\n    Returns:\n        RedisResponseType: The response from the server, typically \"PONG\".\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pttl","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pttl(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the remaining time to live of a key in milliseconds asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in milliseconds asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.incrby","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.incrby(name, amount=1)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Increments the integer value of a key by the given amount asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to increment.</p> required <code>amount</code> <code>int</code> <p>The amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after incrementing.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increments the integer value of a key by the given amount asynchronously.\n\n    Args:\n        name (RedisKeyType): The key to increment.\n        amount (int): The amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after incrementing.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.set","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets a key to a value with optional expiration and conditions asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set for the key.</p> required <code>ex</code> <code>RedisExpiryType</code> <p>Expiration time in seconds or timedelta.</p> <code>None</code> <code>px</code> <code>RedisExpiryType</code> <p>Expiration time in milliseconds or timedelta.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>If True, set only if the key does not exist. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, set only if the key already exists. Defaults to False.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>If True, retain the existing TTL. Defaults to False.</p> <code>False</code> <code>get</code> <code>bool</code> <p>If True, return the old value before setting. Defaults to False.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time as Unix timestamp or datetime.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time in milliseconds or datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The result of the operation, often \"OK\" or the old value if get=True.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value with optional expiration and conditions asynchronously.\n\n    Args:\n        name (RedisKeyType): The key to set.\n        value (RedisSetType): The value to set for the key.\n        ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n        px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n        nx (bool): If True, set only if the key does not exist. Defaults to False.\n        xx (bool): If True, set only if the key already exists. Defaults to False.\n        keepttl (bool): If True, retain the existing TTL. Defaults to False.\n        get (bool): If True, return the old value before setting. Defaults to False.\n        exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n        pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n    Returns:\n        RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.get","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.get(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves the value of a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value associated with the key, or None if the key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Retrieves the value of a key asynchronously.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.mget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.mget(keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the values of multiple keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>A single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of values corresponding to the keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Gets the values of multiple keys asynchronously.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: A list of values corresponding to the keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.mset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.mset(mapping)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets multiple keys to their respective values asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of keys to values.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Typically \"OK\" on success.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Sets multiple keys to their respective values asynchronously.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n    Returns:\n        RedisResponseType: Typically \"OK\" on success.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.keys","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.keys(pattern='*', **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns all keys matching a pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of matching keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Returns all keys matching a pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of matching keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.getset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.getset(key, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets a key to a value and returns its old value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value to set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The old value of the key, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value and returns its old value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key to set.\n        value (bytes | str | float): The new value to set.\n\n    Returns:\n        RedisResponseType: The old value of the key, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.getdel","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.getdel(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the value of a key and deletes it asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to get and delete.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key before deletion, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the value of a key and deletes it asynchronously.\n\n    Args:\n        key (bytes | str): The key to get and delete.\n\n    Returns:\n        RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.exists","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.exists(*names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if one or more keys exist asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to check.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys that exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Checks if one or more keys exist asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of keys to check.\n\n    Returns:\n        RedisResponseType: The number of keys that exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.delete","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.delete(*names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes one or more keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Deletes one or more keys asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of keys to delete.\n\n    Returns:\n        RedisResponseType: The number of keys deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.append","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.append(key, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Appends a value to a key's string value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to append to.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The length of the string after appending.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Appends a value to a key's string value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key to append to.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: The length of the string after appending.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.ttl","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.ttl(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the remaining time to live of a key in seconds asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in seconds asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.type","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.type(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Determines the type of value stored at a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The type of the key's value (e.g., \"string\", \"list\", etc.).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determines the type of value stored at a key asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.llen","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.llen(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the length of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of items in the list.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the length of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n\n    Returns:\n        RedisIntegerResponseType: The number of items in the list.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lpop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lpop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns the first element(s) of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the first element(s) of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lpush","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lpush(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Pushes one or more values to the start of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the start of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lrange(name, start, end)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting index (inclusive).</p> required <code>end</code> <code>int</code> <p>The ending index (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of elements in the specified range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Gets a range of elements from a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        start (int): The starting index (inclusive).\n        end (int): The ending index (inclusive).\n\n    Returns:\n        RedisListResponseType: A list of elements in the specified range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lrem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lrem(name, count, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes occurrences of a value from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove (0 for all).</p> required <code>value</code> <code>str</code> <p>The value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of elements removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes occurrences of a value from a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int): Number of occurrences to remove (0 for all).\n        value (str): The value to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of elements removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lset(name, index, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets the value of an element in a list by index asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index to set.</p> required <code>value</code> <code>str</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Sets the value of an element in a list by index asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        index (int): The index to set.\n        value (str): The new value.\n\n    Returns:\n        bool: True if successful.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.rpop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.rpop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns the last element(s) of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the last element(s) of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.rpush","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.rpush(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Pushes one or more values to the end of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the end of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scan","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Iterates over keys in the database incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_keys).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over keys in the database incrementally asynchronously.\n\n    Args:\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scan_iter","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Provides an iterator over keys in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over keys in the database asynchronously.\n\n    Args:\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Iterator: An iterator yielding keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sscan","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sscan(name, cursor=0, match=None, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Iterates over members of a set incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_members).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over members of a set incrementally asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sscan_iter","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sscan_iter(name, match=None, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Provides an iterator over members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding set members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over members of a set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        Iterator: An iterator yielding set members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sadd","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sadd(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds one or more members to a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members added (excluding duplicates).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Adds one or more members to a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scard","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scard(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of members in a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The cardinality (size) of the set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of members in a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisIntegerResponseType: The cardinality (size) of the set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sismember","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sismember(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if a value is a member of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the value is a member, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a value is a member of a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        value (str): The value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.smembers","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.smembers(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set of all members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Gets all members of a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisSetResponseType: A set of all members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.spop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.spop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns one or more random members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Removes and returns one or more random members from a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.srem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.srem(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes one or more members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes one or more members from a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sunion","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sunion(keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the union of multiple sets asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>Name of the first key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set containing members of the resulting union.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Gets the union of multiple sets asynchronously.\n\n    Args:\n        keys (RedisKeyType): Name of the first key.\n        *args (bytes | str): Additional key names.\n\n    Returns:\n        RedisSetResponseType: A set containing members of the resulting union.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zadd","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds members with scores to a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of members to scores.</p> required <code>nx</code> <code>bool</code> <p>If True, only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>If True, return the number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>If True, increment scores instead of setting. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>If True, only update if new score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>If True, only update if new score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of elements added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Adds members with scores to a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n        nx (bool): If True, only add new elements. Defaults to False.\n        xx (bool): If True, only update existing elements. Defaults to False.\n        ch (bool): If True, return the number of changed elements. Defaults to False.\n        incr (bool): If True, increment scores instead of setting. Defaults to False.\n        gt (bool): If True, only update if new score is greater. Defaults to False.\n        lt (bool): If True, only update if new score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: The number of elements added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zcard","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zcard(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of members in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The cardinality (size) of the sorted set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the number of members in a sorted set asynchronously.\n\n    Args:\n        name (bytes | str): The key of the sorted set.\n\n    Returns:\n        RedisResponseType: The cardinality (size) of the sorted set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zcount","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zcount(name, min, max)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Counts members in a sorted set within a score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members within the score range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Counts members in a sorted set within a score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n\n    Returns:\n        RedisResponseType: The number of members within the score range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zpopmax","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zpopmax(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns members with the highest scores from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the highest scores from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zpopmin","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zpopmin(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns members with the lowest scores from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the lowest scores from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of members from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index or score (depending on byscore).</p> required <code>end</code> <code>int</code> <p>The ending index or score (depending on byscore).</p> required <code>desc</code> <code>bool</code> <p>If True, sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>If True, range by score instead of rank. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>If True, range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int</code> <p>Offset for byscore or bylex.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements for byscore or bylex.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index or score (depending on byscore).\n        end (int): The ending index or score (depending on byscore).\n        desc (bool): If True, sort in descending order. Defaults to False.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): If True, range by score instead of rank. Defaults to False.\n        bylex (bool): If True, range by lexicographical order. Defaults to False.\n        offset (int, optional): Offset for byscore or bylex.\n        num (int, optional): Number of elements for byscore or bylex.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrevrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of members from a sorted set in reverse order asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set in reverse order asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index.\n        end (int): The ending index.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrangebyscore","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets members from a sorted set by score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <code>start</code> <code>int</code> <p>Starting offset.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements to return.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets members from a sorted set by score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n        start (int, optional): Starting offset.\n        num (int, optional): Number of elements to return.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrank","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrank(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the rank of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to find.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The rank (index) of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the rank of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to find.\n\n    Returns:\n        RedisResponseType: The rank (index) of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrem(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes one or more members from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Removes one or more members from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zscore","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zscore(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the score of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The score of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the score of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to check.\n\n    Returns:\n        RedisResponseType: The score of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hdel","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hdel(name, *keys)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes one or more fields from a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Deletes one or more fields from a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hexists","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hexists(name, key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if a field exists in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the field exists, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a field exists in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hget(name, key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the value of a field in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: The value of the field, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Gets the value of a field in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hgetall","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hgetall(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all fields and values in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: A dictionary of field/value pairs.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Gets all fields and values in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hkeys","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hkeys(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hlen","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hlen(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets one or more fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str | bytes</code> <p>A single field to set.</p> <code>None</code> <code>value</code> <code>str | bytes</code> <p>The value for the single field.</p> <code>None</code> <code>mapping</code> <code>dict</code> <p>A dictionary of field/value pairs.</p> <code>None</code> <code>items</code> <code>list</code> <p>A list of field/value pairs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Sets one or more fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str | bytes, optional): A single field to set.\n        value (str | bytes, optional): The value for the single field.\n        mapping (dict, optional): A dictionary of field/value pairs.\n        items (list, optional): A list of field/value pairs.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hmget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hmget(name, keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the values of multiple fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>keys</code> <code>list</code> <p>A list of fields to get.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional fields to get.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values for the specified fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Gets the values of multiple fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        keys (list): A list of fields to get.\n        *args (str | bytes): Additional fields to get.\n\n    Returns:\n        RedisListResponseType: A list of values for the specified fields.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hvals","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hvals(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all values in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all values in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of values in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.publish","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.publish(channel, message, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Publishes a message to a channel asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>The channel to publish to.</p> required <code>message</code> <code>bytes | str</code> <p>The message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of subscribers that received the message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publishes a message to a channel asynchronously.\n\n    Args:\n        channel (RedisKeyType): The channel to publish to.\n        message (bytes | str): The message to publish.\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: The number of subscribers that received the message.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pubsub_channels","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pubsub_channels(pattern='*', **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Lists active channels matching a pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of active channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Lists active channels matching a pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of active channels.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zincrby","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zincrby(name, amount, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Increments the score of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>amount</code> <code>float</code> <p>The amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new score of the member.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increments the score of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        amount (float): The amount to increment by.\n        value (bytes | str | float): The member to increment.\n\n    Returns:\n        RedisResponseType: The new score of the member.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pubsub","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pubsub(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns a pub/sub object for subscribing to channels asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pub/sub object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pubsub(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns a pub/sub object for subscribing to channels asynchronously.\n\n    Args:\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Any: A pub/sub object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.get_pipeline","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.get_pipeline(transaction=True, shard_hint=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns a pipeline object for batching commands asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>If True, execute commands in a transaction. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding in clustered Redis.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pipeline object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n    \"\"\"Returns a pipeline object for batching commands asynchronously.\n\n    Args:\n        transaction (Any): If True, execute commands in a transaction. Defaults to True.\n        shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n    Returns:\n        Any: A pipeline object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#kafka","title":"Kafka","text":"<p>Kafka integration for message streaming and event-driven architectures.</p> <pre><code>from archipy.adapters.kafka import KafkaAdapter\n\n# Create a Kafka adapter\nkafka = KafkaAdapter()  # Uses global config by default\n\n# Publish a message\nkafka.publish(\"my-topic\", \"Hello, Kafka!\")\n\n# Consume messages\ndef process_message(message: dict[str, Any]) -&gt; None:\n    print(f\"Received: {message['value']}\")\n\nkafka.consume(\"my-topic\", process_message)\n</code></pre> <p>For detailed examples and usage guidelines, see the Kafka Adapter Examples.</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaExceptionHandlerMixin","title":"<code>archipy.adapters.kafka.adapters.KafkaExceptionHandlerMixin</code>","text":"<p>Mixin class to handle Kafka exceptions in a consistent way.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaExceptionHandlerMixin:\n    \"\"\"Mixin class to handle Kafka exceptions in a consistent way.\"\"\"\n\n    @classmethod\n    def _handle_kafka_exception(cls, exception: Exception, operation: str) -&gt; None:\n        \"\"\"Handle Kafka exceptions and map them to appropriate application errors.\n\n        Args:\n            exception: The original exception\n            operation: The name of the operation that failed\n\n        Raises:\n            Various application-specific errors based on the exception type/content\n        \"\"\"\n        error_msg = str(exception).lower()\n\n        # Configuration errors\n        if \"configuration\" in error_msg:\n            raise ConfigurationError(config_key=\"kafka\") from exception\n\n        # Invalid argument errors\n        if \"invalid\" in error_msg:\n            raise InvalidArgumentError(argument_name=operation) from exception\n\n        # Timeout errors\n        if \"timeout\" in error_msg:\n            # Extract timeout value if available\n            timeout = None\n            if hasattr(exception, \"args\") and len(exception.args) &gt; 1:\n                try:\n                    timeout = int(exception.args[1])\n                except (IndexError, ValueError):\n                    pass\n            raise ConnectionTimeoutError(service=\"Kafka\", timeout=timeout) from exception\n\n        # Network/connectivity errors\n        if \"network\" in error_msg:\n            raise NetworkError(service=\"Kafka\") from exception\n\n        # Service availability errors\n        if \"unavailable\" in error_msg or \"connection\" in error_msg:\n            raise ServiceUnavailableError(service=\"Kafka\") from exception\n        raise InternalError(additional_data={\"operation\": operation}) from exception\n\n    @classmethod\n    def _handle_producer_exception(cls, exception: Exception, operation: str) -&gt; None:\n        \"\"\"Handle producer-specific exceptions.\n\n        Args:\n            exception: The original exception\n            operation: The name of the operation that failed\n\n        Raises:\n            ResourceExhaustedError: If the producer queue is full\n            Various other errors from _handle_kafka_exception\n        \"\"\"\n        # Producer-specific error handling\n        if isinstance(exception, BufferError):\n            raise ResourceExhaustedError(resource_type=\"producer_queue\") from exception\n\n        # Fall back to general Kafka error handling\n        cls._handle_kafka_exception(exception, operation)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter</code>","text":"<p>               Bases: <code>KafkaAdminPort</code>, <code>KafkaExceptionHandlerMixin</code></p> <p>Synchronous Kafka admin adapter.</p> <p>This adapter provides synchronous administrative operations for Kafka topics. It implements the KafkaAdminPort interface and handles topic creation, deletion, and listing operations.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaAdminAdapter(KafkaAdminPort, KafkaExceptionHandlerMixin):\n    \"\"\"Synchronous Kafka admin adapter.\n\n    This adapter provides synchronous administrative operations for Kafka topics.\n    It implements the KafkaAdminPort interface and handles topic creation, deletion,\n    and listing operations.\n    \"\"\"\n\n    def __init__(self, kafka_configs: KafkaConfig | None = None) -&gt; None:\n        \"\"\"Initializes the admin adapter with Kafka configuration.\n\n        Args:\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error initializing the admin client.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\"bootstrap.servers\": broker_list_csv}\n            if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n                config |= {\n                    \"sasl.username\": configs.USERNAME,\n                    \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanism\": configs.SASL_MECHANISM,\n                    \"ssl.ca.location\": configs.SSL_CA_FILE,\n                    \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                    \"ssl.key.location\": configs.SSL_KEY_FILE,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                }\n            self.adapter: AdminClient = AdminClient(config)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"KafkaAdmin_init\")\n\n    @override\n    def create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n        \"\"\"Creates a new Kafka topic.\n\n        Args:\n            topic (str): Name of the topic to create.\n            num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n            replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n        Raises:\n            InvalidArgumentError: If the topic name or partition configuration is invalid.\n            ServiceUnavailableError: If the Kafka service is unavailable during topic creation.\n            InternalError: If there is an internal error creating the topic.\n        \"\"\"\n        try:\n            new_topic = NewTopic(topic, num_partitions, replication_factor)\n            self.adapter.create_topics([new_topic])\n        except Exception as e:\n            self._handle_kafka_exception(e, \"create_topic\")\n\n    @override\n    def delete_topic(self, topics: list[str]) -&gt; None:\n        \"\"\"Deletes one or more Kafka topics.\n\n        Args:\n            topics (list[str]): List of topic names to delete.\n\n        Raises:\n            InvalidArgumentError: If the topics list is invalid.\n            ServiceUnavailableError: If the Kafka service is unavailable during topic deletion.\n            InternalError: If there is an internal error deleting the topics.\n        \"\"\"\n        try:\n            self.adapter.delete_topics(topics)\n            logger.debug(\"Deleted topics: %s\", topics)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"delete_topic\")\n\n    @override\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If the Kafka service is unavailable.\n            UnavailableError: If there is an unknown issue accessing Kafka.\n        \"\"\"\n        try:\n            result = self.adapter.list_topics(topic=topic, timeout=timeout)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"list_topics\")\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.__init__(kafka_configs=None)</code>","text":"<p>Initializes the admin adapter with Kafka configuration.</p> <p>Parameters:</p> Name Type Description Default <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If there is an error in the Kafka configuration.</p> <code>InternalError</code> <p>If there is an error initializing the admin client.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(self, kafka_configs: KafkaConfig | None = None) -&gt; None:\n    \"\"\"Initializes the admin adapter with Kafka configuration.\n\n    Args:\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        ConfigurationError: If there is an error in the Kafka configuration.\n        InternalError: If there is an error initializing the admin client.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    try:\n        broker_list_csv = \",\".join(configs.BROKERS_LIST)\n        config = {\"bootstrap.servers\": broker_list_csv}\n        if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n            config |= {\n                \"sasl.username\": configs.USERNAME,\n                \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                \"security.protocol\": configs.SECURITY_PROTOCOL,\n                \"sasl.mechanism\": configs.SASL_MECHANISM,\n                \"ssl.ca.location\": configs.SSL_CA_FILE,\n                \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                \"ssl.key.location\": configs.SSL_KEY_FILE,\n                \"ssl.endpoint.identification.algorithm\": \"none\",\n            }\n        self.adapter: AdminClient = AdminClient(config)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"KafkaAdmin_init\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.create_topic","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.create_topic(topic, num_partitions=1, replication_factor=1)</code>","text":"<p>Creates a new Kafka topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required <code>num_partitions</code> <code>int</code> <p>Number of partitions for the topic. Defaults to 1.</p> <code>1</code> <code>replication_factor</code> <code>int</code> <p>Replication factor for the topic. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the topic name or partition configuration is invalid.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable during topic creation.</p> <code>InternalError</code> <p>If there is an internal error creating the topic.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n    \"\"\"Creates a new Kafka topic.\n\n    Args:\n        topic (str): Name of the topic to create.\n        num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n        replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n    Raises:\n        InvalidArgumentError: If the topic name or partition configuration is invalid.\n        ServiceUnavailableError: If the Kafka service is unavailable during topic creation.\n        InternalError: If there is an internal error creating the topic.\n    \"\"\"\n    try:\n        new_topic = NewTopic(topic, num_partitions, replication_factor)\n        self.adapter.create_topics([new_topic])\n    except Exception as e:\n        self._handle_kafka_exception(e, \"create_topic\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.delete_topic","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.delete_topic(topics)</code>","text":"<p>Deletes one or more Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>list[str]</code> <p>List of topic names to delete.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the topics list is invalid.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable during topic deletion.</p> <code>InternalError</code> <p>If there is an internal error deleting the topics.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef delete_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Deletes one or more Kafka topics.\n\n    Args:\n        topics (list[str]): List of topic names to delete.\n\n    Raises:\n        InvalidArgumentError: If the topics list is invalid.\n        ServiceUnavailableError: If the Kafka service is unavailable during topic deletion.\n        InternalError: If there is an internal error deleting the topics.\n    \"\"\"\n    try:\n        self.adapter.delete_topics(topics)\n        logger.debug(\"Deleted topics: %s\", topics)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"delete_topic\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.list_topics","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.list_topics(topic=None, timeout=1)</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable.</p> <code>UnavailableError</code> <p>If there is an unknown issue accessing Kafka.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If the Kafka service is unavailable.\n        UnavailableError: If there is an unknown issue accessing Kafka.\n    \"\"\"\n    try:\n        result = self.adapter.list_topics(topic=topic, timeout=timeout)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"list_topics\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter</code>","text":"<p>               Bases: <code>KafkaConsumerPort</code>, <code>KafkaExceptionHandlerMixin</code></p> <p>Synchronous Kafka consumer adapter.</p> <p>This adapter provides synchronous message consumption from Kafka topics. It implements the KafkaConsumerPort interface and handles message polling, batch consumption, and offset management.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaConsumerAdapter(KafkaConsumerPort, KafkaExceptionHandlerMixin):\n    \"\"\"Synchronous Kafka consumer adapter.\n\n    This adapter provides synchronous message consumption from Kafka topics.\n    It implements the KafkaConsumerPort interface and handles message polling,\n    batch consumption, and offset management.\n    \"\"\"\n\n    def __init__(\n        self,\n        group_id: str,\n        topic_list: list[str] | None = None,\n        partition_list: list[TopicPartition] | None = None,\n        kafka_configs: KafkaConfig | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the consumer adapter with Kafka configuration and subscription.\n\n        Args:\n            group_id (str): Consumer group ID.\n            topic_list (list[str] | None, optional): List of topics to subscribe to.\n                Defaults to None.\n            partition_list (list[TopicPartition] | None, optional): List of partitions\n                to assign. Defaults to None.\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            InvalidArgumentError: If both topic_list and partition_list are provided or\n                neither is provided.\n            InternalError: If there is an error initializing the consumer.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        self._adapter: Consumer = self._get_adapter(group_id, configs)\n        if topic_list and not partition_list:\n            self.subscribe(topic_list)\n        elif not topic_list and partition_list:\n            self.assign(partition_list)\n        else:\n            logger.error(\"Invalid topic or partition list\")\n            raise InvalidArgumentError(\n                argument_name=\"topic_list or partition_list\",\n                additional_data={\"reason\": \"Exactly one of topic_list or partition_list must be provided\"},\n            )\n\n    @classmethod\n    def _get_adapter(cls, group_id: str, configs: KafkaConfig) -&gt; Consumer:\n        \"\"\"Creates and configures a Kafka Consumer instance.\n\n        Args:\n            group_id (str): Consumer group ID.\n            configs (KafkaConfig): Kafka configuration.\n\n        Returns:\n            Consumer: Configured Kafka Consumer instance.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error creating the consumer.\n        \"\"\"\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\n                \"bootstrap.servers\": broker_list_csv,\n                \"group.id\": group_id,\n                \"session.timeout.ms\": configs.SESSION_TIMEOUT_MS,\n                \"auto.offset.reset\": configs.AUTO_OFFSET_RESET,\n                \"enable.auto.commit\": configs.ENABLE_AUTO_COMMIT,\n                \"fetch.min.bytes\": configs.FETCH_MIN_BYTES,\n                \"heartbeat.interval.ms\": configs.HEARTBEAT_INTERVAL_MS,\n                \"isolation.level\": configs.ISOLATION_LEVEL,\n                \"max.poll.interval.ms\": configs.MAX_POLL_INTERVAL_MS,\n                \"partition.assignment.strategy\": configs.PARTITION_ASSIGNMENT_STRATEGY,\n                \"fetch.max.bytes\": configs.FETCH_MAX_BYTES,\n                \"max.partition.fetch.bytes\": configs.MAX_PARTITION_FETCH_BYTES,\n            }\n            if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n                config |= {\n                    \"sasl.username\": configs.USERNAME,\n                    \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanism\": configs.SASL_MECHANISM,\n                    \"ssl.ca.location\": configs.SSL_CA_FILE,\n                    \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                    \"ssl.key.location\": configs.SSL_KEY_FILE,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                }\n            consumer = Consumer(config)\n        except Exception as e:\n            cls._handle_kafka_exception(e, \"KafkaConsumer_init\")\n        else:\n            return consumer\n\n    @override\n    def batch_consume(self, messages_number: int = 500, timeout: int = 1) -&gt; list[Message]:\n        \"\"\"Consumes a batch of messages from subscribed topics.\n\n        Args:\n            messages_number (int, optional): Maximum number of messages to consume.\n                Defaults to 500.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            list[Message]: List of consumed messages.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error consuming messages.\n        \"\"\"\n        try:\n            result_list: list[Message] = []\n            messages: list[Message] = self._adapter.consume(num_messages=messages_number, timeout=timeout)\n            for message in messages:\n                if message.error():\n                    logger.error(\"Consumer error: %s\", message.error())\n                    continue\n                logger.debug(\"Message consumed: %s\", message)\n                message.set_value(message.value())\n                result_list.append(message)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"batch_consume\")\n        else:\n            return result_list\n\n    @override\n    def poll(self, timeout: int = 1) -&gt; Message | None:\n        \"\"\"Polls for a single message from subscribed topics.\n\n        Args:\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            Message | None: The consumed message or None if no message was received.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error polling for messages.\n        \"\"\"\n        try:\n            message: Message | None = self._adapter.poll(timeout)\n            if message is None:\n                logger.debug(\"No message received\")\n                return None\n            if message.error():\n                logger.error(\"Consumer error: %s\", message.error())\n                return None\n            logger.debug(\"Message consumed: %s\", message)\n            message.set_value(message.value())\n        except Exception as e:\n            self._handle_kafka_exception(e, \"poll\")\n        else:\n            return message\n\n    @override\n    def commit(self, message: Message, asynchronous: bool = True) -&gt; None | list[TopicPartition]:\n        \"\"\"Commits the offset for a message.\n\n        Args:\n            message (Message): The message to commit.\n            asynchronous (bool, optional): Whether to commit asynchronously. Defaults to True.\n\n        Returns:\n            None | list[TopicPartition]: None for async commits, list of TopicPartition for sync commits.\n\n        Raises:\n            InvalidArgumentError: If the message is invalid.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error committing the offset.\n        \"\"\"\n        try:\n            if asynchronous:\n                self._adapter.commit(message=message, asynchronous=True)\n                result = None\n            else:\n                result = self._adapter.commit(message=message, asynchronous=False)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"commit\")\n        else:\n            return result\n\n    @override\n    def subscribe(self, topic_list: list[str]) -&gt; None:\n        \"\"\"Subscribes to a list of topics.\n\n        Args:\n            topic_list (list[str]): List of topics to subscribe to.\n\n        Raises:\n            InvalidArgumentError: If the topic list is invalid.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error subscribing to topics.\n        \"\"\"\n        try:\n            self._adapter.subscribe(topic_list)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"subscribe\")\n\n    @override\n    def assign(self, partition_list: list[TopicPartition]) -&gt; None:\n        \"\"\"Assigns the consumer to a list of topic partitions.\n\n        Args:\n            partition_list (list[TopicPartition]): List of partitions to assign.\n\n        Raises:\n            InvalidArgumentError: If the partition list is invalid.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error assigning partitions.\n        \"\"\"\n        try:\n            self._adapter.assign(partition_list)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"assign\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.__init__(group_id, topic_list=None, partition_list=None, kafka_configs=None)</code>","text":"<p>Initializes the consumer adapter with Kafka configuration and subscription.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Consumer group ID.</p> required <code>topic_list</code> <code>list[str] | None</code> <p>List of topics to subscribe to. Defaults to None.</p> <code>None</code> <code>partition_list</code> <code>list[TopicPartition] | None</code> <p>List of partitions to assign. Defaults to None.</p> <code>None</code> <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If both topic_list and partition_list are provided or neither is provided.</p> <code>InternalError</code> <p>If there is an error initializing the consumer.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(\n    self,\n    group_id: str,\n    topic_list: list[str] | None = None,\n    partition_list: list[TopicPartition] | None = None,\n    kafka_configs: KafkaConfig | None = None,\n) -&gt; None:\n    \"\"\"Initializes the consumer adapter with Kafka configuration and subscription.\n\n    Args:\n        group_id (str): Consumer group ID.\n        topic_list (list[str] | None, optional): List of topics to subscribe to.\n            Defaults to None.\n        partition_list (list[TopicPartition] | None, optional): List of partitions\n            to assign. Defaults to None.\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        InvalidArgumentError: If both topic_list and partition_list are provided or\n            neither is provided.\n        InternalError: If there is an error initializing the consumer.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    self._adapter: Consumer = self._get_adapter(group_id, configs)\n    if topic_list and not partition_list:\n        self.subscribe(topic_list)\n    elif not topic_list and partition_list:\n        self.assign(partition_list)\n    else:\n        logger.error(\"Invalid topic or partition list\")\n        raise InvalidArgumentError(\n            argument_name=\"topic_list or partition_list\",\n            additional_data={\"reason\": \"Exactly one of topic_list or partition_list must be provided\"},\n        )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.batch_consume","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.batch_consume(messages_number=500, timeout=1)</code>","text":"<p>Consumes a batch of messages from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>messages_number</code> <code>int</code> <p>Maximum number of messages to consume. Defaults to 500.</p> <code>500</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[Message]</code> <p>list[Message]: List of consumed messages.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error consuming messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef batch_consume(self, messages_number: int = 500, timeout: int = 1) -&gt; list[Message]:\n    \"\"\"Consumes a batch of messages from subscribed topics.\n\n    Args:\n        messages_number (int, optional): Maximum number of messages to consume.\n            Defaults to 500.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        list[Message]: List of consumed messages.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error consuming messages.\n    \"\"\"\n    try:\n        result_list: list[Message] = []\n        messages: list[Message] = self._adapter.consume(num_messages=messages_number, timeout=timeout)\n        for message in messages:\n            if message.error():\n                logger.error(\"Consumer error: %s\", message.error())\n                continue\n            logger.debug(\"Message consumed: %s\", message)\n            message.set_value(message.value())\n            result_list.append(message)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"batch_consume\")\n    else:\n        return result_list\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.poll","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.poll(timeout=1)</code>","text":"<p>Polls for a single message from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Message | None</code> <p>Message | None: The consumed message or None if no message was received.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error polling for messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef poll(self, timeout: int = 1) -&gt; Message | None:\n    \"\"\"Polls for a single message from subscribed topics.\n\n    Args:\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        Message | None: The consumed message or None if no message was received.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error polling for messages.\n    \"\"\"\n    try:\n        message: Message | None = self._adapter.poll(timeout)\n        if message is None:\n            logger.debug(\"No message received\")\n            return None\n        if message.error():\n            logger.error(\"Consumer error: %s\", message.error())\n            return None\n        logger.debug(\"Message consumed: %s\", message)\n        message.set_value(message.value())\n    except Exception as e:\n        self._handle_kafka_exception(e, \"poll\")\n    else:\n        return message\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.commit","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.commit(message, asynchronous=True)</code>","text":"<p>Commits the offset for a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to commit.</p> required <code>asynchronous</code> <code>bool</code> <p>Whether to commit asynchronously. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None | list[TopicPartition]</code> <p>None | list[TopicPartition]: None for async commits, list of TopicPartition for sync commits.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the message is invalid.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error committing the offset.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef commit(self, message: Message, asynchronous: bool = True) -&gt; None | list[TopicPartition]:\n    \"\"\"Commits the offset for a message.\n\n    Args:\n        message (Message): The message to commit.\n        asynchronous (bool, optional): Whether to commit asynchronously. Defaults to True.\n\n    Returns:\n        None | list[TopicPartition]: None for async commits, list of TopicPartition for sync commits.\n\n    Raises:\n        InvalidArgumentError: If the message is invalid.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error committing the offset.\n    \"\"\"\n    try:\n        if asynchronous:\n            self._adapter.commit(message=message, asynchronous=True)\n            result = None\n        else:\n            result = self._adapter.commit(message=message, asynchronous=False)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"commit\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.subscribe","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.subscribe(topic_list)</code>","text":"<p>Subscribes to a list of topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic_list</code> <code>list[str]</code> <p>List of topics to subscribe to.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the topic list is invalid.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error subscribing to topics.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef subscribe(self, topic_list: list[str]) -&gt; None:\n    \"\"\"Subscribes to a list of topics.\n\n    Args:\n        topic_list (list[str]): List of topics to subscribe to.\n\n    Raises:\n        InvalidArgumentError: If the topic list is invalid.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error subscribing to topics.\n    \"\"\"\n    try:\n        self._adapter.subscribe(topic_list)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"subscribe\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.assign","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.assign(partition_list)</code>","text":"<p>Assigns the consumer to a list of topic partitions.</p> <p>Parameters:</p> Name Type Description Default <code>partition_list</code> <code>list[TopicPartition]</code> <p>List of partitions to assign.</p> required <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the partition list is invalid.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error assigning partitions.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef assign(self, partition_list: list[TopicPartition]) -&gt; None:\n    \"\"\"Assigns the consumer to a list of topic partitions.\n\n    Args:\n        partition_list (list[TopicPartition]): List of partitions to assign.\n\n    Raises:\n        InvalidArgumentError: If the partition list is invalid.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error assigning partitions.\n    \"\"\"\n    try:\n        self._adapter.assign(partition_list)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"assign\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter</code>","text":"<p>               Bases: <code>KafkaProducerPort</code>, <code>KafkaExceptionHandlerMixin</code></p> <p>Synchronous Kafka producer adapter.</p> <p>This adapter provides synchronous message production to Kafka topics. It implements the KafkaProducerPort interface and handles message production.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaProducerAdapter(KafkaProducerPort, KafkaExceptionHandlerMixin):\n    \"\"\"Synchronous Kafka producer adapter.\n\n    This adapter provides synchronous message production to Kafka topics.\n    It implements the KafkaProducerPort interface and handles message production.\n    \"\"\"\n\n    def __init__(self, topic_name: str, kafka_configs: KafkaConfig | None = None) -&gt; None:\n        \"\"\"Initializes the producer adapter with Kafka configuration.\n\n        Args:\n            topic_name (str): Default topic name to produce messages to.\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error initializing the producer.\n        \"\"\"\n        self._topic_name = topic_name\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        self._adapter: Producer = self._get_adapter(configs)\n\n    @classmethod\n    def _get_adapter(cls, configs: KafkaConfig) -&gt; Producer:\n        \"\"\"Creates and configures a Kafka Producer instance.\n\n        Args:\n            configs (KafkaConfig): Kafka configuration.\n\n        Returns:\n            Producer: Configured Kafka Producer instance.\n\n        Raises:\n            ConfigurationError: If there is an error in the Kafka configuration.\n            InternalError: If there is an error creating the producer.\n        \"\"\"\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\n                \"bootstrap.servers\": broker_list_csv,\n                \"linger.ms\": configs.LINGER_MS,\n                \"batch.size\": configs.BATCH_SIZE,\n                \"acks\": configs.ACKS,\n                \"request.timeout.ms\": configs.REQUEST_TIMEOUT_MS,\n                \"delivery.timeout.ms\": configs.DELIVERY_TIMEOUT_MS,\n                \"compression.type\": configs.COMPRESSION_TYPE or \"none\",\n                \"max.in.flight.requests.per.connection\": configs.MAX_IN_FLIGHT_REQUESTS,\n                \"retries\": configs.RETRIES,\n                \"enable.idempotence\": configs.ENABLE_IDEMPOTENCE,\n                \"queue.buffering.max.messages\": configs.QUEUE_BUFFERING_MAX_MESSAGES,\n                \"statistics.interval.ms\": configs.STATISTICS_INTERVAL_MS,\n            }\n            if configs.TRANSACTIONAL_ID:\n                config[\"transactional.id\"] = configs.TRANSACTIONAL_ID\n            if configs.USERNAME and configs.PASSWORD and configs.SSL_CA_FILE:\n                config |= {\n                    \"sasl.username\": configs.USERNAME,\n                    \"sasl.password\": configs.PASSWORD.get_secret_value(),\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanism\": configs.SASL_MECHANISM,\n                    \"ssl.ca.location\": configs.SSL_CA_FILE,\n                    \"ssl.certificate.location\": configs.SSL_CERT_FILE,\n                    \"ssl.key.location\": configs.SSL_KEY_FILE,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                }\n            producer = Producer(config)\n        except Exception as e:\n            cls._handle_kafka_exception(e, \"KafkaProducer_init\")\n        else:\n            return producer\n\n    @staticmethod\n    def _pre_process_message(message: str | bytes) -&gt; bytes:\n        \"\"\"Pre-processes a message to ensure it's in the correct format.\n\n        Args:\n            message (str | bytes): The message to pre-process.\n\n        Returns:\n            bytes: The pre-processed message as bytes.\n        \"\"\"\n        if isinstance(message, str):\n            return message.encode(\"utf-8\")\n        return message\n\n    @staticmethod\n    def _delivery_callback(error: KafkaError | None, message: Message) -&gt; None:\n        \"\"\"Callback for message delivery confirmation.\n\n        Args:\n            error (KafkaError | None): Error that occurred during delivery, or None if successful.\n            message (Message): The delivered message.\n        \"\"\"\n        if error:\n            logger.error(\"Message delivery failed: %s: %s\", error, message.value())\n        else:\n            logger.debug(\n                \"Message delivered to %s [%d] at offset %d\",\n                message.topic(),\n                message.partition(),\n                message.offset(),\n            )\n\n    @override\n    def produce(self, message: str | bytes) -&gt; None:\n        \"\"\"Produces a message to the configured topic.\n\n        Args:\n            message (str | bytes): The message to produce.\n\n        Raises:\n            NetworkError: If there is a network error producing the message.\n            ResourceExhaustedError: If the producer queue is full.\n            InternalError: If there is an error producing the message.\n        \"\"\"\n        try:\n            processed_message = self._pre_process_message(message)\n            self._adapter.produce(\n                topic=self._topic_name,\n                value=processed_message,\n                callback=self._delivery_callback,\n            )\n        except Exception as e:\n            self._handle_producer_exception(e, \"produce\")\n\n    @override\n    def flush(self, timeout: int | None = None) -&gt; None:\n        \"\"\"Flushes the producer queue.\n\n        Args:\n            timeout (int | None, optional): Timeout in seconds for the operation. Defaults to None.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If Kafka is unavailable.\n            InternalError: If there is an error flushing the queue.\n        \"\"\"\n        try:\n            remaining_messages = self._adapter.flush(timeout=timeout)\n            if remaining_messages &gt; 0:\n                logger.warning(\"%d messages left in the queue after flush\", remaining_messages)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"flush\")\n\n    @override\n    def validate_healthiness(self) -&gt; None:\n        \"\"\"Validates the health of the Kafka connection.\n\n        Raises:\n            UnavailableError: If the Kafka service is unavailable.\n        \"\"\"\n        try:\n            self.list_topics(timeout=1)\n        except Exception as e:\n            raise UnavailableError(service=\"Kafka\") from e\n\n    @override\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            ConnectionTimeoutError: If the operation times out.\n            ServiceUnavailableError: If the Kafka service is unavailable.\n            UnavailableError: If there is an unknown issue accessing Kafka.\n        \"\"\"\n        try:\n            result = self._adapter.list_topics(topic=topic, timeout=timeout)\n        except Exception as e:\n            self._handle_kafka_exception(e, \"list_topics\")\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.__init__(topic_name, kafka_configs=None)</code>","text":"<p>Initializes the producer adapter with Kafka configuration.</p> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>Default topic name to produce messages to.</p> required <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If there is an error in the Kafka configuration.</p> <code>InternalError</code> <p>If there is an error initializing the producer.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(self, topic_name: str, kafka_configs: KafkaConfig | None = None) -&gt; None:\n    \"\"\"Initializes the producer adapter with Kafka configuration.\n\n    Args:\n        topic_name (str): Default topic name to produce messages to.\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        ConfigurationError: If there is an error in the Kafka configuration.\n        InternalError: If there is an error initializing the producer.\n    \"\"\"\n    self._topic_name = topic_name\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    self._adapter: Producer = self._get_adapter(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.produce","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.produce(message)</code>","text":"<p>Produces a message to the configured topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | bytes</code> <p>The message to produce.</p> required <p>Raises:</p> Type Description <code>NetworkError</code> <p>If there is a network error producing the message.</p> <code>ResourceExhaustedError</code> <p>If the producer queue is full.</p> <code>InternalError</code> <p>If there is an error producing the message.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef produce(self, message: str | bytes) -&gt; None:\n    \"\"\"Produces a message to the configured topic.\n\n    Args:\n        message (str | bytes): The message to produce.\n\n    Raises:\n        NetworkError: If there is a network error producing the message.\n        ResourceExhaustedError: If the producer queue is full.\n        InternalError: If there is an error producing the message.\n    \"\"\"\n    try:\n        processed_message = self._pre_process_message(message)\n        self._adapter.produce(\n            topic=self._topic_name,\n            value=processed_message,\n            callback=self._delivery_callback,\n        )\n    except Exception as e:\n        self._handle_producer_exception(e, \"produce\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.flush","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.flush(timeout=None)</code>","text":"<p>Flushes the producer queue.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Timeout in seconds for the operation. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If Kafka is unavailable.</p> <code>InternalError</code> <p>If there is an error flushing the queue.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef flush(self, timeout: int | None = None) -&gt; None:\n    \"\"\"Flushes the producer queue.\n\n    Args:\n        timeout (int | None, optional): Timeout in seconds for the operation. Defaults to None.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If Kafka is unavailable.\n        InternalError: If there is an error flushing the queue.\n    \"\"\"\n    try:\n        remaining_messages = self._adapter.flush(timeout=timeout)\n        if remaining_messages &gt; 0:\n            logger.warning(\"%d messages left in the queue after flush\", remaining_messages)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"flush\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.validate_healthiness","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.validate_healthiness()</code>","text":"<p>Validates the health of the Kafka connection.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If the Kafka service is unavailable.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef validate_healthiness(self) -&gt; None:\n    \"\"\"Validates the health of the Kafka connection.\n\n    Raises:\n        UnavailableError: If the Kafka service is unavailable.\n    \"\"\"\n    try:\n        self.list_topics(timeout=1)\n    except Exception as e:\n        raise UnavailableError(service=\"Kafka\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.list_topics","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.list_topics(topic=None, timeout=1)</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If the operation times out.</p> <code>ServiceUnavailableError</code> <p>If the Kafka service is unavailable.</p> <code>UnavailableError</code> <p>If there is an unknown issue accessing Kafka.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        ConnectionTimeoutError: If the operation times out.\n        ServiceUnavailableError: If the Kafka service is unavailable.\n        UnavailableError: If there is an unknown issue accessing Kafka.\n    \"\"\"\n    try:\n        result = self._adapter.list_topics(topic=topic, timeout=timeout)\n    except Exception as e:\n        self._handle_kafka_exception(e, \"list_topics\")\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort</code>","text":"<p>Interface for Kafka admin operations.</p> <p>This interface defines the contract for performing administrative operations on Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaAdminPort:\n    \"\"\"Interface for Kafka admin operations.\n\n    This interface defines the contract for performing administrative operations on Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n        \"\"\"Creates a new Kafka topic.\n\n        Args:\n            topic (str): Name of the topic to create.\n            num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n            replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_topic(self, topics: list[str]) -&gt; None:\n        \"\"\"Deletes one or more Kafka topics.\n\n        Args:\n            topics (list[str]): List of topic names to delete.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.create_topic","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.create_topic(topic, num_partitions=1, replication_factor=1)</code>  <code>abstractmethod</code>","text":"<p>Creates a new Kafka topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required <code>num_partitions</code> <code>int</code> <p>Number of partitions for the topic. Defaults to 1.</p> <code>1</code> <code>replication_factor</code> <code>int</code> <p>Replication factor for the topic. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n    \"\"\"Creates a new Kafka topic.\n\n    Args:\n        topic (str): Name of the topic to create.\n        num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n        replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.delete_topic","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.delete_topic(topics)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>list[str]</code> <p>List of topic names to delete.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef delete_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Deletes one or more Kafka topics.\n\n    Args:\n        topics (list[str]): List of topic names to delete.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.list_topics","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.list_topics(topic=None, timeout=1)</code>  <code>abstractmethod</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort</code>","text":"<p>Interface for Kafka consumer operations.</p> <p>This interface defines the contract for consuming messages from Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaConsumerPort:\n    \"\"\"Interface for Kafka consumer operations.\n\n    This interface defines the contract for consuming messages from Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def batch_consume(self, messages_number: int, timeout: int) -&gt; list[Message]:\n        \"\"\"Consumes a batch of messages from subscribed topics.\n\n        Args:\n            messages_number (int): Maximum number of messages to consume.\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            list[Message]: List of consumed messages.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def poll(self, timeout: int) -&gt; Message | None:\n        \"\"\"Polls for a single message from subscribed topics.\n\n        Args:\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            Message | None: The consumed message or None if no message was received.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def commit(self, message: Message, asynchronous: bool) -&gt; None | list[TopicPartition]:\n        \"\"\"Commits the offset of a consumed message.\n\n        Args:\n            message (Message): The message whose offset should be committed.\n            asynchronous (bool): Whether to commit asynchronously.\n\n        Returns:\n            None | list[TopicPartition]: None for synchronous commits, or list of committed\n                partitions for asynchronous commits.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def subscribe(self, topic_list: list[str]) -&gt; None:\n        \"\"\"Subscribes to a list of topics.\n\n        Args:\n            topic_list (list[str]): List of topic names to subscribe to.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign(self, partition_list: list[TopicPartition]) -&gt; None:\n        \"\"\"Assigns specific partitions to the consumer.\n\n        Args:\n            partition_list (list[TopicPartition]): List of partitions to assign.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.batch_consume","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.batch_consume(messages_number, timeout)</code>  <code>abstractmethod</code>","text":"<p>Consumes a batch of messages from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>messages_number</code> <code>int</code> <p>Maximum number of messages to consume.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Type Description <code>list[Message]</code> <p>list[Message]: List of consumed messages.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef batch_consume(self, messages_number: int, timeout: int) -&gt; list[Message]:\n    \"\"\"Consumes a batch of messages from subscribed topics.\n\n    Args:\n        messages_number (int): Maximum number of messages to consume.\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        list[Message]: List of consumed messages.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.poll","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.poll(timeout)</code>  <code>abstractmethod</code>","text":"<p>Polls for a single message from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Type Description <code>Message | None</code> <p>Message | None: The consumed message or None if no message was received.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout: int) -&gt; Message | None:\n    \"\"\"Polls for a single message from subscribed topics.\n\n    Args:\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        Message | None: The consumed message or None if no message was received.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.commit","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.commit(message, asynchronous)</code>  <code>abstractmethod</code>","text":"<p>Commits the offset of a consumed message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message whose offset should be committed.</p> required <code>asynchronous</code> <code>bool</code> <p>Whether to commit asynchronously.</p> required <p>Returns:</p> Type Description <code>None | list[TopicPartition]</code> <p>None | list[TopicPartition]: None for synchronous commits, or list of committed partitions for asynchronous commits.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef commit(self, message: Message, asynchronous: bool) -&gt; None | list[TopicPartition]:\n    \"\"\"Commits the offset of a consumed message.\n\n    Args:\n        message (Message): The message whose offset should be committed.\n        asynchronous (bool): Whether to commit asynchronously.\n\n    Returns:\n        None | list[TopicPartition]: None for synchronous commits, or list of committed\n            partitions for asynchronous commits.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.subscribe","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.subscribe(topic_list)</code>  <code>abstractmethod</code>","text":"<p>Subscribes to a list of topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic_list</code> <code>list[str]</code> <p>List of topic names to subscribe to.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef subscribe(self, topic_list: list[str]) -&gt; None:\n    \"\"\"Subscribes to a list of topics.\n\n    Args:\n        topic_list (list[str]): List of topic names to subscribe to.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.assign","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.assign(partition_list)</code>  <code>abstractmethod</code>","text":"<p>Assigns specific partitions to the consumer.</p> <p>Parameters:</p> Name Type Description Default <code>partition_list</code> <code>list[TopicPartition]</code> <p>List of partitions to assign.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef assign(self, partition_list: list[TopicPartition]) -&gt; None:\n    \"\"\"Assigns specific partitions to the consumer.\n\n    Args:\n        partition_list (list[TopicPartition]): List of partitions to assign.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort</code>","text":"<p>Interface for Kafka producer operations.</p> <p>This interface defines the contract for producing messages to Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaProducerPort:\n    \"\"\"Interface for Kafka producer operations.\n\n    This interface defines the contract for producing messages to Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def produce(self, message: str | bytes) -&gt; None:\n        \"\"\"Produces a message to the configured topic.\n\n        Args:\n            message (str | bytes): The message to produce.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def flush(self, timeout: int | None) -&gt; None:\n        \"\"\"Flushes any pending messages to the broker.\n\n        Args:\n            timeout (int | None): Maximum time to wait for messages to be delivered.\n                If None, wait indefinitely.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_healthiness(self) -&gt; None:\n        \"\"\"Validates the health of the producer connection.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_topics(self, topic: str | None, timeout: int) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None): Specific topic to list. If None, lists all topics.\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.produce","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.produce(message)</code>  <code>abstractmethod</code>","text":"<p>Produces a message to the configured topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | bytes</code> <p>The message to produce.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef produce(self, message: str | bytes) -&gt; None:\n    \"\"\"Produces a message to the configured topic.\n\n    Args:\n        message (str | bytes): The message to produce.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.flush","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.flush(timeout)</code>  <code>abstractmethod</code>","text":"<p>Flushes any pending messages to the broker.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Maximum time to wait for messages to be delivered. If None, wait indefinitely.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef flush(self, timeout: int | None) -&gt; None:\n    \"\"\"Flushes any pending messages to the broker.\n\n    Args:\n        timeout (int | None): Maximum time to wait for messages to be delivered.\n            If None, wait indefinitely.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.validate_healthiness","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.validate_healthiness()</code>  <code>abstractmethod</code>","text":"<p>Validates the health of the producer connection.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef validate_healthiness(self) -&gt; None:\n    \"\"\"Validates the health of the producer connection.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.list_topics","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.list_topics(topic, timeout)</code>  <code>abstractmethod</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef list_topics(self, topic: str | None, timeout: int) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None): Specific topic to list. If None, lists all topics.\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#payment-gateways","title":"Payment Gateways","text":"<p>Integrations with various payment processing services for online transactions.</p>"},{"location":"api_reference/adapters/#parsian-shaparak","title":"Parsian Shaparak","text":"<p>Parsian Shaparak payment gateway adapter for processing online payments in Iran.</p> <pre><code>from archipy.adapters.internet_payment_gateways.ir.parsian.adapters import (\n    ParsianShaparakPaymentAdapter,\n    PaymentRequestDTO,\n    ConfirmRequestDTO\n)\n\n# Create a Parsian Shaparak payment adapter\npayment_adapter = ParsianShaparakPaymentAdapter()  # Uses global config by default\n\n# Create payment request\npayment_request = PaymentRequestDTO(\n    amount=10000,  # Amount in IRR\n    order_id=12345,  # Your unique order ID\n    callback_url=\"https://your-app.com/payment/callback\",\n)\n\n# Send payment request\npayment_response = payment_adapter.initiate_payment(payment_request)\n\nif payment_response.status == 0:  # 0 means success\n    # Redirect user to payment page\n    payment_url = f\"https://pec.shaparak.ir/NewIPG/?Token={payment_response.token}\"\n</code></pre> <p>For detailed examples and usage guidelines, see the Parsian Payment Gateway Examples.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for initiating a payment request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class PaymentRequestDTO(BaseDTO):\n    \"\"\"DTO for initiating a payment request.\"\"\"\n\n    amount: int = Field(..., gt=0, description=\"Transaction amount in IRR\")\n    order_id: int = Field(..., gt=0, description=\"Unique order identifier\")\n    callback_url: HttpUrl = Field(..., description=\"URL to redirect after payment\")\n    additional_data: str | None = Field(None, description=\"Additional transaction data\")\n    originator: str | None = Field(None, description=\"Transaction originator\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.PaymentResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for payment response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class PaymentResponseDTO(BaseDTO):\n    \"\"\"DTO for payment response.\"\"\"\n\n    token: int | None = Field(None, description=\"Transaction token\")\n    status: int | None = Field(None, description=\"Transaction status code\")\n    message: str | None = Field(None, description=\"Status message or error description\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirming a payment.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmRequestDTO(BaseDTO):\n    \"\"\"DTO for confirming a payment.\"\"\"\n\n    token: int = Field(..., gt=0, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirm payment response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmResponseDTO(BaseDTO):\n    \"\"\"DTO for confirm payment response.\"\"\"\n\n    status: int | None = Field(None, description=\"Transaction status code\")\n    rrn: int | None = Field(None, description=\"Retrieval Reference Number\")\n    card_number_masked: str | None = Field(None, description=\"Masked card number\")\n    token: int | None = Field(None, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirming a payment with amount and order verification.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmWithAmountRequestDTO(BaseDTO):\n    \"\"\"DTO for confirming a payment with amount and order verification.\"\"\"\n\n    token: int = Field(..., gt=0, description=\"Transaction token\")\n    order_id: int = Field(..., gt=0, description=\"Unique order identifier\")\n    amount: int = Field(..., gt=0, description=\"Transaction amount in IRR\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ConfirmWithAmountResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for confirm payment with amount response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ConfirmWithAmountResponseDTO(BaseDTO):\n    \"\"\"DTO for confirm payment with amount response.\"\"\"\n\n    status: int | None = Field(None, description=\"Transaction status code\")\n    rrn: int | None = Field(None, description=\"Retrieval Reference Number\")\n    card_number_masked: str | None = Field(None, description=\"Masked card number\")\n    token: int | None = Field(None, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseRequestDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseRequestDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for reversing a payment.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ReverseRequestDTO(BaseDTO):\n    \"\"\"DTO for reversing a payment.\"\"\"\n\n    token: int = Field(..., gt=0, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseResponseDTO","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ReverseResponseDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>DTO for reverse payment response.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ReverseResponseDTO(BaseDTO):\n    \"\"\"DTO for reverse payment response.\"\"\"\n\n    status: int | None = Field(None, description=\"Transaction status code\")\n    message: str | None = Field(None, description=\"Status message or error description\")\n    token: int | None = Field(None, description=\"Transaction token\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter</code>","text":"<p>Adapter for interacting with Parsian Shaparak payment gateway services.</p> <p>Provides methods for initiating payments, confirming transactions, and reversing payments through the Parsian Shaparak payment gateway SOAP services. Supports proxy configuration for environments where direct connections are not possible.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>class ParsianShaparakPaymentAdapter:\n    \"\"\"Adapter for interacting with Parsian Shaparak payment gateway services.\n\n    Provides methods for initiating payments, confirming transactions, and reversing\n    payments through the Parsian Shaparak payment gateway SOAP services. Supports\n    proxy configuration for environments where direct connections are not possible.\n    \"\"\"\n\n    def __init__(self, config: ParsianShaparakConfig | None = None) -&gt; None:\n        \"\"\"Initialize the adapter with Parsian Shaparak configuration.\n\n        Args:\n            config (ParsianShaparakConfig | None): Configuration for Parsian Shaparak services.\n                If None, uses global config. Includes optional proxy configuration via\n                the PROXIES field.\n\n        Raises:\n            ValueError: If LOGIN_ACCOUNT is not a valid string.\n        \"\"\"\n        configs = BaseConfig.global_config().PARSIAN_SHAPARAK if config is None else config\n        if not configs.LOGIN_ACCOUNT or not isinstance(configs.LOGIN_ACCOUNT, str):\n            raise ValueError(\"LOGIN_ACCOUNT must be a non-empty string\")\n\n        self.login_account = configs.LOGIN_ACCOUNT\n        transport = None\n        if configs.PROXIES:\n            session = requests.Session()\n            session.proxies = configs.PROXIES\n            transport = Transport(session=session)\n\n        # Initialize SOAP clients\n        self.sale_client = zeep.Client(wsdl=configs.PAYMENT_WSDL_URL, transport=transport)\n        self.confirm_client = zeep.Client(wsdl=configs.CONFIRM_WSDL_URL, transport=transport)\n        self.reversal_client = zeep.Client(wsdl=configs.REVERSAL_WSDL_URL, transport=transport)\n\n    def initiate_payment(self, request: PaymentRequestDTO) -&gt; PaymentResponseDTO:\n        \"\"\"Initiate a payment request.\n\n        Args:\n            request (PaymentRequestDTO): Payment request data.\n\n        Returns:\n            PaymentResponseDTO: Response containing token, status, and message.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\n                \"LoginAccount\": self.login_account,\n                \"Amount\": request.amount,\n                \"OrderId\": request.order_id,\n                \"CallBackUrl\": str(request.callback_url),\n                \"AdditionalData\": request.additional_data,\n                \"Originator\": request.originator,\n            }\n\n            logger.debug(f\"Initiating payment: {request_data}\")\n            response = self.sale_client.service.SalePaymentRequest(requestData=request_data)\n            result = PaymentResponseDTO(\n                token=response.Token,\n                status=response.Status,\n                message=response.Message,\n            )\n            logger.debug(f\"Payment response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Sale Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n\n    def confirm_payment(self, request: ConfirmRequestDTO) -&gt; ConfirmResponseDTO:\n        \"\"\"Confirm a payment transaction.\n\n        Args:\n            request (ConfirmRequestDTO): Confirm request data.\n\n        Returns:\n            ConfirmResponseDTO: Response containing status, RRN, card number, and token.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n            logger.debug(f\"Confirming payment: {request_data}\")\n            response = self.confirm_client.service.ConfirmPayment(requestData=request_data)\n            result = ConfirmResponseDTO(\n                status=response.Status,\n                rrn=response.RRN,\n                card_number_masked=response.CardNumberMasked,\n                token=response.Token,\n            )\n            logger.debug(f\"Confirm response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n\n    def confirm_payment_with_amount(self, request: ConfirmWithAmountRequestDTO) -&gt; ConfirmWithAmountResponseDTO:\n        \"\"\"Confirm a payment transaction with amount and order verification.\n\n        Args:\n            request (ConfirmWithAmountRequestDTO): Confirm with amount request data.\n\n        Returns:\n            ConfirmWithAmountResponseDTO: Response containing status, RRN, card number, and token.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\n                \"LoginAccount\": self.login_account,\n                \"Token\": request.token,\n                \"OrderId\": request.order_id,\n                \"Amount\": request.amount,\n            }\n\n            logger.debug(f\"Confirming payment with amount: {request_data}\")\n            response = self.confirm_client.service.ConfirmPaymentWithAmount(requestData=request_data)\n            result = ConfirmWithAmountResponseDTO(\n                status=response.Status,\n                rrn=response.RRN,\n                card_number_masked=response.CardNumberMasked,\n                token=response.Token,\n            )\n            logger.debug(f\"Confirm with amount response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n\n    def reverse_payment(self, request: ReverseRequestDTO) -&gt; ReverseResponseDTO:\n        \"\"\"Request a reversal of a confirmed transaction.\n\n        Args:\n            request (ReverseRequestDTO): Reverse request data.\n\n        Returns:\n            ReverseResponseDTO: Response containing status, message, and token.\n\n        Raises:\n            UnavailableError: If a SOAP fault occurs during the request.\n            InternalError: If an unexpected error occurs during the request.\n        \"\"\"\n        try:\n            request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n            logger.debug(f\"Reversing payment: {request_data}\")\n            response = self.reversal_client.service.ReversalRequest(requestData=request_data)\n            result = ReverseResponseDTO(\n                status=response.Status,\n                message=response.Message,\n                token=response.Token,\n            )\n            logger.debug(f\"Reversal response: {result}\")\n        except Fault as exception:\n            raise UnavailableError(service=\"Parsian Shaparak Reversal Service\") from exception\n        except Exception as exception:\n            raise InternalError() from exception\n        else:\n            return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.__init__","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.__init__(config=None)</code>","text":"<p>Initialize the adapter with Parsian Shaparak configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ParsianShaparakConfig | None</code> <p>Configuration for Parsian Shaparak services. If None, uses global config. Includes optional proxy configuration via the PROXIES field.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If LOGIN_ACCOUNT is not a valid string.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def __init__(self, config: ParsianShaparakConfig | None = None) -&gt; None:\n    \"\"\"Initialize the adapter with Parsian Shaparak configuration.\n\n    Args:\n        config (ParsianShaparakConfig | None): Configuration for Parsian Shaparak services.\n            If None, uses global config. Includes optional proxy configuration via\n            the PROXIES field.\n\n    Raises:\n        ValueError: If LOGIN_ACCOUNT is not a valid string.\n    \"\"\"\n    configs = BaseConfig.global_config().PARSIAN_SHAPARAK if config is None else config\n    if not configs.LOGIN_ACCOUNT or not isinstance(configs.LOGIN_ACCOUNT, str):\n        raise ValueError(\"LOGIN_ACCOUNT must be a non-empty string\")\n\n    self.login_account = configs.LOGIN_ACCOUNT\n    transport = None\n    if configs.PROXIES:\n        session = requests.Session()\n        session.proxies = configs.PROXIES\n        transport = Transport(session=session)\n\n    # Initialize SOAP clients\n    self.sale_client = zeep.Client(wsdl=configs.PAYMENT_WSDL_URL, transport=transport)\n    self.confirm_client = zeep.Client(wsdl=configs.CONFIRM_WSDL_URL, transport=transport)\n    self.reversal_client = zeep.Client(wsdl=configs.REVERSAL_WSDL_URL, transport=transport)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.initiate_payment","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.initiate_payment(request)</code>","text":"<p>Initiate a payment request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>PaymentRequestDTO</code> <p>Payment request data.</p> required <p>Returns:</p> Name Type Description <code>PaymentResponseDTO</code> <code>PaymentResponseDTO</code> <p>Response containing token, status, and message.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def initiate_payment(self, request: PaymentRequestDTO) -&gt; PaymentResponseDTO:\n    \"\"\"Initiate a payment request.\n\n    Args:\n        request (PaymentRequestDTO): Payment request data.\n\n    Returns:\n        PaymentResponseDTO: Response containing token, status, and message.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\n            \"LoginAccount\": self.login_account,\n            \"Amount\": request.amount,\n            \"OrderId\": request.order_id,\n            \"CallBackUrl\": str(request.callback_url),\n            \"AdditionalData\": request.additional_data,\n            \"Originator\": request.originator,\n        }\n\n        logger.debug(f\"Initiating payment: {request_data}\")\n        response = self.sale_client.service.SalePaymentRequest(requestData=request_data)\n        result = PaymentResponseDTO(\n            token=response.Token,\n            status=response.Status,\n            message=response.Message,\n        )\n        logger.debug(f\"Payment response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Sale Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment(request)</code>","text":"<p>Confirm a payment transaction.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ConfirmRequestDTO</code> <p>Confirm request data.</p> required <p>Returns:</p> Name Type Description <code>ConfirmResponseDTO</code> <code>ConfirmResponseDTO</code> <p>Response containing status, RRN, card number, and token.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def confirm_payment(self, request: ConfirmRequestDTO) -&gt; ConfirmResponseDTO:\n    \"\"\"Confirm a payment transaction.\n\n    Args:\n        request (ConfirmRequestDTO): Confirm request data.\n\n    Returns:\n        ConfirmResponseDTO: Response containing status, RRN, card number, and token.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n        logger.debug(f\"Confirming payment: {request_data}\")\n        response = self.confirm_client.service.ConfirmPayment(requestData=request_data)\n        result = ConfirmResponseDTO(\n            status=response.Status,\n            rrn=response.RRN,\n            card_number_masked=response.CardNumberMasked,\n            token=response.Token,\n        )\n        logger.debug(f\"Confirm response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment_with_amount","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.confirm_payment_with_amount(request)</code>","text":"<p>Confirm a payment transaction with amount and order verification.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ConfirmWithAmountRequestDTO</code> <p>Confirm with amount request data.</p> required <p>Returns:</p> Name Type Description <code>ConfirmWithAmountResponseDTO</code> <code>ConfirmWithAmountResponseDTO</code> <p>Response containing status, RRN, card number, and token.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def confirm_payment_with_amount(self, request: ConfirmWithAmountRequestDTO) -&gt; ConfirmWithAmountResponseDTO:\n    \"\"\"Confirm a payment transaction with amount and order verification.\n\n    Args:\n        request (ConfirmWithAmountRequestDTO): Confirm with amount request data.\n\n    Returns:\n        ConfirmWithAmountResponseDTO: Response containing status, RRN, card number, and token.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\n            \"LoginAccount\": self.login_account,\n            \"Token\": request.token,\n            \"OrderId\": request.order_id,\n            \"Amount\": request.amount,\n        }\n\n        logger.debug(f\"Confirming payment with amount: {request_data}\")\n        response = self.confirm_client.service.ConfirmPaymentWithAmount(requestData=request_data)\n        result = ConfirmWithAmountResponseDTO(\n            status=response.Status,\n            rrn=response.RRN,\n            card_number_masked=response.CardNumberMasked,\n            token=response.Token,\n        )\n        logger.debug(f\"Confirm with amount response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Confirm Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.reverse_payment","title":"<code>archipy.adapters.internet_payment_gateways.ir.parsian.adapters.ParsianShaparakPaymentAdapter.reverse_payment(request)</code>","text":"<p>Request a reversal of a confirmed transaction.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ReverseRequestDTO</code> <p>Reverse request data.</p> required <p>Returns:</p> Name Type Description <code>ReverseResponseDTO</code> <code>ReverseResponseDTO</code> <p>Response containing status, message, and token.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If a SOAP fault occurs during the request.</p> <code>InternalError</code> <p>If an unexpected error occurs during the request.</p> Source code in <code>archipy/adapters/internet_payment_gateways/ir/parsian/adapters.py</code> <pre><code>def reverse_payment(self, request: ReverseRequestDTO) -&gt; ReverseResponseDTO:\n    \"\"\"Request a reversal of a confirmed transaction.\n\n    Args:\n        request (ReverseRequestDTO): Reverse request data.\n\n    Returns:\n        ReverseResponseDTO: Response containing status, message, and token.\n\n    Raises:\n        UnavailableError: If a SOAP fault occurs during the request.\n        InternalError: If an unexpected error occurs during the request.\n    \"\"\"\n    try:\n        request_data = {\"LoginAccount\": self.login_account, \"Token\": request.token}\n\n        logger.debug(f\"Reversing payment: {request_data}\")\n        response = self.reversal_client.service.ReversalRequest(requestData=request_data)\n        result = ReverseResponseDTO(\n            status=response.Status,\n            message=response.Message,\n            token=response.Token,\n        )\n        logger.debug(f\"Reversal response: {result}\")\n    except Fault as exception:\n        raise UnavailableError(service=\"Parsian Shaparak Reversal Service\") from exception\n    except Exception as exception:\n        raise InternalError() from exception\n    else:\n        return result\n</code></pre>"},{"location":"api_reference/configs/","title":"Configs","text":""},{"location":"api_reference/configs/#overview","title":"Overview","text":"<p>The configs module provides tools for standardized configuration management and injection, supporting consistent setup across services like databases, Redis, and email.</p>"},{"location":"api_reference/configs/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\npoetry add archipy\n</code></pre>"},{"location":"api_reference/configs/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/configs/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/configs/#api-stability","title":"API Stability","text":"Component Status Notes BaseConfig \ud83d\udfe2 Stable Production-ready Config Templates \ud83d\udfe2 Stable Production-ready Environment Types \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/configs/#examples","title":"Examples","text":"<p>For practical examples, see the Configuration Management Guide.</p>"},{"location":"api_reference/configs/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api_reference/configs/#base-config","title":"Base Config","text":"<p>Documentation for <code>archipy.configs.base_config</code> module.</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n</code></pre> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#config-templates","title":"Config Templates","text":"<p>Documentation for <code>archipy.configs.config_template</code> module.</p> <pre><code>from archipy.configs.config_template import SQLAlchemyConfig\n\nclass DatabaseConfig(SQLAlchemyConfig):\n    DB_POOL_SIZE: int = 5\n    DB_POOL_TIMEOUT: int = 30\n</code></pre> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/configs/#baseconfig","title":"BaseConfig","text":"<p>Class: <code>archipy.configs.base_config.BaseConfig</code></p> <p>Configures:</p> <ul> <li>Environment variable support</li> <li>Type validation</li> <li>Global configuration access</li> <li>Nested configuration support</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#sqlalchemyconfig","title":"SQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.SQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>Database connection settings</li> <li>Pool configuration</li> <li>Migration settings</li> <li>Debug options</li> </ul> <p>Attributes:</p> <ul> <li><code>DATABASE</code>: Database name</li> <li><code>DRIVER_NAME</code>: Database driver name</li> <li><code>ECHO</code>: Whether to log SQL statements</li> <li><code>ECHO_POOL</code>: Whether to log connection pool events</li> <li><code>ENABLE_FROM_LINTING</code>: Whether to enable SQL linting</li> <li><code>HIDE_PARAMETERS</code>: Whether to hide SQL parameters in logs</li> <li><code>HOST</code>: Database host</li> <li><code>ISOLATION_LEVEL</code>: Transaction isolation level</li> <li><code>PASSWORD</code>: Database password</li> <li><code>POOL_MAX_OVERFLOW</code>: Maximum number of connections in pool overflow</li> <li><code>POOL_PRE_PING</code>: Whether to ping connections before use</li> <li><code>POOL_RECYCLE_SECONDS</code>: Seconds between connection recycling</li> <li><code>POOL_RESET_ON_RETURN</code>: Action when returning connections to pool</li> <li><code>POOL_SIZE</code>: Number of connections to keep open</li> <li><code>POOL_TIMEOUT</code>: Seconds to wait for a connection</li> <li><code>POOL_USE_LIFO</code>: Whether to use LIFO for connection pool</li> <li><code>PORT</code>: Database port</li> <li><code>QUERY_CACHE_SIZE</code>: Size of the query cache</li> <li><code>USERNAME</code>: Database username</li> </ul>"},{"location":"api_reference/configs/#sqlitesqlalchemyconfig","title":"SQLiteSQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.SQLiteSQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>SQLite-specific database settings</li> <li>In-memory database options</li> <li>SQLite isolation levels</li> </ul> <p>Attributes:</p> <ul> <li><code>DRIVER_NAME</code>: SQLite driver name</li> <li><code>DATABASE</code>: SQLite database path</li> <li><code>ISOLATION_LEVEL</code>: SQLite isolation level</li> <li><code>PORT</code>: Not used for SQLite</li> </ul>"},{"location":"api_reference/configs/#postgressqlalchemyconfig","title":"PostgresSQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.PostgresSQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>PostgreSQL-specific database settings</li> <li>Connection URL building</li> <li>DSN configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>POSTGRES_DSN</code>: PostgreSQL connection URL</li> </ul>"},{"location":"api_reference/configs/#starrockssqlalchemyconfig","title":"StarrocksSQLAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.StarrocksSQLAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>Starrocks-specific database settings</li> <li>Catalog configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>CATALOG</code>: Starrocks catalog name</li> </ul>"},{"location":"api_reference/configs/#redisconfig","title":"RedisConfig","text":"<p>Class: <code>archipy.configs.config_template.RedisConfig</code></p> <p>Configures:</p> <ul> <li>Connection settings</li> <li>Pool configuration</li> <li>SSL options</li> <li>Sentinel support</li> </ul> <p>Attributes:</p> <ul> <li><code>MASTER_HOST</code>: Redis master host</li> <li><code>SLAVE_HOST</code>: Redis slave host</li> <li><code>PORT</code>: Redis server port</li> <li><code>DATABASE</code>: Redis database number</li> <li><code>PASSWORD</code>: Redis password</li> <li><code>DECODE_RESPONSES</code>: Whether to decode responses</li> <li><code>VERSION</code>: Redis protocol version</li> <li><code>HEALTH_CHECK_INTERVAL</code>: Health check interval in seconds</li> </ul>"},{"location":"api_reference/configs/#emailconfig","title":"EmailConfig","text":"<p>Class: <code>archipy.configs.config_template.EmailConfig</code></p> <p>Configures:</p> <ul> <li>SMTP settings</li> <li>Authentication</li> <li>TLS options</li> <li>Default headers</li> </ul> <p>Attributes:</p> <ul> <li><code>SMTP_SERVER</code>: SMTP server host</li> <li><code>SMTP_PORT</code>: SMTP server port</li> <li><code>USERNAME</code>: SMTP username</li> <li><code>PASSWORD</code>: SMTP password</li> <li><code>POOL_SIZE</code>: Connection pool size</li> <li><code>CONNECTION_TIMEOUT</code>: Connection timeout in seconds</li> <li><code>MAX_RETRIES</code>: Maximum retry attempts</li> <li><code>ATTACHMENT_MAX_SIZE</code>: Maximum attachment size in bytes</li> </ul>"},{"location":"api_reference/configs/#fastapiconfig","title":"FastAPIConfig","text":"<p>Class: <code>archipy.configs.config_template.FastAPIConfig</code></p> <p>Configures:</p> <ul> <li>API versioning</li> <li>CORS configuration</li> <li>Rate limiting</li> <li>Documentation</li> </ul> <p>Attributes:</p> <ul> <li><code>PROJECT_NAME</code>: Name of the FastAPI project</li> <li><code>API_PREFIX</code>: URL prefix for API endpoints</li> <li><code>ACCESS_LOG</code>: Whether to enable access logging</li> <li><code>BACKLOG</code>: Maximum number of queued connections</li> <li><code>DATE_HEADER</code>: Whether to include date header in responses</li> <li><code>FORWARDED_ALLOW_IPS</code>: List of allowed forwarded IPs</li> <li><code>LIMIT_CONCURRENCY</code>: Maximum concurrent requests</li> <li><code>LIMIT_MAX_REQUESTS</code>: Maximum number of requests</li> <li><code>CORS_MIDDLEWARE_ALLOW_CREDENTIALS</code>: Whether to allow credentials in CORS</li> <li><code>CORS_MIDDLEWARE_ALLOW_HEADERS</code>: Allowed CORS headers</li> <li><code>CORS_MIDDLEWARE_ALLOW_METHODS</code>: Allowed CORS methods</li> <li><code>CORS_MIDDLEWARE_ALLOW_ORIGINS</code>: Allowed CORS origins</li> <li><code>PROXY_HEADERS</code>: Whether to trust proxy headers</li> <li><code>RELOAD</code>: Whether to enable auto-reload</li> <li><code>SERVER_HEADER</code>: Whether to include server header</li> <li><code>SERVE_HOST</code>: Host to serve the application on</li> <li><code>SERVE_PORT</code>: Port to serve the application on</li> <li><code>TIMEOUT_GRACEFUL_SHUTDOWN</code>: Graceful shutdown timeout</li> <li><code>TIMEOUT_KEEP_ALIVE</code>: Keep-alive timeout</li> <li><code>WORKERS_COUNT</code>: Number of worker processes</li> <li><code>WS_MAX_SIZE</code>: Maximum WebSocket message size</li> <li><code>WS_PER_MESSAGE_DEFLATE</code>: Whether to enable WebSocket compression</li> <li><code>WS_PING_INTERVAL</code>: WebSocket ping interval</li> <li><code>WS_PING_TIMEOUT</code>: WebSocket ping timeout</li> <li><code>OPENAPI_URL</code>: URL for OpenAPI schema</li> <li><code>DOCS_URL</code>: URL for API documentation</li> <li><code>RE_DOCS_URL</code>: URL for ReDoc documentation</li> <li><code>SWAGGER_UI_PARAMS</code>: Swagger UI parameters</li> </ul>"},{"location":"api_reference/configs/#grpcconfig","title":"GrpcConfig","text":"<p>Class: <code>archipy.configs.config_template.GrpcConfig</code></p> <p>Configures:</p> <ul> <li>Server settings</li> <li>Client configuration</li> <li>Interceptors</li> <li>SSL/TLS options</li> </ul> <p>Attributes:</p> <ul> <li><code>SERVE_PORT</code>: Port to serve gRPC on</li> <li><code>SERVE_HOST</code>: Host to serve gRPC on</li> <li><code>THREAD_WORKER_COUNT</code>: Number of worker threads</li> <li><code>THREAD_PER_CPU_CORE</code>: Threads per CPU core</li> <li><code>SERVER_OPTIONS_CONFIG_LIST</code>: Server configuration options</li> <li><code>STUB_OPTIONS_CONFIG_LIST</code>: Client stub configuration options</li> </ul>"},{"location":"api_reference/configs/#sentryconfig","title":"SentryConfig","text":"<p>Class: <code>archipy.configs.config_template.SentryConfig</code></p> <p>Configures:</p> <ul> <li>DSN configuration</li> <li>Environment settings</li> <li>Sample rates</li> <li>Performance monitoring</li> </ul> <p>Attributes:</p> <ul> <li><code>IS_ENABLED</code>: Whether Sentry is enabled</li> <li><code>DSN</code>: Sentry DSN for error reporting</li> <li><code>DEBUG</code>: Whether to enable debug mode</li> <li><code>RELEASE</code>: Application release version</li> <li><code>SAMPLE_RATE</code>: Error sampling rate (0.0 to 1.0)</li> <li><code>TRACES_SAMPLE_RATE</code>: Performance monitoring sampling rate (0.0 to 1.0)</li> </ul>"},{"location":"api_reference/configs/#elasticsearchconfig","title":"ElasticSearchConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticSearchConfig</code></p> <p>Configures:</p> <ul> <li>Cluster configuration</li> <li>Authentication</li> <li>Index settings</li> <li>Retry policies</li> </ul> <p>Attributes:</p> <ul> <li><code>SEARCH_HOSTS</code>: List of Elasticsearch server hosts</li> <li><code>SEARCH_HTTP_USER_NAME</code>: Username for HTTP authentication</li> <li><code>SEARCH_HTTP_PASSWORD</code>: Password for HTTP authentication</li> <li><code>SEARCH_HTTPS_VERIFY_CERTS</code>: Whether to verify SSL certificates</li> <li><code>SEARCH_KWARG</code>: Additional keyword arguments for Elasticsearch client</li> <li><code>SEARCH_BATCH_INTERVAL_THRESHOLD_IN_SECONDS</code>: Time threshold for batch operations</li> <li><code>SEARCH_BATCH_DOC_COUNT_THRESHOLD</code>: Document count threshold for batch operations</li> </ul>"},{"location":"api_reference/configs/#elasticsearchapmconfig","title":"ElasticSearchAPMConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticSearchAPMConfig</code></p> <p>Configures:</p> <ul> <li>APM server settings</li> <li>Service name</li> <li>Transaction sampling</li> <li>Instrumentation</li> </ul> <p>Attributes:</p> <ul> <li><code>API_REQUEST_SIZE</code>: Maximum size of API requests</li> <li><code>API_REQUEST_TIME</code>: Maximum time for API requests</li> <li><code>AUTO_LOG_STACKS</code>: Whether to automatically log stack traces</li> <li><code>CAPTURE_BODY</code>: Level of request body capture</li> <li><code>CAPTURE_HEADERS</code>: Whether to capture HTTP headers</li> <li><code>COLLECT_LOCAL_VARIABLES</code>: Level of local variable collection</li> <li><code>IS_ENABLED</code>: Whether APM is enabled</li> <li><code>ENVIRONMENT</code>: APM environment name</li> <li><code>LOG_FILE</code>: Path to APM log file</li> <li><code>LOG_FILE_SIZE</code>: Maximum size of APM log file</li> <li><code>RECORDING</code>: Whether to record transactions</li> <li><code>SECRET_TOKEN</code>: APM secret token</li> <li><code>SERVER_TIMEOUT</code>: Server timeout duration</li> <li><code>SERVER_URL</code>: APM server URL</li> <li><code>SERVICE_NAME</code>: Name of the service being monitored</li> <li><code>SERVICE_VERSION</code>: Version of the service</li> <li><code>TRANSACTION_SAMPLE_RATE</code>: Rate at which to sample transactions</li> <li><code>API_KEY</code>: API key for authentication</li> </ul>"},{"location":"api_reference/configs/#kafkaconfig","title":"KafkaConfig","text":"<p>Class: <code>archipy.configs.config_template.KafkaConfig</code></p> <p>Configures:</p> <ul> <li>Broker configuration</li> <li>Consumer groups</li> <li>Producer settings</li> <li>Security options</li> </ul> <p>Attributes:</p> <ul> <li><code>ACKNOWLEDGE_COUNT</code>: Number of acknowledgments required</li> <li><code>AUTO_OFFSET_RESET</code>: Action to take when there is no initial offset</li> <li><code>BROKERS_LIST</code>: List of Kafka broker addresses</li> <li><code>CERT_PEM</code>: Path to SSL certificate</li> <li><code>ENABLE_AUTO_COMMIT</code>: Whether to enable auto-commit</li> <li><code>MAX_BUFFER_MS</code>: Maximum time to buffer messages</li> <li><code>MAX_BUFFER_SIZE</code>: Maximum number of messages to buffer</li> <li><code>PASSWORD</code>: Password for authentication</li> <li><code>SASL_MECHANISMS</code>: SASL mechanism for authentication</li> <li><code>SECURITY_PROTOCOL</code>: Security protocol to use</li> <li><code>SESSION_TIMEOUT_MS</code>: Session timeout in milliseconds</li> <li><code>REQUEST_ACK_TIMEOUT_MS</code>: Request acknowledgment timeout</li> <li><code>DELIVERY_MESSAGE_TIMEOUT_MS</code>: Message delivery timeout</li> <li><code>USER_NAME</code>: Username for authentication</li> <li><code>LIST_TOPICS_TIMEOUT</code>: Timeout for listing topics</li> </ul>"},{"location":"api_reference/configs/#keycloakconfig","title":"KeycloakConfig","text":"<p>Class: <code>archipy.configs.config_template.KeycloakConfig</code></p> <p>Configures:</p> <ul> <li>Server connection</li> <li>Authentication settings</li> <li>SSL verification</li> <li>Timeout configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>SERVER_URL</code>: URL of the Keycloak server</li> <li><code>CLIENT_ID</code>: Client ID for authentication</li> <li><code>REALM_NAME</code>: Name of the Keycloak realm</li> <li><code>CLIENT_SECRET_KEY</code>: Client secret key</li> <li><code>VERIFY_SSL</code>: Whether to verify SSL certificates</li> <li><code>TIMEOUT</code>: Request timeout in seconds</li> </ul>"},{"location":"api_reference/configs/#minioconfig","title":"MinioConfig","text":"<p>Class: <code>archipy.configs.config_template.MinioConfig</code></p> <p>Configures:</p> <ul> <li>Server connection</li> <li>Authentication</li> <li>Security settings</li> <li>Region configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>ENDPOINT</code>: MinIO server endpoint</li> <li><code>ACCESS_KEY</code>: Access key for authentication</li> <li><code>SECRET_KEY</code>: Secret key for authentication</li> <li><code>SECURE</code>: Whether to use secure (HTTPS) connection</li> <li><code>SESSION_TOKEN</code>: Session token for temporary credentials</li> <li><code>REGION</code>: AWS region for S3 compatibility</li> </ul>"},{"location":"api_reference/configs/#prometheusconfig","title":"PrometheusConfig","text":"<p>Class: <code>archipy.configs.config_template.PrometheusConfig</code></p> <p>Configures:</p> <ul> <li>Metrics collection</li> <li>Server settings</li> <li>Endpoint configuration</li> </ul> <p>Attributes:</p> <ul> <li><code>IS_ENABLED</code>: Whether Prometheus metrics are enabled</li> <li><code>SERVER_PORT</code>: Port for the Prometheus metrics endpoint</li> </ul>"},{"location":"api_reference/configs/#kavenegarconfig","title":"KavenegarConfig","text":"<p>Class: <code>archipy.configs.config_template.KavenegarConfig</code></p> <p>Configures:</p> <ul> <li>API connection</li> <li>Authentication</li> <li>Default sender settings</li> </ul> <p>Attributes:</p> <ul> <li><code>SERVER_URL</code>: Kavenegar API server URL</li> <li><code>API_KEY</code>: Kavenegar API key</li> <li><code>PHONE_NUMBER</code>: Default sender phone number</li> </ul>"},{"location":"api_reference/configs/#authconfig","title":"AuthConfig","text":"<p>Class: <code>archipy.configs.config_template.AuthConfig</code></p> <p>Configures:</p> <ul> <li>JWT settings</li> <li>TOTP configuration</li> <li>Rate limiting</li> <li>Password policies</li> <li>Token security</li> </ul> <p>Attributes:</p> <ul> <li><code>SECRET_KEY</code>: JWT signing key</li> <li><code>ACCESS_TOKEN_EXPIRES_IN</code>: Access token expiration in seconds</li> <li><code>REFRESH_TOKEN_EXPIRES_IN</code>: Refresh token expiration in seconds</li> <li><code>HASH_ALGORITHM</code>: JWT signing algorithm</li> <li><code>JWT_ISSUER</code>: JWT issuer claim</li> <li><code>JWT_AUDIENCE</code>: JWT audience claim</li> <li><code>TOKEN_VERSION</code>: JWT token version</li> <li><code>TOTP_SECRET_KEY</code>: TOTP master key</li> <li><code>TOTP_HASH_ALGORITHM</code>: TOTP hash algorithm</li> <li><code>TOTP_LENGTH</code>: TOTP code length</li> <li><code>TOTP_EXPIRES_IN</code>: TOTP expiration in seconds</li> <li><code>TOTP_TIME_STEP</code>: TOTP time step in seconds</li> <li><code>TOTP_VERIFICATION_WINDOW</code>: TOTP verification window size</li> <li><code>TOTP_MAX_ATTEMPTS</code>: Maximum TOTP verification attempts</li> <li><code>TOTP_LOCKOUT_TIME</code>: TOTP lockout duration in seconds</li> <li><code>LOGIN_RATE_LIMIT</code>: Login attempts per minute</li> <li><code>TOTP_RATE_LIMIT</code>: TOTP requests per minute</li> <li><code>PASSWORD_RESET_RATE_LIMIT</code>: Password reset requests per hour</li> <li><code>HASH_ITERATIONS</code>: Password hash iterations</li> <li><code>MIN_LENGTH</code>: Minimum password length</li> <li><code>REQUIRE_DIGIT</code>: Whether password requires digits</li> <li><code>REQUIRE_LOWERCASE</code>: Whether password requires lowercase</li> <li><code>REQUIRE_SPECIAL</code>: Whether password requires special chars</li> <li><code>REQUIRE_UPPERCASE</code>: Whether password requires uppercase</li> <li><code>SALT_LENGTH</code>: Password salt length</li> <li><code>SPECIAL_CHARACTERS</code>: Allowed special characters</li> <li><code>PASSWORD_HISTORY_SIZE</code>: Number of previous passwords to remember</li> <li><code>ENABLE_JTI_CLAIM</code>: Whether to enable JWT ID claim</li> <li><code>ENABLE_TOKEN_ROTATION</code>: Whether to enable refresh token rotation</li> <li><code>REFRESH_TOKEN_REUSE_INTERVAL</code>: Refresh token reuse grace period</li> </ul>"},{"location":"api_reference/configs/#fileconfig","title":"FileConfig","text":"<p>Class: <code>archipy.configs.config_template.FileConfig</code></p> <p>Configures:</p> <ul> <li>File link security</li> <li>Expiration policies</li> <li>File type restrictions</li> </ul> <p>Attributes:</p> <ul> <li><code>SECRET_KEY</code>: Secret key for generating secure file links</li> <li><code>DEFAULT_EXPIRY_MINUTES</code>: Default link expiration time in minutes</li> <li><code>ALLOWED_EXTENSIONS</code>: List of allowed file extensions</li> </ul>"},{"location":"api_reference/configs/#datetimeconfig","title":"DatetimeConfig","text":"<p>Class: <code>archipy.configs.config_template.DatetimeConfig</code></p> <p>Configures:</p> <ul> <li>API connections</li> <li>Time service settings</li> <li>Caching behavior</li> </ul> <p>Attributes:</p> <ul> <li><code>TIME_IR_API_KEY</code>: API key for time.ir service</li> <li><code>TIME_IR_API_ENDPOINT</code>: Endpoint for time.ir service</li> <li><code>REQUEST_TIMEOUT</code>: Request timeout in seconds</li> <li><code>MAX_RETRIES</code>: Maximum retry attempts</li> <li><code>CACHE_TTL</code>: Cache time-to-live in seconds</li> </ul>"},{"location":"api_reference/configs/#environmenttype","title":"EnvironmentType","text":"<p>Class: <code>archipy.configs.environment_type.EnvironmentType</code></p> <p>Configures:</p> <ul> <li>Environment types (DEV, STAGING, PROD)</li> <li>Environment-specific behaviors</li> <li>Configuration validation rules</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/","title":"Helpers","text":"<p>The <code>helpers</code> module provides utility functions, decorators, interceptors, and metaclasses to support common development tasks and patterns.</p>"},{"location":"api_reference/helpers/#overview","title":"Overview","text":"<p>The <code>helpers</code> module provides utility functions and classes to simplify common development tasks.</p>"},{"location":"api_reference/helpers/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\npoetry add archipy\n</code></pre> <p>For development features:</p> <pre><code># Add ArchiPy with development extras\npoetry add archipy -E dev\n</code></pre>"},{"location":"api_reference/helpers/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/helpers/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/helpers/#api-stability","title":"API Stability","text":"Component Status Notes Decorators \ud83d\udfe2 Stable Production-ready Utils \ud83d\udfe2 Stable Production-ready Interceptors \ud83d\udfe1 Beta API may change Metaclasses \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/helpers/#submodules","title":"Submodules","text":""},{"location":"api_reference/helpers/#utils","title":"Utils","text":"<p>See Utils Documentation for full documentation.</p> <p>General utility functions for common operations:</p> <ul> <li>String manipulation</li> <li>Date and time handling</li> <li>Error utilities</li> <li>File operations</li> <li>Password utilities</li> <li>JWT token handling</li> <li>TOTP generation</li> </ul>"},{"location":"api_reference/helpers/#decorators","title":"Decorators","text":"<p>See Decorators Documentation for full documentation.</p> <p>Function and class decorators for:</p> <ul> <li>Method deprecation</li> <li>Class deprecation</li> <li>Timing operations</li> <li>Retry logic</li> </ul>"},{"location":"api_reference/helpers/#interceptors","title":"Interceptors","text":"<p>See Interceptors Documentation for full documentation.</p> <p>Classes for cross-cutting concerns:</p> <ul> <li>Logging</li> <li>Performance monitoring</li> <li>Request/response tracking</li> </ul>"},{"location":"api_reference/helpers/#overview_1","title":"Overview","text":"<p>The helpers module offers utilities, decorators, and interceptors to enhance productivity and simplify common development tasks, such as retry logic, rate limiting, and tracing.</p> <p>See Examples: Examples Helpers</p>"},{"location":"api_reference/helpers/#decorators_1","title":"Decorators","text":"<p>Tip: See Examples Helpers Decorators for practical examples of decorators.</p>"},{"location":"api_reference/helpers/#retry-decorator","title":"Retry Decorator","text":"<p>The retry decorator provides a mechanism to automatically retry failed operations with configurable backoff strategies.</p> <pre><code>from archipy.helpers.decorators.retry import retry\n\n@retry(max_attempts=3, delay=1, backoff=2)\ndef risky_operation():\n    # Operation that might fail\n    result = some_unreliable_function()\n    return result\n\n# Will retry up to 3 times with exponential backoff\nresult = risky_operation()\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.retry.retry_decorator","title":"<code>archipy.helpers.decorators.retry.retry_decorator(max_retries=3, delay=1, retry_on=None, ignore=None, resource_type=None, lang=LanguageType.FA)</code>","text":"<p>A decorator that retries a function when it raises an exception.</p> <p>Parameters:</p> Name Type Description Default <code>max_retries</code> <code>int</code> <p>The maximum number of retry attempts. Defaults to 3.</p> <code>3</code> <code>delay</code> <code>float</code> <p>The delay (in seconds) between retries. Defaults to 1.</p> <code>1</code> <code>retry_on</code> <code>Optional[Tuple[Type[Exception], ...]]</code> <p>A tuple of errors to retry on. If None, retries on all errors. Defaults to None.</p> <code>None</code> <code>ignore</code> <code>Optional[Tuple[Type[Exception], ...]]</code> <p>A tuple of errors to ignore (not retry on). If None, no errors are ignored. Defaults to None.</p> <code>None</code> <code>resource_type</code> <code>Optional[str]</code> <p>The type of resource being exhausted. Defaults to None.</p> <code>None</code> <code>lang</code> <code>str</code> <p>The language for the error message (default: \"fa\").</p> <code>FA</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[F], F]</code> <p>The decorated function with retry logic.</p> Example <p>To use this decorator, apply it to a function:</p> <pre><code>@retry_decorator(max_retries=3, delay=1, retry_on=(ValueError,), ignore=(TypeError,), resource_type=\"API\")\ndef unreliable_function():\n    if random.random() &lt; 0.5:\n        raise ValueError(\"Temporary failure\")\n    return \"Success\"\n\nresult = unreliable_function()\n</code></pre> <p>Output: <pre><code>2023-10-10 12:00:00,000 - WARNING - Attempt 1 failed: Temporary failure\n2023-10-10 12:00:01,000 - INFO - Attempt 2 succeeded.\nSuccess\n</code></pre></p> Source code in <code>archipy/helpers/decorators/retry.py</code> <pre><code>def retry_decorator(\n    max_retries: int = 3,\n    delay: float = 1,\n    retry_on: tuple[type[Exception], ...] | None = None,\n    ignore: tuple[type[Exception], ...] | None = None,\n    resource_type: str | None = None,\n    lang: LanguageType = LanguageType.FA,\n) -&gt; Callable[[F], F]:\n    \"\"\"A decorator that retries a function when it raises an exception.\n\n    Args:\n        max_retries (int): The maximum number of retry attempts. Defaults to 3.\n        delay (float): The delay (in seconds) between retries. Defaults to 1.\n        retry_on (Optional[Tuple[Type[Exception], ...]]): A tuple of errors to retry on.\n            If None, retries on all errors. Defaults to None.\n        ignore (Optional[Tuple[Type[Exception], ...]]): A tuple of errors to ignore (not retry on).\n            If None, no errors are ignored. Defaults to None.\n        resource_type (Optional[str]): The type of resource being exhausted. Defaults to None.\n        lang (str): The language for the error message (default: \"fa\").\n\n    Returns:\n        Callable: The decorated function with retry logic.\n\n    Example:\n        To use this decorator, apply it to a function:\n\n        ```python\n        @retry_decorator(max_retries=3, delay=1, retry_on=(ValueError,), ignore=(TypeError,), resource_type=\"API\")\n        def unreliable_function():\n            if random.random() &lt; 0.5:\n                raise ValueError(\"Temporary failure\")\n            return \"Success\"\n\n        result = unreliable_function()\n        ```\n\n        Output:\n        ```\n        2023-10-10 12:00:00,000 - WARNING - Attempt 1 failed: Temporary failure\n        2023-10-10 12:00:01,000 - INFO - Attempt 2 succeeded.\n        Success\n        ```\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            retries = 0\n            while retries &lt; max_retries:\n                try:\n                    result = func(*args, **kwargs)\n                    if retries &gt; 0:\n                        logging.info(\"Attempt %d succeeded.\", retries + 1)\n                except Exception as e:\n                    retries += 1\n                    # Check if the exception should be ignored\n                    if ignore and isinstance(e, ignore):\n                        raise\n                    # Check if the exception should be retried\n                    if retry_on and not isinstance(e, retry_on):\n                        raise\n                    logging.warning(\"Attempt %d failed: %s\", retries, e)\n                    if retries &lt; max_retries:\n                        time.sleep(delay)\n                    continue\n                return result\n            raise ResourceExhaustedError(resource_type=resource_type, lang=lang)\n\n        return cast(F, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"api_reference/helpers/#singleton-decorator","title":"Singleton Decorator","text":"<p>The singleton decorator ensures that a class has only one instance throughout the application lifecycle.</p> <pre><code>from archipy.helpers.decorators.singleton import singleton\n\n@singleton\nclass DatabaseConnection:\n    def __init__(self):\n        self.connection = create_connection()\n\n# Both instances will be the same\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nassert db1 is db2\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.singleton.singleton_decorator","title":"<code>archipy.helpers.decorators.singleton.singleton_decorator(*, thread_safe=True)</code>","text":"<p>A decorator to create thread-safe Singleton classes.</p> <p>This decorator ensures that only one instance of a class is created. It supports an optional <code>thread_safe</code> parameter to control whether thread-safety mechanisms (e.g., locks) should be used.</p> <p>Parameters:</p> Name Type Description Default <code>thread_safe</code> <code>bool</code> <p>If True, enables thread-safety for instance creation.                           Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>function</code> <code>Callable[[type[Any]], Callable[..., Any]]</code> <p>A decorator function that can be applied to a class.</p> Example <p>To create a Singleton class, apply the <code>singleton</code> decorator and optionally specify whether thread-safety should be enabled:</p> <pre><code>@singleton(thread_safe=True)\nclass MySingletonClass:\n    def __init__(self, value):\n        self.value = value\n\n# Create instances of MySingletonClass\ninstance1 = MySingletonClass(10)\ninstance2 = MySingletonClass(20)\n\n# Verify that both instances are the same\nprint(instance1.value)  # Output: 10\nprint(instance2.value)  # Output: 10\nprint(instance1 is instance2)  # Output: True\n</code></pre> Source code in <code>archipy/helpers/decorators/singleton.py</code> <pre><code>def singleton_decorator(*, thread_safe: bool = True) -&gt; Callable[[type[Any]], Callable[..., Any]]:\n    \"\"\"A decorator to create thread-safe Singleton classes.\n\n    This decorator ensures that only one instance of a class is created. It supports an optional\n    `thread_safe` parameter to control whether thread-safety mechanisms (e.g., locks) should be used.\n\n    Args:\n        thread_safe (bool, optional): If True, enables thread-safety for instance creation.\n                                      Defaults to True.\n\n    Returns:\n        function: A decorator function that can be applied to a class.\n\n    Example:\n        To create a Singleton class, apply the `singleton` decorator and optionally specify\n        whether thread-safety should be enabled:\n\n        ```python\n        @singleton(thread_safe=True)\n        class MySingletonClass:\n            def __init__(self, value):\n                self.value = value\n\n        # Create instances of MySingletonClass\n        instance1 = MySingletonClass(10)\n        instance2 = MySingletonClass(20)\n\n        # Verify that both instances are the same\n        print(instance1.value)  # Output: 10\n        print(instance2.value)  # Output: 10\n        print(instance1 is instance2)  # Output: True\n        ```\n    \"\"\"\n\n    def decorator(cls: type[Any]) -&gt; Callable[..., Any]:\n        \"\"\"The inner decorator function that implements the Singleton pattern.\n\n        Args:\n            cls: The class to be decorated as a Singleton.\n\n        Returns:\n            function: A function that returns the Singleton instance of the class.\n        \"\"\"\n        instances = {}  # Stores instances of Singleton classes\n        lock: threading.Lock | None = (\n            threading.Lock() if thread_safe else None\n        )  # Lock for thread-safe instance creation\n\n        def get_instance(*args: Any, **kwargs: Any) -&gt; Any:\n            \"\"\"Create or return the Singleton instance of the class.\n\n            If `thread_safe` is True, a lock is used to ensure that only one instance is created\n            even in a multi-threaded environment. If `thread_safe` is False, no locking mechanism\n            is used, which may result in multiple instances being created in a multi-threaded context.\n\n            Args:\n                *args: Positional arguments to pass to the class constructor.\n                **kwargs: Keyword arguments to pass to the class constructor.\n\n            Returns:\n                object: The Singleton instance of the class.\n            \"\"\"\n            if cls not in instances:\n                if thread_safe:\n                    if lock is not None:\n                        with lock:\n                            if cls not in instances:\n                                instances[cls] = cls(*args, **kwargs)\n                else:\n                    instances[cls] = cls(*args, **kwargs)\n            return instances[cls]\n\n        return get_instance\n\n    return decorator\n</code></pre>"},{"location":"api_reference/helpers/#sqlalchemy-atomic-decorator","title":"SQLAlchemy Atomic Decorator","text":"<p>The SQLAlchemy atomic decorator provides transaction management for database operations.</p> <pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import sqlalchemy_atomic\n\n@sqlalchemy_atomic\ndef create_user(username: str, email: str):\n    user = User(username=username, email=email)\n    db.session.add(user)\n    # If any operation fails, the entire transaction is rolled back\n    db.session.commit()\n</code></pre> <p>SQLAlchemy atomic transaction decorators.</p> <p>This module provides decorators for managing SQLAlchemy transactions with automatic commit/rollback and support for different database types (PostgreSQL, SQLite, StarRocks).</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator(db_type, is_async=False, function=None)</code>","text":"<p>Factory for creating SQLAlchemy atomic transaction decorators.</p> <p>This decorator ensures that a function runs within a database transaction for the specified database type. If the function succeeds, the transaction is committed; otherwise, it is rolled back. Supports both synchronous and asynchronous functions.</p> <p>Parameters:</p> Name Type Description Default <code>db_type</code> <code>str</code> <p>The database type (\"postgres\", \"sqlite\", or \"starrocks\").</p> required <code>is_async</code> <code>bool</code> <p>Whether the function is asynchronous. Defaults to False.</p> <code>False</code> <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial[Callable[..., Any]]</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid db_type is provided.</p> <code>DatabaseSerializationError</code> <p>If a serialization failure is detected.</p> <code>DatabaseDeadlockError</code> <p>If an operational error occurs due to a deadlock.</p> <code>DatabaseTransactionError</code> <p>If a transaction-related error occurs.</p> <code>DatabaseQueryError</code> <p>If a query-related error occurs.</p> <code>DatabaseConnectionError</code> <p>If a connection-related error occurs.</p> <code>DatabaseConstraintError</code> <p>If a constraint violation is detected.</p> <code>DatabaseIntegrityError</code> <p>If an integrity violation is detected.</p> <code>DatabaseTimeoutError</code> <p>If a database operation times out.</p> <code>DatabaseConfigurationError</code> <p>If there's an error in the database configuration.</p> Example Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def sqlalchemy_atomic_decorator(\n    db_type: str,\n    is_async: bool = False,\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial[Callable[..., Any]]:\n    \"\"\"Factory for creating SQLAlchemy atomic transaction decorators.\n\n    This decorator ensures that a function runs within a database transaction for the specified\n    database type. If the function succeeds, the transaction is committed; otherwise, it is rolled back.\n    Supports both synchronous and asynchronous functions.\n\n    Args:\n        db_type (str): The database type (\"postgres\", \"sqlite\", or \"starrocks\").\n        is_async (bool): Whether the function is asynchronous. Defaults to False.\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n\n    Raises:\n        ValueError: If an invalid db_type is provided.\n        DatabaseSerializationError: If a serialization failure is detected.\n        DatabaseDeadlockError: If an operational error occurs due to a deadlock.\n        DatabaseTransactionError: If a transaction-related error occurs.\n        DatabaseQueryError: If a query-related error occurs.\n        DatabaseConnectionError: If a connection-related error occurs.\n        DatabaseConstraintError: If a constraint violation is detected.\n        DatabaseIntegrityError: If an integrity violation is detected.\n        DatabaseTimeoutError: If a database operation times out.\n        DatabaseConfigurationError: If there's an error in the database configuration.\n\n    Example:\n        # Synchronous PostgreSQL example\n        @sqlalchemy_atomic_decorator(db_type=\"postgres\")\n        def update_user(id: int, name: str) -&gt; None:\n            # Database operations\n            pass\n\n        # Asynchronous SQLite example\n        @sqlalchemy_atomic_decorator(db_type=\"sqlite\", is_async=True)\n        async def update_record(id: int, data: str) -&gt; None:\n            # Async database operations\n            pass\n    \"\"\"\n    if db_type not in ATOMIC_BLOCK_CONFIGS:\n        raise ValueError(f\"Invalid db_type: {db_type}. Must be one of {list(ATOMIC_BLOCK_CONFIGS.keys())}\")\n\n    atomic_flag = ATOMIC_BLOCK_CONFIGS[db_type][\"flag\"]\n\n    # Dynamically import the registry class\n    def get_registry() -&gt; type[SessionManagerRegistry]:\n        \"\"\"Get the session manager registry for the specified database type.\n\n        Returns:\n            type[SessionManagerRegistry]: The session manager registry class.\n\n        Raises:\n            DatabaseConfigurationError: If the registry cannot be loaded.\n        \"\"\"\n        try:\n            import importlib\n\n            module_path, class_name = ATOMIC_BLOCK_CONFIGS[db_type][\"registry\"].rsplit(\".\", 1)\n            module = importlib.import_module(module_path)\n            return getattr(module, class_name)\n        except (ImportError, AttributeError) as e:\n            raise DatabaseConfigurationError(\n                database=db_type,\n                additional_data={\"registry_path\": ATOMIC_BLOCK_CONFIGS[db_type][\"registry\"]},\n            ) from e\n\n    def decorator(func: Callable[..., R]) -&gt; Callable[..., R]:\n        \"\"\"Create a transaction-aware wrapper for the given function.\n\n        Args:\n            func (Callable[..., R]): The function to wrap with transaction management.\n\n        Returns:\n            Callable[..., R]: The wrapped function that manages transactions.\n        \"\"\"\n        if is_async:\n\n            @wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -&gt; R:\n                \"\"\"Async wrapper for managing database transactions.\n\n                Args:\n                    *args: Positional arguments to pass to the wrapped function.\n                    **kwargs: Keyword arguments to pass to the wrapped function.\n\n                Returns:\n                    R: The result of the wrapped function.\n\n                Raises:\n                    DatabaseSerializationError: If a serialization failure is detected.\n                    DatabaseDeadlockError: If an operational error occurs due to a deadlock.\n                    DatabaseTransactionError: If a transaction-related error occurs.\n                    DatabaseQueryError: If a query-related error occurs.\n                    DatabaseConnectionError: If a connection-related error occurs.\n                    DatabaseConstraintError: If a constraint violation is detected.\n                    DatabaseIntegrityError: If an integrity violation is detected.\n                    DatabaseTimeoutError: If a database operation times out.\n                \"\"\"\n                registry = get_registry()\n                session_manager: AsyncSessionManagerPort = registry.get_async_manager()\n                session = session_manager.get_session()\n                is_nested = session.info.get(atomic_flag, False)\n                if not is_nested:\n                    session.info[atomic_flag] = True\n\n                try:\n                    if session.in_transaction():\n                        result = await func(*args, **kwargs)\n                        if not is_nested:\n                            await session.commit()\n                        return result\n                    async with session.begin():\n                        return await func(*args, **kwargs)\n                except Exception as exception:\n                    await session.rollback()\n                    _handle_db_exception(exception, db_type, func.__name__)\n                finally:\n                    if not session.in_transaction():\n                        await session.close()\n                        await session_manager.remove_session()\n\n            return async_wrapper\n        else:\n\n            @wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -&gt; R:\n                \"\"\"Synchronous wrapper for managing database transactions.\n\n                Args:\n                    *args: Positional arguments to pass to the wrapped function.\n                    **kwargs: Keyword arguments to pass to the wrapped function.\n\n                Returns:\n                    R: The result of the wrapped function.\n\n                Raises:\n                    DatabaseSerializationError: If a serialization failure is detected.\n                    DatabaseDeadlockError: If an operational error occurs due to a deadlock.\n                    DatabaseTransactionError: If a transaction-related error occurs.\n                    DatabaseQueryError: If a query-related error occurs.\n                    DatabaseConnectionError: If a connection-related error occurs.\n                    DatabaseConstraintError: If a constraint violation is detected.\n                    DatabaseIntegrityError: If an integrity violation is detected.\n                    DatabaseTimeoutError: If a database operation times out.\n                \"\"\"\n                registry = get_registry()\n                session_manager: SessionManagerPort = registry.get_sync_manager()\n                session = session_manager.get_session()\n                is_nested = session.info.get(atomic_flag, False)\n                if not is_nested:\n                    session.info[atomic_flag] = True\n\n                try:\n                    if session.in_transaction():\n                        result = func(*args, **kwargs)\n                        if not is_nested:\n                            session.commit()\n                        return result\n                    with session.begin():\n                        return func(*args, **kwargs)\n                except Exception as exception:\n                    session.rollback()\n                    _handle_db_exception(exception, db_type, func.__name__)\n                finally:\n                    if not session.in_transaction():\n                        session.close()\n                        session_manager.remove_session()\n\n            return sync_wrapper\n\n    return decorator(function) if function else partial(sqlalchemy_atomic_decorator, db_type=db_type, is_async=is_async)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator--synchronous-postgresql-example","title":"Synchronous PostgreSQL example","text":"<p>@sqlalchemy_atomic_decorator(db_type=\"postgres\") def update_user(id: int, name: str) -&gt; None:     # Database operations     pass</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlalchemy_atomic_decorator--asynchronous-sqlite-example","title":"Asynchronous SQLite example","text":"<p>@sqlalchemy_atomic_decorator(db_type=\"sqlite\", is_async=True) async def update_record(id: int, data: str) -&gt; None:     # Async database operations     pass</p>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.postgres_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.postgres_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for PostgreSQL atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def postgres_sqlalchemy_atomic_decorator(function: Callable[..., Any] | None = None) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for PostgreSQL atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"postgres\", function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.async_postgres_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.async_postgres_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for asynchronous PostgreSQL atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def async_postgres_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for asynchronous PostgreSQL atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"postgres\", is_async=True, function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.sqlite_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.sqlite_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for SQLite atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def sqlite_sqlalchemy_atomic_decorator(function: Callable[..., Any] | None = None) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for SQLite atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"sqlite\", function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.async_sqlite_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.async_sqlite_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for asynchronous SQLite atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def async_sqlite_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for asynchronous SQLite atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"sqlite\", is_async=True, function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.starrocks_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.starrocks_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for StarRocks atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def starrocks_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for StarRocks atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"starrocks\", function=function)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.decorators.sqlalchemy_atomic.async_starrocks_sqlalchemy_atomic_decorator","title":"<code>archipy.helpers.decorators.sqlalchemy_atomic.async_starrocks_sqlalchemy_atomic_decorator(function=None)</code>","text":"<p>Decorator for asynchronous StarRocks atomic transactions.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable | None</code> <p>The function to wrap. If None, returns a partial function.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Any] | partial</code> <p>Callable | partial: The wrapped function or a partial function for later use.</p> Source code in <code>archipy/helpers/decorators/sqlalchemy_atomic.py</code> <pre><code>def async_starrocks_sqlalchemy_atomic_decorator(\n    function: Callable[..., Any] | None = None,\n) -&gt; Callable[..., Any] | partial:\n    \"\"\"Decorator for asynchronous StarRocks atomic transactions.\n\n    Args:\n        function (Callable | None): The function to wrap. If None, returns a partial function.\n\n    Returns:\n        Callable | partial: The wrapped function or a partial function for later use.\n    \"\"\"\n    return sqlalchemy_atomic_decorator(db_type=\"starrocks\", is_async=True, function=function)\n</code></pre>"},{"location":"api_reference/helpers/#interceptors_1","title":"Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-interceptors","title":"FastAPI Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-rest-rate-limit-handler","title":"FastAPI Rest Rate Limit Handler","text":"<p>Provides rate limiting functionality for FastAPI endpoints.</p> <pre><code>from archipy.helpers.interceptors.fastapi.rate_limit import FastAPIRestRateLimitHandler\nfrom fastapi import FastAPI\n\napp = FastAPI()\nrate_limit_handler = FastAPIRestRateLimitHandler(\n    redis_client=redis_client,\n    rate_limit=100,  # requests per minute\n    rate_limit_period=60\n)\n\n@app.get(\"/api/data\")\n@rate_limit_handler\nasync def get_data():\n    return {\"data\": \"protected by rate limit\"}\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler","title":"<code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler</code>","text":"<p>A rate-limiting handler for FastAPI REST endpoints using Redis for tracking.</p> <p>This class provides rate-limiting functionality by tracking the number of requests made to a specific endpoint within a defined time window. If the request limit is exceeded, it raises an HTTP 429 Too Many Requests error.</p> <p>Parameters:</p> Name Type Description Default <code>calls_count</code> <code>StrictInt</code> <p>The maximum number of allowed requests within the time window.</p> <code>1</code> <code>milliseconds</code> <code>StrictInt</code> <p>The time window in milliseconds.</p> <code>0</code> <code>seconds</code> <code>StrictInt</code> <p>The time window in seconds.</p> <code>0</code> <code>minutes</code> <code>StrictInt</code> <p>The time window in minutes.</p> <code>0</code> <code>hours</code> <code>StrictInt</code> <p>The time window in hours.</p> <code>0</code> <code>days</code> <code>StrictInt</code> <p>The time window in days.</p> <code>0</code> <code>query_params</code> <code>set(StrictStr</code> <p>request query parameters for rate-limiting based on query params.</p> <code>None</code> Source code in <code>archipy/helpers/interceptors/fastapi/rate_limit/fastapi_rest_rate_limit_handler.py</code> <pre><code>class FastAPIRestRateLimitHandler:\n    \"\"\"A rate-limiting handler for FastAPI REST endpoints using Redis for tracking.\n\n    This class provides rate-limiting functionality by tracking the number of requests\n    made to a specific endpoint within a defined time window. If the request limit is\n    exceeded, it raises an HTTP 429 Too Many Requests error.\n\n    Args:\n        calls_count (StrictInt): The maximum number of allowed requests within the time window.\n        milliseconds (StrictInt): The time window in milliseconds.\n        seconds (StrictInt): The time window in seconds.\n        minutes (StrictInt): The time window in minutes.\n        hours (StrictInt): The time window in hours.\n        days (StrictInt): The time window in days.\n        query_params (set(StrictStr)): request query parameters for rate-limiting based on query params.\n    \"\"\"\n\n    def __init__(\n        self,\n        calls_count: StrictInt = 1,\n        milliseconds: StrictInt = 0,\n        seconds: StrictInt = 0,\n        minutes: StrictInt = 0,\n        hours: StrictInt = 0,\n        days: StrictInt = 0,\n        query_params: set[StrictStr] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the rate limit handler with specified time window and request limits.\n\n        The time window is calculated by combining all time unit parameters into milliseconds.\n        At least one time unit parameter should be greater than 0 to create a valid window.\n\n        Args:\n            calls_count (StrictInt, optional): Maximum number of allowed requests within the time window.\n                Defaults to 1.\n            milliseconds (StrictInt, optional): Number of milliseconds in the time window.\n                Defaults to 0.\n            seconds (StrictInt, optional): Number of seconds in the time window.\n                Defaults to 0.\n            minutes (StrictInt, optional): Number of minutes in the time window.\n                Defaults to 0.\n            hours (StrictInt, optional): Number of hours in the time window.\n                Defaults to 0.\n            days (StrictInt, optional): Number of days in the time window.\n                Defaults to 0.\n            query_params (set[StrictStr] | None, optional): Set of query parameter names to include\n                in rate limit key generation. If None, no query parameters will be used.\n                Defaults to None.\n\n        Example:\n            &gt;&gt;&gt; # Allow 100 requests per minute\n            &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(calls_count=100, minutes=1)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Allow 1000 requests per day with specific query params\n            &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(\n            ...     calls_count=1000,\n            ...     days=1,\n            ...     query_params={'user_id', 'action'}\n            ... )\n        \"\"\"\n        self.query_params = query_params or set()\n        self.calls_count = calls_count\n        # Calculate total time in milliseconds directly for better readability\n        self.milliseconds = (\n            milliseconds + 1000 * seconds + 60 * 1000 * minutes + 60 * 60 * 1000 * hours + 24 * 60 * 60 * 1000 * days\n        )\n        self.redis_client = AsyncRedisAdapter()\n\n    async def _check(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Checks if the request count for the given key exceeds the allowed limit.\n\n        Args:\n            key (str): The Redis key used to track the request count.\n\n        Returns:\n            int: The remaining time-to-live (TTL) in milliseconds if the limit is exceeded, otherwise 0.\n        \"\"\"\n        # Use await for getting value from Redis as it's asynchronous\n        current_request = await self.redis_client.get(key)\n        if current_request is None:\n            await self.redis_client.set(key, 1, px=self.milliseconds)\n            return 0\n\n        current_request = int(current_request)  # type:ignore[arg-type]\n        if current_request &lt; self.calls_count:\n            await self.redis_client.incrby(key)\n            return 0\n\n        ttl = await self.redis_client.pttl(key)\n        if ttl == -1:\n            await self.redis_client.delete(key)\n        return ttl\n\n    async def __call__(self, request: Request) -&gt; None:\n        \"\"\"Handles the rate-limiting logic for incoming requests.\n\n        Args:\n            request (Request): The incoming FastAPI request.\n\n        Raises:\n            HTTPException: If the rate limit is exceeded, an HTTP 429 Too Many Requests error is raised.\n        \"\"\"\n        rate_key = await self._get_identifier(request)\n        key = f\"RateLimitHandler:{rate_key}:{request.scope['path']}:{request.method}\"\n        pexpire = await self._check(key)  # Awaiting the function since it is an async call\n        if pexpire != 0:\n            await self._create_callback(pexpire)  # type:ignore[arg-type]\n\n    @staticmethod\n    async def _create_callback(pexpire: int) -&gt; None:\n        \"\"\"Raises an HTTP 429 Too Many Requests error with the appropriate headers.\n\n        Args:\n            pexpire (int): The remaining time-to-live (TTL) in milliseconds before the rate limit resets.\n\n        Raises:\n            HTTPException: An HTTP 429 Too Many Requests error with the `Retry-After` header.\n        \"\"\"\n        expire = ceil(pexpire / 1000)\n        raise HTTPException(\n            status_code=HTTP_429_TOO_MANY_REQUESTS,\n            detail=\"Too Many Requests\",\n            headers={\"Retry-After\": str(expire)},\n        )\n\n    async def _get_identifier(self, request: Request) -&gt; str:\n        \"\"\"Extracts a unique identifier from the request, typically an IP address and endpoint.\n\n        Args:\n            request (Request): The FastAPI request object containing headers and client info.\n\n        Returns:\n            str: A Redis key generated using the extracted identifier and request information.\n\n        Note:\n            - Validates IP addresses for proper formatting\n            - Handles forwarded IPs with comma-separated values\n            - Filters out private, loopback, link-local, and multicast IPs in X-Forwarded-For\n            - Falls back to client.host if no valid IP is found\n        \"\"\"\n        base_identifier = await self._extract_client_ip(request)\n        return self._generate_redis_key(request=request, base_identifier=base_identifier)\n\n    async def _extract_client_ip(self, request: Request) -&gt; str:\n        \"\"\"Extracts and validates client IP from request headers.\n\n        Args:\n            request (Request): The FastAPI request object.\n\n        Returns:\n            str: Validated IP address or client host.\n        \"\"\"\n        try:\n            # Check X-Real-IP header first\n            if real_ip := self._validate_ip_from_header(request.headers.get(\"X-Real-IP\")):\n                return real_ip\n\n            # Then check X-Forwarded-For header\n            if forwarded_for := self._validate_forwarded_for_header(request.headers.get(\"X-Forwarded-For\")):\n                return forwarded_for\n            # Fallback to client host\n        except ValueError:\n            return request.client.host  # type:ignore[union-attr]\n        else:\n            return request.client.host  # type:ignore[union-attr]\n\n    def _validate_ip_from_header(self, header_value: str | None) -&gt; str | None:\n        \"\"\"Validates IP address from header value.\n\n        Args:\n            header_value (Optional[str]): IP address from header.\n\n        Returns:\n            Optional[str]: First valid IP address or None.\n        \"\"\"\n        if not header_value:\n            return None\n        try:\n            ip_str = header_value.split(\",\")[0].strip()\n            ip = ip_address(ip_str)  # Validate IP format\n            if not (ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_multicast):\n                return ip_str\n        except ValueError:\n            return None\n        else:\n            return None\n\n    def _validate_forwarded_for_header(self, forwarded_for: str | None) -&gt; str | None:\n        \"\"\"Validates IP from X-Forwarded-For header.\n\n        Args:\n            forwarded_for (Optional[str]): X-Forwarded-For header value.\n\n        Returns:\n            Optional[str]: Valid non-private IP, the header or None.\n        \"\"\"\n        if not forwarded_for:\n            return None\n\n        try:\n            ip_str = forwarded_for.split(\",\")[0].strip()\n            ip = ip_address(ip_str)\n\n            if not (ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_multicast):\n                return ip_str\n\n        except ValueError:\n            pass\n        return forwarded_for\n\n    def _generate_redis_key(self, request: Request, base_identifier: str) -&gt; str:\n        \"\"\"Generates a Redis key for rate limiting based on the request and base identifier.\n\n        Args:\n            request (Request): The FastAPI request object containing path and query parameters.\n            base_identifier (str): The base identifier (typically an IP address) for the request.\n\n        Returns:\n            str: A Redis key string with optional query parameters.\n        \"\"\"\n        path_key = f\"{base_identifier}:{request.scope['path']}\"\n\n        if not self.query_params:\n            return path_key\n\n        return self._append_query_params(path_key, request.query_params)\n\n    def _append_query_params(self, base_key: str, query_params: QueryParams) -&gt; str:\n        \"\"\"Appends sorted query parameters to the Redis key.\n\n        Args:\n            base_key (str): Base Redis key without query parameters.\n            query_params (dict[str, str]): Request query parameters.\n\n        Returns:\n            str: Redis key with appended query parameters.\n        \"\"\"\n        filtered_params = {k: v for k, v in query_params.items() if k in self.query_params and v is not None}\n\n        if not filtered_params:\n            return base_key\n\n        sorted_params = sorted(filtered_params.items())\n        query_string = \"&amp;\".join(f\"{k}={v}\" for k, v in sorted_params)\n        return f\"{base_key}?{query_string}\"\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__","title":"<code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__(calls_count=1, milliseconds=0, seconds=0, minutes=0, hours=0, days=0, query_params=None)</code>","text":"<p>Initialize the rate limit handler with specified time window and request limits.</p> <p>The time window is calculated by combining all time unit parameters into milliseconds. At least one time unit parameter should be greater than 0 to create a valid window.</p> <p>Parameters:</p> Name Type Description Default <code>calls_count</code> <code>StrictInt</code> <p>Maximum number of allowed requests within the time window. Defaults to 1.</p> <code>1</code> <code>milliseconds</code> <code>StrictInt</code> <p>Number of milliseconds in the time window. Defaults to 0.</p> <code>0</code> <code>seconds</code> <code>StrictInt</code> <p>Number of seconds in the time window. Defaults to 0.</p> <code>0</code> <code>minutes</code> <code>StrictInt</code> <p>Number of minutes in the time window. Defaults to 0.</p> <code>0</code> <code>hours</code> <code>StrictInt</code> <p>Number of hours in the time window. Defaults to 0.</p> <code>0</code> <code>days</code> <code>StrictInt</code> <p>Number of days in the time window. Defaults to 0.</p> <code>0</code> <code>query_params</code> <code>set[StrictStr] | None</code> <p>Set of query parameter names to include in rate limit key generation. If None, no query parameters will be used. Defaults to None.</p> <code>None</code> Example Source code in <code>archipy/helpers/interceptors/fastapi/rate_limit/fastapi_rest_rate_limit_handler.py</code> <pre><code>def __init__(\n    self,\n    calls_count: StrictInt = 1,\n    milliseconds: StrictInt = 0,\n    seconds: StrictInt = 0,\n    minutes: StrictInt = 0,\n    hours: StrictInt = 0,\n    days: StrictInt = 0,\n    query_params: set[StrictStr] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the rate limit handler with specified time window and request limits.\n\n    The time window is calculated by combining all time unit parameters into milliseconds.\n    At least one time unit parameter should be greater than 0 to create a valid window.\n\n    Args:\n        calls_count (StrictInt, optional): Maximum number of allowed requests within the time window.\n            Defaults to 1.\n        milliseconds (StrictInt, optional): Number of milliseconds in the time window.\n            Defaults to 0.\n        seconds (StrictInt, optional): Number of seconds in the time window.\n            Defaults to 0.\n        minutes (StrictInt, optional): Number of minutes in the time window.\n            Defaults to 0.\n        hours (StrictInt, optional): Number of hours in the time window.\n            Defaults to 0.\n        days (StrictInt, optional): Number of days in the time window.\n            Defaults to 0.\n        query_params (set[StrictStr] | None, optional): Set of query parameter names to include\n            in rate limit key generation. If None, no query parameters will be used.\n            Defaults to None.\n\n    Example:\n        &gt;&gt;&gt; # Allow 100 requests per minute\n        &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(calls_count=100, minutes=1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Allow 1000 requests per day with specific query params\n        &gt;&gt;&gt; handler = FastAPIRestRateLimitHandler(\n        ...     calls_count=1000,\n        ...     days=1,\n        ...     query_params={'user_id', 'action'}\n        ... )\n    \"\"\"\n    self.query_params = query_params or set()\n    self.calls_count = calls_count\n    # Calculate total time in milliseconds directly for better readability\n    self.milliseconds = (\n        milliseconds + 1000 * seconds + 60 * 1000 * minutes + 60 * 60 * 1000 * hours + 24 * 60 * 60 * 1000 * days\n    )\n    self.redis_client = AsyncRedisAdapter()\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__--allow-100-requests-per-minute","title":"Allow 100 requests per minute","text":"<p>handler = FastAPIRestRateLimitHandler(calls_count=100, minutes=1)</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__init__--allow-1000-requests-per-day-with-specific-query-params","title":"Allow 1000 requests per day with specific query params","text":"<p>handler = FastAPIRestRateLimitHandler( ...     calls_count=1000, ...     days=1, ...     query_params={'user_id', 'action'} ... )</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__call__","title":"<code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler.__call__(request)</code>  <code>async</code>","text":"<p>Handles the rate-limiting logic for incoming requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming FastAPI request.</p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the rate limit is exceeded, an HTTP 429 Too Many Requests error is raised.</p> Source code in <code>archipy/helpers/interceptors/fastapi/rate_limit/fastapi_rest_rate_limit_handler.py</code> <pre><code>async def __call__(self, request: Request) -&gt; None:\n    \"\"\"Handles the rate-limiting logic for incoming requests.\n\n    Args:\n        request (Request): The incoming FastAPI request.\n\n    Raises:\n        HTTPException: If the rate limit is exceeded, an HTTP 429 Too Many Requests error is raised.\n    \"\"\"\n    rate_key = await self._get_identifier(request)\n    key = f\"RateLimitHandler:{rate_key}:{request.scope['path']}:{request.method}\"\n    pexpire = await self._check(key)  # Awaiting the function since it is an async call\n    if pexpire != 0:\n        await self._create_callback(pexpire)  # type:ignore[arg-type]\n</code></pre>"},{"location":"api_reference/helpers/#grpc-interceptors","title":"gRPC Interceptors","text":"<p>gRPC interceptors for tracing and monitoring:</p> <p>options: show_root_heading: true show_source: true</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor</code>","text":"<p>               Bases: <code>BaseGrpcClientInterceptor</code></p> <p>A gRPC client interceptor for tracing requests using Elastic APM and Sentry APM.</p> <p>This interceptor injects the Elastic APM trace parent header into gRPC client requests to enable distributed tracing across services. It also creates Sentry transactions to monitor the performance of gRPC calls.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>class GrpcClientTraceInterceptor(BaseGrpcClientInterceptor):\n    \"\"\"A gRPC client interceptor for tracing requests using Elastic APM and Sentry APM.\n\n    This interceptor injects the Elastic APM trace parent header into gRPC client requests\n    to enable distributed tracing across services. It also creates Sentry transactions\n    to monitor the performance of gRPC calls.\n    \"\"\"\n\n    def intercept(self, method: Callable, request_or_iterator: Any, call_details: grpc.ClientCallDetails):\n        \"\"\"Intercepts a gRPC client call to inject the Elastic APM trace parent header and monitor performance with Sentry.\n\n        Args:\n            method (Callable): The gRPC method being intercepted.\n            request_or_iterator (Any): The request or request iterator.\n            call_details (grpc.ClientCallDetails): Details of the gRPC call.\n\n        Returns:\n            Any: The result of the intercepted gRPC method.\n\n        Notes:\n            - If Elastic APM is disabled, the interceptor does nothing and passes the call through.\n            - If no trace parent header is available, the interceptor does nothing and passes the call through.\n        \"\"\"\n        # Skip tracing if Elastic APM is disabled\n        if not BaseConfig.global_config().ELASTIC_APM.ENABLED:\n            return method(request_or_iterator, call_details)\n\n        # Skip tracing if no trace parent header is available\n        if not (trace_parent_id := elasticapm.get_trace_parent_header()):\n            return method(request_or_iterator, call_details)\n\n        # Inject the trace parent header into the call details\n        new_details = ClientCallDetails(\n            method=call_details.method,\n            timeout=call_details.timeout,\n            metadata=[(TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\")],\n            credentials=call_details.credentials,\n            wait_for_ready=call_details.wait_for_ready,\n            compression=call_details.compression,\n        )\n\n        # Execute the gRPC method with the updated call details\n        return method(request_or_iterator, new_details)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.GrpcClientTraceInterceptor.intercept(method, request_or_iterator, call_details)</code>","text":"<p>Intercepts a gRPC client call to inject the Elastic APM trace parent header and monitor performance with Sentry.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The gRPC method being intercepted.</p> required <code>request_or_iterator</code> <code>Any</code> <p>The request or request iterator.</p> required <code>call_details</code> <code>ClientCallDetails</code> <p>Details of the gRPC call.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the intercepted gRPC method.</p> Notes <ul> <li>If Elastic APM is disabled, the interceptor does nothing and passes the call through.</li> <li>If no trace parent header is available, the interceptor does nothing and passes the call through.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>def intercept(self, method: Callable, request_or_iterator: Any, call_details: grpc.ClientCallDetails):\n    \"\"\"Intercepts a gRPC client call to inject the Elastic APM trace parent header and monitor performance with Sentry.\n\n    Args:\n        method (Callable): The gRPC method being intercepted.\n        request_or_iterator (Any): The request or request iterator.\n        call_details (grpc.ClientCallDetails): Details of the gRPC call.\n\n    Returns:\n        Any: The result of the intercepted gRPC method.\n\n    Notes:\n        - If Elastic APM is disabled, the interceptor does nothing and passes the call through.\n        - If no trace parent header is available, the interceptor does nothing and passes the call through.\n    \"\"\"\n    # Skip tracing if Elastic APM is disabled\n    if not BaseConfig.global_config().ELASTIC_APM.ENABLED:\n        return method(request_or_iterator, call_details)\n\n    # Skip tracing if no trace parent header is available\n    if not (trace_parent_id := elasticapm.get_trace_parent_header()):\n        return method(request_or_iterator, call_details)\n\n    # Inject the trace parent header into the call details\n    new_details = ClientCallDetails(\n        method=call_details.method,\n        timeout=call_details.timeout,\n        metadata=[(TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\")],\n        credentials=call_details.credentials,\n        wait_for_ready=call_details.wait_for_ready,\n        compression=call_details.compression,\n    )\n\n    # Execute the gRPC method with the updated call details\n    return method(request_or_iterator, new_details)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor</code>","text":"<p>               Bases: <code>BaseAsyncGrpcClientInterceptor</code></p> <p>An asynchronous gRPC client interceptor for tracing requests using Elastic APM.</p> <p>This interceptor injects the Elastic APM trace parent header into asynchronous gRPC client requests to enable distributed tracing across services.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>class AsyncGrpcClientTraceInterceptor(BaseAsyncGrpcClientInterceptor):\n    \"\"\"An asynchronous gRPC client interceptor for tracing requests using Elastic APM.\n\n    This interceptor injects the Elastic APM trace parent header into asynchronous gRPC client requests\n    to enable distributed tracing across services.\n    \"\"\"\n\n    async def intercept(self, method: Callable, request_or_iterator: Any, call_details: grpc.aio.ClientCallDetails):\n        \"\"\"Intercepts an asynchronous gRPC client call to inject the Elastic APM trace parent header.\n\n        Args:\n            method (Callable): The asynchronous gRPC method being intercepted.\n            request_or_iterator (Any): The request or request iterator.\n            call_details (grpc.aio.ClientCallDetails): Details of the gRPC call.\n\n        Returns:\n            Any: The result of the intercepted gRPC method.\n\n        Notes:\n            - If Elastic APM is disabled, the interceptor does nothing and passes the call through.\n            - If no trace parent header is available, the interceptor does nothing and passes the call through.\n        \"\"\"\n        # Skip tracing if Elastic APM is disabled\n        if not BaseConfig.global_config().ELASTIC_APM.ENABLED:\n            return await method(request_or_iterator, call_details)\n\n        # Skip tracing if no trace parent header is available\n        if not (trace_parent_id := elasticapm.get_trace_parent_header()):\n            return await method(request_or_iterator, call_details)\n\n        # Inject the trace parent header into the call details\n        new_details = AsyncClientCallDetails(\n            method=call_details.method,\n            timeout=call_details.timeout,\n            metadata=[(TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\")],\n            credentials=call_details.credentials,\n            wait_for_ready=call_details.wait_for_ready,\n        )\n\n        # Execute the gRPC method with the updated call details\n        return await method(request_or_iterator, new_details)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.client_interceptor.AsyncGrpcClientTraceInterceptor.intercept(method, request_or_iterator, call_details)</code>  <code>async</code>","text":"<p>Intercepts an asynchronous gRPC client call to inject the Elastic APM trace parent header.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The asynchronous gRPC method being intercepted.</p> required <code>request_or_iterator</code> <code>Any</code> <p>The request or request iterator.</p> required <code>call_details</code> <code>ClientCallDetails</code> <p>Details of the gRPC call.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the intercepted gRPC method.</p> Notes <ul> <li>If Elastic APM is disabled, the interceptor does nothing and passes the call through.</li> <li>If no trace parent header is available, the interceptor does nothing and passes the call through.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/client_interceptor.py</code> <pre><code>async def intercept(self, method: Callable, request_or_iterator: Any, call_details: grpc.aio.ClientCallDetails):\n    \"\"\"Intercepts an asynchronous gRPC client call to inject the Elastic APM trace parent header.\n\n    Args:\n        method (Callable): The asynchronous gRPC method being intercepted.\n        request_or_iterator (Any): The request or request iterator.\n        call_details (grpc.aio.ClientCallDetails): Details of the gRPC call.\n\n    Returns:\n        Any: The result of the intercepted gRPC method.\n\n    Notes:\n        - If Elastic APM is disabled, the interceptor does nothing and passes the call through.\n        - If no trace parent header is available, the interceptor does nothing and passes the call through.\n    \"\"\"\n    # Skip tracing if Elastic APM is disabled\n    if not BaseConfig.global_config().ELASTIC_APM.ENABLED:\n        return await method(request_or_iterator, call_details)\n\n    # Skip tracing if no trace parent header is available\n    if not (trace_parent_id := elasticapm.get_trace_parent_header()):\n        return await method(request_or_iterator, call_details)\n\n    # Inject the trace parent header into the call details\n    new_details = AsyncClientCallDetails(\n        method=call_details.method,\n        timeout=call_details.timeout,\n        metadata=[(TRACEPARENT_HEADER_NAME, f\"{trace_parent_id}\")],\n        credentials=call_details.credentials,\n        wait_for_ready=call_details.wait_for_ready,\n    )\n\n    # Execute the gRPC method with the updated call details\n    return await method(request_or_iterator, new_details)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor","title":"<code>archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor</code>","text":"<p>               Bases: <code>BaseGrpcServerInterceptor</code></p> <p>A gRPC server interceptor for tracing requests using Elastic APM.</p> <p>This interceptor captures and traces gRPC server requests, enabling distributed tracing across services. It integrates with Elastic APM to monitor and log transactions.</p> Source code in <code>archipy/helpers/interceptors/grpc/trace/server_interceptor.py</code> <pre><code>class GrpcServerTraceInterceptor(BaseGrpcServerInterceptor):\n    \"\"\"A gRPC server interceptor for tracing requests using Elastic APM.\n\n    This interceptor captures and traces gRPC server requests, enabling distributed tracing\n    across services. It integrates with Elastic APM to monitor and log transactions.\n    \"\"\"\n\n    def intercept(self, method: Callable, request: Any, context: grpc.ServicerContext):\n        \"\"\"Intercepts a gRPC server call to trace the request using Elastic APM.\n\n        Args:\n            method (Callable): The gRPC method being intercepted.\n            request (Any): The request object passed to the method.\n            context (grpc.ServicerContext): The context of the gRPC call.\n\n        Returns:\n            Any: The result of the intercepted gRPC method.\n\n        Raises:\n            Exception: If an exception occurs during the method execution, it is captured and logged.\n\n        Notes:\n            - If Elastic APM is disabled, the interceptor does nothing and passes the call through.\n            - If a trace parent header is present in the metadata, it is used to link the transaction\n              to the distributed trace.\n            - If no trace parent header is present, a new transaction is started.\n        \"\"\"\n        try:\n            # Skip tracing if Elastic APM is disabled\n            config = BaseConfig.global_config()\n            if not config.ELASTIC_APM.IS_ENABLED:\n                return method(request, context)\n\n            # Get the Elastic APM client\n            client = elasticapm.Client(config.ELASTIC_APM.model_dump())\n\n            # Extract method name details from the context\n            method_name_model = context.method_name_model\n\n            # Convert metadata to a dictionary for easier access\n            metadata_dict = dict(context.invocation_metadata())\n\n            # Check if a trace parent header is present in the metadata\n            if parent := elasticapm.trace_parent_from_headers(metadata_dict):\n                # Start a transaction linked to the distributed trace\n                client.begin_transaction(transaction_type=\"request\", trace_parent=parent)\n                try:\n                    # Execute the gRPC method\n                    result = method(request, context)\n\n                    # End the transaction with a success status\n                    client.end_transaction(name=method_name_model.full_name, result=\"success\")\n                    return result\n                except Exception as e:\n                    # End the transaction with a failure status if an exception occurs\n                    client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n                    raise e\n            else:\n                # Start a new transaction if no trace parent header is present\n                client.begin_transaction(transaction_type=\"request\")\n                try:\n                    # Execute the gRPC method\n                    result = method(request, context)\n\n                    # End the transaction with a success status\n                    client.end_transaction(name=method_name_model.full_name, result=\"success\")\n                    return result\n                except Exception as e:\n                    # End the transaction with a failure status if an exception occurs\n                    client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n                    raise e\n\n        except Exception as exception:\n            BaseUtils.capture_exception(exception)\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor.intercept","title":"<code>archipy.helpers.interceptors.grpc.trace.server_interceptor.GrpcServerTraceInterceptor.intercept(method, request, context)</code>","text":"<p>Intercepts a gRPC server call to trace the request using Elastic APM.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable</code> <p>The gRPC method being intercepted.</p> required <code>request</code> <code>Any</code> <p>The request object passed to the method.</p> required <code>context</code> <code>ServicerContext</code> <p>The context of the gRPC call.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The result of the intercepted gRPC method.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an exception occurs during the method execution, it is captured and logged.</p> Notes <ul> <li>If Elastic APM is disabled, the interceptor does nothing and passes the call through.</li> <li>If a trace parent header is present in the metadata, it is used to link the transaction   to the distributed trace.</li> <li>If no trace parent header is present, a new transaction is started.</li> </ul> Source code in <code>archipy/helpers/interceptors/grpc/trace/server_interceptor.py</code> <pre><code>def intercept(self, method: Callable, request: Any, context: grpc.ServicerContext):\n    \"\"\"Intercepts a gRPC server call to trace the request using Elastic APM.\n\n    Args:\n        method (Callable): The gRPC method being intercepted.\n        request (Any): The request object passed to the method.\n        context (grpc.ServicerContext): The context of the gRPC call.\n\n    Returns:\n        Any: The result of the intercepted gRPC method.\n\n    Raises:\n        Exception: If an exception occurs during the method execution, it is captured and logged.\n\n    Notes:\n        - If Elastic APM is disabled, the interceptor does nothing and passes the call through.\n        - If a trace parent header is present in the metadata, it is used to link the transaction\n          to the distributed trace.\n        - If no trace parent header is present, a new transaction is started.\n    \"\"\"\n    try:\n        # Skip tracing if Elastic APM is disabled\n        config = BaseConfig.global_config()\n        if not config.ELASTIC_APM.IS_ENABLED:\n            return method(request, context)\n\n        # Get the Elastic APM client\n        client = elasticapm.Client(config.ELASTIC_APM.model_dump())\n\n        # Extract method name details from the context\n        method_name_model = context.method_name_model\n\n        # Convert metadata to a dictionary for easier access\n        metadata_dict = dict(context.invocation_metadata())\n\n        # Check if a trace parent header is present in the metadata\n        if parent := elasticapm.trace_parent_from_headers(metadata_dict):\n            # Start a transaction linked to the distributed trace\n            client.begin_transaction(transaction_type=\"request\", trace_parent=parent)\n            try:\n                # Execute the gRPC method\n                result = method(request, context)\n\n                # End the transaction with a success status\n                client.end_transaction(name=method_name_model.full_name, result=\"success\")\n                return result\n            except Exception as e:\n                # End the transaction with a failure status if an exception occurs\n                client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n                raise e\n        else:\n            # Start a new transaction if no trace parent header is present\n            client.begin_transaction(transaction_type=\"request\")\n            try:\n                # Execute the gRPC method\n                result = method(request, context)\n\n                # End the transaction with a success status\n                client.end_transaction(name=method_name_model.full_name, result=\"success\")\n                return result\n            except Exception as e:\n                # End the transaction with a failure status if an exception occurs\n                client.end_transaction(name=method_name_model.full_name, result=\"failure\")\n                raise e\n\n    except Exception as exception:\n        BaseUtils.capture_exception(exception)\n</code></pre>"},{"location":"api_reference/helpers/#metaclasses","title":"Metaclasses","text":""},{"location":"api_reference/helpers/#singleton-metaclass","title":"Singleton Metaclass","text":"<p>A metaclass implementation of the singleton pattern.</p> <pre><code>from archipy.helpers.metaclasses.singleton import Singleton\n\nclass DatabaseConnection(metaclass=Singleton):\n    def __init__(self):\n        self.connection = create_connection()\n\n# Both instances will be the same\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nassert db1 is db2\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/helpers/#archipy.helpers.metaclasses.singleton.Singleton","title":"<code>archipy.helpers.metaclasses.singleton.Singleton</code>","text":"<p>               Bases: <code>type</code></p> <p>A thread-safe Singleton metaclass that ensures only one instance of a class is created.</p> <p>This metaclass can be used to create Singleton classes. It supports an optional <code>thread_safe</code> parameter to control whether thread-safety mechanisms (e.g., locks) should be used.</p> <p>Attributes:</p> Name Type Description <code>_instances</code> <code>dict</code> <p>A dictionary to store instances of Singleton classes.</p> <code>_lock</code> <code>Lock</code> <p>A lock to ensure thread-safe instance creation.</p> Example <p>To create a Singleton class, use the <code>Singleton</code> metaclass and optionally specify whether thread-safety should be enabled:</p> <pre><code>class MySingletonClass(metaclass=Singleton, thread_safe=True):\n    def __init__(self, value):\n        self.value = value\n\n# Create instances of MySingletonClass\ninstance1 = MySingletonClass(10)\ninstance2 = MySingletonClass(20)\n\n# Verify that both instances are the same\nprint(instance1.value)  # Output: 10\nprint(instance2.value)  # Output: 10\nprint(instance1 is instance2)  # Output: True\n</code></pre> Source code in <code>archipy/helpers/metaclasses/singleton.py</code> <pre><code>class Singleton(type):\n    \"\"\"A thread-safe Singleton metaclass that ensures only one instance of a class is created.\n\n    This metaclass can be used to create Singleton classes. It supports an optional `thread_safe`\n    parameter to control whether thread-safety mechanisms (e.g., locks) should be used.\n\n    Attributes:\n        _instances (dict): A dictionary to store instances of Singleton classes.\n        _lock (threading.Lock): A lock to ensure thread-safe instance creation.\n\n    Example:\n        To create a Singleton class, use the `Singleton` metaclass and optionally specify\n        whether thread-safety should be enabled:\n\n        ```python\n        class MySingletonClass(metaclass=Singleton, thread_safe=True):\n            def __init__(self, value):\n                self.value = value\n\n        # Create instances of MySingletonClass\n        instance1 = MySingletonClass(10)\n        instance2 = MySingletonClass(20)\n\n        # Verify that both instances are the same\n        print(instance1.value)  # Output: 10\n        print(instance2.value)  # Output: 10\n        print(instance1 is instance2)  # Output: True\n        ```\n    \"\"\"\n\n    _instances: ClassVar[dict[type, SingletonInstance]] = {}  # Stores instances of Singleton classes\n    _lock: ClassVar[threading.Lock] = threading.Lock()  # Lock for thread-safe instance creation\n\n    def __new__(\n        cls,\n        name: str,\n        bases: ClassBases,\n        dct: ClassDict,\n        **kwargs: object,\n    ) -&gt; type:\n        \"\"\"Create a new Singleton metaclass instance.\n\n        Args:\n            name (str): The name of the class.\n            bases (tuple): The base classes of the class.\n            dct (dict): The namespace containing the class attributes.\n            **kwargs: Additional keyword arguments, including `thread_safe`.\n\n        Returns:\n            type: A new metaclass instance.\n        \"\"\"\n        # Extract the `thread_safe` parameter from kwargs\n        thread_safe = kwargs.pop(\"thread_safe\", True)\n        # Create the new class\n        new_class = super().__new__(cls, name, bases, dct, **kwargs)\n        # Store thread_safe as an attribute using setattr to avoid linting errors\n        setattr(new_class, \"__thread_safe\", thread_safe)\n        return new_class\n\n    def __call__(cls, *args: object, **kwargs: object) -&gt; SingletonInstance:\n        \"\"\"Create or return the Singleton instance of the class.\n\n        If `thread_safe` is True, a lock is used to ensure that only one instance is created\n        even in a multi-threaded environment. If `thread_safe` is False, no locking mechanism\n        is used, which may result in multiple instances being created in a multi-threaded context.\n\n        Args:\n            *args: Positional arguments to pass to the class constructor.\n            **kwargs: Keyword arguments to pass to the class constructor.\n\n        Returns:\n            object: The Singleton instance of the class.\n        \"\"\"\n        if cls not in cls._instances:\n            if getattr(cls, \"__thread_safe\", True):\n                with cls._lock:\n                    if cls not in cls._instances:\n                        cls._instances[cls] = super().__call__(*args, **kwargs)\n            else:\n                cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.metaclasses.singleton.Singleton.__new__","title":"<code>archipy.helpers.metaclasses.singleton.Singleton.__new__(name, bases, dct, **kwargs)</code>","text":"<p>Create a new Singleton metaclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the class.</p> required <code>bases</code> <code>tuple</code> <p>The base classes of the class.</p> required <code>dct</code> <code>dict</code> <p>The namespace containing the class attributes.</p> required <code>**kwargs</code> <code>object</code> <p>Additional keyword arguments, including <code>thread_safe</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>type</code> <code>type</code> <p>A new metaclass instance.</p> Source code in <code>archipy/helpers/metaclasses/singleton.py</code> <pre><code>def __new__(\n    cls,\n    name: str,\n    bases: ClassBases,\n    dct: ClassDict,\n    **kwargs: object,\n) -&gt; type:\n    \"\"\"Create a new Singleton metaclass instance.\n\n    Args:\n        name (str): The name of the class.\n        bases (tuple): The base classes of the class.\n        dct (dict): The namespace containing the class attributes.\n        **kwargs: Additional keyword arguments, including `thread_safe`.\n\n    Returns:\n        type: A new metaclass instance.\n    \"\"\"\n    # Extract the `thread_safe` parameter from kwargs\n    thread_safe = kwargs.pop(\"thread_safe\", True)\n    # Create the new class\n    new_class = super().__new__(cls, name, bases, dct, **kwargs)\n    # Store thread_safe as an attribute using setattr to avoid linting errors\n    setattr(new_class, \"__thread_safe\", thread_safe)\n    return new_class\n</code></pre>"},{"location":"api_reference/helpers/#archipy.helpers.metaclasses.singleton.Singleton.__call__","title":"<code>archipy.helpers.metaclasses.singleton.Singleton.__call__(*args, **kwargs)</code>","text":"<p>Create or return the Singleton instance of the class.</p> <p>If <code>thread_safe</code> is True, a lock is used to ensure that only one instance is created even in a multi-threaded environment. If <code>thread_safe</code> is False, no locking mechanism is used, which may result in multiple instances being created in a multi-threaded context.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>object</code> <p>Positional arguments to pass to the class constructor.</p> <code>()</code> <code>**kwargs</code> <code>object</code> <p>Keyword arguments to pass to the class constructor.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>object</code> <code>SingletonInstance</code> <p>The Singleton instance of the class.</p> Source code in <code>archipy/helpers/metaclasses/singleton.py</code> <pre><code>def __call__(cls, *args: object, **kwargs: object) -&gt; SingletonInstance:\n    \"\"\"Create or return the Singleton instance of the class.\n\n    If `thread_safe` is True, a lock is used to ensure that only one instance is created\n    even in a multi-threaded environment. If `thread_safe` is False, no locking mechanism\n    is used, which may result in multiple instances being created in a multi-threaded context.\n\n    Args:\n        *args: Positional arguments to pass to the class constructor.\n        **kwargs: Keyword arguments to pass to the class constructor.\n\n    Returns:\n        object: The Singleton instance of the class.\n    \"\"\"\n    if cls not in cls._instances:\n        if getattr(cls, \"__thread_safe\", True):\n            with cls._lock:\n                if cls not in cls._instances:\n                    cls._instances[cls] = super().__call__(*args, **kwargs)\n        else:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n    return cls._instances[cls]\n</code></pre>"},{"location":"api_reference/helpers/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/helpers/#retry-decorator_1","title":"Retry Decorator","text":"<p>Function: <code>archipy.helpers.decorators.retry.retry</code></p> <p>A decorator that retries a function call when it fails, with configurable:</p> <ul> <li>Maximum number of attempts</li> <li>Delay between attempts</li> <li>Backoff strategy</li> <li>Exception types to catch</li> </ul>"},{"location":"api_reference/helpers/#singleton","title":"Singleton","text":"<p>Class: <code>archipy.helpers.metaclasses.singleton.Singleton</code></p> <p>A metaclass that ensures a class has only one instance. Features:</p> <ul> <li>Thread-safe implementation</li> <li>Lazy initialization</li> <li>Support for inheritance</li> <li>Clear instance access</li> </ul>"},{"location":"api_reference/helpers/#fastapirestratelimithandler","title":"FastAPIRestRateLimitHandler","text":"<p>Class: <code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler</code></p> <p>A rate limiting handler for FastAPI applications that:</p> <ul> <li>Supports Redis-based rate limiting</li> <li>Configurable rate limits and periods</li> <li>Customizable response handling</li> <li>Support for multiple rate limit rules</li> </ul>"},{"location":"api_reference/models/","title":"Models","text":"<p>The <code>models</code> module provides core data structures and types used throughout the application, following clean architecture principles.</p>"},{"location":"api_reference/models/#dtos-data-transfer-objects","title":"DTOs (Data Transfer Objects)","text":""},{"location":"api_reference/models/#base-dtos","title":"Base DTOs","text":"<p>Base classes for all DTOs with common functionality.</p> <pre><code>from archipy.models.dtos.base_dtos import BaseDTO\nfrom pydantic import BaseModel\n\nclass UserDTO(BaseDTO):\n    id: str\n    username: str\n    email: str\n    created_at: datetime\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.base_dtos.BaseDTO","title":"<code>archipy.models.dtos.base_dtos.BaseDTO</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base Data Transfer Object class.</p> <p>This class extends Pydantic's BaseModel to provide common configuration for all DTOs in the application.</p> Source code in <code>archipy/models/dtos/base_dtos.py</code> <pre><code>class BaseDTO(BaseModel):\n    \"\"\"Base Data Transfer Object class.\n\n    This class extends Pydantic's BaseModel to provide common configuration\n    for all DTOs in the application.\n    \"\"\"\n\n    model_config = ConfigDict(\n        extra=\"ignore\",\n        validate_default=True,\n        from_attributes=True,\n        frozen=True,\n        str_strip_whitespace=True,\n        arbitrary_types_allowed=True,\n    )\n</code></pre>"},{"location":"api_reference/models/#email-dtos","title":"Email DTOs","text":"<p>DTOs for email-related operations.</p> <pre><code>from archipy.models.dtos.email_dtos import EmailAttachmentDTO\n\nattachment = EmailAttachmentDTO(\n    filename=\"document.pdf\",\n    content_type=\"application/pdf\",\n    content=b\"...\"\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.email_dtos.EmailAttachmentDTO","title":"<code>archipy.models.dtos.email_dtos.EmailAttachmentDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>Pydantic model for email attachments.</p> Source code in <code>archipy/models/dtos/email_dtos.py</code> <pre><code>class EmailAttachmentDTO(BaseDTO):\n    \"\"\"Pydantic model for email attachments.\"\"\"\n\n    content: str | bytes | BinaryIO\n    filename: str\n    content_type: str | None = Field(default=None)\n    content_disposition: EmailAttachmentDispositionType = Field(default=EmailAttachmentDispositionType.ATTACHMENT)\n    content_id: str | None = Field(default=None)\n    attachment_type: EmailAttachmentType\n    max_size: int\n\n    @field_validator(\"content_type\")  # type: ignore[type-var]\n    def set_content_type(self, v: str | None, values: dict) -&gt; str | None:\n        \"\"\"Set content type based on filename extension if not provided.\n\n        Args:\n            v: The content type value\n            values: Other field values\n\n        Returns:\n            The determined content type or the original value\n        \"\"\"\n        if v is None and \"filename\" in values:\n            content_type, _ = mimetypes.guess_type(values[\"filename\"])\n            return content_type or \"application/octet-stream\"\n        return v\n\n    @model_validator(mode=\"after\")  # type: ignore[arg-type]\n    def validate_attachment_size(self, model: Self) -&gt; Self:\n        \"\"\"Validate that the attachment size does not exceed the maximum allowed size.\n\n        Args:\n            model: The model instance\n\n        Returns:\n            The validated model instance\n\n        Raises:\n            ValueError: If attachment size exceeds maximum allowed size\n        \"\"\"\n        content = model.content\n        if isinstance(content, str | bytes):\n            content_size = len(content)\n            if content_size &gt; model.max_size:\n                error_msg = f\"Attachment size exceeds maximum allowed size of {model.max_size} bytes\"\n                raise ValueError(error_msg)\n        return model\n\n    @field_validator(\"content_id\")  # type: ignore[type-var]\n    def validate_content_id(self, v: str | None, _: dict) -&gt; str | None:\n        \"\"\"Ensure content_id is properly formatted with angle brackets.\n\n        Args:\n            v: The content_id value\n            _: Unused field values\n\n        Returns:\n            Properly formatted content_id\n        \"\"\"\n        if v and not v.startswith(\"&lt;\"):\n            return f\"&lt;{v}&gt;\"\n        return v\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.email_dtos.EmailAttachmentDTO.set_content_type","title":"<code>archipy.models.dtos.email_dtos.EmailAttachmentDTO.set_content_type(v, values)</code>","text":"<p>Set content type based on filename extension if not provided.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str | None</code> <p>The content type value</p> required <code>values</code> <code>dict</code> <p>Other field values</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The determined content type or the original value</p> Source code in <code>archipy/models/dtos/email_dtos.py</code> <pre><code>@field_validator(\"content_type\")  # type: ignore[type-var]\ndef set_content_type(self, v: str | None, values: dict) -&gt; str | None:\n    \"\"\"Set content type based on filename extension if not provided.\n\n    Args:\n        v: The content type value\n        values: Other field values\n\n    Returns:\n        The determined content type or the original value\n    \"\"\"\n    if v is None and \"filename\" in values:\n        content_type, _ = mimetypes.guess_type(values[\"filename\"])\n        return content_type or \"application/octet-stream\"\n    return v\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.email_dtos.EmailAttachmentDTO.validate_attachment_size","title":"<code>archipy.models.dtos.email_dtos.EmailAttachmentDTO.validate_attachment_size(model)</code>","text":"<p>Validate that the attachment size does not exceed the maximum allowed size.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Self</code> <p>The model instance</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If attachment size exceeds maximum allowed size</p> Source code in <code>archipy/models/dtos/email_dtos.py</code> <pre><code>@model_validator(mode=\"after\")  # type: ignore[arg-type]\ndef validate_attachment_size(self, model: Self) -&gt; Self:\n    \"\"\"Validate that the attachment size does not exceed the maximum allowed size.\n\n    Args:\n        model: The model instance\n\n    Returns:\n        The validated model instance\n\n    Raises:\n        ValueError: If attachment size exceeds maximum allowed size\n    \"\"\"\n    content = model.content\n    if isinstance(content, str | bytes):\n        content_size = len(content)\n        if content_size &gt; model.max_size:\n            error_msg = f\"Attachment size exceeds maximum allowed size of {model.max_size} bytes\"\n            raise ValueError(error_msg)\n    return model\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.email_dtos.EmailAttachmentDTO.validate_content_id","title":"<code>archipy.models.dtos.email_dtos.EmailAttachmentDTO.validate_content_id(v, _)</code>","text":"<p>Ensure content_id is properly formatted with angle brackets.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str | None</code> <p>The content_id value</p> required <code>_</code> <code>dict</code> <p>Unused field values</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Properly formatted content_id</p> Source code in <code>archipy/models/dtos/email_dtos.py</code> <pre><code>@field_validator(\"content_id\")  # type: ignore[type-var]\ndef validate_content_id(self, v: str | None, _: dict) -&gt; str | None:\n    \"\"\"Ensure content_id is properly formatted with angle brackets.\n\n    Args:\n        v: The content_id value\n        _: Unused field values\n\n    Returns:\n        Properly formatted content_id\n    \"\"\"\n    if v and not v.startswith(\"&lt;\"):\n        return f\"&lt;{v}&gt;\"\n    return v\n</code></pre>"},{"location":"api_reference/models/#error-dtos","title":"Error DTOs","text":"<p>Standardized error response format.</p> <pre><code>from archipy.models.dtos.error_dto import ErrorDetailDTO\n\nerror = ErrorDetailDTO(\n    code=\"USER_NOT_FOUND\",\n    message_en=\"User not found\",\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.error_dto.ErrorDetailDTO","title":"<code>archipy.models.dtos.error_dto.ErrorDetailDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>Standardized error detail model.</p> Source code in <code>archipy/models/dtos/error_dto.py</code> <pre><code>class ErrorDetailDTO(BaseDTO):\n    \"\"\"Standardized error detail model.\"\"\"\n\n    code: str\n    message_en: str\n    message_fa: str\n    http_status: int | None = None\n    grpc_status: int | None = None\n\n    @classmethod\n    def create_error_detail(\n        cls,\n        code: str,\n        message_en: str,\n        message_fa: str,\n        http_status: HTTPStatus | int | None = None,\n        grpc_status: StatusCode | int | None = None,\n    ) -&gt; Self:\n        \"\"\"Creates an `ErrorDetailDTO` with appropriate status codes.\n\n        Args:\n            code (str): A unique error code.\n            message_en (str): The error message in English.\n            message_fa (str): The error message in Persian.\n            http_status (HTTPStatus | int | None): The HTTP status code associated with the error.\n            grpc_status (StatusCode | int  | None): The gRPC status code associated with the error.\n\n        Returns:\n            ErrorDetailDTO: The created exception detail object.\n        \"\"\"\n        status_kwargs = {}\n\n        if HTTP_AVAILABLE and http_status is not None:\n            status_kwargs[\"http_status\"] = http_status.value if isinstance(http_status, HTTPStatus) else http_status\n\n        if GRPC_AVAILABLE and grpc_status is not None:\n            # StatusCode.value can be a tuple, but we need only the first element (integer value)\n            if isinstance(grpc_status, StatusCode):\n                status_kwargs[\"grpc_status\"] = (\n                    grpc_status.value[0] if isinstance(grpc_status.value, tuple) else grpc_status.value\n                )\n            else:\n                status_kwargs[\"grpc_status\"] = grpc_status\n\n        # We need to use cls() for proper typing with Self return type\n        return cls(code=code, message_en=message_en, message_fa=message_fa, **status_kwargs)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.error_dto.ErrorDetailDTO.create_error_detail","title":"<code>archipy.models.dtos.error_dto.ErrorDetailDTO.create_error_detail(code, message_en, message_fa, http_status=None, grpc_status=None)</code>  <code>classmethod</code>","text":"<p>Creates an <code>ErrorDetailDTO</code> with appropriate status codes.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>A unique error code.</p> required <code>message_en</code> <code>str</code> <p>The error message in English.</p> required <code>message_fa</code> <code>str</code> <p>The error message in Persian.</p> required <code>http_status</code> <code>HTTPStatus | int | None</code> <p>The HTTP status code associated with the error.</p> <code>None</code> <code>grpc_status</code> <code>StatusCode | int | None</code> <p>The gRPC status code associated with the error.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ErrorDetailDTO</code> <code>Self</code> <p>The created exception detail object.</p> Source code in <code>archipy/models/dtos/error_dto.py</code> <pre><code>@classmethod\ndef create_error_detail(\n    cls,\n    code: str,\n    message_en: str,\n    message_fa: str,\n    http_status: HTTPStatus | int | None = None,\n    grpc_status: StatusCode | int | None = None,\n) -&gt; Self:\n    \"\"\"Creates an `ErrorDetailDTO` with appropriate status codes.\n\n    Args:\n        code (str): A unique error code.\n        message_en (str): The error message in English.\n        message_fa (str): The error message in Persian.\n        http_status (HTTPStatus | int | None): The HTTP status code associated with the error.\n        grpc_status (StatusCode | int  | None): The gRPC status code associated with the error.\n\n    Returns:\n        ErrorDetailDTO: The created exception detail object.\n    \"\"\"\n    status_kwargs = {}\n\n    if HTTP_AVAILABLE and http_status is not None:\n        status_kwargs[\"http_status\"] = http_status.value if isinstance(http_status, HTTPStatus) else http_status\n\n    if GRPC_AVAILABLE and grpc_status is not None:\n        # StatusCode.value can be a tuple, but we need only the first element (integer value)\n        if isinstance(grpc_status, StatusCode):\n            status_kwargs[\"grpc_status\"] = (\n                grpc_status.value[0] if isinstance(grpc_status.value, tuple) else grpc_status.value\n            )\n        else:\n            status_kwargs[\"grpc_status\"] = grpc_status\n\n    # We need to use cls() for proper typing with Self return type\n    return cls(code=code, message_en=message_en, message_fa=message_fa, **status_kwargs)\n</code></pre>"},{"location":"api_reference/models/#pagination-dto","title":"Pagination DTO","text":"<p>Handles pagination parameters for queries.</p> <pre><code>from archipy.models.dtos.pagination_dto import PaginationDTO\n\npagination = PaginationDTO(\n    page=1,\n    page_size=10,\n    total_items=100\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.pagination_dto.PaginationDTO","title":"<code>archipy.models.dtos.pagination_dto.PaginationDTO</code>","text":"<p>               Bases: <code>BaseDTO</code></p> <p>Data Transfer Object for pagination parameters.</p> <p>This DTO encapsulates pagination information for database queries and API responses, providing a standard way to specify which subset of results to retrieve.</p> <p>Attributes:</p> Name Type Description <code>page</code> <code>int</code> <p>The current page number (1-based indexing)</p> <code>page_size</code> <code>int</code> <p>Number of items per page</p> <code>offset</code> <code>int</code> <p>Calculated offset for database queries based on page and page_size</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.models.dtos.pagination_dto import PaginationDTO\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Default pagination (page 1, 10 items per page)\n&gt;&gt;&gt; pagination = PaginationDTO()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom pagination\n&gt;&gt;&gt; pagination = PaginationDTO(page=2, page_size=25)\n&gt;&gt;&gt; print(pagination.offset)  # Access offset as a property\n25\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using with a database query\n&gt;&gt;&gt; def get_users(pagination: PaginationDTO):\n...     query = select(User).offset(pagination.offset).limit(pagination.page_size)\n...     return db.execute(query).scalars().all()\n</code></pre> Source code in <code>archipy/models/dtos/pagination_dto.py</code> <pre><code>class PaginationDTO(BaseDTO):\n    \"\"\"Data Transfer Object for pagination parameters.\n\n    This DTO encapsulates pagination information for database queries and API responses,\n    providing a standard way to specify which subset of results to retrieve.\n\n    Attributes:\n        page (int): The current page number (1-based indexing)\n        page_size (int): Number of items per page\n        offset (int): Calculated offset for database queries based on page and page_size\n\n    Examples:\n        &gt;&gt;&gt; from archipy.models.dtos.pagination_dto import PaginationDTO\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Default pagination (page 1, 10 items per page)\n        &gt;&gt;&gt; pagination = PaginationDTO()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Custom pagination\n        &gt;&gt;&gt; pagination = PaginationDTO(page=2, page_size=25)\n        &gt;&gt;&gt; print(pagination.offset)  # Access offset as a property\n        25\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using with a database query\n        &gt;&gt;&gt; def get_users(pagination: PaginationDTO):\n        ...     query = select(User).offset(pagination.offset).limit(pagination.page_size)\n        ...     return db.execute(query).scalars().all()\n    \"\"\"\n\n    page: int = Field(default=1, ge=1, description=\"Page number (1-indexed)\")\n    page_size: int = Field(default=10, ge=1, le=100, description=\"Number of items per page\")\n\n    MAX_ITEMS: ClassVar = 10000\n\n    @model_validator(mode=\"after\")\n    def validate_pagination(self) -&gt; Self:\n        \"\"\"Validate pagination limits to prevent excessive resource usage.\n\n        Ensures that the requested number of items (page * page_size) doesn't exceed\n        the maximum allowed limit.\n\n        Returns:\n            The validated model instance if valid.\n\n        Raises:\n            OutOfRangeError: If the total requested items exceeds MAX_ITEMS.\n        \"\"\"\n        total_items = self.page * self.page_size\n        if total_items &gt; self.MAX_ITEMS:\n            raise OutOfRangeError(field_name=\"pagination\")\n        return self\n\n    @property\n    def offset(self) -&gt; int:\n        \"\"\"Calculate the offset for database queries.\n\n        This property calculates how many records to skip based on the\n        current page and page size.\n\n        Returns:\n            int: The number of records to skip\n\n        Examples:\n            &gt;&gt;&gt; pagination = PaginationDTO(page=3, page_size=20)\n            &gt;&gt;&gt; pagination.offset\n            40  # Skip the first 40 records (2 pages of 20 items)\n        \"\"\"\n        return (self.page - 1) * self.page_size\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.pagination_dto.PaginationDTO.offset","title":"<code>archipy.models.dtos.pagination_dto.PaginationDTO.offset</code>  <code>property</code>","text":"<p>Calculate the offset for database queries.</p> <p>This property calculates how many records to skip based on the current page and page size.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of records to skip</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pagination = PaginationDTO(page=3, page_size=20)\n&gt;&gt;&gt; pagination.offset\n40  # Skip the first 40 records (2 pages of 20 items)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.pagination_dto.PaginationDTO.validate_pagination","title":"<code>archipy.models.dtos.pagination_dto.PaginationDTO.validate_pagination()</code>","text":"<p>Validate pagination limits to prevent excessive resource usage.</p> <p>Ensures that the requested number of items (page * page_size) doesn't exceed the maximum allowed limit.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated model instance if valid.</p> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If the total requested items exceeds MAX_ITEMS.</p> Source code in <code>archipy/models/dtos/pagination_dto.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_pagination(self) -&gt; Self:\n    \"\"\"Validate pagination limits to prevent excessive resource usage.\n\n    Ensures that the requested number of items (page * page_size) doesn't exceed\n    the maximum allowed limit.\n\n    Returns:\n        The validated model instance if valid.\n\n    Raises:\n        OutOfRangeError: If the total requested items exceeds MAX_ITEMS.\n    \"\"\"\n    total_items = self.page * self.page_size\n    if total_items &gt; self.MAX_ITEMS:\n        raise OutOfRangeError(field_name=\"pagination\")\n    return self\n</code></pre>"},{"location":"api_reference/models/#range-dtos","title":"Range DTOs","text":"<p>Handles range-based queries and filters.</p> <pre><code>from archipy.models.dtos.range_dtos import (\n    RangeDTO,\n    IntegerRangeDTO,\n    DateRangeDTO,\n    DatetimeRangeDTO\n)\n\n# Integer range\nint_range = IntegerRangeDTO(start=1, end=100)\n\n# Date range\ndate_range = DateRangeDTO(\n    start=date(2023, 1, 1),\n    end=date(2023, 12, 31)\n)\n\n# Datetime range\ndt_range = DatetimeRangeDTO(\n    start=datetime(2023, 1, 1),\n    end=datetime(2023, 12, 31)\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.BaseRangeDTO","title":"<code>archipy.models.dtos.range_dtos.BaseRangeDTO</code>","text":"<p>               Bases: <code>BaseDTO</code>, <code>Generic[R]</code></p> <p>Base Data Transfer Object for range queries.</p> <p>Encapsulates a range of values with from_ and to fields. Provides validation to ensure range integrity.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class BaseRangeDTO(BaseDTO, Generic[R]):\n    \"\"\"Base Data Transfer Object for range queries.\n\n    Encapsulates a range of values with from_ and to fields.\n    Provides validation to ensure range integrity.\n    \"\"\"\n\n    from_: R | None = None\n    to: R | None = None\n\n    @model_validator(mode=\"after\")\n    def validate_range(self) -&gt; Self:\n        \"\"\"Validate that from_ is less than or equal to to when both are provided.\n\n        Returns:\n            Self: The validated model instance.\n\n        Raises:\n            OutOfRangeError: If from_ is greater than to.\n        \"\"\"\n        if self.from_ is not None and self.to is not None and self.from_ &gt; self.to:\n            raise OutOfRangeError(field_name=\"from_\")\n        return self\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.BaseRangeDTO.validate_range","title":"<code>archipy.models.dtos.range_dtos.BaseRangeDTO.validate_range()</code>","text":"<p>Validate that from_ is less than or equal to to when both are provided.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The validated model instance.</p> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If from_ is greater than to.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_range(self) -&gt; Self:\n    \"\"\"Validate that from_ is less than or equal to to when both are provided.\n\n    Returns:\n        Self: The validated model instance.\n\n    Raises:\n        OutOfRangeError: If from_ is greater than to.\n    \"\"\"\n    if self.from_ is not None and self.to is not None and self.from_ &gt; self.to:\n        raise OutOfRangeError(field_name=\"from_\")\n    return self\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DecimalRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DecimalRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[Decimal]</code></p> <p>Data Transfer Object for decimal range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DecimalRangeDTO(BaseRangeDTO[Decimal]):\n    \"\"\"Data Transfer Object for decimal range queries.\"\"\"\n\n    from_: Decimal | None = None\n    to: Decimal | None = None\n\n    @field_validator(\"from_\", \"to\", mode=\"before\")\n    @classmethod\n    def convert_to_decimal(cls, value: Decimal | str | None) -&gt; Decimal | None:\n        \"\"\"Convert input values to Decimal type.\n\n        Args:\n            value: The value to convert (None, string, or Decimal).\n\n        Returns:\n            Decimal | None: The converted Decimal value or None.\n\n        Raises:\n            InvalidArgumentError: If the value cannot be converted to Decimal.\n        \"\"\"\n        if value is None:\n            return None\n        try:\n            return Decimal(value)\n        except (TypeError, ValueError) as e:\n            raise InvalidArgumentError(argument_name=\"value\") from e\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DecimalRangeDTO.convert_to_decimal","title":"<code>archipy.models.dtos.range_dtos.DecimalRangeDTO.convert_to_decimal(value)</code>  <code>classmethod</code>","text":"<p>Convert input values to Decimal type.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal | str | None</code> <p>The value to convert (None, string, or Decimal).</p> required <p>Returns:</p> Type Description <code>Decimal | None</code> <p>Decimal | None: The converted Decimal value or None.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the value cannot be converted to Decimal.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>@field_validator(\"from_\", \"to\", mode=\"before\")\n@classmethod\ndef convert_to_decimal(cls, value: Decimal | str | None) -&gt; Decimal | None:\n    \"\"\"Convert input values to Decimal type.\n\n    Args:\n        value: The value to convert (None, string, or Decimal).\n\n    Returns:\n        Decimal | None: The converted Decimal value or None.\n\n    Raises:\n        InvalidArgumentError: If the value cannot be converted to Decimal.\n    \"\"\"\n    if value is None:\n        return None\n    try:\n        return Decimal(value)\n    except (TypeError, ValueError) as e:\n        raise InvalidArgumentError(argument_name=\"value\") from e\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.IntegerRangeDTO","title":"<code>archipy.models.dtos.range_dtos.IntegerRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[int]</code></p> <p>Data Transfer Object for integer range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class IntegerRangeDTO(BaseRangeDTO[int]):\n    \"\"\"Data Transfer Object for integer range queries.\"\"\"\n\n    from_: int | None = None\n    to: int | None = None\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DateRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DateRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[date]</code></p> <p>Data Transfer Object for date range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DateRangeDTO(BaseRangeDTO[date]):\n    \"\"\"Data Transfer Object for date range queries.\"\"\"\n\n    from_: date | None = None\n    to: date | None = None\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DatetimeRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DatetimeRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[datetime]</code></p> <p>Data Transfer Object for datetime range queries.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DatetimeRangeDTO(BaseRangeDTO[datetime]):\n    \"\"\"Data Transfer Object for datetime range queries.\"\"\"\n\n    from_: datetime | None = None\n    to: datetime | None = None\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO","title":"<code>archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO</code>","text":"<p>               Bases: <code>BaseRangeDTO[datetime]</code></p> <p>Data Transfer Object for datetime range queries with interval.</p> <p>Rejects requests if the number of intervals exceeds MAX_ITEMS or if interval-specific range size or 'to' age constraints are violated.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>class DatetimeIntervalRangeDTO(BaseRangeDTO[datetime]):\n    \"\"\"Data Transfer Object for datetime range queries with interval.\n\n    Rejects requests if the number of intervals exceeds MAX_ITEMS or if interval-specific\n    range size or 'to' age constraints are violated.\n    \"\"\"\n\n    from_: datetime\n    to: datetime\n    interval: TimeIntervalUnitType\n\n    # Maximum number of intervals allowed\n    MAX_ITEMS: ClassVar[int] = 100\n\n    # Range size limits for each interval\n    RANGE_SIZE_LIMITS: ClassVar[dict[TimeIntervalUnitType, timedelta]] = {\n        TimeIntervalUnitType.SECONDS: timedelta(days=2),\n        TimeIntervalUnitType.MINUTES: timedelta(days=7),\n        TimeIntervalUnitType.HOURS: timedelta(days=30),\n        TimeIntervalUnitType.DAYS: timedelta(days=365),\n        TimeIntervalUnitType.WEEKS: timedelta(days=365 * 2),\n        TimeIntervalUnitType.MONTHS: timedelta(days=365 * 5),  # No limit for MONTHS, set high\n        TimeIntervalUnitType.YEAR: timedelta(days=365 * 10),  # No limit for YEAR, set high\n    }\n\n    # 'to' age limits for each interval\n    TO_AGE_LIMITS: ClassVar[dict[TimeIntervalUnitType, timedelta]] = {\n        TimeIntervalUnitType.SECONDS: timedelta(days=2),\n        TimeIntervalUnitType.MINUTES: timedelta(days=7),\n        TimeIntervalUnitType.HOURS: timedelta(days=30),\n        TimeIntervalUnitType.DAYS: timedelta(days=365 * 5),\n        TimeIntervalUnitType.WEEKS: timedelta(days=365 * 10),\n        TimeIntervalUnitType.MONTHS: timedelta(days=365 * 20),  # No limit for MONTHS, set high\n        TimeIntervalUnitType.YEAR: timedelta(days=365 * 50),  # No limit for YEAR, set high\n    }\n\n    # Mapping of intervals to timedelta for step size\n    INTERVAL_TO_TIMEDELTA: ClassVar[dict[TimeIntervalUnitType, timedelta]] = {\n        TimeIntervalUnitType.SECONDS: timedelta(seconds=1),\n        TimeIntervalUnitType.MINUTES: timedelta(minutes=1),\n        TimeIntervalUnitType.HOURS: timedelta(hours=1),\n        TimeIntervalUnitType.DAYS: timedelta(days=1),\n        TimeIntervalUnitType.WEEKS: timedelta(weeks=1),\n        TimeIntervalUnitType.MONTHS: timedelta(days=30),  # Approximate\n        TimeIntervalUnitType.YEAR: timedelta(days=365),  # Approximate\n    }\n\n    @model_validator(mode=\"after\")\n    def validate_interval_constraints(self) -&gt; Self:\n        \"\"\"Validate interval based on range size, 'to' field age, and max intervals.\n\n        - Each interval has specific range size and 'to' age limits.\n        - Rejects if the number of intervals exceeds MAX_ITEMS.\n\n        Returns:\n            Self: The validated model instance.\n\n        Raises:\n            OutOfRangeError: If interval constraints are violated or number of intervals &gt; MAX_ITEMS.\n        \"\"\"\n        if self.from_ is not None and self.to is not None:\n            # Validate range size limit for the selected interval\n            range_size = self.to - self.from_\n            max_range_size = self.RANGE_SIZE_LIMITS.get(self.interval)\n            if max_range_size and range_size &gt; max_range_size:\n                raise OutOfRangeError(field_name=\"range_size\")\n\n            # Validate 'to' age limit\n            current_time = datetime.now()\n            max_to_age = self.TO_AGE_LIMITS.get(self.interval)\n            if max_to_age:\n                age_threshold = current_time - max_to_age\n                if self.to &lt; age_threshold:\n                    raise OutOfRangeError(field_name=\"to\")\n\n            # Calculate number of intervals\n            step = self.INTERVAL_TO_TIMEDELTA[self.interval]\n            range_duration = self.to - self.from_\n            num_intervals = int(range_duration.total_seconds() / step.total_seconds()) + 1\n\n            # Reject if number of intervals exceeds MAX_ITEMS\n            if num_intervals &gt; self.MAX_ITEMS:\n                raise OutOfRangeError(field_name=\"interval_count\")\n\n        return self\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO.validate_interval_constraints","title":"<code>archipy.models.dtos.range_dtos.DatetimeIntervalRangeDTO.validate_interval_constraints()</code>","text":"<p>Validate interval based on range size, 'to' field age, and max intervals.</p> <ul> <li>Each interval has specific range size and 'to' age limits.</li> <li>Rejects if the number of intervals exceeds MAX_ITEMS.</li> </ul> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The validated model instance.</p> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If interval constraints are violated or number of intervals &gt; MAX_ITEMS.</p> Source code in <code>archipy/models/dtos/range_dtos.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_interval_constraints(self) -&gt; Self:\n    \"\"\"Validate interval based on range size, 'to' field age, and max intervals.\n\n    - Each interval has specific range size and 'to' age limits.\n    - Rejects if the number of intervals exceeds MAX_ITEMS.\n\n    Returns:\n        Self: The validated model instance.\n\n    Raises:\n        OutOfRangeError: If interval constraints are violated or number of intervals &gt; MAX_ITEMS.\n    \"\"\"\n    if self.from_ is not None and self.to is not None:\n        # Validate range size limit for the selected interval\n        range_size = self.to - self.from_\n        max_range_size = self.RANGE_SIZE_LIMITS.get(self.interval)\n        if max_range_size and range_size &gt; max_range_size:\n            raise OutOfRangeError(field_name=\"range_size\")\n\n        # Validate 'to' age limit\n        current_time = datetime.now()\n        max_to_age = self.TO_AGE_LIMITS.get(self.interval)\n        if max_to_age:\n            age_threshold = current_time - max_to_age\n            if self.to &lt; age_threshold:\n                raise OutOfRangeError(field_name=\"to\")\n\n        # Calculate number of intervals\n        step = self.INTERVAL_TO_TIMEDELTA[self.interval]\n        range_duration = self.to - self.from_\n        num_intervals = int(range_duration.total_seconds() / step.total_seconds()) + 1\n\n        # Reject if number of intervals exceeds MAX_ITEMS\n        if num_intervals &gt; self.MAX_ITEMS:\n            raise OutOfRangeError(field_name=\"interval_count\")\n\n    return self\n</code></pre>"},{"location":"api_reference/models/#search-input-dto","title":"Search Input DTO","text":"<p>Standardized search parameters.</p> <pre><code>from archipy.models.dtos.search_input_dto import SearchInputDTO\n\nsearch = SearchInputDTO[str](\n    query=\"john\",\n    filters={\"active\": True},\n    pagination=pagination\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.search_input_dto.SearchInputDTO","title":"<code>archipy.models.dtos.search_input_dto.SearchInputDTO</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Data Transfer Object for search inputs with pagination and sorting.</p> <p>This DTO encapsulates search parameters for database queries and API responses, providing a standard way to handle pagination and sorting.</p> Type Parameters <p>T: The type for sort column (usually an Enum with column names).</p> Source code in <code>archipy/models/dtos/search_input_dto.py</code> <pre><code>class SearchInputDTO(BaseModel, Generic[T]):\n    \"\"\"Data Transfer Object for search inputs with pagination and sorting.\n\n    This DTO encapsulates search parameters for database queries and API responses,\n    providing a standard way to handle pagination and sorting.\n\n    Type Parameters:\n        T: The type for sort column (usually an Enum with column names).\n    \"\"\"\n\n    pagination: PaginationDTO | None = None\n    sort_info: SortDTO[T] | None = None\n</code></pre>"},{"location":"api_reference/models/#sort-dto","title":"Sort DTO","text":"<p>Handles sorting parameters for queries.</p> <pre><code>from archipy.models.dtos.sort_dto import SortDTO\n\nsort = SortDTO[str](\n    field=\"created_at\",\n    order=\"desc\"\n)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.dtos.sort_dto.SortDTO","title":"<code>archipy.models.dtos.sort_dto.SortDTO</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Data Transfer Object for sorting parameters.</p> <p>This DTO encapsulates sorting information for database queries and API responses, providing a standard way to specify how results should be ordered.</p> <p>Attributes:</p> Name Type Description <code>column</code> <code>T | str</code> <p>The name or enum value of the column to sort by</p> <code>order</code> <code>str</code> <p>The sort direction - \"ASC\" for ascending, \"DESC\" for descending</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.models.dtos.sort_dto import SortDTO\n&gt;&gt;&gt; from archipy.models.types.sort_order_type import SortOrderType\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Sort by name in ascending order\n&gt;&gt;&gt; sort = SortDTO(column=\"name\", order=SortOrderType.ASCENDING)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Sort by creation date in descending order (newest first)\n&gt;&gt;&gt; sort = SortDTO(column=\"created_at\", order=\"DESCENDING\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using with a database query\n&gt;&gt;&gt; def get_sorted_users(sort: SortDTO = SortDTO.default()):\n...     query = select(User)\n...     if sort.order == SortOrderType.ASCENDING:\n...         query = query.order_by(getattr(User, sort.column).asc())\n...     else:\n...         query = query.order_by(getattr(User, sort.column).desc())\n...     return db.execute(query).scalars().all()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using with enum column types\n&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; class UserColumns(Enum):\n...     ID = \"id\"\n...     NAME = \"name\"\n...     EMAIL = \"email\"\n...     CREATED_AT = \"created_at\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a sort configuration with enum\n&gt;&gt;&gt; sort = SortDTO[UserColumns](column=UserColumns.NAME, order=SortOrderType.ASCENDING)\n</code></pre> Source code in <code>archipy/models/dtos/sort_dto.py</code> <pre><code>class SortDTO(BaseModel, Generic[T]):\n    \"\"\"Data Transfer Object for sorting parameters.\n\n    This DTO encapsulates sorting information for database queries and API responses,\n    providing a standard way to specify how results should be ordered.\n\n    Attributes:\n        column (T | str): The name or enum value of the column to sort by\n        order (str): The sort direction - \"ASC\" for ascending, \"DESC\" for descending\n\n    Examples:\n        &gt;&gt;&gt; from archipy.models.dtos.sort_dto import SortDTO\n        &gt;&gt;&gt; from archipy.models.types.sort_order_type import SortOrderType\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Sort by name in ascending order\n        &gt;&gt;&gt; sort = SortDTO(column=\"name\", order=SortOrderType.ASCENDING)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Sort by creation date in descending order (newest first)\n        &gt;&gt;&gt; sort = SortDTO(column=\"created_at\", order=\"DESCENDING\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using with a database query\n        &gt;&gt;&gt; def get_sorted_users(sort: SortDTO = SortDTO.default()):\n        ...     query = select(User)\n        ...     if sort.order == SortOrderType.ASCENDING:\n        ...         query = query.order_by(getattr(User, sort.column).asc())\n        ...     else:\n        ...         query = query.order_by(getattr(User, sort.column).desc())\n        ...     return db.execute(query).scalars().all()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using with enum column types\n        &gt;&gt;&gt; from enum import Enum\n        &gt;&gt;&gt; class UserColumns(Enum):\n        ...     ID = \"id\"\n        ...     NAME = \"name\"\n        ...     EMAIL = \"email\"\n        ...     CREATED_AT = \"created_at\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a sort configuration with enum\n        &gt;&gt;&gt; sort = SortDTO[UserColumns](column=UserColumns.NAME, order=SortOrderType.ASCENDING)\n    \"\"\"\n\n    column: T | str = Field(default=\"created_at\", description=\"Column name or enum to sort by\")\n    order: SortOrderType = Field(default=SortOrderType.DESCENDING, description=\"Sort order (ASCENDING or DESCENDING)\")\n\n    @classmethod\n    def default(cls) -&gt; \"SortDTO\":\n        \"\"\"Create a default sort configuration.\n\n        Returns a sort configuration that orders by created_at in descending order\n        (newest first), which is a common default sorting behavior.\n\n        Returns:\n            SortDTO: A default sort configuration\n\n        Examples:\n            &gt;&gt;&gt; default_sort = SortDTO.default()\n            &gt;&gt;&gt; print(f\"Sort by {default_sort.column} {default_sort.order}\")\n            Sort by created_at DESCENDING\n        \"\"\"\n        return cls(column=\"created_at\", order=SortOrderType.DESCENDING)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.dtos.sort_dto.SortDTO.default","title":"<code>archipy.models.dtos.sort_dto.SortDTO.default()</code>  <code>classmethod</code>","text":"<p>Create a default sort configuration.</p> <p>Returns a sort configuration that orders by created_at in descending order (newest first), which is a common default sorting behavior.</p> <p>Returns:</p> Name Type Description <code>SortDTO</code> <code>SortDTO</code> <p>A default sort configuration</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; default_sort = SortDTO.default()\n&gt;&gt;&gt; print(f\"Sort by {default_sort.column} {default_sort.order}\")\nSort by created_at DESCENDING\n</code></pre> Source code in <code>archipy/models/dtos/sort_dto.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"SortDTO\":\n    \"\"\"Create a default sort configuration.\n\n    Returns a sort configuration that orders by created_at in descending order\n    (newest first), which is a common default sorting behavior.\n\n    Returns:\n        SortDTO: A default sort configuration\n\n    Examples:\n        &gt;&gt;&gt; default_sort = SortDTO.default()\n        &gt;&gt;&gt; print(f\"Sort by {default_sort.column} {default_sort.order}\")\n        Sort by created_at DESCENDING\n    \"\"\"\n    return cls(column=\"created_at\", order=SortOrderType.DESCENDING)\n</code></pre>"},{"location":"api_reference/models/#entities","title":"Entities","text":""},{"location":"api_reference/models/#sqlalchemy-base-entities","title":"SQLAlchemy Base Entities","text":"<p>Base classes for SQLAlchemy entities with various mixins for different capabilities.</p> <pre><code>from archipy.models.entities.sqlalchemy.base_entities import (\n    BaseEntity,\n    UpdatableEntity,\n    DeletableEntity,\n    AdminEntity,\n    ManagerEntity,\n    UpdatableDeletableEntity,\n    ArchivableEntity,\n    UpdatableAdminEntity,\n    UpdatableManagerEntity,\n    ArchivableDeletableEntity,\n    UpdatableDeletableAdminEntity,\n    UpdatableDeletableManagerEntity,\n    ArchivableAdminEntity,\n    ArchivableManagerEntity,\n    UpdatableManagerAdminEntity,\n    ArchivableManagerAdminEntity,\n    ArchivableDeletableAdminEntity,\n    ArchivableDeletableManagerEntity,\n    UpdatableDeletableManagerAdminEntity,\n    ArchivableDeletableManagerAdminEntity\n)\nfrom sqlalchemy import Column, String\n\n# Basic entity\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n# Entity with update tracking\nclass Post(UpdatableEntity):\n    __tablename__ = \"posts\"\n    title = Column(String(200))\n    content = Column(String)\n\n# Entity with soft deletion\nclass Comment(DeletableEntity):\n    __tablename__ = \"comments\"\n    text = Column(String)\n\n# Entity with admin tracking\nclass AdminLog(AdminEntity):\n    __tablename__ = \"admin_logs\"\n    action = Column(String)\n\n# Entity with manager tracking\nclass ManagerLog(ManagerEntity):\n    __tablename__ = \"manager_logs\"\n    action = Column(String)\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.BaseEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity</code>","text":"<p>               Bases: <code>DeclarativeBase</code></p> <p>Base class for all SQLAlchemy models with automatic timestamps.</p> <p>This class serves as the base for all entities in the application. It provides common functionality such as automatic timestamping for <code>created_at</code> and validation for the primary key column.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class BaseEntity(DeclarativeBase):\n    \"\"\"Base class for all SQLAlchemy models with automatic timestamps.\n\n    This class serves as the base for all entities in the application. It provides\n    common functionality such as automatic timestamping for `created_at` and\n    validation for the primary key column.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n    \"\"\"\n\n    __abstract__ = True\n    created_at: Mapped[datetime] = Column(DateTime(), server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False)\n\n    @classmethod\n    def _is_abstract(cls) -&gt; bool:\n        \"\"\"Check if the class is abstract.\n\n        Returns:\n            bool: True if the class is abstract, False otherwise.\n        \"\"\"\n        return (not hasattr(cls, \"__tablename__\")) and cls.__abstract__\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n\n        Raises:\n            AttributeError: If the subclass does not have the required primary key column.\n        \"\"\"\n        if cls._is_abstract():\n            return\n        cls._validate_pk_column()\n        super().__init_subclass__(**kw)\n\n    @classmethod\n    def _validate_pk_column(cls) -&gt; None:\n        \"\"\"Validate that the subclass has the required primary key column.\n\n        Raises:\n            AttributeError: If the primary key column is missing or invalid.\n        \"\"\"\n        if not hasattr(cls, PK_COLUMN_NAME):\n            error_message = f\"Child class {cls.__name__} must have {PK_COLUMN_NAME}\"\n            raise AttributeError(error_message)\n        pk_column = getattr(cls, PK_COLUMN_NAME)\n        if not isinstance(pk_column, Synonym):\n            error_message = f\"{PK_COLUMN_NAME} must be a sqlalchemy.orm.Synonym type\"\n            raise TypeError(error_message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.BaseEntity.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the subclass does not have the required primary key column.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n\n    Raises:\n        AttributeError: If the subclass does not have the required primary key column.\n    \"\"\"\n    if cls._is_abstract():\n        return\n    cls._validate_pk_column()\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker","title":"<code>archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker</code>","text":"<p>Utility class for validating model attributes.</p> <p>This class provides functionality to ensure that at least one of the specified attributes is present in a model.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>A list of lists, where each inner list contains attribute names. At least one attribute from each inner list must be present.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class EntityAttributeChecker:\n    \"\"\"Utility class for validating model attributes.\n\n    This class provides functionality to ensure that at least one of the specified\n    attributes is present in a model.\n\n    Attributes:\n        required_any: A list of lists, where each inner list contains\n            attribute names. At least one attribute from each inner list must be present.\n    \"\"\"\n\n    required_any: ClassVar[list[list[str]]] = []\n\n    @classmethod\n    def validate(cls, base_class: type) -&gt; None:\n        \"\"\"Validate that at least one of the required attributes is present.\n\n        Args:\n            base_class: The class to validate.\n\n        Raises:\n            AttributeError: If none of the required attributes are present.\n        \"\"\"\n        for attrs in cls.required_any:\n            if not any(hasattr(base_class, attr) for attr in attrs):\n                error_message = f\"One of {attrs} must be defined in {base_class.__name__}\"\n                raise AttributeError(error_message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker.validate","title":"<code>archipy.models.entities.sqlalchemy.base_entities.EntityAttributeChecker.validate(base_class)</code>  <code>classmethod</code>","text":"<p>Validate that at least one of the required attributes is present.</p> <p>Parameters:</p> Name Type Description Default <code>base_class</code> <code>type</code> <p>The class to validate.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If none of the required attributes are present.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>@classmethod\ndef validate(cls, base_class: type) -&gt; None:\n    \"\"\"Validate that at least one of the required attributes is present.\n\n    Args:\n        base_class: The class to validate.\n\n    Raises:\n        AttributeError: If none of the required attributes are present.\n    \"\"\"\n    for attrs in cls.required_any:\n        if not any(hasattr(base_class, attr) for attr in attrs):\n            error_message = f\"One of {attrs} must be defined in {base_class.__name__}\"\n            raise AttributeError(error_message)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.DeletableMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.DeletableMixin</code>","text":"<p>Mixin to add a deletable flag to models.</p> <p>This mixin adds an <code>is_deleted</code> column to indicate whether the entity has been soft-deleted, allowing for logical deletion without physically removing records.</p> <p>Attributes:</p> Name Type Description <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class DeletableMixin:\n    \"\"\"Mixin to add a deletable flag to models.\n\n    This mixin adds an `is_deleted` column to indicate whether the entity has been\n    soft-deleted, allowing for logical deletion without physically removing records.\n\n    Attributes:\n        is_deleted: Flag indicating if the entity is deleted.\n    \"\"\"\n\n    __abstract__ = True\n    is_deleted = Column(Boolean, default=False, nullable=False)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableMixin</code>","text":"<p>Mixin to add updatable timestamp functionality.</p> <p>This mixin adds an <code>updated_at</code> column to track the last update time of the entity, automatically maintaining a timestamp of the most recent modification.</p> <p>Attributes:</p> Name Type Description <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableMixin:\n    \"\"\"Mixin to add updatable timestamp functionality.\n\n    This mixin adds an `updated_at` column to track the last update time of the entity,\n    automatically maintaining a timestamp of the most recent modification.\n\n    Attributes:\n        updated_at: Timestamp indicating when the entity was last updated.\n    \"\"\"\n\n    __abstract__ = True\n    updated_at = Column(\n        DateTime(),\n        default=BaseUtils.get_datetime_now,\n        nullable=False,\n        onupdate=BaseUtils.get_datetime_now,\n    )\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableMixin</code>","text":"<p>Mixin to add Archivable functionality.</p> <p>This mixin adds an <code>is_archived</code> column to indicate whether the entity has been archived, and an <code>origin_uuid</code> column to reference the original entity.</p> <p>Attributes:</p> Name Type Description <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableMixin:\n    \"\"\"Mixin to add Archivable functionality.\n\n    This mixin adds an `is_archived` column to indicate whether the entity has been\n    archived, and an `origin_uuid` column to reference the original entity.\n\n    Attributes:\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n    \"\"\"\n\n    __abstract__ = True\n    is_archived = Column(Boolean, default=False, nullable=False)\n    # Using Column without Mapped is acceptable since Column works with BaseEntity.__table__\n    origin_uuid = Column(ForeignKey(\"self.pk_uuid\"), nullable=True)  # type: ignore[var-annotated]\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.AdminMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.AdminMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models with admin-related attributes.</p> <p>This mixin ensures that at least one of the admin-related attributes is present, providing tracking of which administrator created the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required admin-related attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class AdminMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models with admin-related attributes.\n\n    This mixin ensures that at least one of the admin-related attributes is present,\n    providing tracking of which administrator created the entity.\n\n    Attributes:\n        required_any: Specifies the required admin-related attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"created_by_admin\", \"created_by_admin_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.AdminMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.AdminMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ManagerMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ManagerMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models with manager-related attributes.</p> <p>This mixin ensures that at least one of the manager-related attributes is present, providing tracking of which manager created the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required manager-related attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ManagerMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models with manager-related attributes.\n\n    This mixin ensures that at least one of the manager-related attributes is present,\n    providing tracking of which manager created the entity.\n\n    Attributes:\n        required_any: Specifies the required manager-related attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"created_by\", \"created_by_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ManagerMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ManagerMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models updatable by admin.</p> <p>This mixin ensures that at least one of the admin-related update attributes is present, providing tracking of which administrator last updated the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required admin-related update attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableAdminMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models updatable by admin.\n\n    This mixin ensures that at least one of the admin-related update attributes is present,\n    providing tracking of which administrator last updated the entity.\n\n    Attributes:\n        required_any: Specifies the required admin-related update attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"updated_by_admin\", \"updated_by_admin_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin</code>","text":"<p>               Bases: <code>EntityAttributeChecker</code></p> <p>Mixin for models updatable by managers.</p> <p>This mixin ensures that at least one of the manager-related update attributes is present, providing tracking of which manager last updated the entity.</p> <p>Attributes:</p> Name Type Description <code>required_any</code> <code>list[list[str]]</code> <p>Specifies the required manager-related update attributes.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableManagerMixin(EntityAttributeChecker):\n    \"\"\"Mixin for models updatable by managers.\n\n    This mixin ensures that at least one of the manager-related update attributes is present,\n    providing tracking of which manager last updated the entity.\n\n    Attributes:\n        required_any: Specifies the required manager-related update attributes.\n    \"\"\"\n\n    __abstract__ = True\n    required_any: ClassVar[list[list[str]]] = [[\"updated_by\", \"updated_by_uuid\"]]\n\n    def __init_subclass__(cls, **kw: object) -&gt; None:\n        \"\"\"Validate the subclass during initialization.\n\n        Args:\n            **kw: Additional keyword arguments passed to the subclass.\n        \"\"\"\n        cls.validate(cls)\n        super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin.__init_subclass__","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerMixin.__init_subclass__(**kw)</code>","text":"<p>Validate the subclass during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**kw</code> <code>object</code> <p>Additional keyword arguments passed to the subclass.</p> <code>{}</code> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>def __init_subclass__(cls, **kw: object) -&gt; None:\n    \"\"\"Validate the subclass during initialization.\n\n    Args:\n        **kw: Additional keyword arguments passed to the subclass.\n    \"\"\"\n    cls.validate(cls)\n    super().__init_subclass__(**kw)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code></p> <p>Base class for entities that support updating timestamps.</p> <p>This class extends BaseEntity with update tracking functionality, allowing applications to track when records were last modified.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableEntity(BaseEntity, UpdatableMixin):\n    \"\"\"Base class for entities that support updating timestamps.\n\n    This class extends BaseEntity with update tracking functionality, allowing\n    applications to track when records were last modified.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.DeletableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.DeletableEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>DeletableMixin</code></p> <p>Base class for entities that support soft deletion.</p> <p>This class extends BaseEntity with soft deletion capability, allowing applications to mark records as deleted without physically removing them.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class DeletableEntity(BaseEntity, DeletableMixin):\n    \"\"\"Base class for entities that support soft deletion.\n\n    This class extends BaseEntity with soft deletion capability, allowing\n    applications to mark records as deleted without physically removing them.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        is_deleted: Flag indicating if the entity is deleted.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.AdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.AdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>AdminMixin</code></p> <p>Base class for entities with admin-related attributes.</p> <p>This class extends BaseEntity with tracking of which administrator created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>created_by_admin/created_by_admin_uuid</code> <code>Mapped[datetime]</code> <p>Reference to the admin who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class AdminEntity(BaseEntity, AdminMixin):\n    \"\"\"Base class for entities with admin-related attributes.\n\n    This class extends BaseEntity with tracking of which administrator created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ManagerEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>ManagerMixin</code></p> <p>Base class for entities with manager-related attributes.</p> <p>This class extends BaseEntity with tracking of which manager created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>created_by/created_by_uuid</code> <code>Mapped[datetime]</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ManagerEntity(BaseEntity, ManagerMixin):\n    \"\"\"Base class for entities with manager-related attributes.\n\n    This class extends BaseEntity with tracking of which manager created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities that support updating timestamps and soft deletion.</p> <p>This class combines update tracking and soft deletion capabilities, providing a complete history of when records were created, updated, and deleted.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableEntity(BaseEntity, UpdatableMixin, DeletableMixin):\n    \"\"\"Base class for entities that support updating timestamps and soft deletion.\n\n    This class combines update tracking and soft deletion capabilities, providing\n    a complete history of when records were created, updated, and deleted.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableEntity</code>","text":"<p>               Bases: <code>UpdatableEntity</code>, <code>ArchivableMixin</code></p> <p>Base class for entities that support archiving.</p> <p>This class extends UpdatableEntity with archiving capability, allowing applications to mark records as archived and track the original entity.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableEntity(UpdatableEntity, ArchivableMixin):\n    \"\"\"Base class for entities that support archiving.\n\n    This class extends UpdatableEntity with archiving capability, allowing\n    applications to mark records as archived and track the original entity.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>AdminMixin</code>, <code>UpdatableAdminMixin</code></p> <p>Base class for entities updatable by admin with timestamps.</p> <p>This class combines creation and update tracking for administrator actions, providing a comprehensive audit trail of administrative modifications.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableAdminEntity(BaseEntity, UpdatableMixin, AdminMixin, UpdatableAdminMixin):\n    \"\"\"Base class for entities updatable by admin with timestamps.\n\n    This class combines creation and update tracking for administrator actions,\n    providing a comprehensive audit trail of administrative modifications.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>UpdatableManagerMixin</code></p> <p>Base class for entities updatable by managers with timestamps.</p> <p>This class combines creation and update tracking for manager actions, providing a comprehensive audit trail of management modifications.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableManagerEntity(BaseEntity, UpdatableMixin, ManagerMixin, UpdatableManagerMixin):\n    \"\"\"Base class for entities updatable by managers with timestamps.\n\n    This class combines creation and update tracking for manager actions,\n    providing a comprehensive audit trail of management modifications.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableEntity</code>","text":"<p>               Bases: <code>UpdatableDeletableEntity</code>, <code>ArchivableMixin</code></p> <p>Base class for entities that support both archiving and soft deletion.</p> <p>This class combines archiving and soft deletion capabilities, providing a complete history of when records were created, updated, archived, and deleted.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableEntity(UpdatableDeletableEntity, ArchivableMixin):\n    \"\"\"Base class for entities that support both archiving and soft deletion.\n\n    This class combines archiving and soft deletion capabilities, providing\n    a complete history of when records were created, updated, archived, and deleted.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>AdminMixin</code>, <code>UpdatableAdminMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities updatable by admin with timestamps and soft deletion.</p> <p>This class combines administrator creation and update tracking with soft deletion, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableAdminEntity(BaseEntity, UpdatableMixin, AdminMixin, UpdatableAdminMixin, DeletableMixin):\n    \"\"\"Base class for entities updatable by admin with timestamps and soft deletion.\n\n    This class combines administrator creation and update tracking with soft deletion,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>UpdatableManagerMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities updatable by managers with timestamps and soft deletion.</p> <p>This class combines manager creation and update tracking with soft deletion, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableManagerEntity(BaseEntity, UpdatableMixin, ManagerMixin, UpdatableManagerMixin, DeletableMixin):\n    \"\"\"Base class for entities updatable by managers with timestamps and soft deletion.\n\n    This class combines manager creation and update tracking with soft deletion,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableAdminEntity</code>","text":"<p>               Bases: <code>ArchivableEntity</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable by admin.</p> <p>This class extends ArchivableEntity with tracking of which administrator created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableAdminEntity(ArchivableEntity, AdminMixin):\n    \"\"\"Base class for entities Archivable by admin.\n\n    This class extends ArchivableEntity with tracking of which administrator created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerEntity</code>","text":"<p>               Bases: <code>ArchivableEntity</code>, <code>ManagerMixin</code></p> <p>Base class for entities Archivable by managers.</p> <p>This class extends ArchivableEntity with tracking of which manager created the entity, supporting audit and accountability requirements.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableManagerEntity(ArchivableEntity, ManagerMixin):\n    \"\"\"Base class for entities Archivable by managers.\n\n    This class extends ArchivableEntity with tracking of which manager created\n    the entity, supporting audit and accountability requirements.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableManagerAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>AdminMixin</code>, <code>UpdatableManagerMixin</code>, <code>UpdatableAdminMixin</code></p> <p>Base class for entities updatable by both managers and admins with timestamps.</p> <p>This class provides comprehensive tracking of entity creation and updates by both administrators and managers, supporting complex workflows where different user roles interact with the same data.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableManagerAdminEntity(\n    BaseEntity,\n    UpdatableMixin,\n    ManagerMixin,\n    AdminMixin,\n    UpdatableManagerMixin,\n    UpdatableAdminMixin,\n):\n    \"\"\"Base class for entities updatable by both managers and admins with timestamps.\n\n    This class provides comprehensive tracking of entity creation and updates\n    by both administrators and managers, supporting complex workflows where\n    different user roles interact with the same data.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableManagerAdminEntity</code>","text":"<p>               Bases: <code>ArchivableEntity</code>, <code>ManagerMixin</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable by both managers and admins.</p> <p>This class provides comprehensive tracking of entity creation by both administrators and managers, supporting complex workflows where different user roles interact with the same data.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableManagerAdminEntity(\n    ArchivableEntity,\n    ManagerMixin,\n    AdminMixin,\n):\n    \"\"\"Base class for entities Archivable by both managers and admins.\n\n    This class provides comprehensive tracking of entity creation\n    by both administrators and managers, supporting complex workflows where\n    different user roles interact with the same data.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableAdminEntity</code>","text":"<p>               Bases: <code>ArchivableDeletableEntity</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable and deletable by admin.</p> <p>This class combines administrator creation tracking with soft deletion and archiving, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableAdminEntity(ArchivableDeletableEntity, AdminMixin):\n    \"\"\"Base class for entities Archivable and deletable by admin.\n\n    This class combines administrator creation tracking with soft deletion and archiving,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerEntity</code>","text":"<p>               Bases: <code>ArchivableDeletableEntity</code>, <code>ManagerMixin</code></p> <p>Base class for entities Archivable and deletable by managers.</p> <p>This class combines manager creation tracking with soft deletion and archiving, providing a complete audit trail throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableManagerEntity(ArchivableDeletableEntity, ManagerMixin):\n    \"\"\"Base class for entities Archivable and deletable by managers.\n\n    This class combines manager creation tracking with soft deletion and archiving,\n    providing a complete audit trail throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.UpdatableDeletableManagerAdminEntity</code>","text":"<p>               Bases: <code>BaseEntity</code>, <code>UpdatableMixin</code>, <code>ManagerMixin</code>, <code>AdminMixin</code>, <code>UpdatableManagerMixin</code>, <code>UpdatableAdminMixin</code>, <code>DeletableMixin</code></p> <p>Base class for entities updatable by both managers and admins with timestamps and soft deletion.</p> <p>This is the most comprehensive entity class, supporting tracking of creation and updates by both administrators and managers, along with soft deletion capability. It provides complete accountability for all operations throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> <code>updated_by_admin/updated_by_admin_uuid</code> <p>Reference to the admin who last updated the entity.</p> <code>updated_by/updated_by_uuid</code> <p>Reference to the manager who last updated the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class UpdatableDeletableManagerAdminEntity(\n    BaseEntity,\n    UpdatableMixin,\n    ManagerMixin,\n    AdminMixin,\n    UpdatableManagerMixin,\n    UpdatableAdminMixin,\n    DeletableMixin,\n):\n    \"\"\"Base class for entities updatable by both managers and admins with timestamps and soft deletion.\n\n    This is the most comprehensive entity class, supporting tracking of creation and\n    updates by both administrators and managers, along with soft deletion capability.\n    It provides complete accountability for all operations throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n        updated_by_admin/updated_by_admin_uuid: Reference to the admin who last updated the entity.\n        updated_by/updated_by_uuid: Reference to the manager who last updated the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerAdminEntity","title":"<code>archipy.models.entities.sqlalchemy.base_entities.ArchivableDeletableManagerAdminEntity</code>","text":"<p>               Bases: <code>ArchivableDeletableEntity</code>, <code>ManagerMixin</code>, <code>AdminMixin</code></p> <p>Base class for entities Archivable and deletable by both managers and admins.</p> <p>This is a comprehensive entity class, supporting tracking of creation by both administrators and managers, along with soft deletion and archiving capability. It provides complete accountability for all operations throughout the entity's lifecycle.</p> <p>Attributes:</p> Name Type Description <code>created_at</code> <code>Mapped[datetime]</code> <p>Timestamp indicating when the entity was created.</p> <code>updated_at</code> <p>Timestamp indicating when the entity was last updated.</p> <code>is_deleted</code> <p>Flag indicating if the entity is deleted.</p> <code>is_archived</code> <p>Flag indicating if the entity is archived.</p> <code>origin_uuid</code> <p>Reference to the original entity.</p> <code>created_by_admin/created_by_admin_uuid</code> <p>Reference to the admin who created the entity.</p> <code>created_by/created_by_uuid</code> <p>Reference to the manager who created the entity.</p> Source code in <code>archipy/models/entities/sqlalchemy/base_entities.py</code> <pre><code>class ArchivableDeletableManagerAdminEntity(\n    ArchivableDeletableEntity,\n    ManagerMixin,\n    AdminMixin,\n):\n    \"\"\"Base class for entities Archivable and deletable by both managers and admins.\n\n    This is a comprehensive entity class, supporting tracking of creation\n    by both administrators and managers, along with soft deletion and archiving capability.\n    It provides complete accountability for all operations throughout the entity's lifecycle.\n\n    Attributes:\n        created_at: Timestamp indicating when the entity was created.\n        updated_at: Timestamp indicating when the entity was last updated.\n        is_deleted: Flag indicating if the entity is deleted.\n        is_archived: Flag indicating if the entity is archived.\n        origin_uuid: Reference to the original entity.\n        created_by_admin/created_by_admin_uuid: Reference to the admin who created the entity.\n        created_by/created_by_uuid: Reference to the manager who created the entity.\n    \"\"\"\n\n    __abstract__ = True\n</code></pre>"},{"location":"api_reference/models/#errors","title":"Errors","text":"<p>The error handling system is organized into several categories, each handling specific types of errors:</p>"},{"location":"api_reference/models/#authentication-errors","title":"Authentication Errors","text":"<p>Handles authentication and authorization related errors.</p> <pre><code>from archipy.models.errors import (\n    UnauthenticatedError,\n    InvalidCredentialsError,\n    TokenExpiredError,\n    InvalidTokenError,\n    SessionExpiredError,\n    PermissionDeniedError,\n    AccountLockedError,\n    AccountDisabledError,\n    InvalidVerificationCodeError\n)\n\n# Example: Handle invalid credentials\ntry:\n    authenticate_user(username, password)\nexcept InvalidCredentialsError as e:\n    logger.warning(f\"Failed login attempt: {e}\")\n</code></pre>"},{"location":"api_reference/models/#validation-errors","title":"Validation Errors","text":"<p>Handles input validation and format errors.</p> <pre><code>from archipy.models.errors import (\n    InvalidArgumentError,\n    InvalidFormatError,\n    InvalidEmailError,\n    InvalidPhoneNumberError,\n    InvalidLandlineNumberError,\n    InvalidNationalCodeError,\n    InvalidPasswordError,\n    InvalidDateError,\n    InvalidUrlError,\n    InvalidIpError,\n    InvalidJsonError,\n    InvalidTimestampError,\n    OutOfRangeError\n)\n\n# Example: Validate user input\ntry:\n    validate_user_input(email, phone)\nexcept InvalidEmailError as e:\n    return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"api_reference/models/#resource-errors","title":"Resource Errors","text":"<p>Handles resource and data management errors.</p> <pre><code>from archipy.models.errors import (\n    NotFoundError,\n    AlreadyExistsError,\n    ConflictError,\n    ResourceLockedError,\n    ResourceBusyError,\n    DataLossError,\n    InvalidEntityTypeError,\n    FileTooLargeError,\n    InvalidFileTypeError,\n    QuotaExceededError\n)\n\n# Example: Handle resource not found\ntry:\n    user = get_user(user_id)\nexcept NotFoundError as e:\n    return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"api_reference/models/#network-errors","title":"Network Errors","text":"<p>Handles network and communication errors.</p> <pre><code>from archipy.models.errors import (\n    NetworkError,\n    ConnectionTimeoutError,\n    ServiceUnavailableError,\n    GatewayTimeoutError,\n    BadGatewayError,\n    RateLimitExceededError\n)\n\n# Example: Handle network issues\ntry:\n    response = make_api_request()\nexcept ConnectionTimeoutError as e:\n    logger.error(f\"Connection timeout: {e}\")\n</code></pre>"},{"location":"api_reference/models/#business-errors","title":"Business Errors","text":"<p>Handles business logic and operation errors.</p> <pre><code>from archipy.models.errors import (\n    InvalidStateError,\n    BusinessRuleViolationError,\n    InvalidOperationError,\n    InsufficientFundsError,\n    InsufficientBalanceError,\n    MaintenanceModeError,\n    FailedPreconditionError\n)\n\n# Example: Handle business rule violation\ntry:\n    process_transaction(amount)\nexcept InsufficientFundsError as e:\n    return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"api_reference/models/#database-errors","title":"Database Errors","text":"<p>Handles database and storage related errors.</p> <pre><code>from archipy.models.errors import (\n    DatabaseConnectionError,\n    DatabaseQueryError,\n    DatabaseTransactionError,\n    StorageError,\n    CacheError,\n    CacheMissError\n)\n\n# Example: Handle database errors\ntry:\n    save_to_database(data)\nexcept DatabaseConnectionError as e:\n    logger.error(f\"Database connection failed: {e}\")\n</code></pre>"},{"location":"api_reference/models/#system-errors","title":"System Errors","text":"<p>Handles system and internal errors.</p> <pre><code>from archipy.models.errors import (\n    InternalError,\n    ConfigurationError,\n    ResourceExhaustedError,\n    UnavailableError,\n    UnknownError,\n    AbortedError,\n    DeadlockDetectedError\n)\n\n# Example: Handle system errors\ntry:\n    process_request()\nexcept DeadlockDetectedError as e:\n    logger.error(f\"Deadlock detected: {e}\")\n    # Implement retry logic\n</code></pre> <p>Error handling module for the application.</p> <p>This module provides a comprehensive set of custom exceptions for handling various error scenarios in the application, organized by category.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.errors.AccountDisabledError","title":"<code>archipy.models.errors.AccountDisabledError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an account is disabled.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class AccountDisabledError(BaseError):\n    \"\"\"Exception raised when an account is disabled.\"\"\"\n\n    def __init__(\n        self,\n        username: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.ACCOUNT_DISABLED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if username:\n            data[\"username\"] = username\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.AccountLockedError","title":"<code>archipy.models.errors.AccountLockedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an account is locked.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class AccountLockedError(BaseError):\n    \"\"\"Exception raised when an account is locked.\"\"\"\n\n    def __init__(\n        self,\n        username: str | None = None,\n        lockout_duration: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.ACCOUNT_LOCKED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if username:\n            data[\"username\"] = username\n        if lockout_duration:\n            data[\"lockout_duration\"] = lockout_duration\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidCredentialsError","title":"<code>archipy.models.errors.InvalidCredentialsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid credentials.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class InvalidCredentialsError(BaseError):\n    \"\"\"Exception raised for invalid credentials.\"\"\"\n\n    def __init__(\n        self,\n        username: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_CREDENTIALS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"username\": username} if username else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidTokenError","title":"<code>archipy.models.errors.InvalidTokenError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a token is invalid.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class InvalidTokenError(BaseError):\n    \"\"\"Exception raised when a token is invalid.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_TOKEN.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidVerificationCodeError","title":"<code>archipy.models.errors.InvalidVerificationCodeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a verification code is invalid.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class InvalidVerificationCodeError(BaseError):\n    \"\"\"Exception raised when a verification code is invalid.\"\"\"\n\n    def __init__(\n        self,\n        code: str | None = None,\n        remaining_attempts: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_VERIFICATION_CODE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if code:\n            data[\"code\"] = code\n        if remaining_attempts is not None:\n            data[\"remaining_attempts\"] = remaining_attempts\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.PermissionDeniedError","title":"<code>archipy.models.errors.PermissionDeniedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when permission is denied.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class PermissionDeniedError(BaseError):\n    \"\"\"Exception raised when permission is denied.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.PERMISSION_DENIED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.SessionExpiredError","title":"<code>archipy.models.errors.SessionExpiredError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a session has expired.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class SessionExpiredError(BaseError):\n    \"\"\"Exception raised when a session has expired.\"\"\"\n\n    def __init__(\n        self,\n        session_id: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.SESSION_EXPIRED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"session_id\": session_id} if session_id else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.TokenExpiredError","title":"<code>archipy.models.errors.TokenExpiredError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a token has expired.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class TokenExpiredError(BaseError):\n    \"\"\"Exception raised when a token has expired.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.TOKEN_EXPIRED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UnauthenticatedError","title":"<code>archipy.models.errors.UnauthenticatedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a user is unauthenticated.</p> Source code in <code>archipy/models/errors/auth_errors.py</code> <pre><code>class UnauthenticatedError(BaseError):\n    \"\"\"Exception raised when a user is unauthenticated.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.UNAUTHENTICATED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError","title":"<code>archipy.models.errors.BaseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for all custom errors.</p> <p>This class provides a standardized way to handle errors with support for: - Localization of error messages - Additional context data - Integration with HTTP and gRPC status codes</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>ErrorDetailDTO</code> <p>The error details including message and status codes.</p> <code>lang</code> <code>LanguageType</code> <p>The language for the error message.</p> <code>additional_data</code> <code>dict[str, Any] | None</code> <p>Additional context data for the error.</p> <code>http_status_code</code> <code>ClassVar[int]</code> <p>HTTP status code for the error.</p> <code>grpc_status_code</code> <code>ClassVar[int]</code> <p>gRPC status code for the error.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>class BaseError(Exception):\n    \"\"\"Base exception class for all custom errors.\n\n    This class provides a standardized way to handle errors with support for:\n    - Localization of error messages\n    - Additional context data\n    - Integration with HTTP and gRPC status codes\n\n    Attributes:\n        error (ErrorDetailDTO): The error details including message and status codes.\n        lang (LanguageType): The language for the error message.\n        additional_data (dict[str, Any] | None): Additional context data for the error.\n        http_status_code (ClassVar[int]): HTTP status code for the error.\n        grpc_status_code (ClassVar[int]): gRPC status code for the error.\n    \"\"\"\n\n    http_status_code: ClassVar[int] = 500\n    grpc_status_code: ClassVar[int] = 13  # INTERNAL\n\n    def __init__(\n        self,\n        error: ErrorDetailDTO | ErrorMessageType | None = None,\n        lang: LanguageType = LanguageType.FA,\n        additional_data: dict | None = None,\n        *args: object,\n    ) -&gt; None:\n        \"\"\"Initialize the error with message and optional context.\n\n        Args:\n            error: The error detail or message. Can be:\n                - ErrorDetail: Direct error detail object\n                - ExceptionMessageType: Enum member containing error detail\n                - None: Will use UNKNOWN_ERROR\n            lang: Language code for the error message (defaults to Persian).\n            additional_data: Additional context data for the error.\n            *args: Additional arguments for the base Exception class.\n        \"\"\"\n        if isinstance(error, ErrorMessageType):\n            self.error_detail = error.value\n        elif isinstance(error, ErrorDetailDTO):\n            self.error_detail = error\n        else:\n            self.error_detail = ErrorMessageType.UNKNOWN_ERROR.value\n\n        self.lang = lang\n        self.additional_data = additional_data or {}\n\n        # Initialize base Exception with the message\n        super().__init__(self.get_message(), *args)\n\n    def get_message(self) -&gt; str:\n        \"\"\"Gets the localized error message based on the language setting.\n\n        Returns:\n            str: The error message in the current language.\n        \"\"\"\n        return self.error_detail.message_fa if self.lang == LanguageType.FA else self.error_detail.message_en\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Converts the exception to a dictionary format for API responses.\n\n        Returns:\n            dict: A dictionary containing error details and additional data.\n        \"\"\"\n        response = {\n            \"error\": self.error_detail.code,\n            \"detail\": self.error_detail.model_dump(mode=\"json\", exclude_none=True),\n        }\n\n        # Add additional data if present\n        detail = response[\"detail\"]\n        if isinstance(detail, dict) and self.additional_data:\n            detail.update(self.additional_data)\n\n        return response\n\n    @property\n    def http_status_code(self) -&gt; int | None:\n        \"\"\"Gets the HTTP status code if HTTP support is available.\n\n        Returns:\n            Optional[int]: The HTTP status code or None if HTTP is not available.\n        \"\"\"\n        return self.error_detail.http_status if HTTP_AVAILABLE else None\n\n    @property\n    def grpc_status_code(self) -&gt; int | None:\n        \"\"\"Gets the gRPC status code if gRPC support is available.\n\n        Returns:\n            Optional[int]: The gRPC status code or None if gRPC is not available.\n        \"\"\"\n        return self.error_detail.grpc_status if GRPC_AVAILABLE else None\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the exception.\n\n        Returns:\n            str: A formatted string containing the error code and message.\n        \"\"\"\n        return f\"[{self.error_detail.code}] {self.get_message()}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the exception.\n\n        Returns:\n            str: A detailed string representation including all error details.\n        \"\"\"\n        return (\n            f\"{self.__class__.__name__}(\"\n            f\"code='{self.error_detail.code}', \"\n            f\"message='{self.get_message()}', \"\n            f\"http_status={self.http_status_code}, \"\n            f\"grpc_status={self.grpc_status_code}, \"\n            f\"additional_data={self.additional_data}\"\n            f\")\"\n        )\n\n    @property\n    def code(self) -&gt; str:\n        \"\"\"Gets the error code.\n\n        Returns:\n            str: The error code.\n        \"\"\"\n        return self.error_detail.code\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"Gets the current language message.\n\n        Returns:\n            str: The error message in the current language.\n        \"\"\"\n        return self.get_message()\n\n    @property\n    def message_en(self) -&gt; str:\n        \"\"\"Gets the English message.\n\n        Returns:\n            str: The English error message.\n        \"\"\"\n        return self.error_detail.message_en\n\n    @property\n    def message_fa(self) -&gt; str:\n        \"\"\"Gets the Persian message.\n\n        Returns:\n            str: The Persian error message.\n        \"\"\"\n        return self.error_detail.message_fa\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.http_status_code","title":"<code>archipy.models.errors.BaseError.http_status_code</code>  <code>property</code>","text":"<p>Gets the HTTP status code if HTTP support is available.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Optional[int]: The HTTP status code or None if HTTP is not available.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.grpc_status_code","title":"<code>archipy.models.errors.BaseError.grpc_status_code</code>  <code>property</code>","text":"<p>Gets the gRPC status code if gRPC support is available.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Optional[int]: The gRPC status code or None if gRPC is not available.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.code","title":"<code>archipy.models.errors.BaseError.code</code>  <code>property</code>","text":"<p>Gets the error code.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error code.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.message","title":"<code>archipy.models.errors.BaseError.message</code>  <code>property</code>","text":"<p>Gets the current language message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message in the current language.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.message_en","title":"<code>archipy.models.errors.BaseError.message_en</code>  <code>property</code>","text":"<p>Gets the English message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The English error message.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.message_fa","title":"<code>archipy.models.errors.BaseError.message_fa</code>  <code>property</code>","text":"<p>Gets the Persian message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Persian error message.</p>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.__init__","title":"<code>archipy.models.errors.BaseError.__init__(error=None, lang=LanguageType.FA, additional_data=None, *args)</code>","text":"<p>Initialize the error with message and optional context.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>ErrorDetailDTO | ErrorMessageType | None</code> <p>The error detail or message. Can be: - ErrorDetail: Direct error detail object - ExceptionMessageType: Enum member containing error detail - None: Will use UNKNOWN_ERROR</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language code for the error message (defaults to Persian).</p> <code>FA</code> <code>additional_data</code> <code>dict | None</code> <p>Additional context data for the error.</p> <code>None</code> <code>*args</code> <code>object</code> <p>Additional arguments for the base Exception class.</p> <code>()</code> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def __init__(\n    self,\n    error: ErrorDetailDTO | ErrorMessageType | None = None,\n    lang: LanguageType = LanguageType.FA,\n    additional_data: dict | None = None,\n    *args: object,\n) -&gt; None:\n    \"\"\"Initialize the error with message and optional context.\n\n    Args:\n        error: The error detail or message. Can be:\n            - ErrorDetail: Direct error detail object\n            - ExceptionMessageType: Enum member containing error detail\n            - None: Will use UNKNOWN_ERROR\n        lang: Language code for the error message (defaults to Persian).\n        additional_data: Additional context data for the error.\n        *args: Additional arguments for the base Exception class.\n    \"\"\"\n    if isinstance(error, ErrorMessageType):\n        self.error_detail = error.value\n    elif isinstance(error, ErrorDetailDTO):\n        self.error_detail = error\n    else:\n        self.error_detail = ErrorMessageType.UNKNOWN_ERROR.value\n\n    self.lang = lang\n    self.additional_data = additional_data or {}\n\n    # Initialize base Exception with the message\n    super().__init__(self.get_message(), *args)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.get_message","title":"<code>archipy.models.errors.BaseError.get_message()</code>","text":"<p>Gets the localized error message based on the language setting.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message in the current language.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def get_message(self) -&gt; str:\n    \"\"\"Gets the localized error message based on the language setting.\n\n    Returns:\n        str: The error message in the current language.\n    \"\"\"\n    return self.error_detail.message_fa if self.lang == LanguageType.FA else self.error_detail.message_en\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.to_dict","title":"<code>archipy.models.errors.BaseError.to_dict()</code>","text":"<p>Converts the exception to a dictionary format for API responses.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing error details and additional data.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts the exception to a dictionary format for API responses.\n\n    Returns:\n        dict: A dictionary containing error details and additional data.\n    \"\"\"\n    response = {\n        \"error\": self.error_detail.code,\n        \"detail\": self.error_detail.model_dump(mode=\"json\", exclude_none=True),\n    }\n\n    # Add additional data if present\n    detail = response[\"detail\"]\n    if isinstance(detail, dict) and self.additional_data:\n        detail.update(self.additional_data)\n\n    return response\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.__str__","title":"<code>archipy.models.errors.BaseError.__str__()</code>","text":"<p>String representation of the exception.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string containing the error code and message.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the exception.\n\n    Returns:\n        str: A formatted string containing the error code and message.\n    \"\"\"\n    return f\"[{self.error_detail.code}] {self.get_message()}\"\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BaseError.__repr__","title":"<code>archipy.models.errors.BaseError.__repr__()</code>","text":"<p>Detailed string representation of the exception.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A detailed string representation including all error details.</p> Source code in <code>archipy/models/errors/base_error.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the exception.\n\n    Returns:\n        str: A detailed string representation including all error details.\n    \"\"\"\n    return (\n        f\"{self.__class__.__name__}(\"\n        f\"code='{self.error_detail.code}', \"\n        f\"message='{self.get_message()}', \"\n        f\"http_status={self.http_status_code}, \"\n        f\"grpc_status={self.grpc_status_code}, \"\n        f\"additional_data={self.additional_data}\"\n        f\")\"\n    )\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BusinessRuleViolationError","title":"<code>archipy.models.errors.BusinessRuleViolationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a business rule is violated.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class BusinessRuleViolationError(BaseError):\n    \"\"\"Exception raised when a business rule is violated.\"\"\"\n\n    def __init__(\n        self,\n        rule: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.BUSINESS_RULE_VIOLATION.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if rule:\n            data[\"rule\"] = rule\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.FailedPreconditionError","title":"<code>archipy.models.errors.FailedPreconditionError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a precondition for an operation is not met.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class FailedPreconditionError(BaseError):\n    \"\"\"Exception raised when a precondition for an operation is not met.\"\"\"\n\n    def __init__(\n        self,\n        precondition: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.FAILED_PRECONDITION.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if precondition:\n            data[\"precondition\"] = precondition\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InsufficientBalanceError","title":"<code>archipy.models.errors.InsufficientBalanceError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation fails due to insufficient account balance.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InsufficientBalanceError(BaseError):\n    \"\"\"Exception raised when an operation fails due to insufficient account balance.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INSUFFICIENT_BALANCE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InsufficientFundsError","title":"<code>archipy.models.errors.InsufficientFundsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when there are insufficient funds for an operation.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InsufficientFundsError(BaseError):\n    \"\"\"Exception raised when there are insufficient funds for an operation.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INSUFFICIENT_FUNDS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidOperationError","title":"<code>archipy.models.errors.InvalidOperationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation is not allowed in the current context.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InvalidOperationError(BaseError):\n    \"\"\"Exception raised when an operation is not allowed in the current context.\"\"\"\n\n    def __init__(\n        self,\n        operation: str | None = None,\n        context: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_OPERATION.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if operation:\n            data[\"operation\"] = operation\n        if context:\n            data[\"context\"] = context\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidStateError","title":"<code>archipy.models.errors.InvalidStateError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation is attempted in an invalid state.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class InvalidStateError(BaseError):\n    \"\"\"Exception raised when an operation is attempted in an invalid state.\"\"\"\n\n    def __init__(\n        self,\n        current_state: str | None = None,\n        expected_state: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_STATE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if current_state:\n            data[\"current_state\"] = current_state\n        if expected_state:\n            data[\"expected_state\"] = expected_state\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.MaintenanceModeError","title":"<code>archipy.models.errors.MaintenanceModeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when the system is in maintenance mode.</p> Source code in <code>archipy/models/errors/business_errors.py</code> <pre><code>class MaintenanceModeError(BaseError):\n    \"\"\"Exception raised when the system is in maintenance mode.\"\"\"\n\n    def __init__(\n        self,\n        estimated_duration: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.MAINTENANCE_MODE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"estimated_duration\": estimated_duration} if estimated_duration else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.CacheError","title":"<code>archipy.models.errors.CacheError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for cache access errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class CacheError(BaseError):\n    \"\"\"Exception raised for cache access errors.\"\"\"\n\n    def __init__(\n        self,\n        cache_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.CACHE_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if cache_type:\n            data[\"cache_type\"] = cache_type\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.CacheMissError","title":"<code>archipy.models.errors.CacheMissError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when requested data is not found in cache.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class CacheMissError(BaseError):\n    \"\"\"Exception raised when requested data is not found in cache.\"\"\"\n\n    def __init__(\n        self,\n        cache_key: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.CACHE_MISS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"cache_key\": cache_key} if cache_key else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseConfigurationError","title":"<code>archipy.models.errors.DatabaseConfigurationError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database configuration errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseConfigurationError(DatabaseError):\n    \"\"\"Exception raised for database configuration errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_CONFIGURATION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseConnectionError","title":"<code>archipy.models.errors.DatabaseConnectionError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database connection errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseConnectionError(DatabaseError):\n    \"\"\"Exception raised for database connection errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_CONNECTION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseConstraintError","title":"<code>archipy.models.errors.DatabaseConstraintError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database constraint violations.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseConstraintError(DatabaseError):\n    \"\"\"Exception raised for database constraint violations.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        constraint: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_CONSTRAINT_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if constraint:\n            data[\"constraint\"] = constraint\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseDeadlockError","title":"<code>archipy.models.errors.DatabaseDeadlockError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database deadlock errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseDeadlockError(DatabaseError):\n    \"\"\"Exception raised for database deadlock errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_DEADLOCK_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseError","title":"<code>archipy.models.errors.DatabaseError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Base class for all database-related errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseError(BaseError):\n    \"\"\"Base class for all database-related errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if database:\n            data[\"database\"] = database\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseIntegrityError","title":"<code>archipy.models.errors.DatabaseIntegrityError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database integrity violations.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseIntegrityError(DatabaseError):\n    \"\"\"Exception raised for database integrity violations.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_INTEGRITY_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseQueryError","title":"<code>archipy.models.errors.DatabaseQueryError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database query errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseQueryError(DatabaseError):\n    \"\"\"Exception raised for database query errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        query: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_QUERY_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if query:\n            data[\"query\"] = query\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseSerializationError","title":"<code>archipy.models.errors.DatabaseSerializationError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database serialization errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseSerializationError(DatabaseError):\n    \"\"\"Exception raised for database serialization errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_SERIALIZATION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(database, lang, error, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseTimeoutError","title":"<code>archipy.models.errors.DatabaseTimeoutError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database timeout errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseTimeoutError(DatabaseError):\n    \"\"\"Exception raised for database timeout errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        timeout: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_TIMEOUT_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if timeout:\n            data[\"timeout\"] = timeout\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DatabaseTransactionError","title":"<code>archipy.models.errors.DatabaseTransactionError</code>","text":"<p>               Bases: <code>DatabaseError</code></p> <p>Exception raised for database transaction errors.</p> Source code in <code>archipy/models/errors/database_errors.py</code> <pre><code>class DatabaseTransactionError(DatabaseError):\n    \"\"\"Exception raised for database transaction errors.\"\"\"\n\n    def __init__(\n        self,\n        database: str | None = None,\n        transaction_id: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATABASE_TRANSACTION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if transaction_id:\n            data[\"transaction_id\"] = transaction_id\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(database, lang, error, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.BadGatewayError","title":"<code>archipy.models.errors.BadGatewayError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a gateway returns an invalid response.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class BadGatewayError(BaseError):\n    \"\"\"Exception raised when a gateway returns an invalid response.\"\"\"\n\n    def __init__(\n        self,\n        gateway: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.BAD_GATEWAY.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if gateway:\n            data[\"gateway\"] = gateway\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ConnectionTimeoutError","title":"<code>archipy.models.errors.ConnectionTimeoutError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a connection times out.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class ConnectionTimeoutError(BaseError):\n    \"\"\"Exception raised when a connection times out.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        timeout: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.CONNECTION_TIMEOUT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if timeout:\n            data[\"timeout\"] = timeout\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.GatewayTimeoutError","title":"<code>archipy.models.errors.GatewayTimeoutError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a gateway times out.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class GatewayTimeoutError(BaseError):\n    \"\"\"Exception raised when a gateway times out.\"\"\"\n\n    def __init__(\n        self,\n        gateway: str | None = None,\n        timeout: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.GATEWAY_TIMEOUT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if gateway:\n            data[\"gateway\"] = gateway\n        if timeout:\n            data[\"timeout\"] = timeout\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.NetworkError","title":"<code>archipy.models.errors.NetworkError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for network-related errors.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class NetworkError(BaseError):\n    \"\"\"Exception raised for network-related errors.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.NETWORK_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.RateLimitExceededError","title":"<code>archipy.models.errors.RateLimitExceededError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a rate limit is exceeded.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class RateLimitExceededError(BaseError):\n    \"\"\"Exception raised when a rate limit is exceeded.\"\"\"\n\n    def __init__(\n        self,\n        rate_limit_type: str | None = None,\n        retry_after: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.RATE_LIMIT_EXCEEDED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if rate_limit_type:\n            data[\"rate_limit_type\"] = rate_limit_type\n        if retry_after:\n            data[\"retry_after\"] = retry_after\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ServiceUnavailableError","title":"<code>archipy.models.errors.ServiceUnavailableError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a service is unavailable.</p> Source code in <code>archipy/models/errors/network_errors.py</code> <pre><code>class ServiceUnavailableError(BaseError):\n    \"\"\"Exception raised when a service is unavailable.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        retry_after: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.SERVICE_UNAVAILABLE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if retry_after:\n            data[\"retry_after\"] = retry_after\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.AlreadyExistsError","title":"<code>archipy.models.errors.AlreadyExistsError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource already exists.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class AlreadyExistsError(BaseError):\n    \"\"\"Exception raised when a resource already exists.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.ALREADY_EXISTS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"resource_type\": resource_type} if resource_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ConflictError","title":"<code>archipy.models.errors.ConflictError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when there is a resource conflict.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ConflictError(BaseError):\n    \"\"\"Exception raised when there is a resource conflict.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        resource_id: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.CONFLICT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_type:\n            data[\"resource_type\"] = resource_type\n        if resource_id:\n            data[\"resource_id\"] = resource_id\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DataLossError","title":"<code>archipy.models.errors.DataLossError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when data is lost.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class DataLossError(BaseError):\n    \"\"\"Exception raised when data is lost.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DATA_LOSS.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.FileTooLargeError","title":"<code>archipy.models.errors.FileTooLargeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a file is too large.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class FileTooLargeError(BaseError):\n    \"\"\"Exception raised when a file is too large.\"\"\"\n\n    def __init__(\n        self,\n        file_name: str | None = None,\n        file_size: int | None = None,\n        max_size: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.FILE_TOO_LARGE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if file_name:\n            data[\"file_name\"] = file_name\n        if file_size:\n            data[\"file_size\"] = file_size\n        if max_size:\n            data[\"max_size\"] = max_size\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidEntityTypeError","title":"<code>archipy.models.errors.InvalidEntityTypeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid entity types.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class InvalidEntityTypeError(BaseError):\n    \"\"\"Exception raised for invalid entity types.\"\"\"\n\n    def __init__(\n        self,\n        message: str | None = None,\n        expected_type: str | None = None,\n        actual_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_ENTITY_TYPE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if message:\n            data[\"message\"] = message\n        if expected_type:\n            data[\"expected_type\"] = expected_type\n        if actual_type:\n            data[\"actual_type\"] = actual_type\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidFileTypeError","title":"<code>archipy.models.errors.InvalidFileTypeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid file types.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class InvalidFileTypeError(BaseError):\n    \"\"\"Exception raised for invalid file types.\"\"\"\n\n    def __init__(\n        self,\n        file_name: str | None = None,\n        file_type: str | None = None,\n        allowed_types: list[str] | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_FILE_TYPE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if file_name:\n            data[\"file_name\"] = file_name\n        if file_type:\n            data[\"file_type\"] = file_type\n        if allowed_types:\n            data[\"allowed_types\"] = allowed_types\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.NotFoundError","title":"<code>archipy.models.errors.NotFoundError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is not found.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class NotFoundError(BaseError):\n    \"\"\"Exception raised when a resource is not found.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.NOT_FOUND.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"resource_type\": resource_type} if resource_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.QuotaExceededError","title":"<code>archipy.models.errors.QuotaExceededError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a quota is exceeded.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class QuotaExceededError(BaseError):\n    \"\"\"Exception raised when a quota is exceeded.\"\"\"\n\n    def __init__(\n        self,\n        quota_type: str | None = None,\n        current_usage: int | None = None,\n        quota_limit: int | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.QUOTA_EXCEEDED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if quota_type:\n            data[\"quota_type\"] = quota_type\n        if current_usage:\n            data[\"current_usage\"] = current_usage\n        if quota_limit:\n            data[\"quota_limit\"] = quota_limit\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceBusyError","title":"<code>archipy.models.errors.ResourceBusyError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is busy.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ResourceBusyError(BaseError):\n    \"\"\"Exception raised when a resource is busy.\"\"\"\n\n    def __init__(\n        self,\n        resource_id: str | None = None,\n        busy_reason: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.RESOURCE_BUSY.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_id:\n            data[\"resource_id\"] = resource_id\n        if busy_reason:\n            data[\"busy_reason\"] = busy_reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceExhaustedError","title":"<code>archipy.models.errors.ResourceExhaustedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is exhausted.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ResourceExhaustedError(BaseError):\n    \"\"\"Exception raised when a resource is exhausted.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.RESOURCE_EXHAUSTED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"resource_type\": resource_type} if resource_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ResourceLockedError","title":"<code>archipy.models.errors.ResourceLockedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a resource is locked.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class ResourceLockedError(BaseError):\n    \"\"\"Exception raised when a resource is locked.\"\"\"\n\n    def __init__(\n        self,\n        resource_id: str | None = None,\n        lock_owner: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.RESOURCE_LOCKED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_id:\n            data[\"resource_id\"] = resource_id\n        if lock_owner:\n            data[\"lock_owner\"] = lock_owner\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.StorageError","title":"<code>archipy.models.errors.StorageError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for storage-related errors.</p> Source code in <code>archipy/models/errors/resource_errors.py</code> <pre><code>class StorageError(BaseError):\n    \"\"\"Exception raised for storage-related errors.\"\"\"\n\n    def __init__(\n        self,\n        storage_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.STORAGE_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"storage_type\": storage_type} if storage_type else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.AbortedError","title":"<code>archipy.models.errors.AbortedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when an operation is aborted.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class AbortedError(BaseError):\n    \"\"\"Exception raised when an operation is aborted.\"\"\"\n\n    def __init__(\n        self,\n        operation: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.ABORTED.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if operation:\n            data[\"operation\"] = operation\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.ConfigurationError","title":"<code>archipy.models.errors.ConfigurationError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for system configuration errors.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class ConfigurationError(BaseError):\n    \"\"\"Exception raised for system configuration errors.\"\"\"\n\n    def __init__(\n        self,\n        config_key: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.CONFIGURATION_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if config_key:\n            data[\"config_key\"] = config_key\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.DeadlockDetectedError","title":"<code>archipy.models.errors.DeadlockDetectedError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a deadlock is detected in the system.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class DeadlockDetectedError(BaseError):\n    \"\"\"Exception raised when a deadlock is detected in the system.\"\"\"\n\n    def __init__(\n        self,\n        resource_type: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.DEADLOCK.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if resource_type:\n            data[\"resource_type\"] = resource_type\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InternalError","title":"<code>archipy.models.errors.InternalError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for unexpected internal errors.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class InternalError(BaseError):\n    \"\"\"Exception raised for unexpected internal errors.\"\"\"\n\n    def __init__(\n        self,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INTERNAL_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        super().__init__(error, lang, additional_data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UnavailableError","title":"<code>archipy.models.errors.UnavailableError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a requested service or feature is unavailable.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class UnavailableError(BaseError):\n    \"\"\"Exception raised when a requested service or feature is unavailable.\"\"\"\n\n    def __init__(\n        self,\n        service: str | None = None,\n        reason: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.UNAVAILABLE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if service:\n            data[\"service\"] = service\n        if reason:\n            data[\"reason\"] = reason\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.UnknownError","title":"<code>archipy.models.errors.UnknownError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for unknown or unexpected error conditions.</p> Source code in <code>archipy/models/errors/system_errors.py</code> <pre><code>class UnknownError(BaseError):\n    \"\"\"Exception raised for unknown or unexpected error conditions.\"\"\"\n\n    def __init__(\n        self,\n        error_code: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.UNKNOWN_ERROR.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if error_code:\n            data[\"error_code\"] = error_code\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidArgumentError","title":"<code>archipy.models.errors.InvalidArgumentError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid arguments.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidArgumentError(BaseError):\n    \"\"\"Exception raised for invalid arguments.\"\"\"\n\n    def __init__(\n        self,\n        argument_name: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_ARGUMENT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"argument\": argument_name} if argument_name else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidDateError","title":"<code>archipy.models.errors.InvalidDateError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid date formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidDateError(BaseError):\n    \"\"\"Exception raised for invalid date formats.\"\"\"\n\n    def __init__(\n        self,\n        date: str | None = None,\n        expected_format: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_DATE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if date:\n            data[\"date\"] = date\n        if expected_format:\n            data[\"expected_format\"] = expected_format\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidEmailError","title":"<code>archipy.models.errors.InvalidEmailError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid email formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidEmailError(BaseError):\n    \"\"\"Exception raised for invalid email formats.\"\"\"\n\n    def __init__(\n        self,\n        email: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_EMAIL.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"email\": email} if email else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidFormatError","title":"<code>archipy.models.errors.InvalidFormatError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid data formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidFormatError(BaseError):\n    \"\"\"Exception raised for invalid data formats.\"\"\"\n\n    def __init__(\n        self,\n        format_type: str | None = None,\n        expected_format: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_FORMAT.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if format_type:\n            data[\"format_type\"] = format_type\n        if expected_format:\n            data[\"expected_format\"] = expected_format\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidIpError","title":"<code>archipy.models.errors.InvalidIpError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid IP address formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidIpError(BaseError):\n    \"\"\"Exception raised for invalid IP address formats.\"\"\"\n\n    def __init__(\n        self,\n        ip: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_IP.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"ip\": ip} if ip else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidJsonError","title":"<code>archipy.models.errors.InvalidJsonError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid JSON formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidJsonError(BaseError):\n    \"\"\"Exception raised for invalid JSON formats.\"\"\"\n\n    def __init__(\n        self,\n        json_data: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_JSON.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if json_data:\n            data[\"json_data\"] = json_data\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidLandlineNumberError","title":"<code>archipy.models.errors.InvalidLandlineNumberError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid landline numbers.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidLandlineNumberError(BaseError):\n    \"\"\"Exception raised for invalid landline numbers.\"\"\"\n\n    def __init__(\n        self,\n        landline_number: str,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_LANDLINE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"landline_number\": landline_number}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidNationalCodeError","title":"<code>archipy.models.errors.InvalidNationalCodeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid national codes.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidNationalCodeError(BaseError):\n    \"\"\"Exception raised for invalid national codes.\"\"\"\n\n    def __init__(\n        self,\n        national_code: str,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_NATIONAL_CODE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"national_code\": national_code}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidPasswordError","title":"<code>archipy.models.errors.InvalidPasswordError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a password does not meet the security requirements.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidPasswordError(BaseError):\n    \"\"\"Exception raised when a password does not meet the security requirements.\"\"\"\n\n    def __init__(\n        self,\n        requirements: list[str] | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_PASSWORD.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"requirements\": requirements} if requirements else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidPhoneNumberError","title":"<code>archipy.models.errors.InvalidPhoneNumberError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid phone numbers.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidPhoneNumberError(BaseError):\n    \"\"\"Exception raised for invalid phone numbers.\"\"\"\n\n    def __init__(\n        self,\n        phone_number: str,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_PHONE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"phone_number\": phone_number}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidTimestampError","title":"<code>archipy.models.errors.InvalidTimestampError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a timestamp format is invalid.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidTimestampError(BaseError):\n    \"\"\"Exception raised when a timestamp format is invalid.\"\"\"\n\n    def __init__(\n        self,\n        timestamp: str | None = None,\n        expected_format: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_TIMESTAMP.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {}\n        if timestamp:\n            data[\"timestamp\"] = timestamp\n        if expected_format:\n            data[\"expected_format\"] = expected_format\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.InvalidUrlError","title":"<code>archipy.models.errors.InvalidUrlError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised for invalid URL formats.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class InvalidUrlError(BaseError):\n    \"\"\"Exception raised for invalid URL formats.\"\"\"\n\n    def __init__(\n        self,\n        url: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.INVALID_URL.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"url\": url} if url else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#archipy.models.errors.OutOfRangeError","title":"<code>archipy.models.errors.OutOfRangeError</code>","text":"<p>               Bases: <code>BaseError</code></p> <p>Exception raised when a value is out of range.</p> Source code in <code>archipy/models/errors/validation_errors.py</code> <pre><code>class OutOfRangeError(BaseError):\n    \"\"\"Exception raised when a value is out of range.\"\"\"\n\n    def __init__(\n        self,\n        field_name: str | None = None,\n        lang: LanguageType = LanguageType.FA,\n        error: ErrorDetailDTO = ErrorMessageType.OUT_OF_RANGE.value,\n        additional_data: dict | None = None,\n    ) -&gt; None:\n        data = {\"field\": field_name} if field_name else {}\n        if additional_data:\n            data.update(additional_data)\n        super().__init__(error, lang, data if data else None)\n</code></pre>"},{"location":"api_reference/models/#types","title":"Types","text":""},{"location":"api_reference/models/#base-types","title":"Base Types","text":"<p>Basic type definitions used throughout the application.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.base_types.BaseType","title":"<code>archipy.models.types.base_types.BaseType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Base class for creating enumerated types with custom values.</p> <p>This class extends the <code>Enum</code> class to allow custom values for enum members.</p> Source code in <code>archipy/models/types/base_types.py</code> <pre><code>class BaseType(Enum):\n    \"\"\"Base class for creating enumerated types with custom values.\n\n    This class extends the `Enum` class to allow custom values for enum members.\n    \"\"\"\n\n    def __new__(cls, *args: object, **_: object) -&gt; \"BaseType\":\n        \"\"\"Create a new instance of the enum member.\n\n        Args:\n            cls: The enum class.\n            *args: Arguments passed to the enum member.\n            **_: Unused keyword arguments.\n\n        Returns:\n            BaseType: A new instance of the enum member with the custom value.\n        \"\"\"\n        obj = object.__new__(cls)\n        obj._value_ = args[0]\n        return obj\n</code></pre>"},{"location":"api_reference/models/#archipy.models.types.base_types.BaseType.__new__","title":"<code>archipy.models.types.base_types.BaseType.__new__(*args, **_)</code>","text":"<p>Create a new instance of the enum member.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>The enum class.</p> required <code>*args</code> <code>object</code> <p>Arguments passed to the enum member.</p> <code>()</code> <code>**_</code> <code>object</code> <p>Unused keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BaseType</code> <code>BaseType</code> <p>A new instance of the enum member with the custom value.</p> Source code in <code>archipy/models/types/base_types.py</code> <pre><code>def __new__(cls, *args: object, **_: object) -&gt; \"BaseType\":\n    \"\"\"Create a new instance of the enum member.\n\n    Args:\n        cls: The enum class.\n        *args: Arguments passed to the enum member.\n        **_: Unused keyword arguments.\n\n    Returns:\n        BaseType: A new instance of the enum member with the custom value.\n    \"\"\"\n    obj = object.__new__(cls)\n    obj._value_ = args[0]\n    return obj\n</code></pre>"},{"location":"api_reference/models/#archipy.models.types.base_types.FilterOperationType","title":"<code>archipy.models.types.base_types.FilterOperationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of filter operations for querying or filtering data.</p> <p>This enum defines the types of operations that can be used in filtering, such as equality checks, comparisons, and string matching.</p> <p>Attributes:</p> Name Type Description <code>EQUAL</code> <code>str</code> <p>Represents an equality check.</p> <code>NOT_EQUAL</code> <code>str</code> <p>Represents a non-equality check.</p> <code>LESS_THAN</code> <code>str</code> <p>Represents a less-than comparison.</p> <code>LESS_THAN_OR_EQUAL</code> <code>str</code> <p>Represents a less-than-or-equal comparison.</p> <code>GREATER_THAN</code> <code>str</code> <p>Represents a greater-than comparison.</p> <code>GREATER_THAN_OR_EQUAL</code> <code>str</code> <p>Represents a greater-than-or-equal comparison.</p> <code>IN_LIST</code> <code>str</code> <p>Represents a check for membership in a list.</p> <code>NOT_IN_LIST</code> <code>str</code> <p>Represents a check for non-membership in a list.</p> <code>LIKE</code> <code>str</code> <p>Represents a case-sensitive string pattern match.</p> <code>ILIKE</code> <code>str</code> <p>Represents a case-insensitive string pattern match.</p> <code>STARTS_WITH</code> <code>str</code> <p>Represents a check if a string starts with a given prefix.</p> <code>ENDS_WITH</code> <code>str</code> <p>Represents a check if a string ends with a given suffix.</p> <code>CONTAINS</code> <code>str</code> <p>Represents a check if a string contains a given substring.</p> <code>IS_NULL</code> <code>str</code> <p>Represents a check if a value is null.</p> <code>IS_NOT_NULL</code> <code>str</code> <p>Represents a check if a value is not null.</p> Source code in <code>archipy/models/types/base_types.py</code> <pre><code>class FilterOperationType(Enum):\n    \"\"\"Enumeration of filter operations for querying or filtering data.\n\n    This enum defines the types of operations that can be used in filtering,\n    such as equality checks, comparisons, and string matching.\n\n    Attributes:\n        EQUAL (str): Represents an equality check.\n        NOT_EQUAL (str): Represents a non-equality check.\n        LESS_THAN (str): Represents a less-than comparison.\n        LESS_THAN_OR_EQUAL (str): Represents a less-than-or-equal comparison.\n        GREATER_THAN (str): Represents a greater-than comparison.\n        GREATER_THAN_OR_EQUAL (str): Represents a greater-than-or-equal comparison.\n        IN_LIST (str): Represents a check for membership in a list.\n        NOT_IN_LIST (str): Represents a check for non-membership in a list.\n        LIKE (str): Represents a case-sensitive string pattern match.\n        ILIKE (str): Represents a case-insensitive string pattern match.\n        STARTS_WITH (str): Represents a check if a string starts with a given prefix.\n        ENDS_WITH (str): Represents a check if a string ends with a given suffix.\n        CONTAINS (str): Represents a check if a string contains a given substring.\n        IS_NULL (str): Represents a check if a value is null.\n        IS_NOT_NULL (str): Represents a check if a value is not null.\n    \"\"\"\n\n    EQUAL = \"equal\"\n    NOT_EQUAL = \"not_equal\"\n    LESS_THAN = \"less_than\"\n    LESS_THAN_OR_EQUAL = \"less_than_or_equal\"\n    GREATER_THAN = \"greater_than\"\n    GREATER_THAN_OR_EQUAL = \"greater_than_or_equal\"\n    IN_LIST = \"in_list\"\n    NOT_IN_LIST = \"not_in_list\"\n    LIKE = \"like\"\n    ILIKE = \"ilike\"\n    STARTS_WITH = \"starts_with\"\n    ENDS_WITH = \"ends_with\"\n    CONTAINS = \"contains\"\n    IS_NULL = \"is_null\"\n    IS_NOT_NULL = \"is_not_null\"\n</code></pre>"},{"location":"api_reference/models/#email-types","title":"Email Types","text":"<p>Type definitions for email-related operations.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.email_types.EmailAttachmentType","title":"<code>archipy.models.types.email_types.EmailAttachmentType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing different types of email attachments.</p> <p>This enum defines the types of attachments that can be included in an email, such as files, base64-encoded data, URLs, or binary data.</p> <p>Attributes:</p> Name Type Description <code>FILE</code> <code>str</code> <p>Represents a file attachment.</p> <code>BASE64</code> <code>str</code> <p>Represents a base64-encoded attachment.</p> <code>URL</code> <code>str</code> <p>Represents an attachment referenced by a URL.</p> <code>BINARY</code> <code>str</code> <p>Represents raw binary data as an attachment.</p> Source code in <code>archipy/models/types/email_types.py</code> <pre><code>class EmailAttachmentType(StrEnum):\n    \"\"\"Enum representing different types of email attachments.\n\n    This enum defines the types of attachments that can be included in an email,\n    such as files, base64-encoded data, URLs, or binary data.\n\n    Attributes:\n        FILE (str): Represents a file attachment.\n        BASE64 (str): Represents a base64-encoded attachment.\n        URL (str): Represents an attachment referenced by a URL.\n        BINARY (str): Represents raw binary data as an attachment.\n    \"\"\"\n\n    FILE = \"file\"\n    BASE64 = \"base64\"\n    URL = \"url\"\n    BINARY = \"binary\"\n</code></pre>"},{"location":"api_reference/models/#archipy.models.types.email_types.EmailAttachmentDispositionType","title":"<code>archipy.models.types.email_types.EmailAttachmentDispositionType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum representing attachment disposition types.</p> <p>This enum defines how an email attachment should be displayed or handled, such as being treated as a downloadable attachment or displayed inline.</p> <p>Attributes:</p> Name Type Description <code>ATTACHMENT</code> <code>str</code> <p>Represents an attachment that should be downloaded.</p> <code>INLINE</code> <code>str</code> <p>Represents an attachment that should be displayed inline.</p> Source code in <code>archipy/models/types/email_types.py</code> <pre><code>class EmailAttachmentDispositionType(StrEnum):\n    \"\"\"Enum representing attachment disposition types.\n\n    This enum defines how an email attachment should be displayed or handled,\n    such as being treated as a downloadable attachment or displayed inline.\n\n    Attributes:\n        ATTACHMENT (str): Represents an attachment that should be downloaded.\n        INLINE (str): Represents an attachment that should be displayed inline.\n    \"\"\"\n\n    ATTACHMENT = \"attachment\"\n    INLINE = \"inline\"\n</code></pre>"},{"location":"api_reference/models/#error-message-types","title":"Error Message Types","text":"<p>Standardized error message types for consistent error handling.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.error_message_types.ErrorMessageType","title":"<code>archipy.models.types.error_message_types.ErrorMessageType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of exception types with associated error details.</p> <p>This class defines a set of standard exception types, each with an associated error code, English and Farsi messages, and corresponding HTTP and gRPC status codes.</p> <p>Attributes:</p> Name Type Description <code>UNAUTHENTICATED</code> <p>Indicates that the user is not authenticated.</p> <code>INVALID_PHONE</code> <p>Indicates an invalid Iranian phone number.</p> <code>INVALID_LANDLINE</code> <p>Indicates an invalid Iranian landline number.</p> <code>INVALID_NATIONAL_CODE</code> <p>Indicates an invalid national code format.</p> <code>TOKEN_EXPIRED</code> <p>Indicates that the authentication token has expired.</p> <code>INVALID_TOKEN</code> <p>Indicates an invalid authentication token.</p> <code>PERMISSION_DENIED</code> <p>Indicates that the user does not have permission for the operation.</p> <code>NOT_FOUND</code> <p>Indicates that the requested resource was not found.</p> <code>ALREADY_EXISTS</code> <p>Indicates that the resource already exists.</p> <code>INVALID_ARGUMENT</code> <p>Indicates an invalid argument was provided.</p> <code>OUT_OF_RANGE</code> <p>Indicates that a value is out of the acceptable range.</p> <code>DEADLINE_EXCEEDED</code> <p>Indicates that the operation deadline was exceeded.</p> <code>FAILED_PRECONDITION</code> <p>Indicates that the operation preconditions were not met.</p> <code>RESOURCE_EXHAUSTED</code> <p>Indicates that the resource limit has been reached.</p> <code>ABORTED</code> <p>Indicates that the operation was aborted.</p> <code>CANCELLED</code> <p>Indicates that the operation was cancelled.</p> <code>INVALID_ENTITY_TYPE</code> <p>Indicates an invalid entity type.</p> <code>INTERNAL_ERROR</code> <p>Indicates an internal system error.</p> <code>DATA_LOSS</code> <p>Indicates critical data loss.</p> <code>UNIMPLEMENTED</code> <p>Indicates that the operation is not implemented.</p> <code>DEPRECATION</code> <p>Indicates that the operation is deprecated.</p> <code>UNAVAILABLE</code> <p>Indicates that the service is unavailable.</p> <code>UNKNOWN_ERROR</code> <p>Indicates an unknown error occurred.</p> <code>DEADLOCK</code> <p>Indicates a deadlock condition was detected.</p> Source code in <code>archipy/models/types/error_message_types.py</code> <pre><code>class ErrorMessageType(Enum):\n    \"\"\"Enumeration of exception types with associated error details.\n\n    This class defines a set of standard exception types, each with an associated error code,\n    English and Farsi messages, and corresponding HTTP and gRPC status codes.\n\n    Attributes:\n        UNAUTHENTICATED: Indicates that the user is not authenticated.\n        INVALID_PHONE: Indicates an invalid Iranian phone number.\n        INVALID_LANDLINE: Indicates an invalid Iranian landline number.\n        INVALID_NATIONAL_CODE: Indicates an invalid national code format.\n        TOKEN_EXPIRED: Indicates that the authentication token has expired.\n        INVALID_TOKEN: Indicates an invalid authentication token.\n        PERMISSION_DENIED: Indicates that the user does not have permission for the operation.\n        NOT_FOUND: Indicates that the requested resource was not found.\n        ALREADY_EXISTS: Indicates that the resource already exists.\n        INVALID_ARGUMENT: Indicates an invalid argument was provided.\n        OUT_OF_RANGE: Indicates that a value is out of the acceptable range.\n        DEADLINE_EXCEEDED: Indicates that the operation deadline was exceeded.\n        FAILED_PRECONDITION: Indicates that the operation preconditions were not met.\n        RESOURCE_EXHAUSTED: Indicates that the resource limit has been reached.\n        ABORTED: Indicates that the operation was aborted.\n        CANCELLED: Indicates that the operation was cancelled.\n        INVALID_ENTITY_TYPE: Indicates an invalid entity type.\n        INTERNAL_ERROR: Indicates an internal system error.\n        DATA_LOSS: Indicates critical data loss.\n        UNIMPLEMENTED: Indicates that the operation is not implemented.\n        DEPRECATION: Indicates that the operation is deprecated.\n        UNAVAILABLE: Indicates that the service is unavailable.\n        UNKNOWN_ERROR: Indicates an unknown error occurred.\n        DEADLOCK: Indicates a deadlock condition was detected.\n    \"\"\"\n\n    # Authentication Errors (400, 401, 403)\n    UNAUTHENTICATED = ErrorDetailDTO.create_error_detail(\n        code=\"UNAUTHENTICATED\",\n        message_en=\"You are not authorized to perform this action.\",\n        message_fa=\"\u0634\u0645\u0627 \u0645\u062c\u0648\u0632 \u0627\u0646\u062c\u0627\u0645 \u0627\u06cc\u0646 \u0639\u0645\u0644 \u0631\u0627 \u0646\u062f\u0627\u0631\u06cc\u062f.\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n    INVALID_PHONE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_PHONE\",\n        message_en=\"Invalid Iranian phone number\",\n        message_fa=\"\u0634\u0645\u0627\u0631\u0647 \u062a\u0644\u0641\u0646 \u0647\u0645\u0631\u0627\u0647 \u0627\u06cc\u0631\u0627\u0646 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_LANDLINE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_LANDLINE\",\n        message_en=\"Invalid Iranian landline number\",\n        message_fa=\"\u0634\u0645\u0627\u0631\u0647 \u062a\u0644\u0641\u0646 \u062b\u0627\u0628\u062a \u0627\u06cc\u0631\u0627\u0646 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_NATIONAL_CODE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_NATIONAL_CODE\",\n        message_en=\"Invalid national code format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u06a9\u062f \u0645\u0644\u06cc \u0648\u0627\u0631\u062f \u0634\u062f\u0647 \u0627\u0634\u062a\u0628\u0627\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    TOKEN_EXPIRED = ErrorDetailDTO.create_error_detail(\n        code=\"TOKEN_EXPIRED\",\n        message_en=\"Authentication token has expired\",\n        message_fa=\"\u062a\u0648\u06a9\u0646 \u0627\u062d\u0631\u0627\u0632 \u0647\u0648\u06cc\u062a \u0645\u0646\u0642\u0636\u06cc \u0634\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_TOKEN = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_TOKEN\",\n        message_en=\"Invalid authentication token\",\n        message_fa=\"\u062a\u0648\u06a9\u0646 \u0627\u062d\u0631\u0627\u0632 \u0647\u0648\u06cc\u062a \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    PERMISSION_DENIED = ErrorDetailDTO.create_error_detail(\n        code=\"PERMISSION_DENIED\",\n        message_en=\"Permission denied for this operation\",\n        message_fa=\"\u062f\u0633\u062a\u0631\u0633\u06cc \u0628\u0631\u0627\u06cc \u0627\u0646\u062c\u0627\u0645 \u0627\u06cc\u0646 \u0639\u0645\u0644\u06cc\u0627\u062a \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u062f.\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    # Resource Errors (404, 409)\n    NOT_FOUND = ErrorDetailDTO.create_error_detail(\n        code=\"NOT_FOUND\",\n        message_en=\"Requested resource not found\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc \u06cc\u0627\u0641\u062a \u0646\u0634\u062f.\",\n        http_status=HTTPStatus.NOT_FOUND if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.NOT_FOUND if GRPC_AVAILABLE else None,\n    )\n\n    ALREADY_EXISTS = ErrorDetailDTO.create_error_detail(\n        code=\"ALREADY_EXISTS\",\n        message_en=\"Resource already exists\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u0627\u0632 \u0642\u0628\u0644 \u0645\u0648\u062c\u0648\u062f \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ALREADY_EXISTS if GRPC_AVAILABLE else None,\n    )\n\n    # Validation Errors (400)\n    INVALID_ARGUMENT = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_ARGUMENT\",\n        message_en=\"Invalid argument provided\",\n        message_fa=\"\u067e\u0627\u0631\u0627\u0645\u062a\u0631 \u0648\u0631\u0648\u062f\u06cc \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_PASSWORD = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_PASSWORD\",\n        message_en=\"Password does not meet the security requirements\",\n        message_fa=\"\u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0627\u0644\u0632\u0627\u0645\u0627\u062a \u0627\u0645\u0646\u06cc\u062a\u06cc \u0631\u0627 \u0628\u0631\u0622\u0648\u0631\u062f\u0647 \u0646\u0645\u06cc\u200c\u06a9\u0646\u062f.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    OUT_OF_RANGE = ErrorDetailDTO.create_error_detail(\n        code=\"OUT_OF_RANGE\",\n        message_en=\"Value is out of acceptable range\",\n        message_fa=\"\u0645\u0642\u062f\u0627\u0631 \u062e\u0627\u0631\u062c \u0627\u0632 \u0645\u062d\u062f\u0648\u062f\u0647 \u0645\u062c\u0627\u0632 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.OUT_OF_RANGE if GRPC_AVAILABLE else None,\n    )\n\n    # Operation Errors (408, 409, 412, 429)\n    DEADLINE_EXCEEDED = ErrorDetailDTO.create_error_detail(\n        code=\"DEADLINE_EXCEEDED\",\n        message_en=\"Operation deadline exceeded\",\n        message_fa=\"\u0645\u0647\u0644\u062a \u0627\u0646\u062c\u0627\u0645 \u0639\u0645\u0644\u06cc\u0627\u062a \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    FAILED_PRECONDITION = ErrorDetailDTO.create_error_detail(\n        code=\"FAILED_PRECONDITION\",\n        message_en=\"Operation preconditions not met\",\n        message_fa=\"\u067e\u06cc\u0634\u200c\u0646\u06cc\u0627\u0632\u0647\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a \u0628\u0631\u0622\u0648\u0631\u062f\u0647 \u0646\u0634\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.PRECONDITION_FAILED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    RESOURCE_EXHAUSTED = ErrorDetailDTO.create_error_detail(\n        code=\"RESOURCE_EXHAUSTED\",\n        message_en=\"Resource limit has been reached\",\n        message_fa=\"\u0645\u062d\u062f\u0648\u062f\u06cc\u062a \u0645\u0646\u0627\u0628\u0639 \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.TOO_MANY_REQUESTS if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    ABORTED = ErrorDetailDTO.create_error_detail(\n        code=\"ABORTED\",\n        message_en=\"Operation was aborted\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u0645\u062a\u0648\u0642\u0641 \u0634\u062f.\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    CANCELLED = ErrorDetailDTO.create_error_detail(\n        code=\"CANCELLED\",\n        message_en=\"Operation was cancelled\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u0644\u063a\u0648 \u0634\u062f.\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.CANCELLED if GRPC_AVAILABLE else None,\n    )\n\n    INSUFFICIENT_BALANCE = ErrorDetailDTO.create_error_detail(\n        code=\"INSUFFICIENT_BALANCE\",\n        message_en=\"Insufficient balance for operation\",\n        message_fa=\"\u0639\u062f\u0645 \u0645\u0648\u062c\u0648\u062f\u06cc \u06a9\u0627\u0641\u06cc \u0628\u0631\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a.\",\n        http_status=HTTPStatus.PAYMENT_REQUIRED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    # System Errors (500, 501, 503)\n    INVALID_ENTITY_TYPE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_ENTITY\",\n        message_en=\"Invalid entity type\",\n        message_fa=\"\u0646\u0648\u0639 \u0645\u0648\u062c\u0648\u062f\u06cc\u062a \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n    INTERNAL_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"INTERNAL_ERROR\",\n        message_en=\"Internal system error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u062f\u0627\u062e\u0644\u06cc \u0633\u06cc\u0633\u062a\u0645 \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATA_LOSS = ErrorDetailDTO.create_error_detail(\n        code=\"DATA_LOSS\",\n        message_en=\"Critical data loss detected\",\n        message_fa=\"\u0627\u0632 \u062f\u0633\u062a \u062f\u0627\u062f\u0646 \u0627\u0637\u0644\u0627\u0639\u0627\u062a \u062d\u06cc\u0627\u062a\u06cc \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DATA_LOSS if GRPC_AVAILABLE else None,\n    )\n\n    UNIMPLEMENTED = ErrorDetailDTO.create_error_detail(\n        code=\"UNIMPLEMENTED\",\n        message_en=\"Requested operation is not implemented\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc \u067e\u06cc\u0627\u062f\u0647\u200c\u0633\u0627\u0632\u06cc \u0646\u0634\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.NOT_IMPLEMENTED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNIMPLEMENTED if GRPC_AVAILABLE else None,\n    )\n\n    DEPRECATION = ErrorDetailDTO.create_error_detail(\n        code=\"DEPRECATION\",\n        message_en=\"This operation is deprecated and will be removed in a future version.\",\n        message_fa=\"\u0627\u06cc\u0646 \u0639\u0645\u0644\u06cc\u0627\u062a \u0645\u0646\u0633\u0648\u062e \u0634\u062f\u0647 \u0648 \u062f\u0631 \u0646\u0633\u062e\u0647\u200c\u0647\u0627\u06cc \u0622\u06cc\u0646\u062f\u0647 \u062d\u0630\u0641 \u062e\u0648\u0627\u0647\u062f \u0634\u062f.\",\n        http_status=HTTPStatus.GONE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    UNAVAILABLE = ErrorDetailDTO.create_error_detail(\n        code=\"UNAVAILABLE\",\n        message_en=\"Service is currently unavailable\",\n        message_fa=\"\u0633\u0631\u0648\u06cc\u0633 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633 \u0646\u06cc\u0633\u062a.\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    UNKNOWN_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"UNKNOWN_ERROR\",\n        message_en=\"An unknown error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0646\u0627\u0634\u0646\u0627\u062e\u062a\u0647\u200c\u0627\u06cc \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNKNOWN if GRPC_AVAILABLE else None,\n    )\n\n    DEADLOCK = ErrorDetailDTO.create_error_detail(\n        code=\"DEADLOCK\",\n        message_en=\"Deadlock detected\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0642\u0641\u0644\u200c\u0634\u062f\u06af\u06cc (Deadlock) \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f.\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Authentication &amp; Authorization\n    INVALID_CREDENTIALS = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_CREDENTIALS\",\n        message_en=\"Invalid username or password\",\n        message_fa=\"\u0646\u0627\u0645 \u06a9\u0627\u0631\u0628\u0631\u06cc \u06cc\u0627 \u0631\u0645\u0632 \u0639\u0628\u0648\u0631 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    ACCOUNT_LOCKED = ErrorDetailDTO.create_error_detail(\n        code=\"ACCOUNT_LOCKED\",\n        message_en=\"Account has been locked due to too many failed attempts\",\n        message_fa=\"\u062d\u0633\u0627\u0628 \u06a9\u0627\u0631\u0628\u0631\u06cc \u0628\u0647 \u062f\u0644\u06cc\u0644 \u062a\u0644\u0627\u0634\u200c\u0647\u0627\u06cc \u0646\u0627\u0645\u0648\u0641\u0642 \u0645\u062a\u0639\u062f\u062f \u0642\u0641\u0644 \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    ACCOUNT_DISABLED = ErrorDetailDTO.create_error_detail(\n        code=\"ACCOUNT_DISABLED\",\n        message_en=\"Account has been disabled\",\n        message_fa=\"\u062d\u0633\u0627\u0628 \u06a9\u0627\u0631\u0628\u0631\u06cc \u063a\u06cc\u0631\u0641\u0639\u0627\u0644 \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    SESSION_EXPIRED = ErrorDetailDTO.create_error_detail(\n        code=\"SESSION_EXPIRED\",\n        message_en=\"Session has expired\",\n        message_fa=\"\u0646\u0634\u0633\u062a \u06a9\u0627\u0631\u0628\u0631\u06cc \u0645\u0646\u0642\u0636\u06cc \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_REFRESH_TOKEN = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_REFRESH_TOKEN\",\n        message_en=\"Invalid refresh token\",\n        message_fa=\"\u062a\u0648\u06a9\u0646 \u062a\u0627\u0632\u0647\u200c\u0633\u0627\u0632\u06cc \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_VERIFICATION_CODE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_VERIFICATION_CODE\",\n        message_en=\"Invalid verification code\",\n        message_fa=\"\u06a9\u062f \u062a\u0627\u06cc\u06cc\u062f \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    # Resource &amp; Data\n    CONFLICT = ErrorDetailDTO.create_error_detail(\n        code=\"CONFLICT\",\n        message_en=\"Resource conflict detected\",\n        message_fa=\"\u062a\u0639\u0627\u0631\u0636 \u062f\u0631 \u0645\u0646\u0627\u0628\u0639 \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_FORMAT = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_FORMAT\",\n        message_en=\"Invalid data format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u062f\u0627\u062f\u0647 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    FILE_TOO_LARGE = ErrorDetailDTO.create_error_detail(\n        code=\"FILE_TOO_LARGE\",\n        message_en=\"File size exceeds the maximum allowed limit\",\n        message_fa=\"\u062d\u062c\u0645 \u0641\u0627\u06cc\u0644 \u0627\u0632 \u062d\u062f \u0645\u062c\u0627\u0632 \u0628\u06cc\u0634\u062a\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_FILE_TYPE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_FILE_TYPE\",\n        message_en=\"File type is not supported\",\n        message_fa=\"\u0646\u0648\u0639 \u0641\u0627\u06cc\u0644 \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u06cc \u0646\u0645\u06cc\u200c\u0634\u0648\u062f\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    QUOTA_EXCEEDED = ErrorDetailDTO.create_error_detail(\n        code=\"QUOTA_EXCEEDED\",\n        message_en=\"Storage quota has been exceeded\",\n        message_fa=\"\u0633\u0647\u0645\u06cc\u0647 \u0630\u062e\u06cc\u0631\u0647\u200c\u0633\u0627\u0632\u06cc \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    RATE_LIMIT_EXCEEDED = ErrorDetailDTO.create_error_detail(\n        code=\"RATE_LIMIT_EXCEEDED\",\n        message_en=\"Rate limit has been exceeded\",\n        message_fa=\"\u0645\u062d\u062f\u0648\u062f\u06cc\u062a \u0646\u0631\u062e \u062f\u0631\u062e\u0648\u0627\u0633\u062a \u0628\u0647 \u067e\u0627\u06cc\u0627\u0646 \u0631\u0633\u06cc\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.TOO_MANY_REQUESTS if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    # Network &amp; Communication\n    CONNECTION_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"CONNECTION_TIMEOUT\",\n        message_en=\"Connection timed out\",\n        message_fa=\"\u0627\u062a\u0635\u0627\u0644 \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    NETWORK_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"NETWORK_ERROR\",\n        message_en=\"Network error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0634\u0628\u06a9\u0647 \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_GATEWAY if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    SERVICE_UNAVAILABLE = ErrorDetailDTO.create_error_detail(\n        code=\"SERVICE_UNAVAILABLE\",\n        message_en=\"Service is currently unavailable\",\n        message_fa=\"\u0633\u0631\u0648\u06cc\u0633 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633 \u0646\u06cc\u0633\u062a\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    GATEWAY_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"GATEWAY_TIMEOUT\",\n        message_en=\"Gateway timeout\",\n        message_fa=\"\u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u062f\u0631\u0648\u0627\u0632\u0647\",\n        http_status=HTTPStatus.GATEWAY_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    BAD_GATEWAY = ErrorDetailDTO.create_error_detail(\n        code=\"BAD_GATEWAY\",\n        message_en=\"Bad gateway\",\n        message_fa=\"\u062f\u0631\u0648\u0627\u0632\u0647 \u0646\u0627\u0645\u0639\u062a\u0628\u0631\",\n        http_status=HTTPStatus.BAD_GATEWAY if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    # Business Logic\n    INVALID_STATE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_STATE\",\n        message_en=\"Invalid state for the requested operation\",\n        message_fa=\"\u0648\u0636\u0639\u06cc\u062a \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0628\u0631\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    BUSINESS_RULE_VIOLATION = ErrorDetailDTO.create_error_detail(\n        code=\"BUSINESS_RULE_VIOLATION\",\n        message_en=\"Business rule violation\",\n        message_fa=\"\u0646\u0642\u0636 \u0642\u0648\u0627\u0646\u06cc\u0646 \u06a9\u0633\u0628 \u0648 \u06a9\u0627\u0631\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    INSUFFICIENT_FUNDS = ErrorDetailDTO.create_error_detail(\n        code=\"INSUFFICIENT_FUNDS\",\n        message_en=\"Insufficient funds for the operation\",\n        message_fa=\"\u0645\u0648\u062c\u0648\u062f\u06cc \u0646\u0627\u06a9\u0627\u0641\u06cc \u0628\u0631\u0627\u06cc \u0639\u0645\u0644\u06cc\u0627\u062a\",\n        http_status=HTTPStatus.PAYMENT_REQUIRED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_OPERATION = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_OPERATION\",\n        message_en=\"Operation is not allowed in the current context\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u0631 \u0648\u0636\u0639\u06cc\u062a \u0641\u0639\u0644\u06cc \u0645\u062c\u0627\u0632 \u0646\u06cc\u0633\u062a\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    MAINTENANCE_MODE = ErrorDetailDTO.create_error_detail(\n        code=\"MAINTENANCE_MODE\",\n        message_en=\"System is currently in maintenance mode\",\n        message_fa=\"\u0633\u06cc\u0633\u062a\u0645 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u062f\u0631 \u062d\u0627\u0644\u062a \u062a\u0639\u0645\u06cc\u0631 \u0648 \u0646\u06af\u0647\u062f\u0627\u0631\u06cc \u0627\u0633\u062a\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    # Validation\n    INVALID_EMAIL = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_EMAIL\",\n        message_en=\"Invalid email format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u0627\u06cc\u0645\u06cc\u0644 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_DATE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_DATE\",\n        message_en=\"Invalid date format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u062a\u0627\u0631\u06cc\u062e \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_URL = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_URL\",\n        message_en=\"Invalid URL format\",\n        message_fa=\"\u0641\u0631\u0645\u062a URL \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_IP = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_IP\",\n        message_en=\"Invalid IP address format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u0622\u062f\u0631\u0633 IP \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_JSON = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_JSON\",\n        message_en=\"Invalid JSON format\",\n        message_fa=\"\u0641\u0631\u0645\u062a JSON \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    # Database &amp; Storage Errors\n    DATABASE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_ERROR\",\n        message_en=\"Database error occurred\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647 \u0631\u062e \u062f\u0627\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_CONNECTION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_CONNECTION_ERROR\",\n        message_en=\"Failed to connect to the database\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0627\u062a\u0635\u0627\u0644 \u0628\u0647 \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_QUERY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_QUERY_ERROR\",\n        message_en=\"Error executing database query\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0627\u062c\u0631\u0627\u06cc \u067e\u0631\u0633 \u0648 \u062c\u0648\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_TRANSACTION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_TRANSACTION_ERROR\",\n        message_en=\"Error in database transaction\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062a\u0631\u0627\u06a9\u0646\u0634 \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_TIMEOUT_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_TIMEOUT_ERROR\",\n        message_en=\"Database operation timed out\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647 \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_CONSTRAINT_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_CONSTRAINT_ERROR\",\n        message_en=\"Database constraint violation\",\n        message_fa=\"\u0646\u0642\u0636 \u0645\u062d\u062f\u0648\u062f\u06cc\u062a \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_INTEGRITY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_INTEGRITY_ERROR\",\n        message_en=\"Database integrity violation\",\n        message_fa=\"\u0646\u0642\u0636 \u06cc\u06a9\u067e\u0627\u0631\u0686\u06af\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_DEADLOCK_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_DEADLOCK_ERROR\",\n        message_en=\"Database deadlock detected\",\n        message_fa=\"\u0642\u0641\u0644\u200c\u0634\u062f\u06af\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647 \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_SERIALIZATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_SERIALIZATION_ERROR\",\n        message_en=\"Database serialization failure\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u0633\u0631\u06cc\u0627\u0644\u200c\u0633\u0627\u0632\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    DATABASE_CONFIGURATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"DATABASE_CONFIGURATION_ERROR\",\n        message_en=\"Database configuration error\",\n        message_fa=\"\u062e\u0637\u0627\u06cc \u067e\u06cc\u06a9\u0631\u0628\u0646\u062f\u06cc \u067e\u0627\u06cc\u06af\u0627\u0647 \u062f\u0627\u062f\u0647\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    STORAGE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"STORAGE_ERROR\",\n        message_en=\"Storage access error occurred\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633\u06cc \u0628\u0647 \u0641\u0636\u0627\u06cc \u0630\u062e\u06cc\u0631\u0647\u200c\u0633\u0627\u0632\u06cc\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Cache Errors\n    CACHE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"CACHE_ERROR\",\n        message_en=\"Error accessing cache\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062f\u0633\u062a\u0631\u0633\u06cc \u0628\u0647 \u062d\u0627\u0641\u0638\u0647 \u0646\u0647\u0627\u0646\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    CACHE_MISS = ErrorDetailDTO.create_error_detail(\n        code=\"CACHE_MISS\",\n        message_en=\"Requested data not found in cache\",\n        message_fa=\"\u062f\u0627\u062f\u0647 \u062f\u0631\u062e\u0648\u0627\u0633\u062a\u06cc \u062f\u0631 \u062d\u0627\u0641\u0638\u0647 \u0646\u0647\u0627\u0646 \u06cc\u0627\u0641\u062a \u0646\u0634\u062f\",\n        http_status=HTTPStatus.NOT_FOUND if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.NOT_FOUND if GRPC_AVAILABLE else None,\n    )\n\n    # Message Queue Errors\n    QUEUE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"QUEUE_ERROR\",\n        message_en=\"Error in message queue operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0639\u0645\u0644\u06cc\u0627\u062a \u0635\u0641 \u067e\u06cc\u0627\u0645\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    QUEUE_FULL = ErrorDetailDTO.create_error_detail(\n        code=\"QUEUE_FULL\",\n        message_en=\"Message queue is full\",\n        message_fa=\"\u0635\u0641 \u067e\u06cc\u0627\u0645 \u067e\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.SERVICE_UNAVAILABLE if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.RESOURCE_EXHAUSTED if GRPC_AVAILABLE else None,\n    )\n\n    # Search Engine Errors\n    SEARCH_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"SEARCH_ERROR\",\n        message_en=\"Error performing search operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0627\u0646\u062c\u0627\u0645 \u0639\u0645\u0644\u06cc\u0627\u062a \u062c\u0633\u062a\u062c\u0648\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    SEARCH_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"SEARCH_TIMEOUT\",\n        message_en=\"Search operation timed out\",\n        message_fa=\"\u0639\u0645\u0644\u06cc\u0627\u062a \u062c\u0633\u062a\u062c\u0648 \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.REQUEST_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    # External Service Errors\n    EXTERNAL_SERVICE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"EXTERNAL_SERVICE_ERROR\",\n        message_en=\"Error in external service\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0633\u0631\u0648\u06cc\u0633 \u062e\u0627\u0631\u062c\u06cc\",\n        http_status=HTTPStatus.BAD_GATEWAY if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAVAILABLE if GRPC_AVAILABLE else None,\n    )\n\n    EXTERNAL_SERVICE_TIMEOUT = ErrorDetailDTO.create_error_detail(\n        code=\"EXTERNAL_SERVICE_TIMEOUT\",\n        message_en=\"External service request timed out\",\n        message_fa=\"\u062f\u0631\u062e\u0648\u0627\u0633\u062a \u0628\u0647 \u0633\u0631\u0648\u06cc\u0633 \u062e\u0627\u0631\u062c\u06cc \u0628\u0627 \u062a\u0627\u06cc\u0645\u200c\u0627\u0648\u062a \u0645\u0648\u0627\u062c\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.GATEWAY_TIMEOUT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.DEADLINE_EXCEEDED if GRPC_AVAILABLE else None,\n    )\n\n    # Security Errors\n    SECURITY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"SECURITY_ERROR\",\n        message_en=\"Security violation detected\",\n        message_fa=\"\u0646\u0642\u0636 \u0627\u0645\u0646\u06cc\u062a\u06cc \u062a\u0634\u062e\u06cc\u0635 \u062f\u0627\u062f\u0647 \u0634\u062f\",\n        http_status=HTTPStatus.FORBIDDEN if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.PERMISSION_DENIED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_SIGNATURE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_SIGNATURE\",\n        message_en=\"Invalid digital signature\",\n        message_fa=\"\u0627\u0645\u0636\u0627\u06cc \u062f\u06cc\u062c\u06cc\u062a\u0627\u0644 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    INVALID_CERTIFICATE = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_CERTIFICATE\",\n        message_en=\"Invalid security certificate\",\n        message_fa=\"\u06af\u0648\u0627\u0647\u06cc \u0627\u0645\u0646\u06cc\u062a\u06cc \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.UNAUTHORIZED if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.UNAUTHENTICATED if GRPC_AVAILABLE else None,\n    )\n\n    # Configuration Errors\n    CONFIGURATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"CONFIGURATION_ERROR\",\n        message_en=\"Error in system configuration\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u067e\u06cc\u06a9\u0631\u0628\u0646\u062f\u06cc \u0633\u06cc\u0633\u062a\u0645\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    MISSING_CONFIGURATION = ErrorDetailDTO.create_error_detail(\n        code=\"MISSING_CONFIGURATION\",\n        message_en=\"Required configuration is missing\",\n        message_fa=\"\u067e\u06cc\u06a9\u0631\u0628\u0646\u062f\u06cc \u0645\u0648\u0631\u062f \u0646\u06cc\u0627\u0632 \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u062f\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    # Integration Errors\n    INTEGRATION_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"INTEGRATION_ERROR\",\n        message_en=\"Error in system integration\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u06cc\u06a9\u067e\u0627\u0631\u0686\u0647\u200c\u0633\u0627\u0632\u06cc \u0633\u06cc\u0633\u062a\u0645\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    INCOMPATIBLE_VERSION = ErrorDetailDTO.create_error_detail(\n        code=\"INCOMPATIBLE_VERSION\",\n        message_en=\"Incompatible system version\",\n        message_fa=\"\u0646\u0633\u062e\u0647 \u0633\u06cc\u0633\u062a\u0645 \u0646\u0627\u0633\u0627\u0632\u06af\u0627\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.FAILED_PRECONDITION if GRPC_AVAILABLE else None,\n    )\n\n    # Monitoring &amp; Logging Errors\n    MONITORING_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"MONITORING_ERROR\",\n        message_en=\"Error in monitoring system\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0633\u06cc\u0633\u062a\u0645 \u0646\u0638\u0627\u0631\u062a\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    LOGGING_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"LOGGING_ERROR\",\n        message_en=\"Error in logging system\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0633\u06cc\u0633\u062a\u0645 \u062b\u0628\u062a \u0631\u0648\u06cc\u062f\u0627\u062f\u0647\u0627\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Backup &amp; Recovery Errors\n    BACKUP_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"BACKUP_ERROR\",\n        message_en=\"Error in backup operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0639\u0645\u0644\u06cc\u0627\u062a \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u200c\u06af\u06cc\u0631\u06cc\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    RECOVERY_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"RECOVERY_ERROR\",\n        message_en=\"Error in recovery operation\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u0639\u0645\u0644\u06cc\u0627\u062a \u0628\u0627\u0632\u06cc\u0627\u0628\u06cc\",\n        http_status=HTTPStatus.INTERNAL_SERVER_ERROR if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INTERNAL if GRPC_AVAILABLE else None,\n    )\n\n    # Resource Management Errors\n    RESOURCE_LOCKED = ErrorDetailDTO.create_error_detail(\n        code=\"RESOURCE_LOCKED\",\n        message_en=\"Resource is currently locked\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u0642\u0641\u0644 \u0634\u062f\u0647 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    RESOURCE_BUSY = ErrorDetailDTO.create_error_detail(\n        code=\"RESOURCE_BUSY\",\n        message_en=\"Resource is currently busy\",\n        message_fa=\"\u0645\u0646\u0628\u0639 \u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u0645\u0634\u063a\u0648\u0644 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.CONFLICT if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.ABORTED if GRPC_AVAILABLE else None,\n    )\n\n    # Time-related Errors\n    INVALID_TIMESTAMP = ErrorDetailDTO.create_error_detail(\n        code=\"INVALID_TIMESTAMP\",\n        message_en=\"Invalid timestamp format\",\n        message_fa=\"\u0641\u0631\u0645\u062a \u0632\u0645\u0627\u0646 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n\n    TIMEZONE_ERROR = ErrorDetailDTO.create_error_detail(\n        code=\"TIMEZONE_ERROR\",\n        message_en=\"Error in timezone conversion\",\n        message_fa=\"\u062e\u0637\u0627 \u062f\u0631 \u062a\u0628\u062f\u06cc\u0644 \u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc\",\n        http_status=HTTPStatus.BAD_REQUEST if HTTP_AVAILABLE else None,\n        grpc_status=StatusCode.INVALID_ARGUMENT if GRPC_AVAILABLE else None,\n    )\n</code></pre>"},{"location":"api_reference/models/#language-type","title":"Language Type","text":"<p>Language code type definition.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.language_type.LanguageType","title":"<code>archipy.models.types.language_type.LanguageType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum representing supported languages for error messages.</p> <p>This enum defines the languages that are supported for generating or displaying error messages. Each language is represented by its ISO 639-1 code.</p> <p>Attributes:</p> Name Type Description <code>FA</code> <code>str</code> <p>Represents the Persian language (ISO 639-1 code: 'fa').</p> <code>EN</code> <code>str</code> <p>Represents the English language (ISO 639-1 code: 'en').</p> Source code in <code>archipy/models/types/language_type.py</code> <pre><code>class LanguageType(str, Enum):\n    \"\"\"Enum representing supported languages for error messages.\n\n    This enum defines the languages that are supported for generating or displaying\n    error messages. Each language is represented by its ISO 639-1 code.\n\n    Attributes:\n        FA (str): Represents the Persian language (ISO 639-1 code: 'fa').\n        EN (str): Represents the English language (ISO 639-1 code: 'en').\n    \"\"\"\n\n    FA = \"fa\"  # Persian\n    EN = \"en\"  # English\n</code></pre>"},{"location":"api_reference/models/#sort-order-type","title":"Sort Order Type","text":"<p>Sort order type definition for queries.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/models/#archipy.models.types.sort_order_type.SortOrderType","title":"<code>archipy.models.types.sort_order_type.SortOrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of sorting order types.</p> <p>This enum defines the types of sorting orders that can be applied to data, such as ascending or descending.</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <code>str</code> <p>Represents sorting in ascending order.</p> <code>DESCENDING</code> <code>str</code> <p>Represents sorting in descending order.</p> Source code in <code>archipy/models/types/sort_order_type.py</code> <pre><code>class SortOrderType(Enum):\n    \"\"\"Enumeration of sorting order types.\n\n    This enum defines the types of sorting orders that can be applied to data,\n    such as ascending or descending.\n\n    Attributes:\n        ASCENDING (str): Represents sorting in ascending order.\n        DESCENDING (str): Represents sorting in descending order.\n    \"\"\"\n\n    ASCENDING = \"ascending\"\n    DESCENDING = \"descending\"\n</code></pre>"},{"location":"api_reference/models/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/models/#basedto","title":"BaseDTO","text":"<p>Class: <code>archipy.models.dtos.base_dtos.BaseDTO</code></p> <p>Base class for all DTOs with features:</p> <ul> <li>Pydantic model inheritance</li> <li>JSON serialization</li> <li>Validation</li> <li>Type hints</li> <li>Common utility methods</li> </ul>"},{"location":"api_reference/models/#baseentity","title":"BaseEntity","text":"<p>Class: <code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity</code></p> <p>Base class for SQLAlchemy entities with features:</p> <ul> <li>UUID primary key</li> <li>Timestamp fields (created_at, updated_at)</li> <li>Common query methods</li> <li>Relationship support</li> <li>Type-safe column definitions</li> <li>Mixin support for:<ul> <li>Update tracking</li> <li>Soft deletion</li> <li>Admin tracking</li> <li>Manager tracking</li> <li>Archiving</li> <li>Combined capabilities</li> </ul> </li> </ul>"},{"location":"api_reference/models/#baseerror","title":"BaseError","text":"<p>Class: <code>archipy.models.errors.BaseError</code></p> <p>Base class for custom errors with features:</p> <ul> <li>Standardized error format</li> <li>Error code system</li> <li>Detailed error messages</li> <li>Stack trace support</li> <li>Error context</li> <li>Additional data support</li> <li>Language localization</li> <li>HTTP and gRPC status code mapping</li> </ul>"},{"location":"api_reference/utils/","title":"Utils","text":"<p>The <code>utils</code> module provides helper classes with static methods for common operations across the application.</p>"},{"location":"api_reference/utils/#datetime_utils","title":"datetime_utils","text":"<p>Utilities for date and time operations.</p> <pre><code>from archipy.helpers.utils.datetime_utils import DateTimeUtils\n\n# Get current UTC time\nnow = DateTimeUtils.get_utc_now()\n\n# Format datetime\nformatted = DateTimeUtils.format_datetime(now, format=\"%Y-%m-%d %H:%M:%S\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils</code>","text":"<p>A utility class for handling date and time operations, including conversions, caching, and API integrations.</p> <p>This class provides methods for working with both Gregorian and Jalali (Persian) calendars, as well as utility functions for timezone-aware datetime objects, date ranges, and string formatting.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>class DatetimeUtils:\n    \"\"\"A utility class for handling date and time operations, including conversions, caching, and API integrations.\n\n    This class provides methods for working with both Gregorian and Jalali (Persian) calendars, as well as\n    utility functions for timezone-aware datetime objects, date ranges, and string formatting.\n    \"\"\"\n\n    \"\"\"A class-level cache for storing holiday statuses to avoid redundant API calls.\"\"\"\n    _holiday_cache: ClassVar[dict[str, tuple[bool, datetime]]] = {}\n\n    @staticmethod\n    def convert_to_jalali(target_date: date) -&gt; jdatetime.date:\n        \"\"\"Converts a Gregorian date to a Jalali (Persian) date.\n\n        Args:\n            target_date (date): The Gregorian date to convert.\n\n        Returns:\n            jdatetime.date: The corresponding Jalali date.\n        \"\"\"\n        return jdatetime.date.fromgregorian(date=target_date)\n\n    @classmethod\n    def is_holiday_in_iran(cls, target_date: date) -&gt; bool:\n        \"\"\"Determines if the target date is a holiday in Iran.\n\n        This method leverages caching and an external API to check if the given date is a holiday.\n\n        Args:\n            target_date (date): The date to check for holiday status.\n\n        Returns:\n            bool: True if the date is a holiday, False otherwise.\n        \"\"\"\n        # Convert to Jalali date first\n        jalali_date = cls.convert_to_jalali(target_date)\n        date_str = target_date.strftime(\"%Y-%m-%d\")\n        current_time = cls.get_datetime_utc_now()\n\n        # Check cache first\n        is_cached, is_holiday = cls._check_cache(date_str, current_time)\n        if is_cached:\n            return is_holiday\n\n        # Fetch holiday status and cache it\n        return cls._fetch_and_cache_holiday_status(jalali_date, date_str, current_time)\n\n    @classmethod\n    def _check_cache(cls, date_str: str, current_time: datetime) -&gt; tuple[bool, bool]:\n        \"\"\"Checks the cache for holiday status to avoid redundant API calls.\n\n        Args:\n            date_str (str): The date string to check in the cache.\n            current_time (datetime): The current time to compare against cache expiration.\n\n        Returns:\n            tuple[bool, bool]: A tuple where the first element indicates if the cache was hit,\n                               and the second element is the cached holiday status.\n        \"\"\"\n        cached_data = cls._holiday_cache.get(date_str)\n        if cached_data:\n            is_holiday, expiry_time = cached_data\n            if current_time &lt; expiry_time:\n                return True, is_holiday\n\n            # Remove expired cache entry\n            del cls._holiday_cache[date_str]\n\n        return False, False\n\n    @classmethod\n    def _fetch_and_cache_holiday_status(\n        cls,\n        jalali_date: jdatetime.date,\n        date_str: str,\n        current_time: datetime,\n    ) -&gt; bool:\n        \"\"\"Fetches holiday status from the API and caches the result.\n\n        This method calls an external API to determine if the given Jalali date is a holiday.\n        If the API call is successful, the result is cached with an expiration time to avoid\n        redundant API calls. If the API call fails, an `UnknownException` is raised.\n\n        Args:\n            jalali_date (jdatetime.date): The Jalali date to check for holiday status.\n            date_str (str): The date string to use as a cache key.\n            current_time (datetime): The current time to set cache expiration.\n\n        Returns:\n            bool: True if the date is a holiday, False otherwise.\n\n        Raises:\n            UnknownError: If the API request fails due to a network issue or other request-related errors.\n        \"\"\"\n        try:\n            config: Any = BaseConfig.global_config()\n            response = cls._call_holiday_api(jalali_date)\n            is_holiday = cls._parse_holiday_response(response, jalali_date)\n\n            # Cache the result with expiration\n            expiry_time = current_time + timedelta(seconds=config.DATETIME.CACHE_TTL)\n            cls._holiday_cache[date_str] = (is_holiday, expiry_time)\n        except requests.RequestException as exception:\n            raise UnknownError from exception\n\n        return is_holiday\n\n    @staticmethod\n    def _call_holiday_api(jalali_date: jdatetime.date) -&gt; dict[str, Any]:\n        \"\"\"Calls the Time.ir API to fetch holiday data for the given Jalali date.\n\n        Args:\n            jalali_date (jdatetime.date): The Jalali date to fetch data for.\n\n        Returns:\n            Dict[str, Any]: The JSON response from the API.\n\n        Raises:\n            requests.RequestException: If the API request fails.\n        \"\"\"\n        config: Any = BaseConfig.global_config()\n        retry_strategy = Retry(\n            total=config.DATETIME.MAX_RETRIES,\n            status_forcelist=[429, 500, 502, 503, 504],\n            allowed_methods=[\"HEAD\", \"GET\", \"OPTIONS\"],\n        )\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n        session = requests.Session()\n        session.mount(\"https://\", adapter)\n\n        url = DatetimeUtils._build_api_url(jalali_date)\n        headers = {\"x-api-key\": config.DATETIME.TIME_IR_API_KEY}\n        response = session.get(url, headers=headers, timeout=config.DATETIME.REQUEST_TIMEOUT)\n        response.raise_for_status()\n        result: dict[str, Any] = response.json()\n        return result\n\n    @staticmethod\n    def _build_api_url(jalali_date: jdatetime.date) -&gt; str:\n        \"\"\"Builds the API URL with Jalali date parameters.\n\n        Args:\n            jalali_date (jdatetime.date): The Jalali date to include in the URL.\n\n        Returns:\n            str: The constructed API URL.\n        \"\"\"\n        config: Any = BaseConfig.global_config()\n        base_url = config.DATETIME.TIME_IR_API_ENDPOINT\n        return f\"{base_url}?year={jalali_date.year}&amp;month={jalali_date.month}&amp;day={jalali_date.day}\"\n\n    @staticmethod\n    def _parse_holiday_response(response_data: dict[str, Any], jalali_date: jdatetime.date) -&gt; bool:\n        \"\"\"Parses the API response to extract and return the holiday status.\n\n        Args:\n            response_data (Dict[str, Any]): The JSON response from the API.\n            jalali_date (jdatetime.date): The Jalali date to check.\n\n        Returns:\n            bool: True if the date is a holiday, False otherwise.\n        \"\"\"\n        event_list = response_data.get(\"data\", {}).get(\"event_list\", [])\n        for event_info in event_list:\n            if (\n                event_info.get(\"jalali_year\") == jalali_date.year\n                and event_info.get(\"jalali_month\") == jalali_date.month\n                and event_info.get(\"jalali_day\") == jalali_date.day\n            ):\n                is_holiday = event_info.get(\"is_holiday\", False)\n                return bool(is_holiday)\n        return False\n\n    @classmethod\n    def ensure_timezone_aware(cls, dt: datetime) -&gt; datetime:\n        \"\"\"Ensures a datetime object is timezone-aware, converting it to UTC if necessary.\n\n        Args:\n            dt (datetime): The datetime object to make timezone-aware.\n\n        Returns:\n            datetime: The timezone-aware datetime object.\n        \"\"\"\n        if dt.tzinfo is None:\n            return dt.replace(tzinfo=UTC)\n        return dt\n\n    @classmethod\n    def daterange(cls, start_date: datetime, end_date: datetime) -&gt; Generator[date, None, None]:\n        \"\"\"Generates a range of dates from start_date to end_date, exclusive of end_date.\n\n        Args:\n            start_date (datetime): The start date of the range.\n            end_date (datetime): The end date of the range.\n\n        Yields:\n            date: Each date in the range.\n        \"\"\"\n        for n in range((end_date - start_date).days):\n            yield (start_date + timedelta(n)).date()\n\n    @classmethod\n    def get_string_datetime_from_datetime(cls, dt: datetime, format_: str | None = None) -&gt; str:\n        \"\"\"Converts a datetime object to a formatted string. Default format is ISO 8601.\n\n        Args:\n            dt (datetime): The datetime object to format.\n            format_ (str | None): The format string. If None, uses ISO 8601.\n\n        Returns:\n            str: The formatted datetime string.\n        \"\"\"\n        format_ = format_ or \"%Y-%m-%dT%H:%M:%S.%f\"\n        return dt.strftime(format_)\n\n    @classmethod\n    def standardize_string_datetime(cls, date_string: str) -&gt; str:\n        \"\"\"Standardizes a datetime string to the default format.\n\n        Args:\n            date_string (str): The datetime string to standardize.\n\n        Returns:\n            str: The standardized datetime string.\n        \"\"\"\n        datetime_ = cls.get_datetime_from_string_datetime(date_string)\n        return cls.get_string_datetime_from_datetime(datetime_)\n\n    @classmethod\n    def get_datetime_from_string_datetime(cls, date_string: str, format_: str | None = None) -&gt; datetime:\n        \"\"\"Parses a string to a datetime object using the given format, or ISO 8601 by default.\n\n        Args:\n            date_string (str): The datetime string to parse.\n            format_ (str | None): The format string. If None, uses ISO 8601.\n\n        Returns:\n            datetime: The parsed datetime object with UTC timezone.\n        \"\"\"\n        # Parse using a single expression and immediately make timezone-aware for both cases\n        dt = (\n            datetime.fromisoformat(date_string)\n            if format_ is None\n            else datetime.strptime(date_string, format_).replace(tzinfo=UTC)\n        )\n\n        # Handle the fromisoformat case which might already have timezone info\n        if dt.tzinfo is None:\n            dt = dt.replace(tzinfo=UTC)\n\n        return dt\n\n    @classmethod\n    def get_string_datetime_now(cls) -&gt; str:\n        \"\"\"Gets the current datetime as a formatted string. Default format is ISO 8601.\n\n        Returns:\n            str: The formatted datetime string.\n        \"\"\"\n        return cls.get_string_datetime_from_datetime(cls.get_datetime_now())\n\n    @classmethod\n    def get_datetime_now(cls) -&gt; datetime:\n        \"\"\"Gets the current local datetime with timezone information.\n\n        Returns:\n            datetime: The current local datetime with UTC timezone.\n        \"\"\"\n        return datetime.now(UTC)\n\n    @classmethod\n    def get_datetime_utc_now(cls) -&gt; datetime:\n        \"\"\"Gets the current UTC datetime.\n\n        Returns:\n            datetime: The current UTC datetime.\n        \"\"\"\n        return datetime.now(UTC)\n\n    @classmethod\n    def get_epoch_time_now(cls) -&gt; int:\n        \"\"\"Gets the current time in seconds since the epoch.\n\n        Returns:\n            int: The current epoch time.\n        \"\"\"\n        return int(time.time())\n\n    @classmethod\n    def get_datetime_before_given_datetime_or_now(\n        cls,\n        weeks: int = 0,\n        days: int = 0,\n        hours: int = 0,\n        minutes: int = 0,\n        seconds: int = 0,\n        datetime_given: datetime | None = None,\n    ) -&gt; datetime:\n        \"\"\"Subtracts time from a given datetime or the current datetime if not specified.\n\n        Args:\n            weeks (int): The number of weeks to subtract.\n            days (int): The number of days to subtract.\n            hours (int): The number of hours to subtract.\n            minutes (int): The number of minutes to subtract.\n            seconds (int): The number of seconds to subtract.\n            datetime_given (datetime | None): The datetime to subtract from. If None, uses the current datetime.\n\n        Returns:\n            datetime: The resulting datetime after subtraction.\n        \"\"\"\n        datetime_given = datetime_given or cls.get_datetime_now()\n        return datetime_given - timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n\n    @classmethod\n    def get_datetime_after_given_datetime_or_now(\n        cls,\n        weeks: int = 0,\n        days: int = 0,\n        hours: int = 0,\n        minutes: int = 0,\n        seconds: int = 0,\n        datetime_given: datetime | None = None,\n    ) -&gt; datetime:\n        \"\"\"Adds time to a given datetime or the current datetime if not specified.\n\n        Args:\n            weeks (int): The number of weeks to add.\n            days (int): The number of days to add.\n            hours (int): The number of hours to add.\n            minutes (int): The number of minutes to add.\n            seconds (int): The number of seconds to add.\n            datetime_given (datetime | None): The datetime to add to. If None, uses the current datetime.\n\n        Returns:\n            datetime: The resulting datetime after addition.\n        \"\"\"\n        datetime_given = datetime_given or cls.get_datetime_now()\n        return datetime_given + timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.convert_to_jalali","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.convert_to_jalali(target_date)</code>  <code>staticmethod</code>","text":"<p>Converts a Gregorian date to a Jalali (Persian) date.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>date</code> <p>The Gregorian date to convert.</p> required <p>Returns:</p> Type Description <code>date</code> <p>jdatetime.date: The corresponding Jalali date.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@staticmethod\ndef convert_to_jalali(target_date: date) -&gt; jdatetime.date:\n    \"\"\"Converts a Gregorian date to a Jalali (Persian) date.\n\n    Args:\n        target_date (date): The Gregorian date to convert.\n\n    Returns:\n        jdatetime.date: The corresponding Jalali date.\n    \"\"\"\n    return jdatetime.date.fromgregorian(date=target_date)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.is_holiday_in_iran","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.is_holiday_in_iran(target_date)</code>  <code>classmethod</code>","text":"<p>Determines if the target date is a holiday in Iran.</p> <p>This method leverages caching and an external API to check if the given date is a holiday.</p> <p>Parameters:</p> Name Type Description Default <code>target_date</code> <code>date</code> <p>The date to check for holiday status.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the date is a holiday, False otherwise.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef is_holiday_in_iran(cls, target_date: date) -&gt; bool:\n    \"\"\"Determines if the target date is a holiday in Iran.\n\n    This method leverages caching and an external API to check if the given date is a holiday.\n\n    Args:\n        target_date (date): The date to check for holiday status.\n\n    Returns:\n        bool: True if the date is a holiday, False otherwise.\n    \"\"\"\n    # Convert to Jalali date first\n    jalali_date = cls.convert_to_jalali(target_date)\n    date_str = target_date.strftime(\"%Y-%m-%d\")\n    current_time = cls.get_datetime_utc_now()\n\n    # Check cache first\n    is_cached, is_holiday = cls._check_cache(date_str, current_time)\n    if is_cached:\n        return is_holiday\n\n    # Fetch holiday status and cache it\n    return cls._fetch_and_cache_holiday_status(jalali_date, date_str, current_time)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.ensure_timezone_aware","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.ensure_timezone_aware(dt)</code>  <code>classmethod</code>","text":"<p>Ensures a datetime object is timezone-aware, converting it to UTC if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The datetime object to make timezone-aware.</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The timezone-aware datetime object.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef ensure_timezone_aware(cls, dt: datetime) -&gt; datetime:\n    \"\"\"Ensures a datetime object is timezone-aware, converting it to UTC if necessary.\n\n    Args:\n        dt (datetime): The datetime object to make timezone-aware.\n\n    Returns:\n        datetime: The timezone-aware datetime object.\n    \"\"\"\n    if dt.tzinfo is None:\n        return dt.replace(tzinfo=UTC)\n    return dt\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.daterange","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.daterange(start_date, end_date)</code>  <code>classmethod</code>","text":"<p>Generates a range of dates from start_date to end_date, exclusive of end_date.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The start date of the range.</p> required <code>end_date</code> <code>datetime</code> <p>The end date of the range.</p> required <p>Yields:</p> Name Type Description <code>date</code> <code>date</code> <p>Each date in the range.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef daterange(cls, start_date: datetime, end_date: datetime) -&gt; Generator[date, None, None]:\n    \"\"\"Generates a range of dates from start_date to end_date, exclusive of end_date.\n\n    Args:\n        start_date (datetime): The start date of the range.\n        end_date (datetime): The end date of the range.\n\n    Yields:\n        date: Each date in the range.\n    \"\"\"\n    for n in range((end_date - start_date).days):\n        yield (start_date + timedelta(n)).date()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_from_datetime","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_from_datetime(dt, format_=None)</code>  <code>classmethod</code>","text":"<p>Converts a datetime object to a formatted string. Default format is ISO 8601.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The datetime object to format.</p> required <code>format_</code> <code>str | None</code> <p>The format string. If None, uses ISO 8601.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted datetime string.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_string_datetime_from_datetime(cls, dt: datetime, format_: str | None = None) -&gt; str:\n    \"\"\"Converts a datetime object to a formatted string. Default format is ISO 8601.\n\n    Args:\n        dt (datetime): The datetime object to format.\n        format_ (str | None): The format string. If None, uses ISO 8601.\n\n    Returns:\n        str: The formatted datetime string.\n    \"\"\"\n    format_ = format_ or \"%Y-%m-%dT%H:%M:%S.%f\"\n    return dt.strftime(format_)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.standardize_string_datetime","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.standardize_string_datetime(date_string)</code>  <code>classmethod</code>","text":"<p>Standardizes a datetime string to the default format.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>The datetime string to standardize.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The standardized datetime string.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef standardize_string_datetime(cls, date_string: str) -&gt; str:\n    \"\"\"Standardizes a datetime string to the default format.\n\n    Args:\n        date_string (str): The datetime string to standardize.\n\n    Returns:\n        str: The standardized datetime string.\n    \"\"\"\n    datetime_ = cls.get_datetime_from_string_datetime(date_string)\n    return cls.get_string_datetime_from_datetime(datetime_)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_from_string_datetime","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_from_string_datetime(date_string, format_=None)</code>  <code>classmethod</code>","text":"<p>Parses a string to a datetime object using the given format, or ISO 8601 by default.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>The datetime string to parse.</p> required <code>format_</code> <code>str | None</code> <p>The format string. If None, uses ISO 8601.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The parsed datetime object with UTC timezone.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_from_string_datetime(cls, date_string: str, format_: str | None = None) -&gt; datetime:\n    \"\"\"Parses a string to a datetime object using the given format, or ISO 8601 by default.\n\n    Args:\n        date_string (str): The datetime string to parse.\n        format_ (str | None): The format string. If None, uses ISO 8601.\n\n    Returns:\n        datetime: The parsed datetime object with UTC timezone.\n    \"\"\"\n    # Parse using a single expression and immediately make timezone-aware for both cases\n    dt = (\n        datetime.fromisoformat(date_string)\n        if format_ is None\n        else datetime.strptime(date_string, format_).replace(tzinfo=UTC)\n    )\n\n    # Handle the fromisoformat case which might already have timezone info\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=UTC)\n\n    return dt\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_string_datetime_now()</code>  <code>classmethod</code>","text":"<p>Gets the current datetime as a formatted string. Default format is ISO 8601.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted datetime string.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_string_datetime_now(cls) -&gt; str:\n    \"\"\"Gets the current datetime as a formatted string. Default format is ISO 8601.\n\n    Returns:\n        str: The formatted datetime string.\n    \"\"\"\n    return cls.get_string_datetime_from_datetime(cls.get_datetime_now())\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_now()</code>  <code>classmethod</code>","text":"<p>Gets the current local datetime with timezone information.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The current local datetime with UTC timezone.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_now(cls) -&gt; datetime:\n    \"\"\"Gets the current local datetime with timezone information.\n\n    Returns:\n        datetime: The current local datetime with UTC timezone.\n    \"\"\"\n    return datetime.now(UTC)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_utc_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_utc_now()</code>  <code>classmethod</code>","text":"<p>Gets the current UTC datetime.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The current UTC datetime.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_utc_now(cls) -&gt; datetime:\n    \"\"\"Gets the current UTC datetime.\n\n    Returns:\n        datetime: The current UTC datetime.\n    \"\"\"\n    return datetime.now(UTC)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_epoch_time_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_epoch_time_now()</code>  <code>classmethod</code>","text":"<p>Gets the current time in seconds since the epoch.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current epoch time.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_epoch_time_now(cls) -&gt; int:\n    \"\"\"Gets the current time in seconds since the epoch.\n\n    Returns:\n        int: The current epoch time.\n    \"\"\"\n    return int(time.time())\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_before_given_datetime_or_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_before_given_datetime_or_now(weeks=0, days=0, hours=0, minutes=0, seconds=0, datetime_given=None)</code>  <code>classmethod</code>","text":"<p>Subtracts time from a given datetime or the current datetime if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>weeks</code> <code>int</code> <p>The number of weeks to subtract.</p> <code>0</code> <code>days</code> <code>int</code> <p>The number of days to subtract.</p> <code>0</code> <code>hours</code> <code>int</code> <p>The number of hours to subtract.</p> <code>0</code> <code>minutes</code> <code>int</code> <p>The number of minutes to subtract.</p> <code>0</code> <code>seconds</code> <code>int</code> <p>The number of seconds to subtract.</p> <code>0</code> <code>datetime_given</code> <code>datetime | None</code> <p>The datetime to subtract from. If None, uses the current datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The resulting datetime after subtraction.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_before_given_datetime_or_now(\n    cls,\n    weeks: int = 0,\n    days: int = 0,\n    hours: int = 0,\n    minutes: int = 0,\n    seconds: int = 0,\n    datetime_given: datetime | None = None,\n) -&gt; datetime:\n    \"\"\"Subtracts time from a given datetime or the current datetime if not specified.\n\n    Args:\n        weeks (int): The number of weeks to subtract.\n        days (int): The number of days to subtract.\n        hours (int): The number of hours to subtract.\n        minutes (int): The number of minutes to subtract.\n        seconds (int): The number of seconds to subtract.\n        datetime_given (datetime | None): The datetime to subtract from. If None, uses the current datetime.\n\n    Returns:\n        datetime: The resulting datetime after subtraction.\n    \"\"\"\n    datetime_given = datetime_given or cls.get_datetime_now()\n    return datetime_given - timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_after_given_datetime_or_now","title":"<code>archipy.helpers.utils.datetime_utils.DatetimeUtils.get_datetime_after_given_datetime_or_now(weeks=0, days=0, hours=0, minutes=0, seconds=0, datetime_given=None)</code>  <code>classmethod</code>","text":"<p>Adds time to a given datetime or the current datetime if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>weeks</code> <code>int</code> <p>The number of weeks to add.</p> <code>0</code> <code>days</code> <code>int</code> <p>The number of days to add.</p> <code>0</code> <code>hours</code> <code>int</code> <p>The number of hours to add.</p> <code>0</code> <code>minutes</code> <code>int</code> <p>The number of minutes to add.</p> <code>0</code> <code>seconds</code> <code>int</code> <p>The number of seconds to add.</p> <code>0</code> <code>datetime_given</code> <code>datetime | None</code> <p>The datetime to add to. If None, uses the current datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The resulting datetime after addition.</p> Source code in <code>archipy/helpers/utils/datetime_utils.py</code> <pre><code>@classmethod\ndef get_datetime_after_given_datetime_or_now(\n    cls,\n    weeks: int = 0,\n    days: int = 0,\n    hours: int = 0,\n    minutes: int = 0,\n    seconds: int = 0,\n    datetime_given: datetime | None = None,\n) -&gt; datetime:\n    \"\"\"Adds time to a given datetime or the current datetime if not specified.\n\n    Args:\n        weeks (int): The number of weeks to add.\n        days (int): The number of days to add.\n        hours (int): The number of hours to add.\n        minutes (int): The number of minutes to add.\n        seconds (int): The number of seconds to add.\n        datetime_given (datetime | None): The datetime to add to. If None, uses the current datetime.\n\n    Returns:\n        datetime: The resulting datetime after addition.\n    \"\"\"\n    datetime_given = datetime_given or cls.get_datetime_now()\n    return datetime_given + timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)\n</code></pre>"},{"location":"api_reference/utils/#file_utils","title":"file_utils","text":"<p>Utilities for file operations.</p> <pre><code>from archipy.helpers.utils.file_utils import FileUtils\n\n# Read file content\ncontent = FileUtils.read_file(\"path/to/file.txt\")\n\n# Write to file\nFileUtils.write_file(\"path/to/output.txt\", \"content\")\n\n# Get file hash\nfile_hash = FileUtils.get_file_hash(\"path/to/file.txt\")\n\n# Validate file type\nis_valid = FileUtils.validate_file_type(\"path/to/file.pdf\", allowed_types=[\"pdf\", \"doc\"])\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.file_utils.FileUtils","title":"<code>archipy.helpers.utils.file_utils.FileUtils</code>","text":"<p>A utility class for handling file-related operations, such as creating secure links and validating file names.</p> Source code in <code>archipy/helpers/utils/file_utils.py</code> <pre><code>class FileUtils:\n    \"\"\"A utility class for handling file-related operations, such as creating secure links and validating file names.\"\"\"\n\n    @staticmethod\n    def _create_secure_link_hash(path: str, expires_at: float, file_config: FileConfig | None = None) -&gt; str:\n        \"\"\"Generates a secure hash for a file link based on the file path, expiration timestamp, and secret key.\n\n        Args:\n            path (str): The file path to generate the hash for.\n            expires_at (float): The expiration timestamp for the link.\n            file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n        Returns:\n            str: A base64-encoded secure hash for the file link.\n\n        Raises:\n            InvalidArgumentError: If the `SECRET_KEY` in the configuration is `None`.\n        \"\"\"\n        configs: FileConfig = file_config or BaseConfig.global_config().FILE\n        secret: str | None = configs.SECRET_KEY\n        if secret is None:\n            raise InvalidArgumentError(argument_name=\"SECRET_KEY\")\n        _input = f\"{expires_at}{path} {secret}\"\n        hash_object = hashlib.md5(_input.encode(\"utf8\"))\n        return base64.urlsafe_b64encode(hash_object.digest()).decode(\"utf-8\").rstrip(\"=\")\n\n    @classmethod\n    def create_secure_link(\n        cls,\n        path: str,\n        minutes: int | None = None,\n        file_config: FileConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates a secure link with expiration for file access.\n\n        Args:\n            path (str): The file path to create a secure link for.\n            minutes (int | None): Number of minutes until link expiration. Defaults to the config's `DEFAULT_EXPIRY_MINUTES`.\n            file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n        Returns:\n            str: A secure link with a hash and expiration timestamp.\n\n        Raises:\n            InvalidArgumentError: If the `path` is empty.\n            OutOfRangeError: If `minutes` is less than 1.\n        \"\"\"\n        if not path:\n            raise InvalidArgumentError(argument_name=\"path\")\n\n        configs: FileConfig = file_config or BaseConfig.global_config().FILE\n        expiry_minutes: int = minutes if minutes is not None else configs.DEFAULT_EXPIRY_MINUTES\n\n        if expiry_minutes &lt; 1:\n            raise OutOfRangeError(field_name=\"minutes\")\n\n        expires_at = int(DatetimeUtils.get_datetime_after_given_datetime_or_now(minutes=expiry_minutes).timestamp())\n        secure_link_hash = cls._create_secure_link_hash(path, expires_at, file_config)\n\n        return f\"{path}?md5={secure_link_hash}&amp;expires_at={expires_at}\"\n\n    @classmethod\n    def validate_file_name(\n        cls,\n        file_name: str,\n        file_config: FileConfig | None = None,\n    ) -&gt; bool:\n        \"\"\"Validates a file name based on allowed extensions.\n\n        Args:\n            file_name (str): The file name to validate.\n            file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n        Returns:\n            bool: `True` if the file name has an allowed extension, `False` otherwise.\n\n        Raises:\n            InvalidArgumentError: If `file_name` is not a string or `allowed_extensions` is not a list.\n        \"\"\"\n        configs: FileConfig = file_config or BaseConfig.global_config().FILE\n        allowed_extensions: list[str] = configs.ALLOWED_EXTENSIONS\n\n        if not isinstance(file_name, str):\n            raise InvalidArgumentError(argument_name=\"file_name\")\n\n        if not allowed_extensions:\n            raise InvalidArgumentError(argument_name=\"allowed_extensions\")\n\n        file_path = Path(file_name)\n        ext = file_path.suffix[1:].lower()\n        return ext in allowed_extensions and bool(ext)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.file_utils.FileUtils.create_secure_link","title":"<code>archipy.helpers.utils.file_utils.FileUtils.create_secure_link(path, minutes=None, file_config=None)</code>  <code>classmethod</code>","text":"<p>Creates a secure link with expiration for file access.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path to create a secure link for.</p> required <code>minutes</code> <code>int | None</code> <p>Number of minutes until link expiration. Defaults to the config's <code>DEFAULT_EXPIRY_MINUTES</code>.</p> <code>None</code> <code>file_config</code> <code>FileConfig | None</code> <p>Optional file configuration object. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A secure link with a hash and expiration timestamp.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the <code>path</code> is empty.</p> <code>OutOfRangeError</code> <p>If <code>minutes</code> is less than 1.</p> Source code in <code>archipy/helpers/utils/file_utils.py</code> <pre><code>@classmethod\ndef create_secure_link(\n    cls,\n    path: str,\n    minutes: int | None = None,\n    file_config: FileConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates a secure link with expiration for file access.\n\n    Args:\n        path (str): The file path to create a secure link for.\n        minutes (int | None): Number of minutes until link expiration. Defaults to the config's `DEFAULT_EXPIRY_MINUTES`.\n        file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n    Returns:\n        str: A secure link with a hash and expiration timestamp.\n\n    Raises:\n        InvalidArgumentError: If the `path` is empty.\n        OutOfRangeError: If `minutes` is less than 1.\n    \"\"\"\n    if not path:\n        raise InvalidArgumentError(argument_name=\"path\")\n\n    configs: FileConfig = file_config or BaseConfig.global_config().FILE\n    expiry_minutes: int = minutes if minutes is not None else configs.DEFAULT_EXPIRY_MINUTES\n\n    if expiry_minutes &lt; 1:\n        raise OutOfRangeError(field_name=\"minutes\")\n\n    expires_at = int(DatetimeUtils.get_datetime_after_given_datetime_or_now(minutes=expiry_minutes).timestamp())\n    secure_link_hash = cls._create_secure_link_hash(path, expires_at, file_config)\n\n    return f\"{path}?md5={secure_link_hash}&amp;expires_at={expires_at}\"\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.file_utils.FileUtils.validate_file_name","title":"<code>archipy.helpers.utils.file_utils.FileUtils.validate_file_name(file_name, file_config=None)</code>  <code>classmethod</code>","text":"<p>Validates a file name based on allowed extensions.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The file name to validate.</p> required <code>file_config</code> <code>FileConfig | None</code> <p>Optional file configuration object. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the file name has an allowed extension, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If <code>file_name</code> is not a string or <code>allowed_extensions</code> is not a list.</p> Source code in <code>archipy/helpers/utils/file_utils.py</code> <pre><code>@classmethod\ndef validate_file_name(\n    cls,\n    file_name: str,\n    file_config: FileConfig | None = None,\n) -&gt; bool:\n    \"\"\"Validates a file name based on allowed extensions.\n\n    Args:\n        file_name (str): The file name to validate.\n        file_config (FileConfig | None): Optional file configuration object. If not provided, uses the global config.\n\n    Returns:\n        bool: `True` if the file name has an allowed extension, `False` otherwise.\n\n    Raises:\n        InvalidArgumentError: If `file_name` is not a string or `allowed_extensions` is not a list.\n    \"\"\"\n    configs: FileConfig = file_config or BaseConfig.global_config().FILE\n    allowed_extensions: list[str] = configs.ALLOWED_EXTENSIONS\n\n    if not isinstance(file_name, str):\n        raise InvalidArgumentError(argument_name=\"file_name\")\n\n    if not allowed_extensions:\n        raise InvalidArgumentError(argument_name=\"allowed_extensions\")\n\n    file_path = Path(file_name)\n    ext = file_path.suffix[1:].lower()\n    return ext in allowed_extensions and bool(ext)\n</code></pre>"},{"location":"api_reference/utils/#jwt_utils","title":"jwt_utils","text":"<p>Utilities for JWT (JSON Web Token) operations.</p> <pre><code>from archipy.helpers.utils.jwt_utils import JWTUtils\n\n# Generate JWT\ntoken = JWTUtils.generate_jwt(\n    payload={\"user_id\": \"123\"},\n    secret=\"your-secret\",\n    expires_in=3600\n)\n\n# Verify JWT\nis_valid = JWTUtils.verify_jwt(token, secret=\"your-secret\")\n\n# Decode JWT\npayload = JWTUtils.decode_jwt(token)\n</code></pre> <p>Utility module for JWT token operations with enhanced security and datetime handling.</p> <p>This module provides a robust JWT handling implementation with support for access and refresh tokens, cryptographic security, token validation, and comprehensive error handling.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils</code>","text":"<p>Utility class for JWT token operations with enhanced security and datetime handling.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>class JWTUtils:\n    \"\"\"Utility class for JWT token operations with enhanced security and datetime handling.\"\"\"\n\n    @classmethod\n    def create_token(\n        cls,\n        data: dict[str, Any],\n        expires_in: int,\n        additional_claims: dict[str, Any] | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates a JWT token with enhanced security features.\n\n        Args:\n            data (dict[str, Any]): Base claims data to include in the token.\n            expires_in (int): Token expiration time in seconds.\n            additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            str: The encoded JWT token.\n\n        Raises:\n            ValueError: If data is empty or expiration is invalid\n        \"\"\"\n        import jwt\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n        current_time = DatetimeUtils.get_datetime_utc_now()\n\n        # Define argument names\n        arg_data = \"data\"\n        arg_expires_in = \"expires_in\"\n\n        if not data:\n            raise InvalidArgumentError(arg_data)\n        if expires_in &lt;= 0:\n            raise InvalidArgumentError(arg_expires_in)\n\n        to_encode = data.copy()\n        expire = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=expires_in, datetime_given=current_time)\n\n        # Add standard claims\n        to_encode.update(\n            {\n                # Registered claims (RFC 7519)\n                \"iss\": configs.JWT_ISSUER,\n                \"aud\": configs.JWT_AUDIENCE,\n                \"exp\": expire,\n                \"iat\": current_time,\n                \"nbf\": current_time,\n            },\n        )\n\n        # Add JWT ID if enabled\n        if configs.ENABLE_JTI_CLAIM:\n            to_encode[\"jti\"] = str(uuid4())\n\n        # Add additional claims\n        if additional_claims:\n            to_encode.update(additional_claims)\n\n        # Validate SECRET_KEY\n        arg_secret_key = \"SECRET_KEY\"\n        secret_key = configs.SECRET_KEY\n        if secret_key is None:\n            raise InvalidArgumentError(arg_secret_key)\n        return jwt.encode(to_encode, secret_key.get_secret_value(), algorithm=configs.HASH_ALGORITHM)\n\n    @classmethod\n    def create_access_token(\n        cls,\n        user_uuid: UUID,\n        additional_claims: dict[str, Any] | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates an access token for a user.\n\n        Args:\n            user_uuid (UUID): The user's UUID to include in the token.\n            additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            str: The encoded access token.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        return cls.create_token(\n            data={\n                \"sub\": str(user_uuid),\n                \"type\": \"access\",\n                \"token_version\": configs.TOKEN_VERSION,\n            },\n            expires_in=configs.ACCESS_TOKEN_EXPIRES_IN,\n            additional_claims=additional_claims,\n            auth_config=configs,\n        )\n\n    @classmethod\n    def create_refresh_token(\n        cls,\n        user_uuid: UUID,\n        additional_claims: dict[str, Any] | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; str:\n        \"\"\"Creates a refresh token for a user.\n\n        Args:\n            user_uuid (UUID): The user's UUID to include in the token.\n            additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            str: The encoded refresh token.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        return cls.create_token(\n            data={\n                \"sub\": str(user_uuid),\n                \"type\": \"refresh\",\n                \"token_version\": configs.TOKEN_VERSION,\n            },\n            expires_in=configs.REFRESH_TOKEN_EXPIRES_IN,\n            additional_claims=additional_claims,\n            auth_config=configs,\n        )\n\n    @classmethod\n    def decode_token(\n        cls,\n        token: str,\n        verify_type: str | None = None,\n        auth_config: AuthConfig | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Decodes and verifies a JWT token with enhanced security checks.\n\n        Args:\n            token (str): The JWT token to decode.\n            verify_type (str | None): Optional token type to verify (e.g., \"access\" or \"refresh\").\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            dict[str, Any]: The decoded token payload.\n\n        Raises:\n            TokenExpiredError: If the token has expired.\n            InvalidTokenError: If the token is invalid (e.g., invalid signature, audience, issuer, or type).\n        \"\"\"\n        import jwt\n        from jwt.exceptions import (\n            ExpiredSignatureError,\n            InvalidAudienceError,\n            InvalidIssuerError,\n            InvalidSignatureError,\n            InvalidTokenError as JWTInvalidTokenError,\n        )\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n        required_claims = [\"exp\", \"iat\", \"nbf\", \"aud\", \"iss\", \"sub\", \"type\", \"token_version\"]\n        if configs.ENABLE_JTI_CLAIM:\n            required_claims.append(\"jti\")\n\n        try:\n            # Validate SECRET_KEY\n            arg_secret_key = \"SECRET_KEY\"\n            secret_key = configs.SECRET_KEY\n            if secret_key is None:\n                raise InvalidArgumentError(arg_secret_key)\n\n            payload = jwt.decode(\n                token,\n                secret_key.get_secret_value(),\n                algorithms=[configs.HASH_ALGORITHM],\n                options={\n                    \"verify_signature\": True,\n                    \"verify_exp\": True,\n                    \"verify_nbf\": True,\n                    \"verify_iat\": True,\n                    \"verify_aud\": True,\n                    \"verify_iss\": True,\n                    \"require\": required_claims,\n                },\n                audience=configs.JWT_AUDIENCE,\n                issuer=configs.JWT_ISSUER,\n            )\n\n            # Verify token type\n            if verify_type and payload.get(\"type\") != verify_type:\n                raise InvalidTokenError\n\n            # Verify token version\n            if payload.get(\"token_version\") != configs.TOKEN_VERSION:\n                raise InvalidTokenError\n\n            # Ensure the return type is dict[str, Any] as declared\n            return dict(payload)\n\n        except ExpiredSignatureError as exception:\n            raise TokenExpiredError from exception\n        except InvalidSignatureError as exception:\n            raise InvalidTokenError from exception\n        except InvalidAudienceError as exception:\n            raise InvalidTokenError from exception\n        except InvalidIssuerError as exception:\n            raise InvalidTokenError from exception\n        except JWTInvalidTokenError as exception:\n            raise InvalidTokenError from exception\n\n    @classmethod\n    def verify_access_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n        \"\"\"Verifies an access token.\n\n        Args:\n            token (str): The access token to verify.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            dict[str, Any]: The decoded access token payload.\n\n        Raises:\n            InvalidTokenException: If the token is invalid or not an access token.\n            TokenExpiredException: If the token has expired.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        return cls.decode_token(token, verify_type=\"access\", auth_config=configs)\n\n    @classmethod\n    def verify_refresh_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n        \"\"\"Verifies a refresh token.\n\n        Args:\n            token (str): The refresh token to verify.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            dict[str, Any]: The decoded refresh token payload.\n\n        Raises:\n            InvalidTokenException: If the token is invalid or not a refresh token.\n            TokenExpiredException: If the token has expired.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        return cls.decode_token(token, verify_type=\"refresh\", auth_config=configs)\n\n    @staticmethod\n    def extract_user_uuid(payload: dict[str, Any]) -&gt; UUID:\n        \"\"\"Extracts the user UUID from the token payload.\n\n        Args:\n            payload (dict[str, Any]): The decoded token payload.\n\n        Returns:\n            UUID: The user's UUID.\n\n        Raises:\n            InvalidTokenException: If the user identifier is invalid or missing.\n        \"\"\"\n        try:\n            return UUID(payload[\"sub\"])\n        except (KeyError, ValueError) as exception:\n            raise InvalidTokenError from exception\n\n    @classmethod\n    def get_token_expiry(cls, token: str, auth_config: AuthConfig | None = None) -&gt; int:\n        \"\"\"Gets the token expiry timestamp.\n\n        Args:\n            token (str): The JWT token.\n            auth_config (AuthConfig | None): Optional auth configuration override.\n                If not provided, uses the global config.\n\n        Returns:\n            int: The token expiry timestamp in seconds.\n\n        Raises:\n            InvalidTokenException: If the token is invalid.\n        \"\"\"\n        payload = cls.decode_token(token, auth_config=auth_config)\n        return int(payload[\"exp\"])\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.create_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.create_token(data, expires_in, additional_claims=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Creates a JWT token with enhanced security features.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Base claims data to include in the token.</p> required <code>expires_in</code> <code>int</code> <p>Token expiration time in seconds.</p> required <code>additional_claims</code> <code>dict[str, Any] | None</code> <p>Optional additional claims to include in the token.</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded JWT token.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is empty or expiration is invalid</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef create_token(\n    cls,\n    data: dict[str, Any],\n    expires_in: int,\n    additional_claims: dict[str, Any] | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates a JWT token with enhanced security features.\n\n    Args:\n        data (dict[str, Any]): Base claims data to include in the token.\n        expires_in (int): Token expiration time in seconds.\n        additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        str: The encoded JWT token.\n\n    Raises:\n        ValueError: If data is empty or expiration is invalid\n    \"\"\"\n    import jwt\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n    current_time = DatetimeUtils.get_datetime_utc_now()\n\n    # Define argument names\n    arg_data = \"data\"\n    arg_expires_in = \"expires_in\"\n\n    if not data:\n        raise InvalidArgumentError(arg_data)\n    if expires_in &lt;= 0:\n        raise InvalidArgumentError(arg_expires_in)\n\n    to_encode = data.copy()\n    expire = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=expires_in, datetime_given=current_time)\n\n    # Add standard claims\n    to_encode.update(\n        {\n            # Registered claims (RFC 7519)\n            \"iss\": configs.JWT_ISSUER,\n            \"aud\": configs.JWT_AUDIENCE,\n            \"exp\": expire,\n            \"iat\": current_time,\n            \"nbf\": current_time,\n        },\n    )\n\n    # Add JWT ID if enabled\n    if configs.ENABLE_JTI_CLAIM:\n        to_encode[\"jti\"] = str(uuid4())\n\n    # Add additional claims\n    if additional_claims:\n        to_encode.update(additional_claims)\n\n    # Validate SECRET_KEY\n    arg_secret_key = \"SECRET_KEY\"\n    secret_key = configs.SECRET_KEY\n    if secret_key is None:\n        raise InvalidArgumentError(arg_secret_key)\n    return jwt.encode(to_encode, secret_key.get_secret_value(), algorithm=configs.HASH_ALGORITHM)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.create_access_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.create_access_token(user_uuid, additional_claims=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Creates an access token for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_uuid</code> <code>UUID</code> <p>The user's UUID to include in the token.</p> required <code>additional_claims</code> <code>dict[str, Any] | None</code> <p>Optional additional claims to include in the token.</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded access token.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef create_access_token(\n    cls,\n    user_uuid: UUID,\n    additional_claims: dict[str, Any] | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates an access token for a user.\n\n    Args:\n        user_uuid (UUID): The user's UUID to include in the token.\n        additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        str: The encoded access token.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    return cls.create_token(\n        data={\n            \"sub\": str(user_uuid),\n            \"type\": \"access\",\n            \"token_version\": configs.TOKEN_VERSION,\n        },\n        expires_in=configs.ACCESS_TOKEN_EXPIRES_IN,\n        additional_claims=additional_claims,\n        auth_config=configs,\n    )\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.create_refresh_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.create_refresh_token(user_uuid, additional_claims=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Creates a refresh token for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_uuid</code> <code>UUID</code> <p>The user's UUID to include in the token.</p> required <code>additional_claims</code> <code>dict[str, Any] | None</code> <p>Optional additional claims to include in the token.</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded refresh token.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef create_refresh_token(\n    cls,\n    user_uuid: UUID,\n    additional_claims: dict[str, Any] | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; str:\n    \"\"\"Creates a refresh token for a user.\n\n    Args:\n        user_uuid (UUID): The user's UUID to include in the token.\n        additional_claims (dict[str, Any] | None): Optional additional claims to include in the token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        str: The encoded refresh token.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    return cls.create_token(\n        data={\n            \"sub\": str(user_uuid),\n            \"type\": \"refresh\",\n            \"token_version\": configs.TOKEN_VERSION,\n        },\n        expires_in=configs.REFRESH_TOKEN_EXPIRES_IN,\n        additional_claims=additional_claims,\n        auth_config=configs,\n    )\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.decode_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.decode_token(token, verify_type=None, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Decodes and verifies a JWT token with enhanced security checks.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token to decode.</p> required <code>verify_type</code> <code>str | None</code> <p>Optional token type to verify (e.g., \"access\" or \"refresh\").</p> <code>None</code> <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The decoded token payload.</p> <p>Raises:</p> Type Description <code>TokenExpiredError</code> <p>If the token has expired.</p> <code>InvalidTokenError</code> <p>If the token is invalid (e.g., invalid signature, audience, issuer, or type).</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef decode_token(\n    cls,\n    token: str,\n    verify_type: str | None = None,\n    auth_config: AuthConfig | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Decodes and verifies a JWT token with enhanced security checks.\n\n    Args:\n        token (str): The JWT token to decode.\n        verify_type (str | None): Optional token type to verify (e.g., \"access\" or \"refresh\").\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        dict[str, Any]: The decoded token payload.\n\n    Raises:\n        TokenExpiredError: If the token has expired.\n        InvalidTokenError: If the token is invalid (e.g., invalid signature, audience, issuer, or type).\n    \"\"\"\n    import jwt\n    from jwt.exceptions import (\n        ExpiredSignatureError,\n        InvalidAudienceError,\n        InvalidIssuerError,\n        InvalidSignatureError,\n        InvalidTokenError as JWTInvalidTokenError,\n    )\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n    required_claims = [\"exp\", \"iat\", \"nbf\", \"aud\", \"iss\", \"sub\", \"type\", \"token_version\"]\n    if configs.ENABLE_JTI_CLAIM:\n        required_claims.append(\"jti\")\n\n    try:\n        # Validate SECRET_KEY\n        arg_secret_key = \"SECRET_KEY\"\n        secret_key = configs.SECRET_KEY\n        if secret_key is None:\n            raise InvalidArgumentError(arg_secret_key)\n\n        payload = jwt.decode(\n            token,\n            secret_key.get_secret_value(),\n            algorithms=[configs.HASH_ALGORITHM],\n            options={\n                \"verify_signature\": True,\n                \"verify_exp\": True,\n                \"verify_nbf\": True,\n                \"verify_iat\": True,\n                \"verify_aud\": True,\n                \"verify_iss\": True,\n                \"require\": required_claims,\n            },\n            audience=configs.JWT_AUDIENCE,\n            issuer=configs.JWT_ISSUER,\n        )\n\n        # Verify token type\n        if verify_type and payload.get(\"type\") != verify_type:\n            raise InvalidTokenError\n\n        # Verify token version\n        if payload.get(\"token_version\") != configs.TOKEN_VERSION:\n            raise InvalidTokenError\n\n        # Ensure the return type is dict[str, Any] as declared\n        return dict(payload)\n\n    except ExpiredSignatureError as exception:\n        raise TokenExpiredError from exception\n    except InvalidSignatureError as exception:\n        raise InvalidTokenError from exception\n    except InvalidAudienceError as exception:\n        raise InvalidTokenError from exception\n    except InvalidIssuerError as exception:\n        raise InvalidTokenError from exception\n    except JWTInvalidTokenError as exception:\n        raise InvalidTokenError from exception\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.verify_access_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.verify_access_token(token, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Verifies an access token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The access token to verify.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The decoded access token payload.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the token is invalid or not an access token.</p> <code>TokenExpiredException</code> <p>If the token has expired.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef verify_access_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n    \"\"\"Verifies an access token.\n\n    Args:\n        token (str): The access token to verify.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        dict[str, Any]: The decoded access token payload.\n\n    Raises:\n        InvalidTokenException: If the token is invalid or not an access token.\n        TokenExpiredException: If the token has expired.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    return cls.decode_token(token, verify_type=\"access\", auth_config=configs)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.verify_refresh_token","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.verify_refresh_token(token, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Verifies a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The refresh token to verify.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The decoded refresh token payload.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the token is invalid or not a refresh token.</p> <code>TokenExpiredException</code> <p>If the token has expired.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef verify_refresh_token(cls, token: str, auth_config: AuthConfig | None = None) -&gt; dict[str, Any]:\n    \"\"\"Verifies a refresh token.\n\n    Args:\n        token (str): The refresh token to verify.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        dict[str, Any]: The decoded refresh token payload.\n\n    Raises:\n        InvalidTokenException: If the token is invalid or not a refresh token.\n        TokenExpiredException: If the token has expired.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    return cls.decode_token(token, verify_type=\"refresh\", auth_config=configs)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.extract_user_uuid","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.extract_user_uuid(payload)</code>  <code>staticmethod</code>","text":"<p>Extracts the user UUID from the token payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict[str, Any]</code> <p>The decoded token payload.</p> required <p>Returns:</p> Name Type Description <code>UUID</code> <code>UUID</code> <p>The user's UUID.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the user identifier is invalid or missing.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@staticmethod\ndef extract_user_uuid(payload: dict[str, Any]) -&gt; UUID:\n    \"\"\"Extracts the user UUID from the token payload.\n\n    Args:\n        payload (dict[str, Any]): The decoded token payload.\n\n    Returns:\n        UUID: The user's UUID.\n\n    Raises:\n        InvalidTokenException: If the user identifier is invalid or missing.\n    \"\"\"\n    try:\n        return UUID(payload[\"sub\"])\n    except (KeyError, ValueError) as exception:\n        raise InvalidTokenError from exception\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.jwt_utils.JWTUtils.get_token_expiry","title":"<code>archipy.helpers.utils.jwt_utils.JWTUtils.get_token_expiry(token, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Gets the token expiry timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The token expiry timestamp in seconds.</p> <p>Raises:</p> Type Description <code>InvalidTokenException</code> <p>If the token is invalid.</p> Source code in <code>archipy/helpers/utils/jwt_utils.py</code> <pre><code>@classmethod\ndef get_token_expiry(cls, token: str, auth_config: AuthConfig | None = None) -&gt; int:\n    \"\"\"Gets the token expiry timestamp.\n\n    Args:\n        token (str): The JWT token.\n        auth_config (AuthConfig | None): Optional auth configuration override.\n            If not provided, uses the global config.\n\n    Returns:\n        int: The token expiry timestamp in seconds.\n\n    Raises:\n        InvalidTokenException: If the token is invalid.\n    \"\"\"\n    payload = cls.decode_token(token, auth_config=auth_config)\n    return int(payload[\"exp\"])\n</code></pre>"},{"location":"api_reference/utils/#password_utils","title":"password_utils","text":"<p>Utilities for password operations.</p> <pre><code>from archipy.helpers.utils.password_utils import PasswordUtils\n\n# Hash password\nhashed = PasswordUtils.hash_password(\"my-password\")\n\n# Verify password\nis_valid = PasswordUtils.verify_password(\"my-password\", hashed)\n\n# Generate secure password\npassword = PasswordUtils.generate_password(length=12)\n\n# Validate password strength\nis_strong = PasswordUtils.validate_password_strength(\"my-password\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils</code>","text":"<p>A utility class for handling password-related operations, such as hashing, verification, and validation.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>class PasswordUtils:\n    \"\"\"A utility class for handling password-related operations, such as hashing, verification, and validation.\"\"\"\n\n    @staticmethod\n    def hash_password(password: str, auth_config: AuthConfig | None = None) -&gt; str:\n        \"\"\"Hashes a password using PBKDF2 with SHA256.\n\n        Args:\n            password (str): The password to hash.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            str: A base64-encoded string containing the salt and hash in the format \"salt:hash\".\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        salt = os.urandom(configs.SALT_LENGTH)\n        pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n        # Combine salt and hash, encode in base64\n        return b64encode(salt + pw_hash).decode(\"utf-8\")\n\n    @staticmethod\n    def verify_password(password: str, stored_password: str, auth_config: AuthConfig | None = None) -&gt; bool:\n        \"\"\"Verifies a password against a stored hash.\n\n        Args:\n            password (str): The password to verify.\n            stored_password (str): The stored password hash to compare against.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            bool: True if the password matches the stored hash, False otherwise.\n        \"\"\"\n        try:\n            configs = auth_config or BaseConfig.global_config().AUTH\n\n            # Decode the stored password\n            decoded = b64decode(stored_password.encode(\"utf-8\"))\n            salt = decoded[: configs.SALT_LENGTH]\n            stored_hash = decoded[configs.SALT_LENGTH :]\n\n            # Hash the provided password with the same salt\n            pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n            # Compare in constant time to prevent timing attacks\n            return hmac.compare_digest(pw_hash, stored_hash)\n        except (ValueError, TypeError, IndexError):\n            # Catch specific exceptions that could occur during decoding or comparison\n            return False\n\n    @staticmethod\n    def validate_password(\n        password: str,\n        auth_config: AuthConfig | None = None,\n        lang: LanguageType = LanguageType.FA,\n    ) -&gt; None:\n        \"\"\"Validates a password against the password policy.\n\n        Args:\n            password (str): The password to validate.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n            lang (LanguageType): The language to use for error messages. Defaults to Persian.\n\n        Raises:\n            InvalidPasswordError: If the password does not meet the policy requirements.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n        errors = []\n\n        if len(password) &lt; configs.MIN_LENGTH:\n            errors.append(f\"Password must be at least {configs.MIN_LENGTH} characters long.\")\n\n        if configs.REQUIRE_DIGIT and not any(char.isdigit() for char in password):\n            errors.append(\"Password must contain at least one digit.\")\n\n        if configs.REQUIRE_LOWERCASE and not any(char.islower() for char in password):\n            errors.append(\"Password must contain at least one lowercase letter.\")\n\n        if configs.REQUIRE_UPPERCASE and not any(char.isupper() for char in password):\n            errors.append(\"Password must contain at least one uppercase letter.\")\n\n        if configs.REQUIRE_SPECIAL and not any(char in configs.SPECIAL_CHARACTERS for char in password):\n            errors.append(f\"Password must contain at least one special character: {configs.SPECIAL_CHARACTERS}\")\n\n        if errors:\n            raise InvalidPasswordError(requirements=errors, lang=lang)\n\n    @staticmethod\n    def generate_password(auth_config: AuthConfig | None = None) -&gt; str:\n        \"\"\"Generates a random password that meets the policy requirements.\n\n        Args:\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            str: A randomly generated password that meets the policy requirements.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        lowercase_chars = string.ascii_lowercase\n        uppercase_chars = string.ascii_uppercase\n        digit_chars = string.digits\n        special_chars = \"\".join(configs.SPECIAL_CHARACTERS)\n\n        # Initialize with required characters\n        password_chars = []\n        if configs.REQUIRE_LOWERCASE:\n            password_chars.append(secrets.choice(lowercase_chars))\n        if configs.REQUIRE_UPPERCASE:\n            password_chars.append(secrets.choice(uppercase_chars))\n        if configs.REQUIRE_DIGIT:\n            password_chars.append(secrets.choice(digit_chars))\n        if configs.REQUIRE_SPECIAL:\n            password_chars.append(secrets.choice(special_chars))\n\n        # Calculate remaining length\n        remaining_length = max(0, configs.MIN_LENGTH - len(password_chars))\n\n        # Add random characters to meet minimum length\n        all_chars = lowercase_chars + uppercase_chars + digit_chars + special_chars\n        password_chars.extend(secrets.choice(all_chars) for _ in range(remaining_length))\n\n        # Shuffle the password characters\n        shuffled = list(password_chars)\n        secrets.SystemRandom().shuffle(shuffled)\n\n        return \"\".join(shuffled)\n\n    @classmethod\n    def validate_password_history(\n        cls,\n        new_password: str,\n        password_history: list[str],\n        auth_config: AuthConfig | None = None,\n        lang: LanguageType = LanguageType.FA,\n    ) -&gt; None:\n        \"\"\"Validates a new password against the password history.\n\n        Args:\n            new_password (str): The new password to validate.\n            password_history (list[str]): A list of previous password hashes.\n            auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n            lang (LanguageType): The language to use for error messages. Defaults to Persian.\n\n        Raises:\n            InvalidPasswordError: If the new password has been used recently or does not meet the policy requirements.\n        \"\"\"\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # First validate against password policy\n        cls.validate_password(new_password, configs, lang)\n\n        # Check password history\n        if any(\n            cls.verify_password(new_password, old_password, configs)\n            for old_password in password_history[-configs.PASSWORD_HISTORY_SIZE :]\n        ):\n            raise InvalidPasswordError(requirements=[\"Password has been used recently\"], lang=lang)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.hash_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.hash_password(password, auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Hashes a password using PBKDF2 with SHA256.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to hash.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A base64-encoded string containing the salt and hash in the format \"salt:hash\".</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef hash_password(password: str, auth_config: AuthConfig | None = None) -&gt; str:\n    \"\"\"Hashes a password using PBKDF2 with SHA256.\n\n    Args:\n        password (str): The password to hash.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        str: A base64-encoded string containing the salt and hash in the format \"salt:hash\".\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    salt = os.urandom(configs.SALT_LENGTH)\n    pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n    # Combine salt and hash, encode in base64\n    return b64encode(salt + pw_hash).decode(\"utf-8\")\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.verify_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.verify_password(password, stored_password, auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Verifies a password against a stored hash.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to verify.</p> required <code>stored_password</code> <code>str</code> <p>The stored password hash to compare against.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the password matches the stored hash, False otherwise.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef verify_password(password: str, stored_password: str, auth_config: AuthConfig | None = None) -&gt; bool:\n    \"\"\"Verifies a password against a stored hash.\n\n    Args:\n        password (str): The password to verify.\n        stored_password (str): The stored password hash to compare against.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        bool: True if the password matches the stored hash, False otherwise.\n    \"\"\"\n    try:\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # Decode the stored password\n        decoded = b64decode(stored_password.encode(\"utf-8\"))\n        salt = decoded[: configs.SALT_LENGTH]\n        stored_hash = decoded[configs.SALT_LENGTH :]\n\n        # Hash the provided password with the same salt\n        pw_hash = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), salt, configs.HASH_ITERATIONS)\n\n        # Compare in constant time to prevent timing attacks\n        return hmac.compare_digest(pw_hash, stored_hash)\n    except (ValueError, TypeError, IndexError):\n        # Catch specific exceptions that could occur during decoding or comparison\n        return False\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.validate_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.validate_password(password, auth_config=None, lang=LanguageType.FA)</code>  <code>staticmethod</code>","text":"<p>Validates a password against the password policy.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to validate.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>The language to use for error messages. Defaults to Persian.</p> <code>FA</code> <p>Raises:</p> Type Description <code>InvalidPasswordError</code> <p>If the password does not meet the policy requirements.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef validate_password(\n    password: str,\n    auth_config: AuthConfig | None = None,\n    lang: LanguageType = LanguageType.FA,\n) -&gt; None:\n    \"\"\"Validates a password against the password policy.\n\n    Args:\n        password (str): The password to validate.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n        lang (LanguageType): The language to use for error messages. Defaults to Persian.\n\n    Raises:\n        InvalidPasswordError: If the password does not meet the policy requirements.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n    errors = []\n\n    if len(password) &lt; configs.MIN_LENGTH:\n        errors.append(f\"Password must be at least {configs.MIN_LENGTH} characters long.\")\n\n    if configs.REQUIRE_DIGIT and not any(char.isdigit() for char in password):\n        errors.append(\"Password must contain at least one digit.\")\n\n    if configs.REQUIRE_LOWERCASE and not any(char.islower() for char in password):\n        errors.append(\"Password must contain at least one lowercase letter.\")\n\n    if configs.REQUIRE_UPPERCASE and not any(char.isupper() for char in password):\n        errors.append(\"Password must contain at least one uppercase letter.\")\n\n    if configs.REQUIRE_SPECIAL and not any(char in configs.SPECIAL_CHARACTERS for char in password):\n        errors.append(f\"Password must contain at least one special character: {configs.SPECIAL_CHARACTERS}\")\n\n    if errors:\n        raise InvalidPasswordError(requirements=errors, lang=lang)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.generate_password","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.generate_password(auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Generates a random password that meets the policy requirements.</p> <p>Parameters:</p> Name Type Description Default <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A randomly generated password that meets the policy requirements.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@staticmethod\ndef generate_password(auth_config: AuthConfig | None = None) -&gt; str:\n    \"\"\"Generates a random password that meets the policy requirements.\n\n    Args:\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        str: A randomly generated password that meets the policy requirements.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    lowercase_chars = string.ascii_lowercase\n    uppercase_chars = string.ascii_uppercase\n    digit_chars = string.digits\n    special_chars = \"\".join(configs.SPECIAL_CHARACTERS)\n\n    # Initialize with required characters\n    password_chars = []\n    if configs.REQUIRE_LOWERCASE:\n        password_chars.append(secrets.choice(lowercase_chars))\n    if configs.REQUIRE_UPPERCASE:\n        password_chars.append(secrets.choice(uppercase_chars))\n    if configs.REQUIRE_DIGIT:\n        password_chars.append(secrets.choice(digit_chars))\n    if configs.REQUIRE_SPECIAL:\n        password_chars.append(secrets.choice(special_chars))\n\n    # Calculate remaining length\n    remaining_length = max(0, configs.MIN_LENGTH - len(password_chars))\n\n    # Add random characters to meet minimum length\n    all_chars = lowercase_chars + uppercase_chars + digit_chars + special_chars\n    password_chars.extend(secrets.choice(all_chars) for _ in range(remaining_length))\n\n    # Shuffle the password characters\n    shuffled = list(password_chars)\n    secrets.SystemRandom().shuffle(shuffled)\n\n    return \"\".join(shuffled)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.password_utils.PasswordUtils.validate_password_history","title":"<code>archipy.helpers.utils.password_utils.PasswordUtils.validate_password_history(new_password, password_history, auth_config=None, lang=LanguageType.FA)</code>  <code>classmethod</code>","text":"<p>Validates a new password against the password history.</p> <p>Parameters:</p> Name Type Description Default <code>new_password</code> <code>str</code> <p>The new password to validate.</p> required <code>password_history</code> <code>list[str]</code> <p>A list of previous password hashes.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>The language to use for error messages. Defaults to Persian.</p> <code>FA</code> <p>Raises:</p> Type Description <code>InvalidPasswordError</code> <p>If the new password has been used recently or does not meet the policy requirements.</p> Source code in <code>archipy/helpers/utils/password_utils.py</code> <pre><code>@classmethod\ndef validate_password_history(\n    cls,\n    new_password: str,\n    password_history: list[str],\n    auth_config: AuthConfig | None = None,\n    lang: LanguageType = LanguageType.FA,\n) -&gt; None:\n    \"\"\"Validates a new password against the password history.\n\n    Args:\n        new_password (str): The new password to validate.\n        password_history (list[str]): A list of previous password hashes.\n        auth_config (AuthConfig | None): Optional auth configuration override. If not provided, uses the global config.\n        lang (LanguageType): The language to use for error messages. Defaults to Persian.\n\n    Raises:\n        InvalidPasswordError: If the new password has been used recently or does not meet the policy requirements.\n    \"\"\"\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    # First validate against password policy\n    cls.validate_password(new_password, configs, lang)\n\n    # Check password history\n    if any(\n        cls.verify_password(new_password, old_password, configs)\n        for old_password in password_history[-configs.PASSWORD_HISTORY_SIZE :]\n    ):\n        raise InvalidPasswordError(requirements=[\"Password has been used recently\"], lang=lang)\n</code></pre>"},{"location":"api_reference/utils/#string_utils","title":"string_utils","text":"<p>Utilities for string operations.</p> <pre><code>from archipy.helpers.utils.string_utils import StringUtils\n\n# Convert to slug\nslug = StringUtils.slugify(\"My Article Title\")\n\n# Truncate string\ntruncated = StringUtils.truncate(\"Long text here\", length=10)\n\n# Generate random string\nrandom_str = StringUtils.generate_random_string(length=8)\n\n# Sanitize HTML\nclean_html = StringUtils.sanitize_html(\"&lt;script&gt;alert('xss')&lt;/script&gt;\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils","title":"<code>archipy.helpers.utils.string_utils.StringUtils</code>","text":"<p>               Bases: <code>StringUtilsConstants</code></p> <p>String utilities for text normalization, cleaning, and masking.</p> <p>This class provides methods for handling Persian and Arabic text, including normalization, punctuation cleaning, number conversion, and masking of sensitive information like URLs, emails, and phone numbers.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>class StringUtils(StringUtilsConstants):\n    \"\"\"String utilities for text normalization, cleaning, and masking.\n\n    This class provides methods for handling Persian and Arabic text, including normalization,\n    punctuation cleaning, number conversion, and masking of sensitive information like URLs,\n    emails, and phone numbers.\n    \"\"\"\n\n    @classmethod\n    def remove_arabic_vowels(cls, text: str) -&gt; str:\n        \"\"\"Removes Arabic vowels (tashkeel) from the text.\n\n        Args:\n            text (str): The input text containing Arabic vowels.\n\n        Returns:\n            str: The text with Arabic vowels removed.\n        \"\"\"\n        return text.translate(cls.arabic_vowel_translate_table)\n\n    @classmethod\n    def normalize_persian_chars(cls, text: str) -&gt; str:\n        \"\"\"Normalizes Persian characters to their standard forms.\n\n        Args:\n            text (str): The input text containing Persian characters.\n\n        Returns:\n            str: The text with Persian characters normalized.\n        \"\"\"\n        text = text.translate(cls.alphabet_akoolad_alef_translate_table)\n        text = text.translate(cls.alphabet_alef_translate_table)\n        text = text.translate(cls.alphabet_be_translate_table)\n        text = text.translate(cls.alphabet_pe_translate_table)\n        text = text.translate(cls.alphabet_te_translate_table)\n        text = text.translate(cls.alphabet_se_translate_table)\n        text = text.translate(cls.alphabet_jim_translate_table)\n        text = text.translate(cls.alphabet_che_translate_table)\n        text = text.translate(cls.alphabet_he_translate_table)\n        text = text.translate(cls.alphabet_khe_translate_table)\n        text = text.translate(cls.alphabet_dal_translate_table)\n        text = text.translate(cls.alphabet_zal_translate_table)\n        text = text.translate(cls.alphabet_re_translate_table)\n        text = text.translate(cls.alphabet_ze_translate_table)\n        text = text.translate(cls.alphabet_zhe_translate_table)\n        text = text.translate(cls.alphabet_sin_translate_table)\n        text = text.translate(cls.alphabet_shin_translate_table)\n        text = text.translate(cls.alphabet_sad_translate_table)\n        text = text.translate(cls.alphabet_zad_translate_table)\n        text = text.translate(cls.alphabet_ta_translate_table)\n        text = text.translate(cls.alphabet_za_translate_table)\n        text = text.translate(cls.alphabet_eyn_translate_table)\n        text = text.translate(cls.alphabet_gheyn_translate_table)\n        text = text.translate(cls.alphabet_fe_translate_table)\n        text = text.translate(cls.alphabet_ghaf_translate_table)\n        text = text.translate(cls.alphabet_kaf_translate_table)\n        text = text.translate(cls.alphabet_gaf_translate_table)\n        text = text.translate(cls.alphabet_lam_translate_table)\n        text = text.translate(cls.alphabet_mim_translate_table)\n        text = text.translate(cls.alphabet_nun_translate_table)\n        text = text.translate(cls.alphabet_vav_translate_table)\n        text = text.translate(cls.alphabet_ha_translate_table)\n        return text.translate(cls.alphabet_ye_translate_table)\n\n    @classmethod\n    def normalize_punctuation(cls, text: str) -&gt; str:\n        \"\"\"Normalizes punctuation marks in the text.\n\n        Args:\n            text (str): The input text containing punctuation marks.\n\n        Returns:\n            str: The text with punctuation marks normalized.\n        \"\"\"\n        text = text.translate(cls.punctuation_translate_table1)\n        text = text.translate(cls.punctuation_translate_table2)\n        text = text.translate(cls.punctuation_translate_table3)\n        text = text.translate(cls.punctuation_translate_table4)\n        text = text.translate(cls.punctuation_translate_table5)\n        text = text.translate(cls.punctuation_translate_table6)\n        text = text.translate(cls.punctuation_translate_table7)\n        text = text.translate(cls.punctuation_translate_table8)\n        text = text.translate(cls.punctuation_translate_table9)\n        text = text.translate(cls.punctuation_translate_table10)\n        text = text.translate(cls.punctuation_translate_table11)\n        text = text.translate(cls.punctuation_translate_table12)\n        return text.translate(cls.punctuation_translate_table13)\n\n    @classmethod\n    def normalize_numbers(cls, text: str) -&gt; str:\n        \"\"\"Normalizes numbers in the text to English format.\n\n        Args:\n            text (str): The input text containing numbers.\n\n        Returns:\n            str: The text with numbers normalized to English format.\n        \"\"\"\n        text = text.translate(cls.number_zero_translate_table)\n        text = text.translate(cls.number_one_translate_table)\n        text = text.translate(cls.number_two_translate_table)\n        text = text.translate(cls.number_three_translate_table)\n        text = text.translate(cls.number_four_translate_table)\n        text = text.translate(cls.number_five_translate_table)\n        text = text.translate(cls.number_six_translate_table)\n        text = text.translate(cls.number_seven_translate_table)\n        text = text.translate(cls.number_eight_translate_table)\n        return text.translate(cls.number_nine_translate_table)\n\n    @classmethod\n    def clean_spacing(cls, text: str) -&gt; str:\n        \"\"\"Cleans up spacing issues in the text, such as non-breaking spaces and zero-width non-joiners.\n\n        Args:\n            text (str): The input text with spacing issues.\n\n        Returns:\n            str: The text with spacing cleaned up.\n        \"\"\"\n        text = text.replace(\"\\u200c\", \" \")  # ZWNJ\n        text = text.replace(\"\\xa0\", \" \")  # NBSP\n\n        for pattern, repl in cls.character_refinement_patterns:\n            text = pattern.sub(repl, text)\n\n        return text\n\n    @classmethod\n    def normalize_punctuation_spacing(cls, text: str) -&gt; str:\n        \"\"\"Applies proper spacing around punctuation marks.\n\n        Args:\n            text (str): The input text with punctuation spacing issues.\n\n        Returns:\n            str: The text with proper spacing around punctuation marks.\n        \"\"\"\n        for pattern, repl in cls.punctuation_spacing_patterns:\n            text = pattern.sub(repl, text)\n        return text\n\n    @classmethod\n    def remove_punctuation_marks(cls, text: str) -&gt; str:\n        \"\"\"Removes punctuation marks from the text.\n\n        Args:\n            text (str): The input text containing punctuation marks.\n\n        Returns:\n            str: The text with punctuation marks removed.\n        \"\"\"\n        return text.translate(cls.punctuation_persian_marks_to_space_translate_table)\n\n    @classmethod\n    def mask_urls(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks URLs in the text with a specified mask.\n\n        Args:\n            text (str): The input text containing URLs.\n            mask (str | None): The mask to replace URLs with. Defaults to \"MASK_URL\".\n\n        Returns:\n            str: The text with URLs masked.\n        \"\"\"\n        mask = mask or \"MASK_URL\"\n        return compile(r\"https?://\\S+|www\\.\\S+\").sub(f\" {mask} \", text)\n\n    @classmethod\n    def mask_emails(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks email addresses in the text with a specified mask.\n\n        Args:\n            text (str): The input text containing email addresses.\n            mask (str | None): The mask to replace emails with. Defaults to \"MASK_EMAIL\".\n\n        Returns:\n            str: The text with email addresses masked.\n        \"\"\"\n        mask = mask or \"MASK_EMAIL\"\n        return compile(r\"\\S+@\\S+\\.\\S+\").sub(f\" {mask} \", text)\n\n    @classmethod\n    def mask_phones(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks phone numbers in the text with a specified mask.\n\n        Args:\n            text (str): The input text containing phone numbers.\n            mask (str | None): The mask to replace phone numbers with. Defaults to \"MASK_PHONE\".\n\n        Returns:\n            str: The text with phone numbers masked.\n        \"\"\"\n        mask = mask or \"MASK_PHONE\"\n        return compile(r\"(?:\\+98|0)?(?:\\d{3}\\s*?\\d{3}\\s*?\\d{4})\").sub(f\" {mask} \", text)\n\n    @classmethod\n    def convert_english_number_to_persian(cls, text: str) -&gt; str:\n        \"\"\"Converts English numbers to Persian numbers in the text.\n\n        Args:\n            text (str): The input text containing English numbers.\n\n        Returns:\n            str: The text with English numbers converted to Persian numbers.\n        \"\"\"\n        table = {\n            48: 1776,  # 0\n            49: 1777,  # 1\n            50: 1778,  # 2\n            51: 1779,  # 3\n            52: 1780,  # 4\n            53: 1781,  # 5\n            54: 1782,  # 6\n            55: 1783,  # 7\n            56: 1784,  # 8\n            57: 1785,  # 9\n            44: 1548,  # ,\n        }\n        return text.translate(table)\n\n    @classmethod\n    def convert_numbers_to_english(cls, text: str) -&gt; str:\n        \"\"\"Converts Persian/Arabic numbers to English numbers in the text.\n\n        Args:\n            text (str): The input text containing Persian/Arabic numbers.\n\n        Returns:\n            str: The text with Persian/Arabic numbers converted to English numbers.\n        \"\"\"\n        table = {\n            1776: 48,  # 0\n            1777: 49,  # 1\n            1778: 50,  # 2\n            1779: 51,  # 3\n            1780: 52,  # 4\n            1781: 53,  # 5\n            1782: 54,  # 6\n            1783: 55,  # 7\n            1784: 56,  # 8\n            1785: 57,  # 9\n            1632: 48,  # 0\n            1633: 49,  # 1\n            1634: 50,  # 2\n            1635: 51,  # 3\n            1636: 52,  # 4\n            1637: 53,  # 5\n            1638: 54,  # 6\n            1639: 55,  # 7\n            1640: 56,  # 8\n            1641: 57,  # 9\n        }\n        return text.translate(table)\n\n    @classmethod\n    def convert_add_3digit_delimiter(cls, value: int) -&gt; str:\n        \"\"\"Adds thousand separators to numbers.\n\n        Args:\n            value (int): The number to format.\n\n        Returns:\n            str: The formatted number with thousand separators.\n        \"\"\"\n        return f\"{value:,}\" if isinstance(value, int) else value\n\n    @classmethod\n    def remove_emoji(cls, text: str) -&gt; str:\n        \"\"\"Removes emoji characters from the text.\n\n        Args:\n            text (str): The input text containing emojis.\n\n        Returns:\n            str: The text with emojis removed.\n        \"\"\"\n        emoji_pattern = re.compile(\n            r\"[\"\n            r\"\\U0001F600-\\U0001F64F\"  # emoticons\n            r\"\\U0001F300-\\U0001F5FF\"  # symbols &amp; pictographs\n            r\"\\U0001F680-\\U0001F6FF\"  # transport &amp; map symbols\n            r\"\\U0001F1E0-\\U0001F1FF\"  # flags\n            r\"\\U0001F900-\\U0001F9FF\"  # supplemental symbols and pictographs\n            r\"\\U0001FA00-\\U0001FA6F\"  # symbols and pictographs extended-A\n            r\"\\U00002600-\\U000026FF\"  # miscellaneous symbols (some are emojis)\n            r\"\\U00002700-\\U000027BF\"  # dingbats (some are emojis)\n            r\"\\U00002190-\\U000021FF\"  # arrows (some are emojis)\n            r\"]+\",\n            re.UNICODE,\n        )\n        return emoji_pattern.sub(r\"\", text)\n\n    @classmethod\n    def replace_currencies_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks currency symbols and amounts in the text.\n\n        Args:\n            text (str): The input text containing currency symbols and amounts.\n            mask (str | None): The mask to replace currencies with. Defaults to \"MASK_CURRENCIES\".\n\n        Returns:\n            str: The text with currency symbols and amounts masked.\n        \"\"\"\n        mask = mask or \"MASK_CURRENCIES\"\n        currency_pattern = compile(r\"(\\\\|z\u0142|\u00a3|\\$|\u20a1|\u20a6|\u00a5|\u20a9|\u20aa|\u20ab|\u20ac|\u20b1|\u20b2|\u20b4|\u20b9|\ufdfc)+\")\n        return currency_pattern.sub(f\" {mask} \", text)\n\n    @classmethod\n    def replace_numbers_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n        \"\"\"Masks numbers in the text.\n\n        Args:\n            text (str): The input text containing numbers.\n            mask (str | None): The mask to replace numbers with. Defaults to \"MASK_NUMBERS\".\n\n        Returns:\n            str: The text with numbers masked.\n        \"\"\"\n        mask = mask or \"MASK_NUMBERS\"\n        numbers = re.findall(\"[0-9]+\", text)\n        for number in sorted(numbers, key=len, reverse=True):\n            text = text.replace(number, f\" {mask} \")\n        return text\n\n    @classmethod\n    def is_string_none_or_empty(cls, text: str) -&gt; bool:\n        \"\"\"Checks if a string is `None` or empty (after stripping whitespace).\n\n        Args:\n            text (str): The input string to check.\n\n        Returns:\n            bool: `True` if the string is `None` or empty, `False` otherwise.\n        \"\"\"\n        return text is None or isinstance(text, str) and not text.strip()\n\n    @classmethod\n    def normalize_persian_text(\n        cls,\n        text: str,\n        *,\n        remove_vowels: bool = True,\n        normalize_punctuation: bool = True,\n        normalize_numbers: bool = True,\n        normalize_persian_chars: bool = True,\n        mask_urls: bool = False,\n        mask_emails: bool = False,\n        mask_phones: bool = False,\n        mask_currencies: bool = False,\n        mask_all_numbers: bool = False,\n        remove_emojis: bool = False,\n        url_mask: str | None = None,\n        email_mask: str | None = None,\n        phone_mask: str | None = None,\n        currency_mask: str | None = None,\n        number_mask: str | None = None,\n        clean_spacing: bool = True,\n        remove_punctuation: bool = False,\n        normalize_punctuation_spacing: bool = False,\n    ) -&gt; str:\n        \"\"\"Normalizes Persian text with configurable options.\n\n        Args:\n            text (str): The input text to normalize.\n            remove_vowels (bool): Whether to remove Arabic vowels. Defaults to `True`.\n            normalize_punctuation (bool): Whether to normalize punctuation marks. Defaults to `True`.\n            normalize_numbers (bool): Whether to normalize numbers to English format. Defaults to `True`.\n            normalize_persian_chars (bool): Whether to normalize Persian characters. Defaults to `True`.\n            mask_urls (bool): Whether to mask URLs. Defaults to `False`.\n            mask_emails (bool): Whether to mask email addresses. Defaults to `False`.\n            mask_phones (bool): Whether to mask phone numbers. Defaults to `False`.\n            mask_currencies (bool): Whether to mask currency symbols and amounts. Defaults to `False`.\n            mask_all_numbers (bool): Whether to mask all numbers. Defaults to `False`.\n            remove_emojis (bool): Whether to remove emojis. Defaults to `False`.\n            url_mask (str | None): The mask to replace URLs with. Defaults to `None`.\n            email_mask (str | None): The mask to replace email addresses with. Defaults to `None`.\n            phone_mask (str | None): The mask to replace phone numbers with. Defaults to `None`.\n            currency_mask (str | None): The mask to replace currency symbols and amounts with. Defaults to `None`.\n            number_mask (str | None): The mask to replace numbers with. Defaults to `None`.\n            clean_spacing (bool): Whether to clean up spacing issues. Defaults to `True`.\n            remove_punctuation (bool): Whether to remove punctuation marks. Defaults to `False`.\n            normalize_punctuation_spacing (bool): Whether to apply proper spacing around punctuation marks. Defaults to `False`.\n\n        Returns:\n            str: The normalized text.\n        \"\"\"\n        if not text:\n            return text\n\n        # Remove emojis if requested\n        if remove_emojis:\n            text = cls.remove_emoji(text)\n\n        # Apply normalizations\n        if remove_vowels:\n            text = cls.remove_arabic_vowels(text)\n        if normalize_persian_chars:\n            text = cls.normalize_persian_chars(text)\n        if normalize_punctuation:\n            text = cls.normalize_punctuation(text)\n        if remove_punctuation:\n            text = cls.remove_punctuation_marks(text)\n        if normalize_numbers:\n            text = cls.normalize_numbers(text)\n\n        # Apply masking\n        if mask_urls:\n            text = cls.mask_urls(text, mask=url_mask)\n        if mask_emails:\n            text = cls.mask_emails(text, mask=email_mask)\n        if mask_phones:\n            text = cls.mask_phones(text, mask=phone_mask)\n        if mask_currencies:\n            text = cls.replace_currencies_with_mask(text, mask=currency_mask)\n        if mask_all_numbers:\n            text = cls.replace_numbers_with_mask(text, mask=number_mask)\n\n        if clean_spacing:\n            text = cls.clean_spacing(text)\n        if normalize_punctuation_spacing:\n            text = cls.normalize_punctuation_spacing(text)\n\n        return text.strip()\n\n    @classmethod\n    def snake_to_camel_case(cls, text: str) -&gt; str:\n        \"\"\"Converts snake_case to camelCase.\n\n        Args:\n            text (str): The input text in snake_case format.\n\n        Returns:\n            str: The text converted to camelCase format.\n        \"\"\"\n        if cls.is_string_none_or_empty(text):\n            return text\n\n        components = text.split(\"_\")\n        # First component remains lowercase, the rest get capitalized\n        return components[0] + \"\".join(x.title() for x in components[1:])\n\n    @classmethod\n    def camel_to_snake_case(cls, text: str) -&gt; str:\n        \"\"\"Converts camelCase to snake_case.\n\n        Args:\n            text (str): The input text in camelCase format.\n\n        Returns:\n            str: The text converted to snake_case format.\n        \"\"\"\n        if cls.is_string_none_or_empty(text):\n            return text\n\n        # Add underscore before each capital letter and convert to lowercase\n        s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", text)\n        return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.remove_arabic_vowels","title":"<code>archipy.helpers.utils.string_utils.StringUtils.remove_arabic_vowels(text)</code>  <code>classmethod</code>","text":"<p>Removes Arabic vowels (tashkeel) from the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing Arabic vowels.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with Arabic vowels removed.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef remove_arabic_vowels(cls, text: str) -&gt; str:\n    \"\"\"Removes Arabic vowels (tashkeel) from the text.\n\n    Args:\n        text (str): The input text containing Arabic vowels.\n\n    Returns:\n        str: The text with Arabic vowels removed.\n    \"\"\"\n    return text.translate(cls.arabic_vowel_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_persian_chars","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_persian_chars(text)</code>  <code>classmethod</code>","text":"<p>Normalizes Persian characters to their standard forms.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing Persian characters.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with Persian characters normalized.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_persian_chars(cls, text: str) -&gt; str:\n    \"\"\"Normalizes Persian characters to their standard forms.\n\n    Args:\n        text (str): The input text containing Persian characters.\n\n    Returns:\n        str: The text with Persian characters normalized.\n    \"\"\"\n    text = text.translate(cls.alphabet_akoolad_alef_translate_table)\n    text = text.translate(cls.alphabet_alef_translate_table)\n    text = text.translate(cls.alphabet_be_translate_table)\n    text = text.translate(cls.alphabet_pe_translate_table)\n    text = text.translate(cls.alphabet_te_translate_table)\n    text = text.translate(cls.alphabet_se_translate_table)\n    text = text.translate(cls.alphabet_jim_translate_table)\n    text = text.translate(cls.alphabet_che_translate_table)\n    text = text.translate(cls.alphabet_he_translate_table)\n    text = text.translate(cls.alphabet_khe_translate_table)\n    text = text.translate(cls.alphabet_dal_translate_table)\n    text = text.translate(cls.alphabet_zal_translate_table)\n    text = text.translate(cls.alphabet_re_translate_table)\n    text = text.translate(cls.alphabet_ze_translate_table)\n    text = text.translate(cls.alphabet_zhe_translate_table)\n    text = text.translate(cls.alphabet_sin_translate_table)\n    text = text.translate(cls.alphabet_shin_translate_table)\n    text = text.translate(cls.alphabet_sad_translate_table)\n    text = text.translate(cls.alphabet_zad_translate_table)\n    text = text.translate(cls.alphabet_ta_translate_table)\n    text = text.translate(cls.alphabet_za_translate_table)\n    text = text.translate(cls.alphabet_eyn_translate_table)\n    text = text.translate(cls.alphabet_gheyn_translate_table)\n    text = text.translate(cls.alphabet_fe_translate_table)\n    text = text.translate(cls.alphabet_ghaf_translate_table)\n    text = text.translate(cls.alphabet_kaf_translate_table)\n    text = text.translate(cls.alphabet_gaf_translate_table)\n    text = text.translate(cls.alphabet_lam_translate_table)\n    text = text.translate(cls.alphabet_mim_translate_table)\n    text = text.translate(cls.alphabet_nun_translate_table)\n    text = text.translate(cls.alphabet_vav_translate_table)\n    text = text.translate(cls.alphabet_ha_translate_table)\n    return text.translate(cls.alphabet_ye_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation(text)</code>  <code>classmethod</code>","text":"<p>Normalizes punctuation marks in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing punctuation marks.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with punctuation marks normalized.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_punctuation(cls, text: str) -&gt; str:\n    \"\"\"Normalizes punctuation marks in the text.\n\n    Args:\n        text (str): The input text containing punctuation marks.\n\n    Returns:\n        str: The text with punctuation marks normalized.\n    \"\"\"\n    text = text.translate(cls.punctuation_translate_table1)\n    text = text.translate(cls.punctuation_translate_table2)\n    text = text.translate(cls.punctuation_translate_table3)\n    text = text.translate(cls.punctuation_translate_table4)\n    text = text.translate(cls.punctuation_translate_table5)\n    text = text.translate(cls.punctuation_translate_table6)\n    text = text.translate(cls.punctuation_translate_table7)\n    text = text.translate(cls.punctuation_translate_table8)\n    text = text.translate(cls.punctuation_translate_table9)\n    text = text.translate(cls.punctuation_translate_table10)\n    text = text.translate(cls.punctuation_translate_table11)\n    text = text.translate(cls.punctuation_translate_table12)\n    return text.translate(cls.punctuation_translate_table13)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_numbers","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_numbers(text)</code>  <code>classmethod</code>","text":"<p>Normalizes numbers in the text to English format.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing numbers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with numbers normalized to English format.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_numbers(cls, text: str) -&gt; str:\n    \"\"\"Normalizes numbers in the text to English format.\n\n    Args:\n        text (str): The input text containing numbers.\n\n    Returns:\n        str: The text with numbers normalized to English format.\n    \"\"\"\n    text = text.translate(cls.number_zero_translate_table)\n    text = text.translate(cls.number_one_translate_table)\n    text = text.translate(cls.number_two_translate_table)\n    text = text.translate(cls.number_three_translate_table)\n    text = text.translate(cls.number_four_translate_table)\n    text = text.translate(cls.number_five_translate_table)\n    text = text.translate(cls.number_six_translate_table)\n    text = text.translate(cls.number_seven_translate_table)\n    text = text.translate(cls.number_eight_translate_table)\n    return text.translate(cls.number_nine_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.clean_spacing","title":"<code>archipy.helpers.utils.string_utils.StringUtils.clean_spacing(text)</code>  <code>classmethod</code>","text":"<p>Cleans up spacing issues in the text, such as non-breaking spaces and zero-width non-joiners.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text with spacing issues.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with spacing cleaned up.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef clean_spacing(cls, text: str) -&gt; str:\n    \"\"\"Cleans up spacing issues in the text, such as non-breaking spaces and zero-width non-joiners.\n\n    Args:\n        text (str): The input text with spacing issues.\n\n    Returns:\n        str: The text with spacing cleaned up.\n    \"\"\"\n    text = text.replace(\"\\u200c\", \" \")  # ZWNJ\n    text = text.replace(\"\\xa0\", \" \")  # NBSP\n\n    for pattern, repl in cls.character_refinement_patterns:\n        text = pattern.sub(repl, text)\n\n    return text\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation_spacing","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_punctuation_spacing(text)</code>  <code>classmethod</code>","text":"<p>Applies proper spacing around punctuation marks.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text with punctuation spacing issues.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with proper spacing around punctuation marks.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_punctuation_spacing(cls, text: str) -&gt; str:\n    \"\"\"Applies proper spacing around punctuation marks.\n\n    Args:\n        text (str): The input text with punctuation spacing issues.\n\n    Returns:\n        str: The text with proper spacing around punctuation marks.\n    \"\"\"\n    for pattern, repl in cls.punctuation_spacing_patterns:\n        text = pattern.sub(repl, text)\n    return text\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.remove_punctuation_marks","title":"<code>archipy.helpers.utils.string_utils.StringUtils.remove_punctuation_marks(text)</code>  <code>classmethod</code>","text":"<p>Removes punctuation marks from the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing punctuation marks.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with punctuation marks removed.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef remove_punctuation_marks(cls, text: str) -&gt; str:\n    \"\"\"Removes punctuation marks from the text.\n\n    Args:\n        text (str): The input text containing punctuation marks.\n\n    Returns:\n        str: The text with punctuation marks removed.\n    \"\"\"\n    return text.translate(cls.punctuation_persian_marks_to_space_translate_table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.mask_urls","title":"<code>archipy.helpers.utils.string_utils.StringUtils.mask_urls(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks URLs in the text with a specified mask.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing URLs.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace URLs with. Defaults to \"MASK_URL\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with URLs masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef mask_urls(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks URLs in the text with a specified mask.\n\n    Args:\n        text (str): The input text containing URLs.\n        mask (str | None): The mask to replace URLs with. Defaults to \"MASK_URL\".\n\n    Returns:\n        str: The text with URLs masked.\n    \"\"\"\n    mask = mask or \"MASK_URL\"\n    return compile(r\"https?://\\S+|www\\.\\S+\").sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.mask_emails","title":"<code>archipy.helpers.utils.string_utils.StringUtils.mask_emails(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks email addresses in the text with a specified mask.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing email addresses.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace emails with. Defaults to \"MASK_EMAIL\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with email addresses masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef mask_emails(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks email addresses in the text with a specified mask.\n\n    Args:\n        text (str): The input text containing email addresses.\n        mask (str | None): The mask to replace emails with. Defaults to \"MASK_EMAIL\".\n\n    Returns:\n        str: The text with email addresses masked.\n    \"\"\"\n    mask = mask or \"MASK_EMAIL\"\n    return compile(r\"\\S+@\\S+\\.\\S+\").sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.mask_phones","title":"<code>archipy.helpers.utils.string_utils.StringUtils.mask_phones(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks phone numbers in the text with a specified mask.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing phone numbers.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace phone numbers with. Defaults to \"MASK_PHONE\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with phone numbers masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef mask_phones(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks phone numbers in the text with a specified mask.\n\n    Args:\n        text (str): The input text containing phone numbers.\n        mask (str | None): The mask to replace phone numbers with. Defaults to \"MASK_PHONE\".\n\n    Returns:\n        str: The text with phone numbers masked.\n    \"\"\"\n    mask = mask or \"MASK_PHONE\"\n    return compile(r\"(?:\\+98|0)?(?:\\d{3}\\s*?\\d{3}\\s*?\\d{4})\").sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.convert_english_number_to_persian","title":"<code>archipy.helpers.utils.string_utils.StringUtils.convert_english_number_to_persian(text)</code>  <code>classmethod</code>","text":"<p>Converts English numbers to Persian numbers in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing English numbers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with English numbers converted to Persian numbers.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef convert_english_number_to_persian(cls, text: str) -&gt; str:\n    \"\"\"Converts English numbers to Persian numbers in the text.\n\n    Args:\n        text (str): The input text containing English numbers.\n\n    Returns:\n        str: The text with English numbers converted to Persian numbers.\n    \"\"\"\n    table = {\n        48: 1776,  # 0\n        49: 1777,  # 1\n        50: 1778,  # 2\n        51: 1779,  # 3\n        52: 1780,  # 4\n        53: 1781,  # 5\n        54: 1782,  # 6\n        55: 1783,  # 7\n        56: 1784,  # 8\n        57: 1785,  # 9\n        44: 1548,  # ,\n    }\n    return text.translate(table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.convert_numbers_to_english","title":"<code>archipy.helpers.utils.string_utils.StringUtils.convert_numbers_to_english(text)</code>  <code>classmethod</code>","text":"<p>Converts Persian/Arabic numbers to English numbers in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing Persian/Arabic numbers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with Persian/Arabic numbers converted to English numbers.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef convert_numbers_to_english(cls, text: str) -&gt; str:\n    \"\"\"Converts Persian/Arabic numbers to English numbers in the text.\n\n    Args:\n        text (str): The input text containing Persian/Arabic numbers.\n\n    Returns:\n        str: The text with Persian/Arabic numbers converted to English numbers.\n    \"\"\"\n    table = {\n        1776: 48,  # 0\n        1777: 49,  # 1\n        1778: 50,  # 2\n        1779: 51,  # 3\n        1780: 52,  # 4\n        1781: 53,  # 5\n        1782: 54,  # 6\n        1783: 55,  # 7\n        1784: 56,  # 8\n        1785: 57,  # 9\n        1632: 48,  # 0\n        1633: 49,  # 1\n        1634: 50,  # 2\n        1635: 51,  # 3\n        1636: 52,  # 4\n        1637: 53,  # 5\n        1638: 54,  # 6\n        1639: 55,  # 7\n        1640: 56,  # 8\n        1641: 57,  # 9\n    }\n    return text.translate(table)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.convert_add_3digit_delimiter","title":"<code>archipy.helpers.utils.string_utils.StringUtils.convert_add_3digit_delimiter(value)</code>  <code>classmethod</code>","text":"<p>Adds thousand separators to numbers.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The number to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted number with thousand separators.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef convert_add_3digit_delimiter(cls, value: int) -&gt; str:\n    \"\"\"Adds thousand separators to numbers.\n\n    Args:\n        value (int): The number to format.\n\n    Returns:\n        str: The formatted number with thousand separators.\n    \"\"\"\n    return f\"{value:,}\" if isinstance(value, int) else value\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.remove_emoji","title":"<code>archipy.helpers.utils.string_utils.StringUtils.remove_emoji(text)</code>  <code>classmethod</code>","text":"<p>Removes emoji characters from the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing emojis.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with emojis removed.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef remove_emoji(cls, text: str) -&gt; str:\n    \"\"\"Removes emoji characters from the text.\n\n    Args:\n        text (str): The input text containing emojis.\n\n    Returns:\n        str: The text with emojis removed.\n    \"\"\"\n    emoji_pattern = re.compile(\n        r\"[\"\n        r\"\\U0001F600-\\U0001F64F\"  # emoticons\n        r\"\\U0001F300-\\U0001F5FF\"  # symbols &amp; pictographs\n        r\"\\U0001F680-\\U0001F6FF\"  # transport &amp; map symbols\n        r\"\\U0001F1E0-\\U0001F1FF\"  # flags\n        r\"\\U0001F900-\\U0001F9FF\"  # supplemental symbols and pictographs\n        r\"\\U0001FA00-\\U0001FA6F\"  # symbols and pictographs extended-A\n        r\"\\U00002600-\\U000026FF\"  # miscellaneous symbols (some are emojis)\n        r\"\\U00002700-\\U000027BF\"  # dingbats (some are emojis)\n        r\"\\U00002190-\\U000021FF\"  # arrows (some are emojis)\n        r\"]+\",\n        re.UNICODE,\n    )\n    return emoji_pattern.sub(r\"\", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.replace_currencies_with_mask","title":"<code>archipy.helpers.utils.string_utils.StringUtils.replace_currencies_with_mask(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks currency symbols and amounts in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing currency symbols and amounts.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace currencies with. Defaults to \"MASK_CURRENCIES\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with currency symbols and amounts masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef replace_currencies_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks currency symbols and amounts in the text.\n\n    Args:\n        text (str): The input text containing currency symbols and amounts.\n        mask (str | None): The mask to replace currencies with. Defaults to \"MASK_CURRENCIES\".\n\n    Returns:\n        str: The text with currency symbols and amounts masked.\n    \"\"\"\n    mask = mask or \"MASK_CURRENCIES\"\n    currency_pattern = compile(r\"(\\\\|z\u0142|\u00a3|\\$|\u20a1|\u20a6|\u00a5|\u20a9|\u20aa|\u20ab|\u20ac|\u20b1|\u20b2|\u20b4|\u20b9|\ufdfc)+\")\n    return currency_pattern.sub(f\" {mask} \", text)\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.replace_numbers_with_mask","title":"<code>archipy.helpers.utils.string_utils.StringUtils.replace_numbers_with_mask(text, mask=None)</code>  <code>classmethod</code>","text":"<p>Masks numbers in the text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text containing numbers.</p> required <code>mask</code> <code>str | None</code> <p>The mask to replace numbers with. Defaults to \"MASK_NUMBERS\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with numbers masked.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef replace_numbers_with_mask(cls, text: str, mask: str | None = None) -&gt; str:\n    \"\"\"Masks numbers in the text.\n\n    Args:\n        text (str): The input text containing numbers.\n        mask (str | None): The mask to replace numbers with. Defaults to \"MASK_NUMBERS\".\n\n    Returns:\n        str: The text with numbers masked.\n    \"\"\"\n    mask = mask or \"MASK_NUMBERS\"\n    numbers = re.findall(\"[0-9]+\", text)\n    for number in sorted(numbers, key=len, reverse=True):\n        text = text.replace(number, f\" {mask} \")\n    return text\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.is_string_none_or_empty","title":"<code>archipy.helpers.utils.string_utils.StringUtils.is_string_none_or_empty(text)</code>  <code>classmethod</code>","text":"<p>Checks if a string is <code>None</code> or empty (after stripping whitespace).</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input string to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the string is <code>None</code> or empty, <code>False</code> otherwise.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef is_string_none_or_empty(cls, text: str) -&gt; bool:\n    \"\"\"Checks if a string is `None` or empty (after stripping whitespace).\n\n    Args:\n        text (str): The input string to check.\n\n    Returns:\n        bool: `True` if the string is `None` or empty, `False` otherwise.\n    \"\"\"\n    return text is None or isinstance(text, str) and not text.strip()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.normalize_persian_text","title":"<code>archipy.helpers.utils.string_utils.StringUtils.normalize_persian_text(text, *, remove_vowels=True, normalize_punctuation=True, normalize_numbers=True, normalize_persian_chars=True, mask_urls=False, mask_emails=False, mask_phones=False, mask_currencies=False, mask_all_numbers=False, remove_emojis=False, url_mask=None, email_mask=None, phone_mask=None, currency_mask=None, number_mask=None, clean_spacing=True, remove_punctuation=False, normalize_punctuation_spacing=False)</code>  <code>classmethod</code>","text":"<p>Normalizes Persian text with configurable options.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text to normalize.</p> required <code>remove_vowels</code> <code>bool</code> <p>Whether to remove Arabic vowels. Defaults to <code>True</code>.</p> <code>True</code> <code>normalize_punctuation</code> <code>bool</code> <p>Whether to normalize punctuation marks. Defaults to <code>True</code>.</p> <code>True</code> <code>normalize_numbers</code> <code>bool</code> <p>Whether to normalize numbers to English format. Defaults to <code>True</code>.</p> <code>True</code> <code>normalize_persian_chars</code> <code>bool</code> <p>Whether to normalize Persian characters. Defaults to <code>True</code>.</p> <code>True</code> <code>mask_urls</code> <code>bool</code> <p>Whether to mask URLs. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_emails</code> <code>bool</code> <p>Whether to mask email addresses. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_phones</code> <code>bool</code> <p>Whether to mask phone numbers. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_currencies</code> <code>bool</code> <p>Whether to mask currency symbols and amounts. Defaults to <code>False</code>.</p> <code>False</code> <code>mask_all_numbers</code> <code>bool</code> <p>Whether to mask all numbers. Defaults to <code>False</code>.</p> <code>False</code> <code>remove_emojis</code> <code>bool</code> <p>Whether to remove emojis. Defaults to <code>False</code>.</p> <code>False</code> <code>url_mask</code> <code>str | None</code> <p>The mask to replace URLs with. Defaults to <code>None</code>.</p> <code>None</code> <code>email_mask</code> <code>str | None</code> <p>The mask to replace email addresses with. Defaults to <code>None</code>.</p> <code>None</code> <code>phone_mask</code> <code>str | None</code> <p>The mask to replace phone numbers with. Defaults to <code>None</code>.</p> <code>None</code> <code>currency_mask</code> <code>str | None</code> <p>The mask to replace currency symbols and amounts with. Defaults to <code>None</code>.</p> <code>None</code> <code>number_mask</code> <code>str | None</code> <p>The mask to replace numbers with. Defaults to <code>None</code>.</p> <code>None</code> <code>clean_spacing</code> <code>bool</code> <p>Whether to clean up spacing issues. Defaults to <code>True</code>.</p> <code>True</code> <code>remove_punctuation</code> <code>bool</code> <p>Whether to remove punctuation marks. Defaults to <code>False</code>.</p> <code>False</code> <code>normalize_punctuation_spacing</code> <code>bool</code> <p>Whether to apply proper spacing around punctuation marks. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The normalized text.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef normalize_persian_text(\n    cls,\n    text: str,\n    *,\n    remove_vowels: bool = True,\n    normalize_punctuation: bool = True,\n    normalize_numbers: bool = True,\n    normalize_persian_chars: bool = True,\n    mask_urls: bool = False,\n    mask_emails: bool = False,\n    mask_phones: bool = False,\n    mask_currencies: bool = False,\n    mask_all_numbers: bool = False,\n    remove_emojis: bool = False,\n    url_mask: str | None = None,\n    email_mask: str | None = None,\n    phone_mask: str | None = None,\n    currency_mask: str | None = None,\n    number_mask: str | None = None,\n    clean_spacing: bool = True,\n    remove_punctuation: bool = False,\n    normalize_punctuation_spacing: bool = False,\n) -&gt; str:\n    \"\"\"Normalizes Persian text with configurable options.\n\n    Args:\n        text (str): The input text to normalize.\n        remove_vowels (bool): Whether to remove Arabic vowels. Defaults to `True`.\n        normalize_punctuation (bool): Whether to normalize punctuation marks. Defaults to `True`.\n        normalize_numbers (bool): Whether to normalize numbers to English format. Defaults to `True`.\n        normalize_persian_chars (bool): Whether to normalize Persian characters. Defaults to `True`.\n        mask_urls (bool): Whether to mask URLs. Defaults to `False`.\n        mask_emails (bool): Whether to mask email addresses. Defaults to `False`.\n        mask_phones (bool): Whether to mask phone numbers. Defaults to `False`.\n        mask_currencies (bool): Whether to mask currency symbols and amounts. Defaults to `False`.\n        mask_all_numbers (bool): Whether to mask all numbers. Defaults to `False`.\n        remove_emojis (bool): Whether to remove emojis. Defaults to `False`.\n        url_mask (str | None): The mask to replace URLs with. Defaults to `None`.\n        email_mask (str | None): The mask to replace email addresses with. Defaults to `None`.\n        phone_mask (str | None): The mask to replace phone numbers with. Defaults to `None`.\n        currency_mask (str | None): The mask to replace currency symbols and amounts with. Defaults to `None`.\n        number_mask (str | None): The mask to replace numbers with. Defaults to `None`.\n        clean_spacing (bool): Whether to clean up spacing issues. Defaults to `True`.\n        remove_punctuation (bool): Whether to remove punctuation marks. Defaults to `False`.\n        normalize_punctuation_spacing (bool): Whether to apply proper spacing around punctuation marks. Defaults to `False`.\n\n    Returns:\n        str: The normalized text.\n    \"\"\"\n    if not text:\n        return text\n\n    # Remove emojis if requested\n    if remove_emojis:\n        text = cls.remove_emoji(text)\n\n    # Apply normalizations\n    if remove_vowels:\n        text = cls.remove_arabic_vowels(text)\n    if normalize_persian_chars:\n        text = cls.normalize_persian_chars(text)\n    if normalize_punctuation:\n        text = cls.normalize_punctuation(text)\n    if remove_punctuation:\n        text = cls.remove_punctuation_marks(text)\n    if normalize_numbers:\n        text = cls.normalize_numbers(text)\n\n    # Apply masking\n    if mask_urls:\n        text = cls.mask_urls(text, mask=url_mask)\n    if mask_emails:\n        text = cls.mask_emails(text, mask=email_mask)\n    if mask_phones:\n        text = cls.mask_phones(text, mask=phone_mask)\n    if mask_currencies:\n        text = cls.replace_currencies_with_mask(text, mask=currency_mask)\n    if mask_all_numbers:\n        text = cls.replace_numbers_with_mask(text, mask=number_mask)\n\n    if clean_spacing:\n        text = cls.clean_spacing(text)\n    if normalize_punctuation_spacing:\n        text = cls.normalize_punctuation_spacing(text)\n\n    return text.strip()\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.snake_to_camel_case","title":"<code>archipy.helpers.utils.string_utils.StringUtils.snake_to_camel_case(text)</code>  <code>classmethod</code>","text":"<p>Converts snake_case to camelCase.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text in snake_case format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text converted to camelCase format.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef snake_to_camel_case(cls, text: str) -&gt; str:\n    \"\"\"Converts snake_case to camelCase.\n\n    Args:\n        text (str): The input text in snake_case format.\n\n    Returns:\n        str: The text converted to camelCase format.\n    \"\"\"\n    if cls.is_string_none_or_empty(text):\n        return text\n\n    components = text.split(\"_\")\n    # First component remains lowercase, the rest get capitalized\n    return components[0] + \"\".join(x.title() for x in components[1:])\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.string_utils.StringUtils.camel_to_snake_case","title":"<code>archipy.helpers.utils.string_utils.StringUtils.camel_to_snake_case(text)</code>  <code>classmethod</code>","text":"<p>Converts camelCase to snake_case.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text in camelCase format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text converted to snake_case format.</p> Source code in <code>archipy/helpers/utils/string_utils.py</code> <pre><code>@classmethod\ndef camel_to_snake_case(cls, text: str) -&gt; str:\n    \"\"\"Converts camelCase to snake_case.\n\n    Args:\n        text (str): The input text in camelCase format.\n\n    Returns:\n        str: The text converted to snake_case format.\n    \"\"\"\n    if cls.is_string_none_or_empty(text):\n        return text\n\n    # Add underscore before each capital letter and convert to lowercase\n    s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", text)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()\n</code></pre>"},{"location":"api_reference/utils/#totp_utils","title":"totp_utils","text":"<p>Utilities for TOTP (Time-based One-Time Password) operations.</p> <pre><code>from archipy.helpers.utils.totp_utils import TOTPUtils\n\n# Generate TOTP\ntotp_code = TOTPUtils.generate_totp(secret_key=\"your-secret\")\n\n# Verify TOTP\nis_valid = TOTPUtils.verify_totp(totp_code, secret_key=\"your-secret\")\n\n# Generate secret key\nsecret_key = TOTPUtils.generate_secret_key()\n\n# Get TOTP URI for QR code\ntotp_uri = TOTPUtils.get_totp_uri(\n    secret_key=secret_key,\n    issuer=\"MyApp\",\n    account_name=\"user@example.com\"\n)\n</code></pre> <p>Utility module for TOTP (Time-based One-Time Password) operations.</p> <p>This module provides functionality for generating and verifying TOTP codes that are commonly used for multi-factor authentication.</p> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils</code>","text":"<p>Utility class for TOTP (Time-based One-Time Password) operations.</p> <p>This class provides methods for generating and verifying TOTP codes, as well as generating secure secret keys for TOTP initialization.</p> <p>Uses the following configuration parameters from AuthConfig: - TOTP_SECRET_KEY: Master secret key for generating TOTP secrets - TOTP_HASH_ALGORITHM: Hash algorithm used for TOTP generation (default: SHA1) - TOTP_LENGTH: Number of digits in generated TOTP codes - TOTP_TIME_STEP: Time step in seconds between TOTP code changes - TOTP_EXPIRES_IN: TOTP validity period in seconds - TOTP_VERIFICATION_WINDOW: Number of time steps to check before/after - SALT_LENGTH: Length of random bytes for secure key generation</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>class TOTPUtils:\n    \"\"\"Utility class for TOTP (Time-based One-Time Password) operations.\n\n    This class provides methods for generating and verifying TOTP codes, as well as generating\n    secure secret keys for TOTP initialization.\n\n    Uses the following configuration parameters from AuthConfig:\n    - TOTP_SECRET_KEY: Master secret key for generating TOTP secrets\n    - TOTP_HASH_ALGORITHM: Hash algorithm used for TOTP generation (default: SHA1)\n    - TOTP_LENGTH: Number of digits in generated TOTP codes\n    - TOTP_TIME_STEP: Time step in seconds between TOTP code changes\n    - TOTP_EXPIRES_IN: TOTP validity period in seconds\n    - TOTP_VERIFICATION_WINDOW: Number of time steps to check before/after\n    - SALT_LENGTH: Length of random bytes for secure key generation\n    \"\"\"\n\n    @classmethod\n    def generate_totp(cls, secret: str | UUID, auth_config: AuthConfig | None = None) -&gt; tuple[str, datetime]:\n        \"\"\"Generates a TOTP code using the configured hash algorithm.\n\n        Args:\n            secret: The secret key used to generate the TOTP code.\n            auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            A tuple containing the generated TOTP code and its expiration time.\n\n        Raises:\n            InvalidArgumentError: If the secret is invalid or empty.\n        \"\"\"\n        if not secret:\n            raise InvalidArgumentError(\n                argument_name=\"secret\",\n            )\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # Convert secret to bytes if it's UUID\n        if isinstance(secret, UUID):\n            secret = str(secret)\n\n        # Get current timestamp and calculate time step\n        current_time = DatetimeUtils.get_epoch_time_now()\n        time_step_counter = int(current_time / configs.TOTP_TIME_STEP)\n\n        # Generate HMAC hash\n        secret_bytes = str(secret).encode(\"utf-8\")\n        time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n\n        # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n        hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n        hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n        hmac_result = hmac_obj.digest()\n\n        # Get offset and truncate\n        offset = hmac_result[-1] &amp; 0xF\n        truncated_hash = (\n            ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n            | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n            | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n            | (hmac_result[offset + 3] &amp; 0xFF)\n        )\n\n        # Generate TOTP code\n        totp_code = str(truncated_hash % (10**configs.TOTP_LENGTH)).zfill(configs.TOTP_LENGTH)\n\n        # Calculate expiration time\n        expires_in = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=configs.TOTP_EXPIRES_IN)\n\n        return totp_code, expires_in\n\n    @classmethod\n    def verify_totp(cls, secret: str | UUID, totp_code: str, auth_config: AuthConfig | None = None) -&gt; bool:\n        \"\"\"Verifies a TOTP code against the provided secret.\n\n        Args:\n            secret: The secret key used to generate the TOTP code.\n            totp_code: The TOTP code to verify.\n            auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            `True` if the TOTP code is valid, `False` otherwise.\n\n        Raises:\n            InvalidArgumentError: If the secret is invalid or empty.\n            InvalidTokenError: If the TOTP code format is invalid.\n        \"\"\"\n        if not secret:\n            raise InvalidArgumentError(\n                argument_name=\"secret\",\n            )\n\n        if not totp_code:\n            raise InvalidArgumentError(\n                argument_name=\"totp_code\",\n            )\n\n        if not totp_code.isdigit():\n            raise InvalidTokenError\n\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        current_time = DatetimeUtils.get_epoch_time_now()\n\n        # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n        hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n        # Check codes within verification window\n        for i in range(-configs.TOTP_VERIFICATION_WINDOW, configs.TOTP_VERIFICATION_WINDOW + 1):\n            time_step_counter = int(current_time / configs.TOTP_TIME_STEP) + i\n\n            secret_bytes = str(secret).encode(\"utf-8\")\n            time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n            hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n            hmac_result = hmac_obj.digest()\n\n            offset = hmac_result[-1] &amp; 0xF\n            truncated_hash = (\n                ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n                | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n                | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n                | (hmac_result[offset + 3] &amp; 0xFF)\n            )\n\n            computed_totp = str(truncated_hash % (10 ** len(totp_code))).zfill(len(totp_code))\n\n            if hmac.compare_digest(totp_code, computed_totp):\n                return True\n\n        return False\n\n    @staticmethod\n    def generate_secret_key_for_totp(auth_config: AuthConfig | None = None) -&gt; str:\n        \"\"\"Generates a random secret key for TOTP initialization.\n\n        Args:\n            auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n        Returns:\n            A base32-encoded secret key for TOTP initialization.\n\n        Raises:\n            InvalidArgumentError: If the TOTP_SECRET_KEY is not configured.\n            InternalError: If there is an error generating the secret key.\n        \"\"\"\n        try:\n            configs = auth_config or BaseConfig.global_config().AUTH\n\n            # Use secrets module instead of random for better security\n            random_bytes = secrets.token_bytes(configs.SALT_LENGTH)\n\n            # Check if TOTP secret key is configured\n            if not configs.TOTP_SECRET_KEY:\n                # Disable linter for this specific case since we're already in a try-except block\n                # and creating nested functions would reduce code readability\n                raise InvalidArgumentError(\n                    argument_name=\"TOTP_SECRET_KEY\",\n                )\n\n            master_key = configs.TOTP_SECRET_KEY.get_secret_value().encode(\"utf-8\")\n\n            # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n            hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n            # Use HMAC with master key for additional security\n            hmac_obj = hmac.new(master_key, random_bytes, hash_algo)\n            return base64.b32encode(hmac_obj.digest()).decode(\"utf-8\")\n        except Exception as e:\n            # Convert any errors to our custom errors\n            raise InternalError() from e\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils.generate_totp","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils.generate_totp(secret, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Generates a TOTP code using the configured hash algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>str | UUID</code> <p>The secret key used to generate the TOTP code.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, datetime]</code> <p>A tuple containing the generated TOTP code and its expiration time.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the secret is invalid or empty.</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>@classmethod\ndef generate_totp(cls, secret: str | UUID, auth_config: AuthConfig | None = None) -&gt; tuple[str, datetime]:\n    \"\"\"Generates a TOTP code using the configured hash algorithm.\n\n    Args:\n        secret: The secret key used to generate the TOTP code.\n        auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        A tuple containing the generated TOTP code and its expiration time.\n\n    Raises:\n        InvalidArgumentError: If the secret is invalid or empty.\n    \"\"\"\n    if not secret:\n        raise InvalidArgumentError(\n            argument_name=\"secret\",\n        )\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    # Convert secret to bytes if it's UUID\n    if isinstance(secret, UUID):\n        secret = str(secret)\n\n    # Get current timestamp and calculate time step\n    current_time = DatetimeUtils.get_epoch_time_now()\n    time_step_counter = int(current_time / configs.TOTP_TIME_STEP)\n\n    # Generate HMAC hash\n    secret_bytes = str(secret).encode(\"utf-8\")\n    time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n\n    # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n    hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n    hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n    hmac_result = hmac_obj.digest()\n\n    # Get offset and truncate\n    offset = hmac_result[-1] &amp; 0xF\n    truncated_hash = (\n        ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n        | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n        | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n        | (hmac_result[offset + 3] &amp; 0xFF)\n    )\n\n    # Generate TOTP code\n    totp_code = str(truncated_hash % (10**configs.TOTP_LENGTH)).zfill(configs.TOTP_LENGTH)\n\n    # Calculate expiration time\n    expires_in = DatetimeUtils.get_datetime_after_given_datetime_or_now(seconds=configs.TOTP_EXPIRES_IN)\n\n    return totp_code, expires_in\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils.verify_totp","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils.verify_totp(secret, totp_code, auth_config=None)</code>  <code>classmethod</code>","text":"<p>Verifies a TOTP code against the provided secret.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>str | UUID</code> <p>The secret key used to generate the TOTP code.</p> required <code>totp_code</code> <code>str</code> <p>The TOTP code to verify.</p> required <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the TOTP code is valid, <code>False</code> otherwise.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the secret is invalid or empty.</p> <code>InvalidTokenError</code> <p>If the TOTP code format is invalid.</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>@classmethod\ndef verify_totp(cls, secret: str | UUID, totp_code: str, auth_config: AuthConfig | None = None) -&gt; bool:\n    \"\"\"Verifies a TOTP code against the provided secret.\n\n    Args:\n        secret: The secret key used to generate the TOTP code.\n        totp_code: The TOTP code to verify.\n        auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        `True` if the TOTP code is valid, `False` otherwise.\n\n    Raises:\n        InvalidArgumentError: If the secret is invalid or empty.\n        InvalidTokenError: If the TOTP code format is invalid.\n    \"\"\"\n    if not secret:\n        raise InvalidArgumentError(\n            argument_name=\"secret\",\n        )\n\n    if not totp_code:\n        raise InvalidArgumentError(\n            argument_name=\"totp_code\",\n        )\n\n    if not totp_code.isdigit():\n        raise InvalidTokenError\n\n    configs = auth_config or BaseConfig.global_config().AUTH\n\n    current_time = DatetimeUtils.get_epoch_time_now()\n\n    # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n    hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n    # Check codes within verification window\n    for i in range(-configs.TOTP_VERIFICATION_WINDOW, configs.TOTP_VERIFICATION_WINDOW + 1):\n        time_step_counter = int(current_time / configs.TOTP_TIME_STEP) + i\n\n        secret_bytes = str(secret).encode(\"utf-8\")\n        time_bytes = struct.pack(\"&gt;Q\", time_step_counter)\n        hmac_obj = hmac.new(secret_bytes, time_bytes, hash_algo)\n        hmac_result = hmac_obj.digest()\n\n        offset = hmac_result[-1] &amp; 0xF\n        truncated_hash = (\n            ((hmac_result[offset] &amp; 0x7F) &lt;&lt; 24)\n            | ((hmac_result[offset + 1] &amp; 0xFF) &lt;&lt; 16)\n            | ((hmac_result[offset + 2] &amp; 0xFF) &lt;&lt; 8)\n            | (hmac_result[offset + 3] &amp; 0xFF)\n        )\n\n        computed_totp = str(truncated_hash % (10 ** len(totp_code))).zfill(len(totp_code))\n\n        if hmac.compare_digest(totp_code, computed_totp):\n            return True\n\n    return False\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.totp_utils.TOTPUtils.generate_secret_key_for_totp","title":"<code>archipy.helpers.utils.totp_utils.TOTPUtils.generate_secret_key_for_totp(auth_config=None)</code>  <code>staticmethod</code>","text":"<p>Generates a random secret key for TOTP initialization.</p> <p>Parameters:</p> Name Type Description Default <code>auth_config</code> <code>AuthConfig | None</code> <p>Optional auth configuration override. If not provided, uses the global config.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A base32-encoded secret key for TOTP initialization.</p> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If the TOTP_SECRET_KEY is not configured.</p> <code>InternalError</code> <p>If there is an error generating the secret key.</p> Source code in <code>archipy/helpers/utils/totp_utils.py</code> <pre><code>@staticmethod\ndef generate_secret_key_for_totp(auth_config: AuthConfig | None = None) -&gt; str:\n    \"\"\"Generates a random secret key for TOTP initialization.\n\n    Args:\n        auth_config: Optional auth configuration override. If not provided, uses the global config.\n\n    Returns:\n        A base32-encoded secret key for TOTP initialization.\n\n    Raises:\n        InvalidArgumentError: If the TOTP_SECRET_KEY is not configured.\n        InternalError: If there is an error generating the secret key.\n    \"\"\"\n    try:\n        configs = auth_config or BaseConfig.global_config().AUTH\n\n        # Use secrets module instead of random for better security\n        random_bytes = secrets.token_bytes(configs.SALT_LENGTH)\n\n        # Check if TOTP secret key is configured\n        if not configs.TOTP_SECRET_KEY:\n            # Disable linter for this specific case since we're already in a try-except block\n            # and creating nested functions would reduce code readability\n            raise InvalidArgumentError(\n                argument_name=\"TOTP_SECRET_KEY\",\n            )\n\n        master_key = configs.TOTP_SECRET_KEY.get_secret_value().encode(\"utf-8\")\n\n        # Use the dedicated TOTP hash algorithm from config, with fallback to SHA1\n        hash_algo = getattr(configs, \"TOTP_HASH_ALGORITHM\", \"SHA1\")\n\n        # Use HMAC with master key for additional security\n        hmac_obj = hmac.new(master_key, random_bytes, hash_algo)\n        return base64.b32encode(hmac_obj.digest()).decode(\"utf-8\")\n    except Exception as e:\n        # Convert any errors to our custom errors\n        raise InternalError() from e\n</code></pre>"},{"location":"api_reference/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Utilities for Keycloak integration.</p> <pre><code>from archipy.helpers.utils.keycloak_utils import KeycloakUtils\n\n# Get token\ntoken = KeycloakUtils.get_keycloak_token(\n    username=\"user\",\n    password=\"pass\",\n    client_id=\"my-client\"\n)\n\n# Validate token\nis_valid = KeycloakUtils.validate_keycloak_token(token)\n\n# Get user info\nuser_info = KeycloakUtils.get_keycloak_userinfo(token)\n\n# Check role\nhas_role = KeycloakUtils.has_keycloak_role(token, \"admin\")\n</code></pre> <p>options: show_root_heading: true show_source: true</p>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils</code>","text":"<p>Utility class for Keycloak authentication and authorization in FastAPI applications.</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>class KeycloakUtils:\n    \"\"\"Utility class for Keycloak authentication and authorization in FastAPI applications.\"\"\"\n\n    @staticmethod\n    def _get_keycloak_adapter() -&gt; KeycloakAdapter:\n        return KeycloakAdapter()\n\n    @staticmethod\n    def _get_async_keycloak_adapter() -&gt; AsyncKeycloakAdapter:\n        return AsyncKeycloakAdapter()\n\n    @classmethod\n    # Synchronous decorator\n    def fastapi_auth(\n        cls,\n        resource_type_param: str | None = None,\n        resource_type: str | None = None,\n        required_roles: frozenset[str] | None = None,\n        all_roles_required: bool = False,\n        required_permissions: tuple[tuple[str, str], ...] | None = None,\n        admin_roles: frozenset[str] | None = None,\n        lang: LanguageType = DEFAULT_LANG,\n    ) -&gt; Callable:\n        \"\"\"FastAPI decorator for Keycloak authentication and resource-based authorization.\n\n        Args:\n            resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n            resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n            required_roles: Set of role names that the user must have\n            all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n            required_permissions: List of (resource, scope) tuples to check\n            admin_roles: Set of roles that grant administrative access to all resources\n            lang: Language for error messages\n        Raises:\n            UnauthenticatedError: If no valid Authorization header is provided\n            InvalidTokenError: If token is invalid\n            TokenExpiredError: If token is expired\n            PermissionDeniedError: If user lacks required roles, permissions, or resource access\n            InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n        \"\"\"\n\n        def dependency(\n            request: Request,\n            token: HTTPAuthorizationCredentials = Security(security),\n            keycloak: KeycloakAdapter = Depends(cls._get_keycloak_adapter),\n        ) -&gt; dict:\n            if token is None:\n                raise UnauthenticatedError(lang=lang)\n            token_str = token.credentials  # Extract the token string\n            # Validate token\n            if not keycloak.validate_token(token_str):\n                token_info = keycloak.introspect_token(token_str)\n                if not token_info.get(\"active\", False):\n                    raise TokenExpiredError(lang=lang)\n\n            # Get user info from token\n            user_info = keycloak.get_userinfo(token_str)\n            token_info = keycloak.get_token_info(token_str)\n\n            # Resource-based authorization if resource type is provided\n            if resource_type and resource_type_param:\n                # Extract resource UUID from path parameters\n                resource_uuid = request.path_params.get(resource_type_param)\n                if not resource_uuid:\n                    raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n                # Verify resource exists and user has access\n                user_uuid = user_info.get(\"sub\")\n\n                # Check if resource exists\n                resource_user = keycloak.get_user_by_id(resource_uuid)\n                if not resource_user:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n                # Authorization check: either owns the resource or has admin privileges\n                has_admin_privileges = admin_roles and keycloak.has_any_of_roles(token_str, admin_roles)\n                if user_uuid != resource_uuid and not has_admin_privileges:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n            # Check additional roles if specified\n            if required_roles:\n                if all_roles_required:\n                    if not keycloak.has_all_roles(token_str, required_roles):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_roles\": required_roles},\n                        )\n                elif not keycloak.has_any_of_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n\n            # Check permissions if specified\n            if required_permissions:\n                for resource, scope in required_permissions:\n                    if not keycloak.check_permissions(token_str, resource, scope):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                        )\n\n            # Add user info to request state\n            request.state.user_info = user_info\n            request.state.token_info = token_info\n            return user_info\n\n        return dependency\n\n    @classmethod\n    def async_fastapi_auth(\n        cls,\n        resource_type_param: str | None = None,\n        resource_type: str | None = None,\n        required_roles: frozenset[str] | None = None,\n        all_roles_required: bool = False,\n        required_permissions: tuple[tuple[str, str], ...] | None = None,\n        admin_roles: frozenset[str] | None = None,\n        lang: LanguageType = DEFAULT_LANG,\n    ) -&gt; Callable:\n        \"\"\"FastAPI async decorator for Keycloak authentication and resource-based authorization.\n\n        Args:\n            resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n            resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n            required_roles: Set of role names that the user must have\n            all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n            required_permissions: List of (resource, scope) tuples to check\n            admin_roles: Set of roles that grant administrative access to all resources\n            lang: Language for error messages\n        Raises:\n            UnauthenticatedError: If no valid Authorization header is provided\n            InvalidTokenError: If token is invalid\n            TokenExpiredError: If token is expired\n            PermissionDeniedError: If user lacks required roles, permissions, or resource access\n            InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n        \"\"\"\n\n        async def dependency(\n            request: Request,\n            token: HTTPAuthorizationCredentials = Security(security),\n            keycloak: AsyncKeycloakAdapter = Depends(cls._get_async_keycloak_adapter),\n        ) -&gt; dict:\n            if token is None:\n                raise UnauthenticatedError(lang=lang)\n            token_str = token.credentials  # Extract the token string\n\n            # Validate token\n            if not await keycloak.validate_token(token_str):\n                # Handle token validation error\n                token_info = await keycloak.introspect_token(token_str)\n                if not token_info.get(\"active\", False):\n                    raise TokenExpiredError(lang=lang)\n\n            # Get user info from token\n            user_info = await keycloak.get_userinfo(token_str)\n            token_info = await keycloak.get_token_info(token_str)\n\n            # Resource-based authorization if resource type is provided\n            if resource_type and resource_type_param:\n                # Extract resource UUID from path parameters\n                resource_uuid = request.path_params.get(resource_type_param)\n                if not resource_uuid:\n                    raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n                # Verify resource exists and user has access\n                user_uuid = user_info.get(\"sub\")\n\n                # Check if resource exists\n                resource_user = await keycloak.get_user_by_id(resource_uuid)\n                if not resource_user:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n                # Authorization check: either owns the resource or has admin privileges\n                has_admin_privileges = admin_roles and await keycloak.has_any_of_roles(token_str, admin_roles)\n                if user_uuid != resource_uuid and not has_admin_privileges:\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                    )\n\n            # Check additional roles if specified\n            if required_roles:\n                if all_roles_required:\n                    if not await keycloak.has_all_roles(token_str, required_roles):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_roles\": required_roles},\n                        )\n                elif not await keycloak.has_any_of_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n\n            # Check permissions if specified\n            if required_permissions:\n                for resource, scope in required_permissions:\n                    if not await keycloak.check_permissions(token_str, resource, scope):\n                        raise PermissionDeniedError(\n                            lang=lang,\n                            additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                        )\n\n            # Add user info to request state\n            request.state.user_info = user_info\n            request.state.token_info = token_info\n            return user_info\n\n        return dependency\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils.fastapi_auth","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils.fastapi_auth(resource_type_param=None, resource_type=None, required_roles=None, all_roles_required=False, required_permissions=None, admin_roles=None, lang=DEFAULT_LANG)</code>  <code>classmethod</code>","text":"<p>FastAPI decorator for Keycloak authentication and resource-based authorization.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type_param</code> <code>str | None</code> <p>The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')</p> <code>None</code> <code>resource_type</code> <code>str | None</code> <p>The type of resource being accessed (e.g., 'users', 'employees')</p> <code>None</code> <code>required_roles</code> <code>frozenset[str] | None</code> <p>Set of role names that the user must have</p> <code>None</code> <code>all_roles_required</code> <code>bool</code> <p>If True, user must have all specified roles; if False, any role is sufficient</p> <code>False</code> <code>required_permissions</code> <code>tuple[tuple[str, str], ...] | None</code> <p>List of (resource, scope) tuples to check</p> <code>None</code> <code>admin_roles</code> <code>frozenset[str] | None</code> <p>Set of roles that grant administrative access to all resources</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language for error messages</p> <code>DEFAULT_LANG</code> <p>Raises:     UnauthenticatedError: If no valid Authorization header is provided     InvalidTokenError: If token is invalid     TokenExpiredError: If token is expired     PermissionDeniedError: If user lacks required roles, permissions, or resource access     InvalidArgumentError: If resource_type_param is missing when resource_type is provided</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@classmethod\n# Synchronous decorator\ndef fastapi_auth(\n    cls,\n    resource_type_param: str | None = None,\n    resource_type: str | None = None,\n    required_roles: frozenset[str] | None = None,\n    all_roles_required: bool = False,\n    required_permissions: tuple[tuple[str, str], ...] | None = None,\n    admin_roles: frozenset[str] | None = None,\n    lang: LanguageType = DEFAULT_LANG,\n) -&gt; Callable:\n    \"\"\"FastAPI decorator for Keycloak authentication and resource-based authorization.\n\n    Args:\n        resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n        resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n        required_roles: Set of role names that the user must have\n        all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n        required_permissions: List of (resource, scope) tuples to check\n        admin_roles: Set of roles that grant administrative access to all resources\n        lang: Language for error messages\n    Raises:\n        UnauthenticatedError: If no valid Authorization header is provided\n        InvalidTokenError: If token is invalid\n        TokenExpiredError: If token is expired\n        PermissionDeniedError: If user lacks required roles, permissions, or resource access\n        InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n    \"\"\"\n\n    def dependency(\n        request: Request,\n        token: HTTPAuthorizationCredentials = Security(security),\n        keycloak: KeycloakAdapter = Depends(cls._get_keycloak_adapter),\n    ) -&gt; dict:\n        if token is None:\n            raise UnauthenticatedError(lang=lang)\n        token_str = token.credentials  # Extract the token string\n        # Validate token\n        if not keycloak.validate_token(token_str):\n            token_info = keycloak.introspect_token(token_str)\n            if not token_info.get(\"active\", False):\n                raise TokenExpiredError(lang=lang)\n\n        # Get user info from token\n        user_info = keycloak.get_userinfo(token_str)\n        token_info = keycloak.get_token_info(token_str)\n\n        # Resource-based authorization if resource type is provided\n        if resource_type and resource_type_param:\n            # Extract resource UUID from path parameters\n            resource_uuid = request.path_params.get(resource_type_param)\n            if not resource_uuid:\n                raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n            # Verify resource exists and user has access\n            user_uuid = user_info.get(\"sub\")\n\n            # Check if resource exists\n            resource_user = keycloak.get_user_by_id(resource_uuid)\n            if not resource_user:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n            # Authorization check: either owns the resource or has admin privileges\n            has_admin_privileges = admin_roles and keycloak.has_any_of_roles(token_str, admin_roles)\n            if user_uuid != resource_uuid and not has_admin_privileges:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n        # Check additional roles if specified\n        if required_roles:\n            if all_roles_required:\n                if not keycloak.has_all_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n            elif not keycloak.has_any_of_roles(token_str, required_roles):\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"required_roles\": required_roles},\n                )\n\n        # Check permissions if specified\n        if required_permissions:\n            for resource, scope in required_permissions:\n                if not keycloak.check_permissions(token_str, resource, scope):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                    )\n\n        # Add user info to request state\n        request.state.user_info = user_info\n        request.state.token_info = token_info\n        return user_info\n\n    return dependency\n</code></pre>"},{"location":"api_reference/utils/#archipy.helpers.utils.keycloak_utils.KeycloakUtils.async_fastapi_auth","title":"<code>archipy.helpers.utils.keycloak_utils.KeycloakUtils.async_fastapi_auth(resource_type_param=None, resource_type=None, required_roles=None, all_roles_required=False, required_permissions=None, admin_roles=None, lang=DEFAULT_LANG)</code>  <code>classmethod</code>","text":"<p>FastAPI async decorator for Keycloak authentication and resource-based authorization.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type_param</code> <code>str | None</code> <p>The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')</p> <code>None</code> <code>resource_type</code> <code>str | None</code> <p>The type of resource being accessed (e.g., 'users', 'employees')</p> <code>None</code> <code>required_roles</code> <code>frozenset[str] | None</code> <p>Set of role names that the user must have</p> <code>None</code> <code>all_roles_required</code> <code>bool</code> <p>If True, user must have all specified roles; if False, any role is sufficient</p> <code>False</code> <code>required_permissions</code> <code>tuple[tuple[str, str], ...] | None</code> <p>List of (resource, scope) tuples to check</p> <code>None</code> <code>admin_roles</code> <code>frozenset[str] | None</code> <p>Set of roles that grant administrative access to all resources</p> <code>None</code> <code>lang</code> <code>LanguageType</code> <p>Language for error messages</p> <code>DEFAULT_LANG</code> <p>Raises:     UnauthenticatedError: If no valid Authorization header is provided     InvalidTokenError: If token is invalid     TokenExpiredError: If token is expired     PermissionDeniedError: If user lacks required roles, permissions, or resource access     InvalidArgumentError: If resource_type_param is missing when resource_type is provided</p> Source code in <code>archipy/helpers/utils/keycloak_utils.py</code> <pre><code>@classmethod\ndef async_fastapi_auth(\n    cls,\n    resource_type_param: str | None = None,\n    resource_type: str | None = None,\n    required_roles: frozenset[str] | None = None,\n    all_roles_required: bool = False,\n    required_permissions: tuple[tuple[str, str], ...] | None = None,\n    admin_roles: frozenset[str] | None = None,\n    lang: LanguageType = DEFAULT_LANG,\n) -&gt; Callable:\n    \"\"\"FastAPI async decorator for Keycloak authentication and resource-based authorization.\n\n    Args:\n        resource_type_param: The parameter name in the path (e.g., 'user_uuid', 'employee_uuid')\n        resource_type: The type of resource being accessed (e.g., 'users', 'employees')\n        required_roles: Set of role names that the user must have\n        all_roles_required: If True, user must have all specified roles; if False, any role is sufficient\n        required_permissions: List of (resource, scope) tuples to check\n        admin_roles: Set of roles that grant administrative access to all resources\n        lang: Language for error messages\n    Raises:\n        UnauthenticatedError: If no valid Authorization header is provided\n        InvalidTokenError: If token is invalid\n        TokenExpiredError: If token is expired\n        PermissionDeniedError: If user lacks required roles, permissions, or resource access\n        InvalidArgumentError: If resource_type_param is missing when resource_type is provided\n    \"\"\"\n\n    async def dependency(\n        request: Request,\n        token: HTTPAuthorizationCredentials = Security(security),\n        keycloak: AsyncKeycloakAdapter = Depends(cls._get_async_keycloak_adapter),\n    ) -&gt; dict:\n        if token is None:\n            raise UnauthenticatedError(lang=lang)\n        token_str = token.credentials  # Extract the token string\n\n        # Validate token\n        if not await keycloak.validate_token(token_str):\n            # Handle token validation error\n            token_info = await keycloak.introspect_token(token_str)\n            if not token_info.get(\"active\", False):\n                raise TokenExpiredError(lang=lang)\n\n        # Get user info from token\n        user_info = await keycloak.get_userinfo(token_str)\n        token_info = await keycloak.get_token_info(token_str)\n\n        # Resource-based authorization if resource type is provided\n        if resource_type and resource_type_param:\n            # Extract resource UUID from path parameters\n            resource_uuid = request.path_params.get(resource_type_param)\n            if not resource_uuid:\n                raise InvalidArgumentError(argument_name=resource_type_param, lang=lang)\n\n            # Verify resource exists and user has access\n            user_uuid = user_info.get(\"sub\")\n\n            # Check if resource exists\n            resource_user = await keycloak.get_user_by_id(resource_uuid)\n            if not resource_user:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n            # Authorization check: either owns the resource or has admin privileges\n            has_admin_privileges = admin_roles and await keycloak.has_any_of_roles(token_str, admin_roles)\n            if user_uuid != resource_uuid and not has_admin_privileges:\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"resource_type\": resource_type, \"resource_id\": resource_uuid},\n                )\n\n        # Check additional roles if specified\n        if required_roles:\n            if all_roles_required:\n                if not await keycloak.has_all_roles(token_str, required_roles):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_roles\": required_roles},\n                    )\n            elif not await keycloak.has_any_of_roles(token_str, required_roles):\n                raise PermissionDeniedError(\n                    lang=lang,\n                    additional_data={\"required_roles\": required_roles},\n                )\n\n        # Check permissions if specified\n        if required_permissions:\n            for resource, scope in required_permissions:\n                if not await keycloak.check_permissions(token_str, resource, scope):\n                    raise PermissionDeniedError(\n                        lang=lang,\n                        additional_data={\"required_permission\": f\"{resource}#{scope}\"},\n                    )\n\n        # Add user info to request state\n        request.state.user_info = user_info\n        request.state.token_info = token_info\n        return user_info\n\n    return dependency\n</code></pre>"},{"location":"api_reference/utils/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/utils/#datetimeutils","title":"DateTimeUtils","text":"<p>Class: <code>archipy.helpers.utils.datetime_utils.DateTimeUtils</code></p> <p>Provides datetime operations with features:</p> <ul> <li>Timezone-aware</li> <li>Microsecond precision</li> <li>Consistent across the application</li> </ul>"},{"location":"api_reference/utils/#jwtutils","title":"JWTUtils","text":"<p>Class: <code>archipy.helpers.utils.jwt_utils.JWTUtils</code></p> <p>Provides JWT operations with features:</p> <ul> <li>Configurable expiration</li> <li>Custom payload support</li> <li>Multiple signing algorithms</li> <li>Token refresh capability</li> </ul>"},{"location":"api_reference/utils/#passwordutils","title":"PasswordUtils","text":"<p>Class: <code>archipy.helpers.utils.password_utils.PasswordUtils</code></p> <p>Provides password operations with features:</p> <ul> <li>Secure hashing algorithm</li> <li>Salt generation</li> <li>Configurable work factor</li> <li>Protection against timing attacks</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This section contains practical examples of using ArchiPy components.</p>"},{"location":"examples/#adapters","title":"Adapters","text":"<ul> <li>PostgreSQL</li> <li>SQLite</li> <li>StarRocks</li> <li>Redis</li> <li>Email</li> <li>Keycloak</li> <li>MinIO</li> <li>Kafka</li> <li>Payment Gateways</li> </ul>"},{"location":"examples/#helpers","title":"Helpers","text":"<ul> <li>Decorators</li> <li>Interceptors</li> <li>Utils</li> </ul>"},{"location":"examples/#configuration","title":"Configuration","text":"<ul> <li>Configuration Management</li> </ul>"},{"location":"examples/#testing","title":"Testing","text":"<ul> <li>BDD Testing</li> </ul>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<ul> <li>Error Handling Examples</li> </ul>"},{"location":"examples/bdd_testing/","title":"BDD Testing with ArchiPy","text":"<p>This page demonstrates how to use ArchiPy's integrated BDD testing capabilities with Behave.</p>"},{"location":"examples/bdd_testing/#basic-usage","title":"Basic Usage","text":"<p>ArchiPy provides a complete BDD testing setup using Behave. Here's how to use it:</p>"},{"location":"examples/bdd_testing/#feature-files","title":"Feature Files","text":"<p>Create feature files in the <code>features</code> directory with Gherkin syntax:</p> <pre><code># features/user_management.feature\nFeature: User Management\n  As a system administrator\n  I want to manage users\n  So that I can control system access\n\n  Scenario: Create a new user\n    Given I have admin privileges\n    When I create a user with username \"john\" and email \"john@example.com\"\n    Then the user should be saved in the database\n    And the user should have default permissions\n</code></pre>"},{"location":"examples/bdd_testing/#step-implementations","title":"Step Implementations","text":"<p>Implement the steps in Python files under <code>features/steps</code>:</p> <pre><code># features/steps/user_steps.py\nfrom typing import Any\nfrom behave import given, when, then\nfrom app.models import User\nfrom app.services import UserService\nfrom archipy.models.errors import NotFoundError, DatabaseQueryError\n\n@given('I have admin privileges')\ndef step_impl(context: Any) -&gt; None:\n    context.is_admin = True\n\n@when('I create a user with username \"{username}\" and email \"{email}\"')\ndef step_impl(context: Any, username: str, email: str) -&gt; None:\n    service = UserService()\n    try:\n        context.user = service.create_user(username, email)\n    except Exception as e:\n        # Proper exception chaining\n        raise DatabaseQueryError(\n            additional_data={\"username\": username, \"email\": email}\n        ) from e\n\n@then('the user should be saved in the database')\ndef step_impl(context: Any) -&gt; None:\n    # Check user exists in DB\n    try:\n        db_user = User.query.filter_by(username=context.user.username).first()\n        assert db_user is not None\n    except Exception as e:\n        raise NotFoundError(\n            resource_type=\"user\",\n            additional_data={\"username\": context.user.username}\n        ) from e\n\n@then('the user should have default permissions')\ndef step_impl(context: Any) -&gt; None:\n    assert len(context.user.permissions) &gt; 0\n    assert 'user:read' in context.user.permissions\n</code></pre>"},{"location":"examples/bdd_testing/#running-tests","title":"Running Tests","text":"<p>Run BDD tests using the Makefile command:</p> <pre><code>make behave\n</code></pre> <p>To run a specific feature:</p> <pre><code>poetry run behave features/user_management.feature\n</code></pre> <p>To run a specific scenario by line number:</p> <pre><code>poetry run behave features/user_management.feature:7\n</code></pre>"},{"location":"examples/bdd_testing/#advanced-bdd-testing","title":"Advanced BDD Testing","text":""},{"location":"examples/bdd_testing/#using-context-tables","title":"Using Context Tables","text":"<p>Behave supports data tables for testing multiple scenarios:</p> <pre><code>Scenario: Create multiple users\nGiven I have admin privileges\nWhen I create the following users:\n| username | email              | role    |\n| john     | john@example.com   | user    |\n| alice    | alice@example.com  | admin   |\n| bob      | bob@example.com    | support |\nThen all users should be saved in the database\n</code></pre> <pre><code>@when('I create the following users')\ndef step_impl(context: Any) -&gt; None:\n    service = UserService()\n    context.users = []\n    for row in context.table:\n        try:\n            user = service.create_user(\n                username=row['username'],\n                email=row['email'],\n                role=row['role']\n            )\n            context.users.append(user)\n        except Exception as e:\n            raise DatabaseQueryError(\n                additional_data={\"username\": row['username'], \"email\": row['email']}\n            ) from e\n</code></pre>"},{"location":"examples/config_management/","title":"Configuration Management","text":"<p>ArchiPy provides a robust configuration management system that ensures type safety, environment variable support, and consistent access patterns across your application.</p>"},{"location":"examples/config_management/#basic-configuration","title":"Basic Configuration","text":""},{"location":"examples/config_management/#defining-a-configuration","title":"Defining a Configuration","text":"<p>Create a configuration class by inheriting from <code>BaseConfig</code>:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(BaseConfig):\n    # Application settings\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n    DB_NAME: str = \"myapp\"\n    DB_USER: str = \"postgres\"\n    DB_PASSWORD: str = \"password\"\n\n    # Redis settings\n    REDIS_HOST: str = \"localhost\"\n    REDIS_PORT: int = 6379\n\n    # Environment\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEV\n\n    # API settings\n    API_PREFIX: str = \"/api/v1\"\n\n    # Logging\n    LOG_LEVEL: str = \"INFO\"\n</code></pre>"},{"location":"examples/config_management/#using-the-configuration","title":"Using the Configuration","text":"<pre><code># Create and set as global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n\n# Access configuration values from anywhere in your code\nfrom archipy.configs.base_config import BaseConfig\n\ncurrent_config = BaseConfig.global_config()\ndb_url = f\"postgresql://{current_config.DB_USER}:{current_config.DB_PASSWORD}@{current_config.DB_HOST}:{current_config.DB_PORT}/{current_config.DB_NAME}\"\n</code></pre>"},{"location":"examples/config_management/#environment-variables","title":"Environment Variables","text":"<p>ArchiPy configurations automatically load values from environment variables with the same name:</p> <pre><code># .env file\nAPP_NAME = ProductionService\nDB_HOST = db.example.com\nDB_PASSWORD = secure - password\nENVIRONMENT = PRODUCTION\n</code></pre> <p>The environment variables override the default values in your configuration class:</p> <pre><code>config = AppConfig()  # Will have values from environment variables\nprint(config.APP_NAME)  # \"ProductionService\"\nprint(config.ENVIRONMENT)  # EnvironmentType.PRODUCTION\n</code></pre>"},{"location":"examples/config_management/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>You can create environment-specific configurations:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass BaseAppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    # Common settings...\n\nclass DevelopmentConfig(BaseAppConfig):\n    DEBUG: bool = True\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEV\n    LOG_LEVEL: str = \"DEBUG\"\n\nclass ProductionConfig(BaseAppConfig):\n    DEBUG: bool = False\n    ENVIRONMENT: EnvironmentType = EnvironmentType.PRODUCTION\n    LOG_LEVEL: str = \"WARNING\"\n\n# Choose configuration based on environment\nimport os\nenv = os.getenv(\"ENVIRONMENT\", \"development\").lower()\n\nif env == \"production\":\n    config = ProductionConfig()\nelse:\n    config = DevelopmentConfig()\n\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"examples/config_management/#nested-configurations","title":"Nested Configurations","text":"<p>You can use nested Pydantic models for more complex configurations:</p> <pre><code>from pydantic import BaseModel\nfrom archipy.configs.base_config import BaseConfig\n\nclass DatabaseConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 5432\n    NAME: str = \"myapp\"\n    USER: str = \"postgres\"\n    PASSWORD: str = \"password\"\n\n    def connection_string(self) -&gt; str:\n        return f\"postgresql://{self.USER}:{self.PASSWORD}@{self.HOST}:{self.PORT}/{self.NAME}\"\n\nclass RedisConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 6379\n    DB: int = 0\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    DATABASE: DatabaseConfig = DatabaseConfig()\n    REDIS: RedisConfig = RedisConfig()\n\n# Usage\nconfig = AppConfig()\nprint(config.DATABASE.connection_string())\n</code></pre>"},{"location":"examples/config_management/#configuration-template","title":"Configuration Template","text":"<p>ArchiPy provides pre-configured templates for common configuration objects:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(BaseConfig):\n    # Override only what you need\n    APP_NAME: str = \"MyCustomApp\"\n\n    # The BaseConfig provides default templates for common configurations like:\n    # AUTH, DATETIME, ELASTIC, EMAIL, FASTAPI, KAFKA, REDIS, etc.\n\nconfig = AppConfig()\nprint(config.ENVIRONMENT)  # Default value from BaseConfig (EnvironmentType.LOCAL)\n</code></pre>"},{"location":"examples/config_management/#configuration-in-different-components","title":"Configuration in Different Components","text":""},{"location":"examples/config_management/#with-fastapi","title":"With FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Initialize your configuration\nconfig = BaseConfig()\nBaseConfig.set_global(config)\n\n# Create a FastAPI app with configuration\napp = AppUtils.create_fastapi_app()  # Uses global config by default\n\n# Or provide a specific configuration\n# app = AppUtils.create_fastapi_app(config)\n\n# Access config in endpoint\n@app.get(\"/config\")\ndef get_config_info():\n    config = BaseConfig.global_config()\n    return {\n        \"app_name\": config.FASTAPI.PROJECT_NAME,\n        \"environment\": config.ENVIRONMENT.value,\n        \"debug\": config.FASTAPI.RELOAD\n    }\n</code></pre>"},{"location":"examples/config_management/#with-database-adapters","title":"With Database Adapters","text":"<pre><code>from archipy.adapters.postgres.sqlalchemy.session_managers import SQlAlchemySessionManager\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create session manager with config\nsession_manager = SQlAlchemySessionManager(\n    connection_string=config.POSTGRES_SQLALCHEMY.POSTGRES_DSN,\n    echo=config.POSTGRES_SQLALCHEMY.ECHO\n)\n</code></pre>"},{"location":"examples/config_management/#with-redis-adapters","title":"With Redis Adapters","text":"<pre><code>from archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create Redis adapter with config\nredis_adapter = RedisAdapter(\n    host=config.REDIS.MASTER_HOST,\n    port=config.REDIS.PORT,\n    db=config.REDIS.DATABASE\n)\n</code></pre>"},{"location":"examples/config_management/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use meaningful defaults: Configure sensible defaults that work in local development</p> </li> <li> <p>Never hardcode secrets: Always use environment variables for sensitive information</p> </li> <li> <p>Validate configurations: Use Pydantic validators for complex validation rules</p> </li> <li> <p>Document configuration options: Add clear docstrings to your configuration classes</p> </li> <li> <p>Keep configurations centralized: Avoid creating multiple configuration sources</p> </li> </ol>"},{"location":"examples/error_handling/","title":"Error Handling Examples","text":"<p>This document provides examples of how to use the error handling system in different scenarios.</p>"},{"location":"examples/error_handling/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>from archipy.models.errors import (\n    NotFoundError,\n    InvalidArgumentError,\n    PermissionDeniedError\n)\nfrom archipy.models.types.language_type import LanguageType\n\ndef get_user(user_id: str):\n    try:\n        # Attempt to fetch user\n        user = user_repository.find_by_id(user_id)\n        if not user:\n            raise NotFoundError(\n                resource_type=\"user\",\n                error_details=f\"User with ID {user_id} not found\",\n                lang=LanguageType.EN\n            )\n        return user\n    except NotFoundError as e:\n        # Log the error\n        logger.error(f\"User not found: {e.to_dict()}\")\n        # Re-raise or handle as needed\n        raise\n\ndef update_user_permissions(user_id: str, permissions: list[str]):\n    try:\n        # Validate input\n        if not isinstance(permissions, list):\n            raise InvalidArgumentError(\n                argument=\"permissions\",\n                error_details=\"Permissions must be a list\",\n                lang=LanguageType.EN\n            )\n\n        # Check permissions\n        if not has_admin_access():\n            raise PermissionDeniedError(\n                operation=\"update_permissions\",\n                error_details=\"Admin access required\",\n                lang=LanguageType.EN\n            )\n\n        # Update permissions\n        user_repository.update_permissions(user_id, permissions)\n    except (InvalidArgumentError, PermissionDeniedError) as e:\n        logger.error(f\"Failed to update permissions: {e.to_dict()}\")\n        raise\n</code></pre>"},{"location":"examples/error_handling/#business-logic-error-handling","title":"Business Logic Error Handling","text":"<pre><code>from archipy.models.errors import (\n    InsufficientFundsError,\n    BusinessRuleViolationError,\n    InvalidStateError\n)\n\ndef process_transaction(account_id: str, amount: float):\n    try:\n        # Check account state\n        account = account_repository.find_by_id(account_id)\n        if not account.is_active:\n            raise InvalidStateError(\n                current_state=\"inactive\",\n                expected_state=\"active\",\n                error_details=\"Account must be active for transactions\"\n            )\n\n        # Check balance\n        if account.balance &lt; amount:\n            raise InsufficientFundsError(\n                error_details=f\"Required amount: {amount}, Available: {account.balance}\"\n            )\n\n        # Check business rules\n        if amount &gt; account.transaction_limit:\n            raise BusinessRuleViolationError(\n                rule=\"transaction_limit\",\n                details=f\"Amount exceeds limit of {account.transaction_limit}\"\n            )\n\n        # Process transaction\n        account_repository.process_transaction(account_id, amount)\n    except (InsufficientFundsError, BusinessRuleViolationError, InvalidStateError) as e:\n        logger.error(f\"Transaction failed: {e.to_dict()}\")\n        raise\n</code></pre>"},{"location":"examples/error_handling/#system-error-handling","title":"System Error Handling","text":"<pre><code>from archipy.models.errors import (\n    DatabaseConnectionError,\n    DeadlockDetectedError,\n    ResourceExhaustedError\n)\nfrom typing import Any\n\ndef execute_with_retry(operation: callable, max_retries: int = 3) -&gt; Any:\n    retries = 0\n    while retries &lt; max_retries:\n        try:\n            return operation()\n        except DeadlockDetectedError as e:\n            retries += 1\n            if retries == max_retries:\n                logger.error(f\"Max retries exceeded: {e.to_dict()}\")\n                raise\n            logger.warning(f\"Deadlock detected, retrying ({retries}/{max_retries})\")\n            time.sleep(1)  # Wait before retry\n        except DatabaseConnectionError as e:\n            logger.error(f\"Database connection failed: {e.to_dict()}\")\n            raise  # Don't retry connection errors\n        except ResourceExhaustedError as e:\n            logger.error(f\"Resource exhausted: {e.to_dict()}\")\n            raise  # Don't retry resource exhaustion\n\n# Usage example\ndef process_batch(items: list[dict]):\n    def batch_operation():\n        return database.batch_insert(items)\n\n    try:\n        return execute_with_retry(batch_operation)\n    except (DeadlockDetectedError, DatabaseConnectionError, ResourceExhaustedError) as e:\n        # Handle final failure\n        return {\"error\": e.to_dict()}\n</code></pre>"},{"location":"examples/error_handling/#error-response-formatting","title":"Error Response Formatting","text":"<pre><code>from fastapi import HTTPException\nfrom fastapi.responses import JSONResponse\nfrom archipy.models.errors import BaseError\nfrom archipy.models.types.language_type import LanguageType\nfrom datetime import datetime\n\ndef handle_error(error: BaseError) -&gt; dict:\n    \"\"\"Convert error to API response format.\"\"\"\n    error_dict = error.to_dict()\n    return {\n        \"status\": \"error\",\n        \"error\": error_dict,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n# FastAPI error handler\n@app.exception_handler(BaseError)\nasync def error_handler(request: Request, exc: BaseError):\n    return JSONResponse(\n        status_code=exc.http_status_code or 500,\n        content=handle_error(exc)\n    )\n\n# Example usage in endpoint\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: str):\n    try:\n        user = user_service.get_user(user_id)\n        return {\"status\": \"success\", \"data\": user}\n    except NotFoundError as e:\n        # Let the exception handler handle it\n        raise\n</code></pre>"},{"location":"examples/error_handling/#error-logging-and-monitoring","title":"Error Logging and Monitoring","text":"<pre><code>from archipy.models.errors import (\n    InternalError,\n    UnknownError,\n    ConfigurationError\n)\nimport sentry_sdk\n\ndef log_error(error: BaseError, context: dict | None = None):\n    \"\"\"Log error with context and send to monitoring service.\"\"\"\n    error_dict = error.to_dict()\n\n    # Add context if provided\n    if context:\n        error_dict[\"context\"] = context\n\n    # Log to application logger\n    logger.error(\n        f\"Error occurred: {error_dict['error']}\",\n        extra={\"error\": error_dict}\n    )\n\n    # Send to monitoring service\n    if isinstance(error, (InternalError, UnknownError, ConfigurationError)):\n        sentry_sdk.capture_exception(error)\n\n# Example usage\ndef process_request(request_data: dict):\n    try:\n        # Process request\n        result = service.process(request_data)\n        return result\n    except BaseError as e:\n        log_error(e, context={\"request_data\": request_data})\n        raise\n</code></pre>"},{"location":"examples/error_handling/#exception-chaining","title":"Exception Chaining","text":"<pre><code>from archipy.models.errors import (\n    DatabaseQueryError,\n    InvalidEntityTypeError,\n    BaseEntity\n)\n\n# Good - Preserving original error context\ndef fetch_entity(entity_type: type, entity_uuid: str) -&gt; BaseEntity:\n    try:\n        result = session.get(entity_type, entity_uuid)\n        if not result:\n            raise NotFoundError(\n                resource_type=entity_type.__name__,\n                error_details=f\"Entity with UUID {entity_uuid} not found\"\n            )\n        return result\n    except Exception as e:\n        raise DatabaseQueryError() from e\n\n# Good - Type validation with specific error\ndef validate_entity(entity: object) -&gt; None:\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(\n            message=f\"Expected BaseEntity subclass, got {type(entity).__name__}\",\n            expected_type=\"BaseEntity\",\n            actual_type=type(entity).__name__\n        )\n</code></pre>"},{"location":"examples/error_handling/#error-recovery-strategies","title":"Error Recovery Strategies","text":"<pre><code>from archipy.models.errors import (\n    CacheMissError,\n    ServiceUnavailableError,\n    ResourceExhaustedError\n)\n\nclass ErrorRecovery:\n    @staticmethod\n    def handle_cache_miss(error: CacheMissError):\n        \"\"\"Handle cache miss by fetching from primary source.\"\"\"\n        try:\n            # Fetch from database\n            data = database.get(error.key)\n            # Update cache\n            cache.set(error.key, data)\n            return data\n        except Exception as e:\n            logger.error(f\"Failed to recover from cache miss: {str(e)}\")\n            raise  # Re-raise after logging\n\n    @staticmethod\n    def handle_service_unavailable(error: ServiceUnavailableError):\n        \"\"\"Handle service unavailability with fallback.\"\"\"\n        if error.service == \"primary\":\n            try:\n            # Try fallback service\n            return fallback_service.get_data()\n            except Exception as e:\n                # Preserve error chain\n                raise ServiceUnavailableError(\n                    service=\"fallback\",\n                    error_details=\"Both primary and fallback services unavailable\"\n                ) from e\n        raise\n\n    @staticmethod\n    def handle_resource_exhaustion(error: ResourceExhaustedError):\n        \"\"\"Handle resource exhaustion with cleanup.\"\"\"\n        if error.resource_type == \"memory\":\n            # Perform cleanup\n            gc.collect()\n            try:\n            # Retry operation\n            return retry_operation()\n            except Exception as e:\n                # Preserve error chain\n                raise ResourceExhaustedError(\n                    resource_type=\"memory\",\n                    error_details=\"Resource exhaustion persisted after cleanup\"\n                ) from e\n        raise\n\n# Example usage\ndef get_data(key: str):\n    try:\n        return cache.get(key)\n    except CacheMissError as e:\n        return ErrorRecovery.handle_cache_miss(e)\n    except ServiceUnavailableError as e:\n        return ErrorRecovery.handle_service_unavailable(e)\n    except ResourceExhaustedError as e:\n        return ErrorRecovery.handle_resource_exhaustion(e)\n</code></pre>"},{"location":"examples/adapters/","title":"Adapter Examples","text":"<p>ArchiPy provides a variety of adapters to help interface with external systems, maintaining a clean separation between your business logic and external dependencies.</p>"},{"location":"examples/adapters/#available-adapters","title":"Available Adapters","text":"Adapter Purpose Example API Reference Email Email sending interface Connect to SMTP servers for sending emails API Keycloak Authentication &amp; authorization User management and access control with Keycloak API Kafka Message streaming Event-driven architectures with Apache Kafka API Minio Object storage S3-compatible object storage for files and documents API Parsian Payment Payment gateway Process online payments with Parsian Shaparak API PostgreSQL Database access SQLAlchemy integration for PostgreSQL API SQLite Database access SQLAlchemy integration for SQLite API StarRocks Database access SQLAlchemy integration for StarRocks API Redis Key-value store Caching, pub/sub, and data storage with Redis API"},{"location":"examples/adapters/#adapter-architecture","title":"Adapter Architecture","text":"<p>ArchiPy follows the ports and adapters pattern (hexagonal architecture):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Domain Logic               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Ports                  \u2502\n\u2502          (Abstract Interfaces)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 implemented by\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Adapters                \u2502\n\u2502         (Concrete Implementations)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 connects to\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            External Systems            \u2502\n\u2502   (Databases, APIs, Message Queues)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/adapters/#testing-with-mock-adapters","title":"Testing with Mock Adapters","text":"<p>Each adapter in ArchiPy comes with a corresponding mock implementation for testing:</p> <pre><code># Production code\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"redis.example.com\", port=6379)\nredis.set(\"key\", \"value\")\n\n# Test code\nfrom archipy.adapters.redis import RedisMock\n\nredis_mock = RedisMock()\nredis_mock.set(\"key\", \"test_value\")\nassert redis_mock.get(\"key\") == \"test_value\"\n</code></pre>"},{"location":"examples/adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>Creating custom adapters is straightforward:</p> <ol> <li>Define a port (abstract interface)</li> <li>Implement the adapter class</li> <li>Optionally create a mock implementation</li> </ol> <p>See the Architecture guide for more details on creating custom adapters.</p>"},{"location":"examples/adapters/email/","title":"Email Adapter Examples","text":"<p>This page demonstrates how to use ArchiPy's email adapter functionality.</p>"},{"location":"examples/adapters/email/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.email import EmailAdapter\n\n# Configure email adapter\nemail_adapter = EmailAdapter(\n    host=\"smtp.example.com\",\n    port=587,\n    username=\"your-username\",\n    password=\"your-password\",\n    use_tls=True\n)\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email from ArchiPy\",\n    recipients=[\"recipient@example.com\"],\n    cc=[\"cc@example.com\"],\n    bcc=[\"bcc@example.com\"],\n    from_email=\"sender@example.com\"\n)\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/adapters/kafka/","title":"Kafka Adapter","text":"<p>The Kafka adapter provides a clean interface for interacting with Apache Kafka, supporting both synchronous and asynchronous operations.</p>"},{"location":"examples/adapters/kafka/#features","title":"Features","text":"<ul> <li>Topic operations (create, list, delete)</li> <li>Message publishing and consuming</li> <li>Consumer group management</li> <li>Built-in error handling and retry mechanisms</li> <li>Support for both sync and async operations</li> <li>Comprehensive logging and monitoring</li> </ul>"},{"location":"examples/adapters/kafka/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/kafka/#configuration","title":"Configuration","text":"<p>Configure Kafka in your application's config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Using environment variables\n# KAFKA__BOOTSTRAP_SERVERS=localhost:9092\n# KAFKA__CLIENT_ID=my-app\n# KAFKA__GROUP_ID=my-group\n</code></pre>"},{"location":"examples/adapters/kafka/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.kafka.adapters import KafkaAdapter, AsyncKafkaAdapter\n\n# Use global configuration\nkafka = KafkaAdapter()\n\n# Or provide specific configuration\nfrom archipy.configs.config_template import KafkaConfig\n\ncustom_config = KafkaConfig(\n    BOOTSTRAP_SERVERS=\"kafka1:9092,kafka2:9092\",\n    CLIENT_ID=\"custom-client\",\n    GROUP_ID=\"custom-group\"\n)\nkafka = KafkaAdapter(custom_config)\n</code></pre>"},{"location":"examples/adapters/kafka/#topic-operations","title":"Topic Operations","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create a topic\nkafka.create_topic(\"my-topic\", num_partitions=3, replication_factor=1)\n\n# List all topics\ntopics = kafka.list_topics()\nfor topic in topics:\n    logger.info(f\"Topic: {topic}\")\n\n# Delete a topic\nkafka.delete_topic(\"my-topic\")\n</code></pre>"},{"location":"examples/adapters/kafka/#publishing-messages","title":"Publishing Messages","text":"<pre><code>import logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Publish a simple message\nkafka.publish(\"my-topic\", \"Hello, Kafka!\")\n\n# Publish with key and headers\nheaders = {\"source\": \"my-app\", \"version\": \"1.0\"}\nkafka.publish(\"my-topic\", \"Hello, Kafka!\", key=\"message-1\", headers=headers)\n\n# Publish multiple messages\nmessages = [\n    {\"key\": \"msg1\", \"value\": \"Message 1\"},\n    {\"key\": \"msg2\", \"value\": \"Message 2\"}\n]\nkafka.publish_batch(\"my-topic\", messages)\n</code></pre>"},{"location":"examples/adapters/kafka/#consuming-messages","title":"Consuming Messages","text":"<pre><code>import logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Consume messages with a callback\ndef process_message(message: dict[str, Any]) -&gt; None:\n    logger.info(f\"Received message: {message['value']}\")\n\n# Start consuming\nkafka.consume(\"my-topic\", process_message)\n\n# Consume with specific partition and offset\nkafka.consume(\"my-topic\", process_message, partition=0, offset=0)\n\n# Consume with timeout\nkafka.consume(\"my-topic\", process_message, timeout_ms=5000)\n</code></pre>"},{"location":"examples/adapters/kafka/#async-operations","title":"Async Operations","text":"<pre><code>import asyncio\nimport logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nasync def async_example():\n    # Create async Kafka adapter\n    async_kafka = AsyncKafkaAdapter()\n\n    # Publish message asynchronously\n    await async_kafka.publish(\"my-topic\", \"Async message\")\n\n    # Consume messages asynchronously\n    async def process_async(message: dict[str, Any]) -&gt; None:\n        logger.info(f\"Received async message: {message['value']}\")\n\n    await async_kafka.consume(\"my-topic\", process_async)\n\n# Run the async example\nasyncio.run(async_example())\n</code></pre>"},{"location":"examples/adapters/kafka/#error-handling","title":"Error Handling","text":"<p>The KafkaAdapter uses ArchiPy's domain-specific exceptions for consistent error handling:</p> <pre><code>import logging\nfrom archipy.models.errors import (\n    AlreadyExistsError,\n    InternalError,\n    InvalidArgumentError,\n    NotFoundError,\n    PermissionDeniedError,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    kafka.create_topic(\"existing-topic\")\nexcept AlreadyExistsError:\n    logger.warning(\"Topic already exists\")\nexcept PermissionDeniedError:\n    logger.exception(\"Permission denied to create topic\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Invalid argument: {e}\")\nexcept InternalError as e:\n    logger.exception(f\"Internal error: {e}\")\n</code></pre>"},{"location":"examples/adapters/kafka/#consumer-group-management","title":"Consumer Group Management","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# List consumer groups\ngroups = kafka.list_consumer_groups()\nfor group in groups:\n    logger.info(f\"Group: {group['group_id']}, State: {group['state']}\")\n\n# Describe consumer group\ngroup_info = kafka.describe_consumer_group(\"my-group\")\nlogger.info(f\"Group members: {group_info['members']}\")\n\n# Delete consumer group\nkafka.delete_consumer_group(\"my-group\")\n</code></pre>"},{"location":"examples/adapters/kafka/#integration-with-web-applications","title":"Integration with Web Applications","text":""},{"location":"examples/adapters/kafka/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom archipy.adapters.kafka.adapters import KafkaAdapter\nfrom archipy.models.errors import InternalError\n\napp = FastAPI()\nkafka = KafkaAdapter()\n\nclass Message(BaseModel):\n    content: str\n    key: str | None = None\n\n@app.post(\"/publish/{topic}\")\nasync def publish_message(topic: str, message: Message):\n    try:\n        kafka.publish(topic, message.content, key=message.key)\n        return {\"message\": \"Message published successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/topics\")\nasync def list_topics():\n    try:\n        topics = kafka.list_topics()\n        return {\"topics\": topics}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"examples/adapters/kafka/#testing-with-bdd","title":"Testing with BDD","text":"<p>The Kafka adapter comes with BDD tests to verify functionality. Here's a sample feature file:</p> <pre><code>Feature: Kafka Operations Testing\n  As a developer\n  I want to test Kafka messaging operations\n  So that I can ensure reliable message delivery\n\n  Scenario: Publishing and consuming messages\n    Given I have a Kafka topic \"test-topic\"\n    When I publish a message \"Hello, Kafka!\" to \"test-topic\"\n    Then I should be able to consume the message from \"test-topic\"\n</code></pre>"},{"location":"examples/adapters/keycloak/","title":"Keycloak Adapter Usage Guide","text":"<p>The Keycloak adapter provides an interface for interacting with Keycloak's API to manage authentication and authorization. ArchiPy offers both synchronous and asynchronous implementations.</p> <p>For full API reference, see the Keycloak Adapters API Documentation.</p>"},{"location":"examples/adapters/keycloak/#configuration","title":"Configuration","text":"<p>First, configure your Keycloak settings in your application config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.config_template import KeycloakConfig\n\nclass AppConfig(BaseConfig):\n    # Keycloak configuration\n    KEYCLOAK = KeycloakConfig(\n        SERVER_URL=\"https://keycloak.example.com\",\n        REALM_NAME=\"my-realm\",\n        CLIENT_ID=\"my-client\",\n        CLIENT_SECRET_KEY=\"client-secret\",  # Optional, required for admin operations\n        VERIFY_SSL=True,\n        TIMEOUT=10\n    )\n</code></pre>"},{"location":"examples/adapters/keycloak/#synchronous-adapter","title":"Synchronous Adapter","text":"<p>The synchronous adapter provides a blocking API for Keycloak operations.</p> <pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Using global configuration\nkeycloak = KeycloakAdapter()\n\n# Or with custom configuration\ncustom_config = KeycloakConfig(\n    SERVER_URL=\"https://keycloak.example.com\",\n    REALM_NAME=\"another-realm\",\n    CLIENT_ID=\"another-client\",\n    CLIENT_SECRET_KEY=\"client-secret\"\n)\nkeycloak = KeycloakAdapter(custom_config)\n\n# Authentication\ntry:\n    # Get token with username/password\n    token = keycloak.get_token(\"username\", \"password\")\n    access_token = token[\"access_token\"]\n    refresh_token = token[\"refresh_token\"]\n\n    # Refresh an existing token\n    new_token = keycloak.refresh_token(refresh_token)\n\n    # Validate a token\n    is_valid = keycloak.validate_token(access_token)\n\n    # Get user info from token\n    user_info = keycloak.get_userinfo(access_token)\n\n    # Get token using client credentials\n    client_token = keycloak.get_client_credentials_token()\n\n    # Logout (invalidate refresh token)\n    keycloak.logout(refresh_token)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# User operations (requires admin privileges)\ntry:\n    # Get user by ID\n    user = keycloak.get_user_by_id(\"user-uuid\")\n\n    # Get user by username\n    user = keycloak.get_user_by_username(\"johndoe\")\n\n    # Get user by email\n    user = keycloak.get_user_by_email(\"john@example.com\")\n\n    # Create a new user\n    user_data = {\n        \"username\": \"newuser\",\n        \"email\": \"newuser@example.com\",\n        \"enabled\": True,\n        \"firstName\": \"New\",\n        \"lastName\": \"User\",\n        \"credentials\": [{\n            \"type\": \"password\",\n            \"value\": \"initial-password\",\n            \"temporary\": True\n        }]\n    }\n    user_id = keycloak.create_user(user_data)\n\n    # Update a user\n    update_data = {\"firstName\": \"Updated\", \"email\": \"updated@example.com\"}\n    keycloak.update_user(user_id, update_data)\n\n    # Reset password\n    keycloak.reset_password(user_id, \"new-password\", temporary=True)\n\n    # Search for users\n    users = keycloak.search_users(\"john\", max_results=10)\n\n    # Clear all user sessions\n    keycloak.clear_user_sessions(user_id)\n\n    # Delete a user\n    keycloak.delete_user(user_id)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Role operations\ntry:\n    # Get user roles\n    roles = keycloak.get_user_roles(user_id)\n\n    # Get client roles for user\n    client_roles = keycloak.get_client_roles_for_user(user_id, \"client-id\")\n\n    # Check if user has role\n    has_role = keycloak.has_role(access_token, \"admin\")\n\n    # Check if user has any of the specified roles\n    has_any = keycloak.has_any_of_roles(access_token, {\"admin\", \"manager\"})\n\n    # Check if user has all specified roles\n    has_all = keycloak.has_all_roles(access_token, {\"user\", \"viewer\"})\n\n    # Assign realm role\n    keycloak.assign_realm_role(user_id, \"admin\")\n\n    # Remove realm role\n    keycloak.remove_realm_role(user_id, \"admin\")\n\n    # Assign client role\n    keycloak.assign_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Remove client role\n    keycloak.remove_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Get realm roles\n    all_roles = keycloak.get_realm_roles()\n\n    # Get a specific realm role\n    role = keycloak.get_realm_role(\"admin\")\n\n    # Create a realm role\n    new_role = keycloak.create_realm_role(\"new-role\", \"A new role description\")\n\n    # Delete a realm role\n    keycloak.delete_realm_role(\"new-role\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Client operations\ntry:\n    # Get client ID from name\n    client_id = keycloak.get_client_id(\"client-name\")\n\n    # Get client secret\n    secret = keycloak.get_client_secret(client_id)\n\n    # Get service account ID\n    service_account_id = keycloak.get_service_account_id()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# System operations\ntry:\n    # Get public key for token verification\n    public_key = keycloak.get_public_key()\n\n    # Get well-known OpenID configuration\n    config = keycloak.get_well_known_config()\n\n    # Get JWT certificates\n    certs = keycloak.get_certs()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Authorization\ntry:\n    # Exchange authorization code for token\n    token = keycloak.get_token_from_code(\"auth-code\", \"https://my-app.example.com/callback\")\n\n    # Check permissions\n    has_permission = keycloak.check_permissions(access_token, \"resource-name\", \"view\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n</code></pre>"},{"location":"examples/adapters/keycloak/#asynchronous-adapter","title":"Asynchronous Adapter","text":"<p>The asynchronous adapter provides a non-blocking API using <code>async/await</code> syntax:</p> <pre><code>import asyncio\nfrom archipy.adapters.keycloak.adapters import AsyncKeycloakAdapter\n\nasync def main():\n    # Initialize with global config\n    keycloak = AsyncKeycloakAdapter()\n\n    try:\n        # Get token\n        token = await keycloak.get_token(\"username\", \"password\")\n        access_token = token[\"access_token\"]\n\n        # Get user info\n        user_info = await keycloak.get_userinfo(access_token)\n        print(f\"Logged in as: {user_info.get('preferred_username')}\")\n\n        # Check if user has role\n        if await keycloak.has_role(access_token, \"admin\"):\n            print(\"User has admin role\")\n\n        # Search for users\n        users = await keycloak.search_users(\"john\")\n        print(f\"Found {len(users)} users matching 'john'\")\n\n        # Create a new user\n        user_data = {\n            \"username\": \"async_user\",\n            \"email\": \"async@example.com\",\n            \"enabled\": True,\n        }\n        user_id = await keycloak.create_user(user_data)\n        print(f\"Created user with ID: {user_id}\")\n\n        # Delete the user\n        await keycloak.delete_user(user_id)\n    except ValueError as e:\n        print(f\"Keycloak error: {e}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/keycloak/#caching","title":"Caching","text":"<p>Both adapters use TTL (Time-To-Live) caching for appropriate operations to improve performance. Cache durations are configured for each method based on how frequently the data typically changes:</p> <ul> <li>Public keys and certificate information: 1 hour</li> <li>User information from tokens: 30 seconds</li> <li>User details and role information: 5 minutes</li> </ul> <p>You can clear all caches if needed:</p> <pre><code># Sync adapter\nkeycloak = KeycloakAdapter()\nkeycloak.clear_all_caches()\n\n# Async adapter\nasync_keycloak = AsyncKeycloakAdapter()\nasync_keycloak.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/keycloak/#security-considerations","title":"Security Considerations","text":"<ul> <li>Token validation is performed without caching to ensure security.</li> <li>The adapter automatically refreshes admin tokens before they expire.</li> <li>Write operations (like user creation/updates) automatically clear relevant caches.</li> <li>For production use, prefer the authorization code flow over direct username/password authentication.</li> </ul>"},{"location":"examples/adapters/minio/","title":"Minio Adapter","text":"<p>The Minio adapter provides a clean interface for interacting with MinIO and S3-compatible object storage services.</p>"},{"location":"examples/adapters/minio/#features","title":"Features","text":"<ul> <li>Bucket operations (create, list, delete)</li> <li>Object operations (upload, download, delete)</li> <li>Presigned URL generation</li> <li>Bucket policy management</li> <li>Built-in caching for performance optimization</li> <li>Comprehensive error handling with domain-specific exceptions</li> </ul>"},{"location":"examples/adapters/minio/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/minio/#configuration","title":"Configuration","text":"<p>Configure MinIO in your application's config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Method 1: Using environment variables\n# MINIO__ENDPOINT=localhost:9000\n# MINIO__ACCESS_KEY=minioadmin\n# MINIO__SECRET_KEY=minioadmin\n\n# Method 2: Direct configuration\nBaseConfig.global_config().MINIO.ENDPOINT = \"localhost:9000\"\nBaseConfig.global_config().MINIO.ACCESS_KEY = \"minioadmin\"\nBaseConfig.global_config().MINIO.SECRET_KEY = \"minioadmin\"\nBaseConfig.global_config().MINIO.SECURE = False  # Set to True for HTTPS\n</code></pre>"},{"location":"examples/adapters/minio/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.minio.adapters import MinioAdapter\n\n# Use global configuration\nminio = MinioAdapter()\n\n# Or provide specific configuration\nfrom archipy.configs.config_template import MinioConfig\n\ncustom_config = MinioConfig(\n    ENDPOINT=\"play.min.io:9000\",\n    ACCESS_KEY=\"your-access-key\",\n    SECRET_KEY=\"your-secret-key\",\n    SECURE=True\n)\nminio = MinioAdapter(custom_config)\n</code></pre>"},{"location":"examples/adapters/minio/#bucket-operations","title":"Bucket Operations","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Check if bucket exists\nif not minio.bucket_exists(\"my-bucket\"):\n    # Create bucket\n    minio.make_bucket(\"my-bucket\")\n    logger.info(\"Bucket created successfully\")\n\n# List all buckets\nbuckets = minio.list_buckets()\nfor bucket in buckets:\n    logger.info(f\"Bucket: {bucket['name']}, Created: {bucket['creation_date']}\")\n\n# Remove bucket\nminio.remove_bucket(\"my-bucket\")\n</code></pre>"},{"location":"examples/adapters/minio/#working-with-objects","title":"Working with Objects","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Upload a file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/local/document.pdf\")\n\n# Download an object\nminio.get_object(\"my-bucket\", \"document.pdf\", \"/path/to/download/document.pdf\")\n\n# List objects in a bucket\nobjects = minio.list_objects(\"my-bucket\", prefix=\"documents/\", recursive=True)\nfor obj in objects:\n    logger.info(f\"Object: {obj['object_name']}, Size: {obj['size']} bytes\")\n\n# Get object metadata\nmetadata = minio.stat_object(\"my-bucket\", \"document.pdf\")\nlogger.info(f\"Content type: {metadata['content_type']}\")\nlogger.info(f\"Last modified: {metadata['last_modified']}\")\n\n# Remove an object\nminio.remove_object(\"my-bucket\", \"document.pdf\")\n</code></pre>"},{"location":"examples/adapters/minio/#generating-presigned-urls","title":"Generating Presigned URLs","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Generate a presigned URL for downloading (valid for 1 hour by default)\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\")\nlogger.info(f\"Download URL: {download_url}\")\n\n# Generate a presigned URL for uploading (with custom expiry time in seconds)\nupload_url = minio.presigned_put_object(\"my-bucket\", \"new-document.pdf\", expires=7200)  # 2 hours\nlogger.info(f\"Upload URL: {upload_url}\")\n</code></pre>"},{"location":"examples/adapters/minio/#managing-bucket-policies","title":"Managing Bucket Policies","text":"<pre><code>import logging\nimport json\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Set a read-only policy for a bucket\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\"AWS\": \"*\"},\n            \"Action\": [\"s3:GetObject\"],\n            \"Resource\": [f\"arn:aws:s3:::my-bucket/*\"]\n        }\n    ]\n}\nminio.set_bucket_policy(\"my-bucket\", json.dumps(policy))\n\n# Get bucket policy\npolicy_info = minio.get_bucket_policy(\"my-bucket\")\nlogger.info(f\"Bucket policy: {policy_info['policy']}\")\n</code></pre>"},{"location":"examples/adapters/minio/#error-handling","title":"Error Handling","text":"<p>The MinioAdapter uses ArchiPy's domain-specific exceptions for consistent error handling:</p> <pre><code>import logging\nfrom archipy.models.errors import (\n    AlreadyExistsError,\n    InternalError,\n    InvalidArgumentError,\n    NotFoundError,\n    PermissionDeniedError,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    minio.make_bucket(\"existing-bucket\")\nexcept AlreadyExistsError:\n    logger.warning(\"Bucket already exists\")\nexcept PermissionDeniedError:\n    logger.exception(\"Permission denied to create bucket\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Invalid argument: {e}\")\nexcept InternalError as e:\n    logger.exception(f\"Internal error: {e}\")\n</code></pre>"},{"location":"examples/adapters/minio/#performance-optimization","title":"Performance Optimization","text":"<p>The MinioAdapter includes TTL caching for frequently accessed operations:</p> <pre><code># Check if bucket exists (cached for 5 minutes)\nminio.bucket_exists(\"my-bucket\")\n\n# List buckets (cached for 5 minutes)\nminio.list_buckets()\n\n# Clear all caches if needed\nminio.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/minio/#integration-with-web-applications","title":"Integration with Web Applications","text":""},{"location":"examples/adapters/minio/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, File, UploadFile, HTTPException\nfrom fastapi.responses import RedirectResponse\nimport tempfile\nimport os\n\nfrom archipy.adapters.minio.adapters import MinioAdapter\nfrom archipy.models.errors import NotFoundError, PermissionDeniedError\n\napp = FastAPI()\nminio = MinioAdapter()\n\n@app.post(\"/upload/{bucket_name}\")\nasync def upload_file(bucket_name: str, file: UploadFile):\n    try:\n        # Save uploaded file to temporary location\n        with tempfile.NamedTemporaryFile(delete=False) as temp:\n            content = await file.read()\n            temp.write(content)\n            temp_path = temp.name\n\n        # Upload to MinIO\n        try:\n            minio.put_object(bucket_name, file.filename, temp_path)\n            return {\"message\": f\"File {file.filename} uploaded successfully\"}\n        finally:\n            os.unlink(temp_path)  # Clean up temp file\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/download/{bucket_name}/{object_name}\")\nasync def download_file(bucket_name: str, object_name: str):\n    try:\n        # Generate presigned URL\n        url = minio.presigned_get_object(bucket_name, object_name, expires=3600)\n        return RedirectResponse(url)\n    except NotFoundError:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    except PermissionDeniedError:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"examples/adapters/minio/#testing-with-bdd","title":"Testing with BDD","text":"<p>The Minio adapter comes with BDD tests to verify functionality. Here's a sample feature file:</p> <pre><code>Feature: MinIO Operations Testing\n  As a developer\n  I want to test MinIO storage operations\n  So that I can ensure reliable object storage functionality\n\n  Background:\n    Given a configured MinIO adapter\n\n  Scenario: Create and verify a bucket\n    When I create a bucket named \"test-bucket\"\n    Then the bucket \"test-bucket\" should exist\n    And the bucket list should include \"test-bucket\"\n\n  Scenario: Upload and retrieve object\n    Given a bucket named \"test-bucket\" exists\n    When I upload a file \"test.txt\" with content \"Hello World\" to bucket \"test-bucket\"\n    Then the object \"test.txt\" should exist in bucket \"test-bucket\"\n    And downloading \"test.txt\" from \"test-bucket\" should return content \"Hello World\"\n</code></pre>"},{"location":"examples/adapters/parsian_payment/","title":"Parsian Shaparak Payment Gateway","text":"<p>This example demonstrates how to use the Parsian Shaparak payment gateway adapter to process online payments in Iran.</p>"},{"location":"examples/adapters/parsian_payment/#configuration","title":"Configuration","text":"<p>First, configure the Parsian Shaparak settings in your environment or configuration file:</p> <pre><code>from pydantic import BaseModel\nfrom archipy.configs.base_config import BaseConfig\nfrom archipy.configs.config_template import ParsianShaparakConfig\n\nclass MyAppConfig(BaseConfig):\n    # Other configuration settings\n\n    # Parsian Shaparak Configuration\n    PARSIAN_SHAPARAK: ParsianShaparakConfig = ParsianShaparakConfig(\n        LOGIN_ACCOUNT=\"your_merchant_login_account\",\n        # Optionally specify custom WSDL URLs if needed\n        # PAYMENT_WSDL_URL=\"https://custom.url/to/payment/wsdl\",\n        # CONFIRM_WSDL_URL=\"https://custom.url/to/confirm/wsdl\",\n        # REVERSAL_WSDL_URL=\"https://custom.url/to/reversal/wsdl\",\n        # Optionally specify proxy settings\n        # PROXIES={\"http\": \"http://proxy:port\", \"https\": \"https://proxy:port\"}\n    )\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.internet_payment_gateways.ir.parsian.adapters import (\n    ParsianShaparakPaymentAdapter,\n    PaymentRequestDTO,\n    ConfirmRequestDTO,\n    ConfirmWithAmountRequestDTO,\n    ReverseRequestDTO\n)\n\n# Initialize the payment adapter\npayment_adapter = ParsianShaparakPaymentAdapter()\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#processing-payments","title":"Processing Payments","text":""},{"location":"examples/adapters/parsian_payment/#initiating-a-payment","title":"Initiating a Payment","text":"<p>To start a payment transaction:</p> <pre><code># Create payment request\npayment_request = PaymentRequestDTO(\n    amount=10000,  # Amount in IRR (10,000 Rials)\n    order_id=12345,  # Your unique order ID\n    callback_url=\"https://your-app.com/payment/callback\",  # URL to redirect after payment\n    additional_data=\"Optional additional data\",  # Optional\n    originator=\"Optional originator info\"  # Optional\n)\n\n# Send payment request\npayment_response = payment_adapter.initiate_payment(payment_request)\n\n# Check response\nif payment_response.status == 0:  # 0 means success in Parsian API\n    # Redirect user to payment page\n    payment_url = f\"https://pec.shaparak.ir/NewIPG/?Token={payment_response.token}\"\n    # Use this URL to redirect the user to the payment gateway\nelse:\n    # Handle error\n    print(f\"Payment initiation failed: {payment_response.message}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#confirming-a-payment","title":"Confirming a Payment","text":"<p>After the user completes the payment and returns to your callback URL, confirm the payment:</p> <pre><code># Get the token from query parameters in your callback handler\ntoken = 123456789  # This would come from the callback request\n\n# Create confirm request\nconfirm_request = ConfirmRequestDTO(token=token)\n\n# Confirm payment\nconfirm_response = payment_adapter.confirm_payment(confirm_request)\n\nif confirm_response.status == 0:  # 0 means success\n    # Payment successful\n    reference_number = confirm_response.rrn\n    masked_card = confirm_response.card_number_masked\n\n    # Process the successful payment in your system\n    print(f\"Payment confirmed! Reference: {reference_number}, Card: {masked_card}\")\nelse:\n    # Handle failed confirmation\n    print(f\"Payment confirmation failed with status: {confirm_response.status}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#confirming-with-amount-verification","title":"Confirming with Amount Verification","text":"<p>For enhanced security, you can confirm with amount verification:</p> <pre><code># Create confirm with amount request\nconfirm_with_amount_request = ConfirmWithAmountRequestDTO(\n    token=123456789,\n    order_id=12345,\n    amount=10000\n)\n\n# Confirm payment with amount verification\nconfirm_response = payment_adapter.confirm_payment_with_amount(confirm_with_amount_request)\n\nif confirm_response.status == 0:  # 0 means success\n    # Payment successful with amount verification\n    print(f\"Payment confirmed with amount verification!\")\nelse:\n    # Handle failed confirmation\n    print(f\"Payment confirmation failed with status: {confirm_response.status}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#reversing-a-payment","title":"Reversing a Payment","text":"<p>If needed, you can reverse (refund) a successful payment:</p> <pre><code># Create reverse request\nreverse_request = ReverseRequestDTO(token=123456789)\n\n# Request payment reversal\nreverse_response = payment_adapter.reverse_payment(reverse_request)\n\nif reverse_response.status == 0:  # 0 means success\n    # Reversal successful\n    print(f\"Payment reversal successful!\")\nelse:\n    # Handle failed reversal\n    print(f\"Payment reversal failed: {reverse_response.message}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#error-handling","title":"Error Handling","text":"<p>The adapter uses ArchiPy's error system to provide consistent error handling:</p> <pre><code>from archipy.models.errors import UnavailableError, InternalError\n\ntry:\n    payment_response = payment_adapter.initiate_payment(payment_request)\nexcept UnavailableError as e:\n    # Handle service unavailable error\n    print(f\"Payment service unavailable: {e}\")\nexcept InternalError as e:\n    # Handle unexpected error\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"examples/adapters/parsian_payment/#complete-example","title":"Complete Example","text":"<p>Here's a complete example integrating the payment flow into a FastAPI application:</p> <pre><code>from fastapi import FastAPI, Request, Depends, HTTPException, status\nfrom fastapi.responses import RedirectResponse\nfrom pydantic import BaseModel\nfrom typing import Annotated\n\nfrom archipy.adapters.internet_payment_gateways.ir.parsian.adapters import (\n    ParsianShaparakPaymentAdapter,\n    PaymentRequestDTO,\n    ConfirmRequestDTO\n)\nfrom archipy.models.errors import UnavailableError, InternalError\n\napp = FastAPI()\npayment_adapter = ParsianShaparakPaymentAdapter()\n\n# Create order model\nclass OrderCreate(BaseModel):\n    amount: int\n    order_id: int\n    description: str = None\n\n# Payment routes\n@app.post(\"/payments/create\")\nasync def create_payment(order: OrderCreate):\n    try:\n        payment_request = PaymentRequestDTO(\n            amount=order.amount,\n            order_id=order.order_id,\n            callback_url=f\"https://your-app.com/payments/callback\",\n            additional_data=order.description\n        )\n\n        response = payment_adapter.initiate_payment(payment_request)\n\n        if response.status != 0:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=f\"Payment initiation failed: {response.message}\"\n            )\n\n        # Return payment URL or token\n        return {\n            \"token\": response.token,\n            \"payment_url\": f\"https://pec.shaparak.ir/NewIPG/?Token={response.token}\"\n        }\n\n    except UnavailableError as e:\n        raise HTTPException(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            detail=\"Payment service unavailable\"\n        )\n    except InternalError as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal server error\"\n        )\n\n@app.get(\"/payments/callback\")\nasync def payment_callback(token: int, request: Request):\n    try:\n        confirm_request = ConfirmRequestDTO(token=token)\n        confirm_response = payment_adapter.confirm_payment(confirm_request)\n\n        if confirm_response.status == 0:\n            # Payment successful - update your database\n            return {\n                \"status\": \"success\",\n                \"reference_number\": confirm_response.rrn,\n                \"card\": confirm_response.card_number_masked\n            }\n        else:\n            return {\n                \"status\": \"failed\",\n                \"message\": \"Payment verification failed\"\n            }\n\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"message\": str(e)\n        }\n</code></pre>"},{"location":"examples/adapters/postgres/","title":"PostgreSQL Adapter","text":"<p>This example demonstrates how to use the PostgreSQL adapter for database operations.</p>"},{"location":"examples/adapters/postgres/#basic-usage","title":"Basic Usage","text":"<pre><code>from typing import Any\nfrom uuid import UUID\n\nfrom archipy.adapters.postgres.sqlalchemy.adapters import PostgresSQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n\n# Create adapter\nadapter = PostgresSQLAlchemyAdapter()\n\n# Create tables\nBaseEntity.metadata.create_all(adapter.session_manager.engine)\n\n# Basic operations\ntry:\n    # Get session\n    session = adapter.get_session()\n\n    # Create\n    user = User(username=\"john_doe\", email=\"john@example.com\")\n    session.add(user)\n    session.commit()\n\n    # Read\n    user = session.query(User).filter_by(username=\"john_doe\").first()\n    print(user.email)  # john@example.com\n\n    # Update\n    user.email = \"john.doe@example.com\"\n    session.commit()\n\n    # Delete\n    session.delete(user)\n    session.commit()\nexcept Exception as e:\n    # The adapter's SQLAlchemyExceptionHandlerMixin will handle\n    # and convert common exceptions to application-specific ones\n    # These will already preserve the original error context with `from e`\n    raise\n</code></pre>"},{"location":"examples/adapters/postgres/#using-transactions","title":"Using Transactions","text":"<pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseQueryError, AlreadyExistsError\n\n\n@postgres_sqlalchemy_atomic_decorator\ndef create_user_with_profile(username: str, email: str, profile_data: dict[str, Any]) -&gt; User:\n    \"\"\"Create a user and associated profile in a transaction.\n\n    If any part fails, the entire transaction is rolled back.\n\n    Args:\n        username: User's username\n        email: User's email\n        profile_data: Dictionary of profile data\n\n    Returns:\n        User: The created user object\n\n    Raises:\n        DatabaseQueryError: If a database error occurs\n        AlreadyExistsError: If the user or profile already exists\n    \"\"\"\n    try:\n        # Create user\n        user = User(username=username, email=email)\n        adapter.create(user)\n\n        # Create profile with user's UUID\n        profile = Profile(user_id=user.uuid, **profile_data)\n        adapter.create(profile)\n\n        return user\n    except Exception as e:\n        # The decorator will automatically handle the transaction,\n        # rolling back on error and converting exceptions\n        raise\n</code></pre>"},{"location":"examples/adapters/postgres/#async-operations","title":"Async Operations","text":"<pre><code>import asyncio\nfrom typing import Any\nfrom uuid import UUID\n\nfrom archipy.adapters.postgres.sqlalchemy.adapters import AsyncPostgresSQLAlchemyAdapter\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseConnectionError, DatabaseQueryError\n\n\nasync def main() -&gt; None:\n    adapter = AsyncPostgresSQLAlchemyAdapter()\n\n    @async_postgres_sqlalchemy_atomic_decorator\n    async def create_user_async(username: str, email: str) -&gt; User:\n        \"\"\"Create a user asynchronously within a transaction.\n\n        Args:\n            username: User's username\n            email: User's email\n\n        Returns:\n            User: The created user object\n\n        Raises:\n            DatabaseQueryError: If a database error occurs\n            DatabaseConnectionError: If a connection error occurs\n        \"\"\"\n        user = User(username=username, email=email)\n        return await adapter.create(user)\n\n    try:\n        user = await create_user_async(\"jane_doe\", \"jane@example.com\")\n        print(user.username)  # jane_doe\n    except (DatabaseConnectionError, DatabaseQueryError) as e:\n        print(f\"Database error: {e}\")\n</code></pre>"},{"location":"examples/adapters/postgres/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors import (\n    AlreadyExistsError,\n    NotFoundError,\n    DatabaseConnectionError,\n    DatabaseQueryError\n)\nfrom typing import Optional\nfrom uuid import UUID\n\n\ndef get_user_by_id(user_id: UUID) -&gt; Optional[User]:\n    \"\"\"Get a user by their UUID.\n\n    Args:\n        user_id: User UUID to look up\n\n    Returns:\n        User or None: The found user or None if not found\n\n    Raises:\n        NotFoundError: If user doesn't exist\n        DatabaseConnectionError: If database connection fails\n        DatabaseQueryError: For other database errors\n    \"\"\"\n    try:\n        user = adapter.get_by_uuid(User, user_id)\n        if not user:\n            raise NotFoundError(\n                resource_type=\"user\",\n                additional_data={\"user_id\": str(user_id)}\n            )\n        return user\n    except AlreadyExistsError as e:\n        # This would be unlikely for a get operation but included for example\n        print(f\"User already exists: {e}\")\n        raise\n    except (DatabaseConnectionError, DatabaseQueryError) as e:\n        # The adapter's exception handler will have already\n        # converted common exceptions with proper chaining\n        print(f\"Database error: {e}\")\n        raise\n</code></pre>"},{"location":"examples/adapters/redis/","title":"Redis Adapter Examples","text":"<p>This guide demonstrates how to use the ArchiPy Redis adapter for common caching and key-value storage patterns.</p>"},{"location":"examples/adapters/redis/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/redis/#installation","title":"Installation","text":"<p>First, ensure you have the Redis dependencies installed:</p> <pre><code>pip install \"archipy[redis]\"\n# or\npoetry add \"archipy[redis]\"\n</code></pre>"},{"location":"examples/adapters/redis/#synchronous-redis-adapter","title":"Synchronous Redis Adapter","text":"<pre><code>from archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError\n\ntry:\n    # Create a Redis adapter with connection details\n    redis = RedisAdapter(\n        host=\"localhost\",\n        port=6379,\n        db=0,\n        password=None  # Optional\n    )\n\n    # Set and get values\n    redis.set(\"user:123:name\", \"John Doe\")\n    name = redis.get(\"user:123:name\")\n    print(f\"User name: {name}\")  # Output: User name: John Doe\n\n    # Set with expiration (seconds)\n    redis.set(\"session:456\", \"active\", ex=3600)  # Expires in 1 hour\n\n    # Delete a key\n    redis.delete(\"user:123:name\")\n\n    # Check if key exists\n    if redis.exists(\"session:456\"):\n        print(\"Session exists\")\nexcept CacheError as e:\n    print(f\"Redis operation failed: {str(e)}\")\n</code></pre>"},{"location":"examples/adapters/redis/#asynchronous-redis-adapter","title":"Asynchronous Redis Adapter","text":"<pre><code>import asyncio\nfrom typing import Optional\n\nfrom archipy.adapters.redis.adapters import AsyncRedisAdapter\nfrom archipy.models.errors import CacheError\n\n\nasync def main() -&gt; None:\n    try:\n        # Create an async Redis adapter\n        redis = AsyncRedisAdapter(\n            host=\"localhost\",\n            port=6379,\n            db=0\n        )\n\n        # Async operations\n        await redis.set(\"counter\", \"1\")\n        await redis.incr(\"counter\")  # Increment\n        count = await redis.get(\"counter\")\n        print(f\"Counter: {count}\")  # Output: Counter: 2\n\n        # Cleanup\n        await redis.close()\n    except CacheError as e:\n        print(f\"Redis operation failed: {str(e)}\")\n\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/redis/#caching-patterns","title":"Caching Patterns","text":""},{"location":"examples/adapters/redis/#function-result-caching","title":"Function Result Caching","text":"<pre><code>import json\nimport time\nfrom functools import wraps\nfrom typing import Any, Callable, TypeVar, cast\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError, CacheMissError\n\n# Define a type variable for generic function types\nT = TypeVar('T', bound=Callable[..., Any])\n\n# Create a Redis adapter\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n\ndef cache_result(key_prefix: str, ttl: int = 300) -&gt; Callable[[T], T]:\n    \"\"\"Decorator to cache function results in Redis.\n\n    Args:\n        key_prefix: Prefix for the Redis cache key\n        ttl: Time-to-live in seconds (default: 5 minutes)\n\n    Returns:\n        Decorated function with Redis caching\n    \"\"\"\n\n    def decorator(func: T) -&gt; T:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            # Create a cache key with function name and arguments\n            cache_key = f\"{key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}\"\n\n            try:\n                # Try to get from cache\n                cached = redis.get(cache_key)\n                if cached:\n                    return json.loads(cached)\n\n                # Execute function and cache result\n                result = func(*args, **kwargs)\n                redis.set(cache_key, json.dumps(result), ex=ttl)\n                return result\n            except CacheMissError:\n                # Execute function if not in cache\n                result = func(*args, **kwargs)\n                try:\n                    redis.set(cache_key, json.dumps(result), ex=ttl)\n                except CacheError as e:\n                    # Log but don't fail if caching fails\n                    print(f\"Failed to cache result: {e}\")\n                return result\n            except CacheError as e:\n                # Execute function if Redis fails\n                print(f\"Redis error: {e}\")\n                return func(*args, **kwargs)\n\n        return cast(T, wrapper)\n\n    return decorator\n\n\n# Example usage\n@cache_result(\"api\", ttl=60)\ndef expensive_api_call(item_id: int) -&gt; dict[str, Any]:\n    \"\"\"Simulate an expensive API call.\n\n    Args:\n        item_id: ID of the item to fetch\n\n    Returns:\n        Item data dictionary\n    \"\"\"\n    print(\"Executing expensive operation...\")\n    time.sleep(1)  # Simulate expensive operation\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\", \"data\": \"Some data\"}\n\n\n# First call will execute the function\nresult1 = expensive_api_call(123)\nprint(\"First call:\", result1)\n\n# Second call will retrieve from cache\nresult2 = expensive_api_call(123)\nprint(\"Second call:\", result2)\n</code></pre>"},{"location":"examples/adapters/redis/#mock-redis-for-testing","title":"Mock Redis for Testing","text":"<p>ArchiPy provides a Redis mock for unit testing that doesn't require a real Redis server:</p> <pre><code>import unittest\nfrom typing import Optional\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.adapters.redis.mocks import RedisMock\nfrom archipy.models.errors import CacheError, CacheMissError\n\n\nclass UserService:\n    def __init__(self, redis_adapter: RedisAdapter) -&gt; None:\n        self.redis = redis_adapter\n\n    def get_user(self, user_id: int) -&gt; str:\n        \"\"\"Get user data, either from cache or backend.\n\n        Args:\n            user_id: User ID to look up\n\n        Returns:\n            User data as a string\n\n        Raises:\n            CacheError: If Redis operation fails\n        \"\"\"\n        try:\n            cache_key = f\"user:{user_id}\"\n            cached = self.redis.get(cache_key)\n            if cached:\n                return cached\n\n            # In real code, we'd fetch from database if not in cache\n            user_data = f\"User {user_id} data\"\n            self.redis.set(cache_key, user_data, ex=300)\n            return user_data\n        except CacheMissError:\n            # Handle cache miss\n            user_data = f\"User {user_id} data\"\n            try:\n                self.redis.set(f\"user:{user_id}\", user_data, ex=300)\n            except CacheError:\n                pass  # Ignore error setting cache\n            return user_data\n\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self) -&gt; None:\n        # Use the RedisMock instead of a real Redis connection\n        self.redis_mock = RedisMock()\n        self.user_service = UserService(self.redis_mock)\n\n    def test_get_user(self) -&gt; None:\n        # Test first fetch (not cached)\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"User 123 data\")\n\n        # Test that it was cached\n        self.assertEqual(self.redis_mock.get(\"user:123\"), \"User 123 data\")\n\n        # Change the cached value to test cache hit\n        self.redis_mock.set(\"user:123\", \"Modified data\")\n\n        # Test cached fetch\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"Modified data\")\n\n\n# Run the test\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre>"},{"location":"examples/adapters/redis/#advanced-redis-features","title":"Advanced Redis Features","text":""},{"location":"examples/adapters/redis/#publishsubscribe","title":"Publish/Subscribe","text":"<pre><code>import threading\nimport time\nfrom typing import Dict, Any\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError\n\n\n# Subscriber thread\ndef subscribe_thread() -&gt; None:\n    try:\n        subscriber = RedisAdapter(host=\"localhost\", port=6379, db=0)\n        pubsub = subscriber.pubsub()\n\n        def message_handler(message: Dict[str, Any]) -&gt; None:\n            if message[\"type\"] == \"message\":\n                print(f\"Received message: {message['data']}\")\n\n        pubsub.subscribe(**{\"channel:notifications\": message_handler})\n        pubsub.run_in_thread(sleep_time=0.5)\n\n        # Keep thread running for demo\n        time.sleep(10)\n        pubsub.close()\n    except CacheError as e:\n        print(f\"Redis subscription error: {e}\")\n\n\ntry:\n    # Start subscriber in background\n    thread = threading.Thread(target=subscribe_thread)\n    thread.start()\n\n    # Wait for subscriber to initialize\n    time.sleep(1)\n\n    # Create publisher\n    redis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n    # Publish messages\n    for i in range(5):\n        message = f\"Notification {i}\"\n        redis.publish(\"channel:notifications\", message)\n        time.sleep(1)\n\n    # Wait for thread to complete\n    thread.join()\nexcept CacheError as e:\n    print(f\"Redis publisher error: {e}\")\nexcept Exception as e:\n    print(f\"General error: {e}\")\n</code></pre>"},{"location":"examples/adapters/redis/#pipeline-for-multiple-operations","title":"Pipeline for Multiple Operations","text":"<pre><code>from typing import List\n\nfrom archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.models.errors import CacheError\n\ntry:\n    redis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n    # Create a pipeline for atomic operations\n    pipe = redis.pipeline()\n    pipe.set(\"stats:visits\", 0)\n    pipe.set(\"stats:unique_users\", 0)\n    pipe.set(\"stats:conversion_rate\", \"0.0\")\n    pipe.execute()  # Execute all commands at once\n\n    # Increment multiple counters atomically\n    pipe = redis.pipeline()\n    pipe.incr(\"stats:visits\")\n    pipe.incr(\"stats:unique_users\")\n    results: List[int] = pipe.execute()\n    print(f\"Visits: {results[0]}, Unique users: {results[1]}\")\nexcept CacheError as e:\n    print(f\"Redis pipeline error: {e}\")\n</code></pre>"},{"location":"examples/adapters/sqlite/","title":"SQLite Adapter","text":"<p>This example demonstrates how to use the SQLite adapter for database operations.</p>"},{"location":"examples/adapters/sqlite/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.sqlite.sqlalchemy.adapters import SQLiteSQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n# Create adapter\nadapter = SQLiteSQLAlchemyAdapter()\n\n# Create tables\nBaseEntity.metadata.create_all(adapter.session_manager.engine)\n\n# Basic operations\nwith adapter.session() as session:\n    # Create\n    user = User(username=\"john_doe\", email=\"john@example.com\")\n    session.add(user)\n    session.commit()\n\n    # Read\n    user = session.query(User).filter_by(username=\"john_doe\").first()\n    print(user.email)  # john@example.com\n\n    # Update\n    user.email = \"john.doe@example.com\"\n    session.commit()\n\n    # Delete\n    session.delete(user)\n    session.commit()\n</code></pre>"},{"location":"examples/adapters/sqlite/#using-transactions","title":"Using Transactions","text":"<pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import sqlite_sqlalchemy_atomic_decorator\n\n@sqlite_sqlalchemy_atomic_decorator\ndef create_user_with_profile(username, email, profile_data):\n    user = User(username=username, email=email)\n    adapter.create(user)\n\n    profile = Profile(user_id=user.test_uuid, **profile_data)\n    adapter.create(profile)\n\n    return user\n</code></pre>"},{"location":"examples/adapters/sqlite/#async-operations","title":"Async Operations","text":"<pre><code>from archipy.adapters.sqlite.sqlalchemy.adapters import AsyncSQLiteSQLAlchemyAdapter\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_sqlite_sqlalchemy_atomic_decorator\n\nasync def main():\n    adapter = AsyncSQLiteSQLAlchemyAdapter()\n\n    @async_sqlite_sqlalchemy_atomic_decorator\n    async def create_user_async(username, email):\n        user = User(username=username, email=email)\n        return await adapter.create(user)\n\n    user = await create_user_async(\"jane_doe\", \"jane@example.com\")\n    print(user.username)  # jane_doe\n</code></pre>"},{"location":"examples/adapters/sqlite/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors import (\n    AlreadyExistsError,\n    NotFoundError,\n    InternalError\n)\n\ntry:\n    user = adapter.get_by_id(User, user_id)\n    if not user:\n        raise NotFoundError(resource_type=\"user\")\nexcept AlreadyExistsError as e:\n    print(f\"User already exists: {e.message}\")\nexcept InternalError as e:\n    print(f\"Database error: {e.message}\")\n</code></pre>"},{"location":"examples/adapters/starrocks/","title":"StarRocks Adapter","text":"<p>This example demonstrates how to use the StarRocks adapter for database operations.</p>"},{"location":"examples/adapters/starrocks/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.starrocks.sqlalchemy.adapters import StarrocksSQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String, Integer, DateTime\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n    age = Column(Integer)\n    created_at = Column(DateTime)\n\n# Create adapter\nadapter = StarrocksSQLAlchemyAdapter()\n\n# Create tables\nBaseEntity.metadata.create_all(adapter.session_manager.engine)\n\n# Basic operations\nwith adapter.session() as session:\n    # Create\n    user = User(\n        username=\"john_doe\",\n        email=\"john@example.com\",\n        age=30,\n        created_at=datetime.now()\n    )\n    session.add(user)\n    session.commit()\n\n    # Read\n    user = session.query(User).filter_by(username=\"john_doe\").first()\n    print(user.email)  # john@example.com\n\n    # Update\n    user.age = 31\n    session.commit()\n\n    # Delete\n    session.delete(user)\n    session.commit()\n</code></pre>"},{"location":"examples/adapters/starrocks/#using-transactions","title":"Using Transactions","text":"<pre><code>from archipy.helpers.decorators.sqlalchemy_atomic import starrocks_sqlalchemy_atomic_decorator\n\n@starrocks_sqlalchemy_atomic_decorator\ndef create_user_with_profile(username, email, age, profile_data):\n    user = User(username=username, email=email, age=age)\n    adapter.create(user)\n\n    profile = Profile(user_id=user.test_uuid, **profile_data)\n    adapter.create(profile)\n\n    return user\n</code></pre>"},{"location":"examples/adapters/starrocks/#async-operations","title":"Async Operations","text":"<pre><code>from archipy.adapters.starrocks.sqlalchemy.adapters import AsyncStarrocksSQLAlchemyAdapter\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_starrocks_sqlalchemy_atomic_decorator\n\nasync def main():\n    adapter = AsyncStarrocksSQLAlchemyAdapter()\n\n    @async_starrocks_sqlalchemy_atomic_decorator\n    async def create_user_async(username, email, age):\n        user = User(username=username, email=email, age=age)\n        return await adapter.create(user)\n\n    user = await create_user_async(\"jane_doe\", \"jane@example.com\", 28)\n    print(user.username)  # jane_doe\n</code></pre>"},{"location":"examples/adapters/starrocks/#error-handling","title":"Error Handling","text":"<pre><code>from archipy.models.errors import (\n    AlreadyExistsError,\n    NotFoundError,\n    InternalError\n)\n\ntry:\n    user = adapter.get_by_id(User, user_id)\n    if not user:\n        raise NotFoundError(resource_type=\"user\")\nexcept AlreadyExistsError as e:\n    print(f\"User already exists: {e.message}\")\nexcept InternalError as e:\n    print(f\"Database error: {e.message}\")\n</code></pre>"},{"location":"examples/adapters/starrocks/#advanced-queries","title":"Advanced Queries","text":"<pre><code># Complex filtering\nusers = adapter.query(User).filter(\n    User.age &gt; 25,\n    User.created_at &gt;= datetime.now() - timedelta(days=30)\n).all()\n\n# Aggregation\nfrom sqlalchemy import func\nage_stats = adapter.query(\n    func.avg(User.age).label('avg_age'),\n    func.max(User.age).label('max_age'),\n    func.min(User.age).label('min_age')\n).first()\n\n# Joins\nfrom sqlalchemy import join\nuser_profiles = adapter.query(User).join(\n    Profile,\n    User.test_uuid == Profile.user_id\n).all()\n</code></pre>"},{"location":"examples/adapters/starrocks/#batch-operations","title":"Batch Operations","text":"<pre><code># Batch insert\nusers = [\n    User(username=f\"user{i}\", email=f\"user{i}@example.com\", age=20+i)\n    for i in range(100)\n]\nadapter.bulk_create(users)\n\n# Batch update\nadapter.query(User).filter(User.age &lt; 30).update(\n    {\"age\": User.age + 1},\n    synchronize_session=False\n)\n</code></pre>"},{"location":"examples/adapters/starrocks/#configuration","title":"Configuration","text":"<pre><code>from archipy.configs.config_template import StarrocksConfig\n\n# Configure StarRocks connection\nconfig = StarrocksConfig(\n    HOST=\"localhost\",\n    PORT=9030,\n    USER=\"root\",\n    PASSWORD=\"password\",\n    DATABASE=\"test_db\"\n)\n\n# Create adapter with custom config\nadapter = StarrocksSQLAlchemyAdapter(config=config)\n</code></pre>"},{"location":"examples/helpers/","title":"Helper Examples","text":"<p>ArchiPy provides a variety of helper utilities to simplify common development tasks.</p>"},{"location":"examples/helpers/#available-helpers","title":"Available Helpers","text":"Helper Type Purpose Example Decorators Function and method enhancements Timing, retry, deprecation Interceptors Communication layer handlers gRPC tracing, rate limiting Metaclasses Custom class behavior Singletons, registries Utils General-purpose utilities Date/time, file, string handlers <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/decorators/","title":"Decorator Examples","text":"<p>This page demonstrates how to use ArchiPy's decorators for common cross-cutting concerns.</p>"},{"location":"examples/helpers/decorators/#retry-decorator","title":"Retry Decorator","text":"<p>The retry decorator automatically retries a function when it encounters specific exceptions.</p> <pre><code>from typing import Any\nimport random\nfrom archipy.helpers.decorators.retry import retry_decorator\nfrom archipy.models.errors import ResourceExhaustedError\nfrom archipy.models.types.language_type import LanguageType\n\n\n# Retry a function that might fail temporarily\n@retry_decorator(\n    max_retries=3,\n    delay=1,\n    retry_on=(ConnectionError, TimeoutError),\n    ignore=(ValueError,),\n    resource_type=\"API\",\n    lang=LanguageType.EN\n)\ndef unreliable_api_call(item_id: int) -&gt; dict[str, Any]:\n    \"\"\"Make an API call that might fail temporarily.\n\n    Args:\n        item_id: The ID of the item to fetch\n\n    Returns:\n        API response data\n\n    Raises:\n        ResourceExhaustedError: If retries are exhausted\n        ValueError: If input validation fails (not retried)\n    \"\"\"\n    if item_id &lt; 0:\n        # This error won't be retried because it's in the ignored list\n        raise ValueError(\"Item ID must be positive\")\n\n    # Simulate random failures\n    if random.random() &lt; 0.7:\n        # This will be retried because ConnectionError is in retry_on\n        raise ConnectionError(\"Temporary network issue\")\n\n    # Success case\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\"}\n\n\ntry:\n    # This call might succeed after retries\n    result = unreliable_api_call(42)\n    print(f\"Request succeeded: {result}\")\nexcept ResourceExhaustedError as e:\n    # This happens when all retries fail\n    print(f\"All retry attempts failed: {e}\")\nexcept ValueError as e:\n    # This happens for input validation failures (not retried)\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"examples/helpers/decorators/#timeout-decorator","title":"Timeout Decorator","text":"<p>The timeout decorator ensures a function doesn't run longer than a specified duration.</p> <pre><code>import time\nfrom typing import Any\nfrom archipy.helpers.decorators.timeout import timeout_decorator\nfrom archipy.models.errors import DeadlineExceededError\n\n\n# Set a timeout for a potentially long-running function\n@timeout_decorator(3)  # 3 seconds timeout\ndef slow_operation(duration: float) -&gt; str:\n    \"\"\"A function that might take too long.\n\n    Args:\n        duration: How long to run in seconds\n\n    Returns:\n        Completion message\n\n    Raises:\n        DeadlineExceededError: If function takes longer than the timeout\n    \"\"\"\n    time.sleep(duration)  # Simulate work\n    return \"Operation completed\"\n\n\ntry:\n    # This will succeed because it completes within the timeout\n    result = slow_operation(2)\n    print(result)  # \"Operation completed\"\n\n    # This will raise a DeadlineExceededError because it exceeds the timeout\n    result = slow_operation(5)\n    print(\"This won't be reached\")\nexcept DeadlineExceededError as e:\n    print(f\"Operation timed out: {e}\")\n</code></pre>"},{"location":"examples/helpers/decorators/#timing-decorator","title":"Timing Decorator","text":"<p>The timing decorator measures and logs the execution time of functions.</p> <pre><code>import time\nfrom typing import List\nfrom archipy.helpers.decorators.timing import timing_decorator\n\n\n# Measure and log how long a function takes to execute\n@timing_decorator\ndef process_data(items: List[int]) -&gt; int:\n    \"\"\"Process a list of items with time measurement.\n\n    Args:\n        items: List of items to process\n\n    Returns:\n        Sum of processed items\n    \"\"\"\n    time.sleep(0.1)  # Simulate processing time\n    return sum(items)\n\n\n# This will log the execution time before returning\nresult = process_data(list(range(100)))\nprint(f\"Result: {result}\")  # Output: Result: 4950\n# The decorator will log something like:\n# INFO - Function 'process_data' executed in 0.103 seconds\n</code></pre>"},{"location":"examples/helpers/decorators/#cache-decorator","title":"Cache Decorator","text":"<p>The TTL cache decorator caches function results with automatic expiration.</p> <pre><code>import time\nfrom typing import Any, Dict\nfrom archipy.helpers.decorators.cache import ttl_cache_decorator\n\n\n# Cache the results of an expensive function\n@ttl_cache_decorator(ttl_seconds=60, maxsize=100)\ndef fetch_user_data(user_id: int) -&gt; Dict[str, Any]:\n    \"\"\"Fetch user data from a slow source with caching.\n\n    Args:\n        user_id: User ID to fetch\n\n    Returns:\n        User data dictionary\n    \"\"\"\n    print(f\"Fetching data for user {user_id}...\")\n    time.sleep(1)  # Simulate slow API call\n    return {\n        \"id\": user_id,\n        \"name\": f\"User {user_id}\",\n        \"email\": f\"user{user_id}@example.com\"\n    }\n\n\n# First call - will execute the function and cache the result\nstart = time.time()\ndata1 = fetch_user_data(123)\nprint(f\"First call took {time.time() - start:.3f} seconds\")\n\n# Second call with same arguments - will use the cached result\nstart = time.time()\ndata2 = fetch_user_data(123)\nprint(f\"Second call took {time.time() - start:.3f} seconds\")\n\n# Different arguments - will execute the function\nstart = time.time()\ndata3 = fetch_user_data(456)\nprint(f\"Different user call took {time.time() - start:.3f} seconds\")\n\n# Clear the cache if needed\nfetch_user_data.clear_cache()\n</code></pre>"},{"location":"examples/helpers/decorators/#sqlalchemy-transaction-decorators","title":"SQLAlchemy Transaction Decorators","text":"<p>These decorators automatically manage database transactions.</p> <pre><code>from typing import Optional\nfrom uuid import UUID\nfrom archipy.helpers.decorators.sqlalchemy_atomic import postgres_sqlalchemy_atomic_decorator\nfrom archipy.models.errors import DatabaseQueryError, DatabaseConnectionError\n\n\n@postgres_sqlalchemy_atomic_decorator\ndef create_user(username: str, email: str) -&gt; User:\n    \"\"\"Create a user in a database transaction.\n\n    All database operations are wrapped in a transaction that\n    will be automatically committed on success or rolled back on error.\n\n    Args:\n        username: User's username\n        email: User's email address\n\n    Returns:\n        The created user object\n\n    Raises:\n        DatabaseQueryError: If the database operation fails\n        DatabaseConnectionError: If the database connection fails\n    \"\"\"\n    try:\n        user = User(username=username, email=email)\n        # Get session from the adapter injected by the decorator\n        session = adapter.get_session()\n        session.add(user)\n        return user\n    except Exception as e:\n        # The decorator handles rolling back the transaction\n        # and converting exceptions to appropriate types\n        raise\n\n\n# For async operations\nfrom archipy.helpers.decorators.sqlalchemy_atomic import async_postgres_sqlalchemy_atomic_decorator\n\n\n@async_postgres_sqlalchemy_atomic_decorator\nasync def update_user_email(user_id: UUID, new_email: str) -&gt; Optional[User]:\n    \"\"\"Update a user's email in an async transaction.\n\n    Args:\n        user_id: UUID of the user\n        new_email: New email address\n\n    Returns:\n        Updated user or None if not found\n\n    Raises:\n        DatabaseQueryError: If the database operation fails\n    \"\"\"\n    try:\n        # Get async session from the adapter injected by the decorator\n        session = adapter.get_session()\n        user = await session.get(User, user_id)\n        if not user:\n            return None\n\n        user.email = new_email\n        return user\n    except Exception as e:\n        # The decorator handles the error conversion and rollback\n        raise\n</code></pre>"},{"location":"examples/helpers/interceptors/","title":"Interceptor Examples","text":"<p>This page demonstrates how to use ArchiPy's interceptors for cross-cutting concerns like logging, tracing, and error handling.</p>"},{"location":"examples/helpers/interceptors/#grpc-interceptors","title":"gRPC Interceptors","text":""},{"location":"examples/helpers/interceptors/#tracing-interceptor","title":"Tracing Interceptor","text":"<p>The tracing interceptor adds request/response tracking to gRPC services:</p> <pre><code>import grpc\nfrom concurrent import futures\nfrom typing import Any, Callable\n\nfrom archipy.helpers.interceptors.grpc.trace import GrpcServerTraceInterceptor\nfrom archipy.models.errors import InternalError\n\n\n# Create a gRPC server with tracing\ndef create_grpc_server(max_workers: int = 10) -&gt; grpc.Server:\n    \"\"\"Create a gRPC server with tracing interceptor.\n\n    Args:\n        max_workers: Maximum worker threads for the server\n\n    Returns:\n        Configured gRPC server instance\n    \"\"\"\n    try:\n        # Initialize the tracing interceptor\n        trace_interceptor = GrpcServerTraceInterceptor()\n\n        # Create the server with the interceptor\n        server = grpc.server(\n            futures.ThreadPoolExecutor(max_workers=max_workers),\n            interceptors=[trace_interceptor]\n        )\n        return server\n    except Exception as e:\n        raise InternalError(error_details=\"Failed to create gRPC server\") from e\n\n\n# Usage\nserver = create_grpc_server()\n# Add your services to the server\n# my_service.add_to_server(server)\n# server.add_insecure_port('[::]:50051')\n# server.start()\n</code></pre>"},{"location":"examples/helpers/interceptors/#fastapi-interceptors","title":"FastAPI Interceptors","text":""},{"location":"examples/helpers/interceptors/#request-logging","title":"Request Logging","text":"<p>Log all incoming requests and responses:</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom typing import Awaitable, Callable\n\nfrom archipy.helpers.interceptors.fastapi.logging import RequestLoggingMiddleware\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with request logging\napp = AppUtils.create_fastapi_app()\n\n# Add the logging middleware\napp.add_middleware(RequestLoggingMiddleware)\n\n\n# Example endpoint\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n</code></pre>"},{"location":"examples/helpers/interceptors/#performance-monitoring","title":"Performance Monitoring","text":"<p>Monitor endpoint performance:</p> <pre><code>from fastapi import FastAPI\nfrom typing import Awaitable, Callable, Dict, Any\n\nfrom archipy.helpers.interceptors.fastapi.performance import PerformanceMonitoringMiddleware\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app\napp = AppUtils.create_fastapi_app()\n\n# Add the performance monitoring middleware\napp.add_middleware(PerformanceMonitoringMiddleware)\n\n\n# Example endpoint\n@app.get(\"/process\")\nasync def process_data(query: str) -&gt; Dict[str, Any]:\n    # Some processing here\n    return {\"query\": query, \"result\": \"processed\"}\n\n# The middleware will log performance metrics for each request\n# Example log: \"Endpoint GET /process completed in 123.45ms\"\n</code></pre>"},{"location":"examples/helpers/interceptors/#using-multiple-interceptors","title":"Using Multiple Interceptors","text":"<p>Combining multiple interceptors together:</p> <pre><code>import grpc\nfrom concurrent import futures\nfrom fastapi import FastAPI\n\nfrom archipy.helpers.interceptors.grpc.trace import GrpcServerTraceInterceptor\nfrom archipy.helpers.interceptors.fastapi.logging import RequestLoggingMiddleware\nfrom archipy.helpers.interceptors.fastapi.performance import PerformanceMonitoringMiddleware\nfrom archipy.helpers.utils.app_utils import AppUtils\n\n\n# Create a FastAPI app with multiple interceptors\ndef create_fastapi_app() -&gt; FastAPI:\n    app = AppUtils.create_fastapi_app()\n\n    # Add middlewares in order (last added = first executed)\n    app.add_middleware(PerformanceMonitoringMiddleware)\n    app.add_middleware(RequestLoggingMiddleware)\n\n    return app\n\n\n# Create a gRPC server with the tracing interceptor\ndef create_grpc_server() -&gt; grpc.Server:\n    server = grpc.server(\n        futures.ThreadPoolExecutor(max_workers=10),\n        interceptors=[GrpcServerTraceInterceptor()]\n    )\n\n    return server\n</code></pre>"},{"location":"examples/helpers/metaclasses/","title":"Metaclass Examples","text":"<p>This page demonstrates how to use ArchiPy's metaclasses.</p>"},{"location":"examples/helpers/metaclasses/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.metaclasses.singleton import Singleton\n\n# Create a singleton class\nclass Database(metaclass=Singleton):\n    def __init__(self, connection_string=None):\n        self.connection_string = connection_string\n        # Initialize connection\n\n    def query(self, sql):\n        # Execute query\n        pass\n\n# Usage\ndb1 = Database(\"postgresql://localhost:5432/mydb\")\ndb2 = Database()  # No new instance created\n\nprint(db1 is db2)  # True - same instance\nprint(db2.connection_string)  # \"postgresql://localhost:5432/mydb\"\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/utils/","title":"Utilities","text":"<p>Examples of ArchiPy's utility functions:</p>"},{"location":"examples/helpers/utils/#datetime_utils","title":"datetime_utils","text":"<p>Work with dates and times consistently:</p> <pre><code>from archipy.helpers.utils.datetime_utils import DatetimeUtils\n\n# Get current UTC time\nnow = DatetimeUtils.get_datetime_utc_now()\n\n# Format for storage/transmission\ndate_str = DatetimeUtils.get_string_datetime_from_datetime(now)\n\n# Parse date string\nparsed = DatetimeUtils.get_datetime_from_string_datetime(date_str)\n\n# Convert to Jalali (Persian) calendar\njalali_date = DatetimeUtils.convert_to_jalali(now)\n\n# Check if date is a holiday in Iran\nis_holiday = DatetimeUtils.is_holiday_in_iran(now)\n</code></pre>"},{"location":"examples/helpers/utils/#jwt_utils","title":"jwt_utils","text":"<p>Generate and verify JWT tokens:</p> <pre><code>import logging\nfrom archipy.helpers.utils.jwt_utils import JWTUtils\nfrom uuid import uuid4\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Generate a user access token\nuser_id = uuid4()\naccess_token = JWTUtils.create_access_token(user_id)\n\n# Generate a refresh token with additional claims\nadditional_claims = {\"user_role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\nrefresh_token = JWTUtils.create_refresh_token(user_id, additional_claims=additional_claims)\n\n# Verify a token\ntry:\n    payload = JWTUtils.verify_access_token(access_token)\n    logger.info(f\"Token valid for user: {payload['sub']}\")\nexcept (InvalidTokenError, TokenExpiredError) as e:\n    logger.exception(f\"Invalid token: {e}\")\n\n# Get token expiration time\nexpiry = JWTUtils.get_token_expiry(access_token)\nlogger.debug(f\"Token expires at: {expiry}\")\n\n# Extract user UUID from token payload\nuser_uuid = JWTUtils.extract_user_uuid(payload)\n</code></pre>"},{"location":"examples/helpers/utils/#password_utils","title":"password_utils","text":"<p>Secure password handling:</p> <pre><code>import logging\nfrom archipy.helpers.utils.password_utils import PasswordUtils\nfrom archipy.models.types.language_type import LanguageType\nfrom archipy.models.errors import InvalidPasswordError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Hash a password\npassword = \"SecureP@ssword123\"\nhashed = PasswordUtils.hash_password(password)\n\n# Verify password\nis_valid = PasswordUtils.verify_password(password, hashed)\nlogger.info(f\"Password valid: {is_valid}\")\n\n# Generate a secure password that meets policy requirements\nsecure_password = PasswordUtils.generate_password()\nlogger.info(f\"Generated password: {secure_password}\")\n\n# Validate a password against policy\ntry:\n    PasswordUtils.validate_password(password, lang=LanguageType.EN)\n    logger.info(\"Password meets policy requirements\")\nexcept InvalidPasswordError as e:\n    logger.warning(f\"Invalid password: {e.requirements}\")\n\n# Check password against history\npassword_history = [hashed]  # Previous password hashes\ntry:\n    PasswordUtils.validate_password_history(\"NewSecureP@ssword123\", password_history)\n    logger.info(\"Password not previously used\")\nexcept InvalidPasswordError as e:\n    logger.warning(\"Password has been used recently\")\n</code></pre>"},{"location":"examples/helpers/utils/#file_utils","title":"file_utils","text":"<p>Handle files securely:</p> <pre><code>import logging\nfrom archipy.helpers.utils.file_utils import FileUtils\nfrom archipy.models.errors import InvalidArgumentError, OutOfRangeError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create a secure link to a file with expiration\ntry:\n    link = FileUtils.create_secure_link(\"/path/to/document.pdf\", minutes=60)\n    logger.info(f\"Secure link: {link}\")\nexcept (InvalidArgumentError, OutOfRangeError) as e:\n    logger.exception(f\"Error creating link: {e}\")\n\n# Validate file name against allowed extensions\ntry:\n    is_valid = FileUtils.validate_file_name(\"document.pdf\")\n    logger.info(f\"File is valid: {is_valid}\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Error validating file: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#base_utils","title":"base_utils","text":"<p>Validate and sanitize data:</p> <pre><code>import logging\nfrom archipy.helpers.utils.base_utils import BaseUtils\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Sanitize phone number\nphone = BaseUtils.sanitize_iranian_landline_or_phone_number(\"+989123456789\")\nlogger.info(f\"Sanitized phone: {phone}\")  # 09123456789\n\n# Validate Iranian national code\ntry:\n    BaseUtils.validate_iranian_national_code_pattern(\"1234567891\")\n    logger.info(\"National code is valid\")\nexcept Exception as e:\n    logger.exception(f\"Invalid national code: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#error_utils","title":"error_utils","text":"<p>Standardized exception handling:</p>"},{"location":"examples/helpers/utils/#app_utils","title":"app_utils","text":"<p>FastAPI application utilities:</p> <pre><code>from archipy.helpers.utils.app_utils import AppUtils, FastAPIUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with standard config\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Add custom exception handlers\nFastAPIUtils.setup_exception_handlers(app)\n\n\n# Set up CORS\nFastAPIUtils.setup_cors(\n    app,\n    allowed_origins=[\"https://example.com\"]\n)\n</code></pre>"},{"location":"examples/helpers/utils/#string_utils","title":"string_utils","text":"<p>String manipulation utilities:</p>"},{"location":"examples/helpers/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Authentication and authorization utilities with Keycloak integration:</p> <pre><code>if __name__ == '__main__':\n    import uvicorn\n    from uuid import UUID\n    from archipy.configs.base_config import BaseConfig\n    from archipy.helpers.utils.app_utils import AppUtils\n    from archipy.helpers.utils.keycloak_utils import KeycloakUtils\n    from archipy.models.types.language_type import LanguageType\n    from fastapi import Depends\n\n    # Initialize your app configuration\n    config = BaseConfig()\n    BaseConfig.set_global(config)\n    app = AppUtils.create_fastapi_app()\n\n    # Resource-based authorization for users with role and admin access\n    @app.get(\"/users/{user_uuid}/info\")\n    def get_user_info(user_uuid: UUID, user: dict = Depends(KeycloakUtils.fastapi_auth(\n        resource_type_param=\"user_uuid\",\n        resource_type=\"users\",\n        required_roles={\"user\"},\n        admin_roles={\"superusers\", \"administrators\"},\n        lang=LanguageType.EN,\n    ))):\n        return {\n            \"message\": f\"User info for {user_uuid}\",\n            \"username\": user.get(\"preferred_username\")\n        }\n\n    # Async version for employees with multiple acceptable roles\n    @app.get(\"/employees/{employee_uuid}/info\")\n    async def get_employee_info(employee_uuid: UUID, employee: dict = Depends(KeycloakUtils.async_fastapi_auth(\n        resource_type_param=\"employee_uuid\",\n        resource_type=\"employees\",\n        required_roles={\"employee\", \"manager\", \"user\"},\n        all_roles_required=False,  # User can have any of these roles\n        admin_roles={\"hr_admins\", \"system_admins\"},\n        lang=LanguageType.FA,\n    ))):\n        return {\n            \"message\": f\"Employee info for {employee_uuid}\",\n            \"username\": employee.get(\"preferred_username\")\n        }\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"examples/helpers/utils/#additional-resources","title":"Additional Resources","text":"<p>For more examples and detailed documentation:</p> <ul> <li>Helpers Overview</li> <li>Utils API Reference</li> <li>Configuration Examples</li> <li>Keycloak Adapter</li> </ul> <p>Note: This page contains examples of using ArchiPy's utility functions. For API details, see the Utils API Reference.</p>"}]}