{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ArchiPy","text":"<p>Architecture + Python \u2013 Structured Development Simplified</p> <p>ArchiPy provides a clean architecture framework for Python applications that:</p> <ul> <li>Standardizes configuration management</li> <li>Offers pluggable adapters with testing mocks</li> <li>Enforces consistent data models</li> <li>Promotes maintainable code organization</li> <li>Simplifies testing with BDD support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install using pip\npip install archipy\n\n# Or with poetry\npoetry add archipy\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<p>ArchiPy is a comprehensive framework designed to streamline Python application development through clean architecture principles:</p> <ul> <li>Modular Adapters: Plug-and-play implementations with ready-to-use mocks for databases, Redis, email, and more</li> <li>Robust Configuration: Type-safe configuration management with environment variable support</li> <li>Standardized Models: Consistent data modeling with DTOs, entities, and well-defined types</li> <li>Development Helpers: Decorators, metaclasses, and utilities to accelerate development</li> <li>BDD Testing: Integrated Behave support for behavior-driven development</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>archipy/\n\u2502\n\u251c\u2500\u2500 adapters/          # Interfaces to external systems\n\u251c\u2500\u2500 configs/           # Configuration management\n\u251c\u2500\u2500 helpers/           # Development utilities\n\u2502   \u251c\u2500\u2500 decorators/    # Function/method decorators\n\u2502   \u251c\u2500\u2500 interceptors/  # Communication interceptors\n\u2502   \u251c\u2500\u2500 metaclasses/   # Class creators and modifiers\n\u2502   \u2514\u2500\u2500 utils/         # General-purpose utilities\n\u2514\u2500\u2500 models/            # Domain objects\n    \u251c\u2500\u2500 dtos/          # Data Transfer Objects\n    \u251c\u2500\u2500 entities/      # Business entities\n    \u251c\u2500\u2500 errors/        # Error definitions\n    \u2514\u2500\u2500 types/         # Type definitions\n</code></pre>"},{"location":"architecture/","title":"ArchiPy Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>ArchiPy is organized into four main modules, each serving a specific purpose in creating structured, maintainable Python applications:</p> <ol> <li>Adapters: External service integrations</li> <li>Configs: Configuration management</li> <li>Helpers: Utility functions and support classes</li> <li>Models: Core data structures</li> </ol> <p>This architecture follows clean architecture principles, separating concerns and ensuring that dependencies point inward toward the domain core.</p>"},{"location":"architecture/#modules","title":"Modules","text":""},{"location":"architecture/#adapters","title":"Adapters","text":"<p>The <code>adapters</code> module provides implementations for external service integrations, following the Ports and Adapters pattern (Hexagonal Architecture). This module includes:</p> <ul> <li>Database adapters (SQLAlchemy, Redis)</li> <li>Email service adapters</li> <li>External API clients</li> <li>File storage adapters</li> </ul> <p>Each adapter includes both concrete implementations and corresponding mocks for testing.</p>"},{"location":"architecture/#configs","title":"Configs","text":"<p>The <code>configs</code> module manages configuration loading, validation, and injection. It provides:</p> <ul> <li>Environment-based configuration</li> <li>Type-safe configuration through Pydantic models</li> <li>Centralized access to configuration values</li> <li>Support for various configuration sources (environment variables, files, etc.)</li> </ul>"},{"location":"architecture/#helpers","title":"Helpers","text":"<p>The <code>helpers</code> module contains utility functions and classes to simplify common development tasks. It includes several subgroups:</p> <ul> <li>Utils: General utility functions for dates, strings, errors, files, etc.</li> <li>Decorators: Function and class decorators for aspects like logging, timing, and deprecation</li> <li>Interceptors: Classes for cross-cutting concerns like logging, tracing, and validation</li> <li>Validators: Data validation utilities</li> </ul>"},{"location":"architecture/#models","title":"Models","text":"<p>The <code>models</code> module defines the core data structures used throughout the application:</p> <ul> <li>Entities: Domain model objects</li> <li>DTOs: Data Transfer Objects for API input/output</li> <li>Errors: Custom exception classes</li> <li>Types: Type definitions and enumerations</li> </ul>"},{"location":"architecture/#architectural-flow","title":"Architectural Flow","text":"<p>ArchiPy applications follow a clean architecture approach where:</p> <ol> <li>The Models module forms the core domain layer</li> <li>The Helpers module provides supporting functionality</li> <li>The Configs module manages application configuration</li> <li>The Adapters module interfaces with external systems</li> </ol> <p>This modular organization promotes separation of concerns, making ArchiPy applications easier to test, maintain, and extend over time.</p>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":"<p>ArchiPy is designed to standardize and simplify Python application development by providing a flexible set of building blocks that work across different architectural approaches. Rather than enforcing a single architectural pattern, ArchiPy offers components that can be applied to:</p> <ul> <li>Layered Architecture</li> <li>Hexagonal Architecture (Ports &amp; Adapters)</li> <li>Clean Architecture</li> <li>Domain-Driven Design</li> <li>Service-Oriented Architecture</li> <li>And more...</li> </ul> <p>These building blocks help maintain consistency, testability, and maintainability regardless of the specific architectural style chosen for your project.</p>"},{"location":"architecture/#core-building-blocks","title":"Core Building Blocks","text":""},{"location":"architecture/#configuration-management","title":"Configuration Management","text":"<p>ArchiPy provides a standardized way to manage configuration across your application:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    DATABASE = {\n        \"HOST\": \"localhost\",\n        \"PORT\": 5432,\n        \"USERNAME\": \"user\",\n        \"PASSWORD\": \"password\"\n    }\n\n    DEBUG = True\n\n# Set global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"architecture/#adapters-ports","title":"Adapters &amp; Ports","text":"<p>ArchiPy implements the ports and adapters pattern to isolate the application core from external dependencies:</p> <pre><code># Port: defines an interface (contract)\nfrom typing import Protocol\n\nclass UserRepositoryPort(Protocol):\n    def get_by_id(self, user_id: str) -&gt; User: ...\n    def create(self, user: User) -&gt; User: ...\n\n# Adapter: implements the interface for a specific technology\nclass SqlAlchemyUserRepository:\n    def __init__(self, db_adapter: SqlAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n# Application core uses the port, not the adapter\nclass UserService:\n    def __init__(self, repository: UserRepositoryPort):\n        self.repository = repository\n\n    def get_user(self, user_id: str) -&gt; User:\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"architecture/#entity-models","title":"Entity Models","text":"<p>Standardized entity models provide a consistent approach to domain modeling:</p> <pre><code>from sqlalchemy import Column, String\nfrom archipy.models.entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    name = Column(String(100))\n    email = Column(String(255), unique=True)\n</code></pre>"},{"location":"architecture/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>Define consistent data structures for transferring data between layers:</p> <pre><code>from pydantic import BaseModel, EmailStr\nfrom archipy.models.dtos import BaseDTO\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: EmailStr\n\nclass UserResponseDTO(BaseDTO):\n    id: str\n    name: str\n    email: EmailStr\n    created_at: datetime\n</code></pre>"},{"location":"architecture/#example-architectures","title":"Example Architectures","text":""},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":"<p>ArchiPy can be used with a traditional layered architecture approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Presentation      \u2502  API, UI, CLI\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     Application       \u2502  Services, Workflows\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Domain          \u2502  Business Logic, Entities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Infrastructure     \u2502  Adapters, Repositories, External Services\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#clean-architecture","title":"Clean Architecture","text":"<p>ArchiPy supports Clean Architecture principles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Entities                    \u2502\n\u2502     Domain models, business rules            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                  Use Cases                   \u2502\n\u2502     Application services, business workflows \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 Interfaces                   \u2502\n\u2502     Controllers, presenters, gateways        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                Frameworks                    \u2502\n\u2502     External libraries, UI, DB, devices      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#hexagonal-architecture","title":"Hexagonal Architecture","text":"<p>For projects using a Hexagonal (Ports &amp; Adapters) approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                   \u2502\n\u2502                 Application Core                  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2502           Domain Logic / Models             \u2502  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502  Input      \u2502         \u2502  Output Ports       \u2502  \u2502\n\u2502  \u2502  Ports      \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25b2                           \u25b2\n        \u2502                           \u2502\n        \u2502                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  \u2502      \u2502                     \u2502\n\u2502  Input Adapters  \u2502      \u2502  Output Adapters    \u2502\n\u2502  (Controllers)   \u2502      \u2502  (Repositories,     \u2502\n\u2502                  \u2502      \u2502   Clients, etc.)    \u2502\n\u2502                  \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#practical-implementation","title":"Practical Implementation","text":"<p>Let's see how a complete application might be structured using ArchiPy:</p> <pre><code>my_app/\n\u251c\u2500\u2500 configs/\n\u2502   \u2514\u2500\u2500 app_config.py          # Application configuration\n\u251c\u2500\u2500 adapters/\n\u2502   \u251c\u2500\u2500 db/                    # Database adapters\n\u2502   \u2514\u2500\u2500 api/                   # API adapters\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 models/                # Domain models\n\u2502   \u251c\u2500\u2500 ports/                 # Interface definitions\n\u2502   \u2514\u2500\u2500 services/              # Business logic\n\u251c\u2500\u2500 repositories/              # Data access\n\u251c\u2500\u2500 api/                       # API routes\n\u2514\u2500\u2500 main.py                    # Application entry point\n</code></pre>"},{"location":"architecture/#code-example","title":"Code Example","text":"<p>Here's how you might structure a FastAPI application using ArchiPy:</p> <pre><code># adapters/db/user_repository.py\nfrom archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyAdapter\nfrom core.models.user import User\n\n\nclass UserRepository:\n    def __init__(self, db_adapter: SqlAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_user_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create_user(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n\n# core/services/user_service.py\nfrom core.models.user import User\nfrom adapters.db.user_repository import UserRepository\n\n\nclass UserService:\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n\n    def register_user(self, name: str, email: str) -&gt; User:\n        # Business logic and validation here\n        user = User(name=name, email=email)\n        return self.user_repository.create_user(user)\n\n\n# api/users.py\nfrom fastapi import APIRouter, Depends\nfrom core.services.user_service import UserService\nfrom archipy.models.dtos import BaseDTO\n\nrouter = APIRouter()\n\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: str\n\n\n@router.post(\"/users/\")\ndef create_user(\n        data: UserCreateDTO,\n        user_service: UserService = Depends(get_user_service)\n):\n    user = user_service.register_user(data.name, data.email)\n    return {\"id\": str(user.test_uuid), \"name\": user.name, \"email\": user.email}\n\n\n# main.py\nfrom fastapi import FastAPI\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\napp.include_router(users_router)\n</code></pre> <p>By providing standardized building blocks rather than enforcing a specific architecture, ArchiPy helps teams maintain consistent development practices while allowing flexibility to choose the architectural pattern that best fits their needs.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to ArchiPy are documented in this changelog, organized by version.</p>"},{"location":"changelog/#0140-2025-04-16","title":"[0.14.0] - 2025-04-16","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#kafka-integration","title":"Kafka Integration","text":"<ul> <li>Implemented comprehensive Kafka adapter system with ports and adapters</li> <li>Added test suite for Kafka adapters</li> <li>Enhanced Kafka documentation with detailed usage examples</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Refactored and improved documentation structure</li> <li>Added comprehensive Kafka integration guides</li> <li>Enhanced docstrings for better code understanding</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":""},{"location":"changelog/#code-quality","title":"Code Quality","text":"<ul> <li>Resolved linting issues in configuration templates</li> <li>Fixed lint errors in Keycloak adapters and ports</li> </ul>"},{"location":"changelog/#0135-2025-04-16","title":"[0.13.5] - 2025-04-16","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":""},{"location":"changelog/#sqlalchemy","title":"SQLAlchemy","text":"<ul> <li>Resolved sorting functionality in SQLAlchemy mixin</li> <li>Enhanced query sorting capabilities with improved error handling</li> </ul>"},{"location":"changelog/#code-quality_1","title":"Code Quality","text":"<ul> <li>Applied ruff formatter to config_template.py for consistent code style</li> <li>Updated AsyncContextManager to AbstractAsyncContextManager to resolve UP035 lint error</li> </ul>"},{"location":"changelog/#0134-2025-04-15","title":"[0.13.4] - 2025-04-15","text":""},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#fastapi-integration","title":"FastAPI Integration","text":"<ul> <li>Implemented lifespan support for FastAPI applications</li> <li>Enhanced application lifecycle management with proper startup and shutdown handlers</li> </ul>"},{"location":"changelog/#database-configuration","title":"Database Configuration","text":"<ul> <li>Added automatic database URL generation with validation in SqlAlchemyConfig</li> <li>Improved database connection configuration with enhanced error handling</li> </ul>"},{"location":"changelog/#code-quality_2","title":"Code Quality","text":"<ul> <li>Integrated new features with comprehensive test coverage</li> <li>Enhanced configuration validation and error reporting</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Update changelogs</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":""},{"location":"changelog/#configs","title":"Configs","text":"<ul> <li>Run ruff format on config_template.py to resolve formatting issues</li> <li>Replace AsyncContextManager with AbstractAsyncContextManager to fix UP035 lint error</li> </ul>"},{"location":"changelog/#0133-2025-04-15","title":"[0.13.3] - 2025-04-15","text":""},{"location":"changelog/#added_2","title":"Added","text":""},{"location":"changelog/#cicd","title":"CI/CD","text":"<ul> <li>Implemented comprehensive linting workflow for improved code quality</li> <li>Enhanced GitHub Actions with updated tj-actions/changed-files for better change tracking</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Added detailed documentation for range DTOs and their usage patterns</li> <li>Improved API reference documentation with new examples</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":""},{"location":"changelog/#models","title":"Models","text":"<ul> <li>Enhanced range DTOs with improved type safety and validation</li> <li>Updated range DTOs to support more flexible boundary conditions</li> </ul>"},{"location":"changelog/#code-quality_3","title":"Code Quality","text":"<ul> <li>Integrated automated linting for consistent code style</li> <li>Improved code formatting and documentation standards</li> </ul>"},{"location":"changelog/#0132-2025-04-10","title":"[0.13.2] - 2025-04-10","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>Enhanced Redis adapter documentation with comprehensive docstrings</li> <li>Added MinIO adapter to API reference documentation</li> </ul>"},{"location":"changelog/#code-quality_4","title":"Code Quality","text":"<ul> <li>Improved code quality with linter fixes across Redis adapter and ORM components</li> <li>Fixed file utilities test suite</li> <li>Cleaned up redundant changelog files</li> </ul>"},{"location":"changelog/#0131-2025-04-08","title":"[0.13.1] - 2025-04-08","text":""},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Enhanced cryptographic security by replacing <code>random</code> with <code>secrets</code> module</li> <li>Strengthened TOTP implementation with improved security practices</li> <li>Upgraded password utilities with robust validation and generation</li> </ul>"},{"location":"changelog/#code-quality_5","title":"Code Quality","text":"<ul> <li>Improved type safety with explicit typing and modern type hints</li> <li>Enhanced error handling with domain-specific exception types</li> <li>Standardized parameter naming and module consistency</li> </ul>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>Added comprehensive docstrings to configuration classes</li> <li>Expanded utility function documentation</li> <li>Improved error handling documentation</li> </ul>"},{"location":"changelog/#0130-2025-04-08","title":"[0.13.0] - 2025-04-08","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>MinIO Integration: Full S3-compatible object storage adapter with:</li> <li>Comprehensive S3 operation support (12 standardized methods)</li> <li>Built-in TTL caching for performance optimization</li> <li>Flexible configuration with endpoint and credential management</li> <li>Clear cache management through <code>clear_all_caches</code></li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added complete BDD test suite for MinIO adapter:</li> <li>Bucket and object operation validation</li> <li>Presigned URL generation testing</li> <li>Bucket policy management verification</li> </ul>"},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>Added extensive MinIO adapter examples and usage guides</li> <li>Improved error handling documentation</li> <li>Updated configuration documentation with new MinIO settings</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code># Initialize the MinIO adapter\nfrom archipy.adapters.minio.adapters import MinioAdapter\nminio = MinioAdapter()\n\n# Create a bucket and upload a file\nminio.make_bucket(\"my-bucket\")\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/document.pdf\")\n\n# Generate a presigned URL for temporary access\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\", expires=3600)\n</code></pre>"},{"location":"changelog/#0120-2025-03-29","title":"[0.12.0] - 2025-03-29","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Keycloak Integration: Comprehensive authentication and authorization for FastAPI:</li> <li>Role-based access control with customizable requirements</li> <li>Resource-based authorization for fine-grained access control</li> <li>Both synchronous and asynchronous authentication flows</li> <li>Token validation and introspection</li> <li>User info extraction capabilities</li> </ul>"},{"location":"changelog/#code-quality_6","title":"Code Quality","text":"<ul> <li>Improved error handling clarity by renaming <code>ExceptionMessageType</code> to <code>ErrorMessageType</code></li> <li>Enhanced error documentation with detailed descriptions</li> <li>Updated error handling implementation with new message types</li> </ul>"},{"location":"changelog/#usage-example_1","title":"Usage Example","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.keycloak_utils import KeycloakUtils\n\napp = FastAPI()\n\n@app.get(\"/api/profile\")\ndef get_profile(user: dict = Depends(KeycloakUtils.fastapi_auth(\n    required_roles={\"user\"},\n    admin_roles={\"admin\"}\n))):\n    return {\n        \"user_id\": user.get(\"sub\"),\n        \"username\": user.get(\"preferred_username\")\n    }\n</code></pre>"},{"location":"changelog/#0112-2025-03-21","title":"[0.11.2] - 2025-03-21","text":""},{"location":"changelog/#error-handling","title":"Error Handling","text":"<ul> <li>Enhanced exception management with improved error reporting</li> <li>Streamlined error messaging for better debugging</li> <li>Fixed various error handling edge cases</li> </ul>"},{"location":"changelog/#0111-2025-03-15","title":"[0.11.1] - 2025-03-15","text":""},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>Optimized resource usage across core components</li> <li>Enhanced caching mechanisms for improved performance</li> <li>Improved memory utilization in key operations</li> </ul>"},{"location":"changelog/#0110-2025-03-10","title":"[0.11.0] - 2025-03-10","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Keycloak Adapter: New authentication and authorization system:</li> <li>Asynchronous operations support</li> <li>Token management and validation</li> <li>User information retrieval</li> <li>Comprehensive security features</li> </ul>"},{"location":"changelog/#performance_1","title":"Performance","text":"<ul> <li>Added TTL cache decorator for optimized performance</li> <li>Improved Keycloak adapter efficiency</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>Added detailed Keycloak integration guides</li> <li>Included comprehensive usage examples</li> </ul>"},{"location":"changelog/#usage-example_2","title":"Usage Example","text":"<pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Initialize adapter with configuration from global config\nkeycloak = KeycloakAdapter()\n\n# Authenticate and get access token\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Get user information\nuser_info = keycloak.get_userinfo(token)\n\n# Verify token validity\nis_valid = keycloak.validate_token(token)\n</code></pre>"},{"location":"changelog/#0102-2025-03-05","title":"[0.10.2] - 2025-03-05","text":""},{"location":"changelog/#stability","title":"Stability","text":"<ul> <li>Improved Redis connection pool stability and management</li> <li>Enhanced error recovery mechanisms</li> <li>Fixed various edge cases in Redis operations</li> </ul>"},{"location":"changelog/#0101-2025-03-01","title":"[0.10.1] - 2025-03-01","text":""},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>Enhanced Redis and email adapter documentation</li> <li>Added comprehensive API reference</li> <li>Improved usage examples for common operations</li> </ul>"},{"location":"changelog/#0100-2025-02-25","title":"[0.10.0] - 2025-02-25","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Redis Integration: New caching and key-value storage system:</li> <li>Flexible key-value operations</li> <li>Built-in TTL support</li> <li>Connection pooling</li> <li> <p>Comprehensive error handling</p> </li> <li> <p>Email Service: New email integration system:</p> </li> <li>Multiple email provider support</li> <li>Template-based email sending</li> <li>Attachment handling</li> <li>Async operation support</li> </ul>"},{"location":"changelog/#configuration","title":"Configuration","text":"<ul> <li>Enhanced configuration management system</li> <li>Added support for Redis and email settings</li> <li>Improved environment variable handling</li> </ul>"},{"location":"changelog/#usage-example_3","title":"Usage Example","text":"<pre><code># Initialize the Redis adapter\nfrom archipy.adapters.redis.adapters import RedisAdapter\nredis = RedisAdapter()\n\n# Basic operations\nredis.set(\"user:1:name\", \"John Doe\")\nname = redis.get(\"user:1:name\")\n\n# Using with TTL\nredis.set(\"session:token\", \"abc123\", ttl=3600)  # Expires in 1 hour\n</code></pre>"},{"location":"changelog/#090-2025-02-20","title":"[0.9.0] - 2025-02-20","text":""},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>TOTP System: Comprehensive Time-based One-Time Password implementation:</li> <li>Secure token generation and validation</li> <li>Configurable time windows</li> <li>Built-in expiration handling</li> <li> <p>RFC compliance</p> </li> <li> <p>Multi-Factor Authentication: Enhanced security framework:</p> </li> <li>Multiple authentication factor support</li> <li>Flexible factor configuration</li> <li>Integration with existing auth systems</li> </ul>"},{"location":"changelog/#usage-example_4","title":"Usage Example","text":"<pre><code>from archipy.helpers.utils.totp_utils import TOTPUtils\nfrom uuid import uuid4\n\n# Generate a TOTP code\nuser_id = uuid4()\ntotp_code, expires_at = TOTPUtils.generate_totp(user_id)\n\n# Verify a TOTP code\nis_valid = TOTPUtils.verify_totp(user_id, totp_code)\n\n# Generate a secure key for TOTP initialization\nsecret_key = TOTPUtils.generate_secret_key_for_totp()\n</code></pre>"},{"location":"changelog/#080-2025-02-15","title":"[0.8.0] - 2025-02-15","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Redis Integration: Comprehensive key-value store and caching system:</li> <li>Full Redis API implementation</li> <li>Built-in caching functionality</li> <li>Performance-optimized operations</li> <li>Connection pooling support</li> </ul>"},{"location":"changelog/#testing_1","title":"Testing","text":"<ul> <li>Mock Redis Implementation:</li> <li>Complete test coverage for Redis operations</li> <li>Simulated Redis environment for testing</li> <li>Configurable mock behaviors</li> </ul>"},{"location":"changelog/#documentation_7","title":"Documentation","text":"<ul> <li>Added Redis integration guides</li> <li>Included mock testing examples</li> <li>Updated configuration documentation</li> </ul>"},{"location":"changelog/#072-2025-02-10","title":"[0.7.2] - 2025-02-10","text":""},{"location":"changelog/#database","title":"Database","text":"<ul> <li>Enhanced connection pool stability and management</li> <li>Improved transaction isolation and handling</li> <li>Optimized error reporting for database operations</li> <li>Added connection lifecycle management</li> </ul>"},{"location":"changelog/#071-2025-02-05","title":"[0.7.1] - 2025-02-05","text":""},{"location":"changelog/#performance_2","title":"Performance","text":"<ul> <li>Optimized query execution and planning</li> <li>Reduced memory footprint for ORM operations</li> <li>Enhanced connection pool efficiency</li> <li>Improved cache utilization</li> </ul>"},{"location":"changelog/#070-2025-02-01","title":"[0.7.0] - 2025-02-01","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>SQLAlchemy Integration: Complete ORM implementation:</li> <li>Robust entity model system</li> <li>Transaction management with ACID compliance</li> <li>Connection pooling with configurable settings</li> <li>Comprehensive database operations support</li> </ul>"},{"location":"changelog/#usage-example_5","title":"Usage Example","text":"<pre><code>from archipy.adapters.orm.sqlalchemy.adapters import SQLAlchemyAdapter\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom sqlalchemy import Column, String\n\n# Define a model\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    name = Column(String(100))\n    email = Column(String(100), unique=True)\n\n# Use the ORM\norm = SQLAlchemyAdapter()\nwith orm.session() as session:\n    # Create and read operations\n    new_user = User(name=\"John Doe\", email=\"john@example.com\")\n    session.add(new_user)\n    session.commit()\n\n    user = session.query(User).filter_by(email=\"john@example.com\").first()\n</code></pre>"},{"location":"changelog/#061-2025-01-25","title":"[0.6.1] - 2025-01-25","text":""},{"location":"changelog/#stability_1","title":"Stability","text":"<ul> <li>Fixed memory leaks in gRPC interceptors</li> <li>Improved interceptor performance and efficiency</li> <li>Enhanced request/response handling reliability</li> <li>Optimized resource cleanup</li> </ul>"},{"location":"changelog/#060-2025-01-20","title":"[0.6.0] - 2025-01-20","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>gRPC Integration: Comprehensive interceptor system:</li> <li>Client and server-side interceptors</li> <li>Request/response monitoring</li> <li>Performance tracing capabilities</li> <li>Enhanced error management</li> </ul>"},{"location":"changelog/#documentation_8","title":"Documentation","text":"<ul> <li>Added gRPC integration guides</li> <li>Included interceptor configuration examples</li> <li>Updated troubleshooting documentation</li> </ul>"},{"location":"changelog/#051-2025-01-15","title":"[0.5.1] - 2025-01-15","text":""},{"location":"changelog/#stability_2","title":"Stability","text":"<ul> <li>Enhanced FastAPI middleware reliability</li> <li>Improved response processing efficiency</li> <li>Optimized request handling performance</li> <li>Fixed edge cases in error management</li> </ul>"},{"location":"changelog/#050-2025-01-10","title":"[0.5.0] - 2025-01-10","text":""},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>FastAPI Integration: Complete web framework support:</li> <li>Custom middleware components</li> <li>Request/response processors</li> <li>Standardized error handling</li> <li>Response formatting utilities</li> </ul>"},{"location":"changelog/#documentation_9","title":"Documentation","text":"<ul> <li>Added FastAPI integration guides</li> <li>Included middleware configuration examples</li> <li>Updated API documentation</li> </ul>"},{"location":"changelog/#040-2025-01-05","title":"[0.4.0] - 2025-01-05","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Configuration System: Flexible environment management:</li> <li>Environment variable support</li> <li>Type-safe configuration validation</li> <li>Default value management</li> <li>Override capabilities</li> </ul>"},{"location":"changelog/#documentation_10","title":"Documentation","text":"<ul> <li>Added configuration system guides</li> <li>Included environment setup examples</li> <li>Updated validation documentation</li> </ul>"},{"location":"changelog/#030-2024-12-25","title":"[0.3.0] - 2024-12-25","text":""},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Core Utilities: Comprehensive helper functions:</li> <li>Date/time manipulation with timezone support</li> <li>String processing and formatting</li> <li>Common development utilities</li> <li>Type conversion helpers</li> </ul>"},{"location":"changelog/#documentation_11","title":"Documentation","text":"<ul> <li>Added utility function reference</li> <li>Included usage examples</li> <li>Updated API documentation</li> </ul>"},{"location":"changelog/#020-2024-12-20","title":"[0.2.0] - 2024-12-20","text":""},{"location":"changelog/#architecture","title":"Architecture","text":"<ul> <li>Hexagonal Architecture: Core implementation:</li> <li>Ports and adapters pattern</li> <li>Clean architecture principles</li> <li>Domain-driven design</li> <li>Base entity models</li> </ul>"},{"location":"changelog/#documentation_12","title":"Documentation","text":"<ul> <li>Added architecture overview</li> <li>Included design pattern guides</li> <li>Updated component documentation</li> </ul>"},{"location":"changelog/#010-2025-02-21","title":"[0.1.0] - 2025-02-21","text":""},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Initial Release: Project foundation:</li> <li>Core project structure</li> <li>Basic framework components</li> <li>Configuration system</li> <li>CI/CD pipeline with GitHub Actions</li> </ul>"},{"location":"changelog/#documentation_13","title":"Documentation","text":"<ul> <li>Added initial documentation</li> <li>Included getting started guide</li> <li>Created contribution guidelines</li> </ul>"},{"location":"contributing-docs/","title":"ArchiPy Documentation","text":"<p>This directory contains the MkDocs-based documentation for ArchiPy.</p>"},{"location":"contributing-docs/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - Main configuration file for MkDocs</li> <li><code>docs/</code> - Markdown documentation files</li> <li><code>index.md</code> - Home page</li> <li><code>api_reference/</code> - API documentation</li> <li><code>examples/</code> - Usage examples</li> <li><code>assets/</code> - Images and other static assets</li> </ul>"},{"location":"contributing-docs/#converting-from-sphinx-to-mkdocs","title":"Converting from Sphinx to MkDocs","text":"<p>The documentation is being migrated from Sphinx (RST) to MkDocs (Markdown). To help with this process:</p> <ol> <li> <p>Run the conversion script:    <pre><code>python scripts/convert_docs.py\n</code></pre>    This script uses <code>pandoc</code> to convert RST files to Markdown.</p> </li> <li> <p>Manually review and improve the converted files.</p> </li> <li> <p>Preview the documentation:    <pre><code>make docs-serve\n</code></pre></p> </li> <li> <p>Build the documentation:    <pre><code>make docs-build\n</code></pre></p> </li> <li> <p>Deploy to GitHub Pages:    <pre><code>make docs-deploy\n</code></pre></p> </li> </ol>"},{"location":"contributing-docs/#writing-documentation-guidelines","title":"Writing Documentation Guidelines","text":"<ul> <li>Use Markdown syntax for all documentation files</li> <li>Follow the Google Python style for code examples</li> <li>Include type hints in code samples</li> <li>Group related documentation in directories</li> <li>Link between documentation pages using relative links</li> <li>Add admonitions (notes, warnings, tips) using the Material for MkDocs syntax:   <pre><code>!!! note\n    This is a note.\n</code></pre></li> </ul>"},{"location":"contributing-docs/#improving-documentation","title":"Improving Documentation","text":"<p>When improving the documentation:</p> <ol> <li>Focus on clarity and conciseness</li> <li>Include practical, runnable examples</li> <li>Explain \"why\" not just \"how\"</li> <li>Keep navigation logical and intuitive</li> <li>Use diagrams for complex concepts</li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Welcome to ArchiPy! We're excited that you're interested in contributing. This document outlines the process for contributing to ArchiPy.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository</li> </ol> <p>Fork the ArchiPy repository on GitHub.</p> <ol> <li>Clone Your Fork</li> </ol> <pre><code>git clone https://github.com/YOUR-USERNAME/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Set Up Development Environment</li> </ol> <pre><code>make setup\nmake install\nmake install-dev\npoetry run pre-commit install\n</code></pre> <ol> <li>Create a Branch</li> </ol> <p>Create a branch for your feature or bugfix:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>ArchiPy follows a strict code style to maintain consistency across the codebase:</p> <ul> <li>Black: For code formatting</li> <li>Ruff: For linting</li> <li>Mypy: For type checking</li> </ul> <p>All code must pass these checks before being merged:</p> <pre><code>make check\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All contributions should include appropriate tests:</p> <ul> <li>Unit Tests: For testing individual components</li> <li>Integration Tests: For testing component interactions</li> <li>BDD Tests: For behavior-driven development</li> </ul> <p>Run the tests to ensure your changes don't break existing functionality:</p> <pre><code>make test\nmake behave\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All new features or changes should be documented:</p> <ul> <li>Docstrings: Update or add docstrings to document functions, classes, and methods</li> <li>Type Annotations: Include type annotations for all functions and methods</li> <li>Documentation Files: Update relevant documentation files if necessary</li> </ul> <p>Building the documentation locally:</p> <pre><code>cd docs\nmake html\n</code></pre>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>ArchiPy follows the Conventional Commits specification for commit messages:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre> <p>Common types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Formatting changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or modifying tests</li> <li><code>chore</code>: Maintenance tasks</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update Your Branch</li> </ol> <p>Before submitting a pull request, make sure your branch is up to date with the main branch:</p> <pre><code>git checkout main\ngit pull origin main\ngit checkout your-branch\ngit rebase main\n</code></pre> <ol> <li>Run All Checks</li> </ol> <p>Ensure all checks pass:</p> <pre><code>make check\nmake test\n</code></pre> <ol> <li>Submit Your Pull Request</li> </ol> <p>Push your branch to your fork and create a pull request:</p> <pre><code>git push origin your-branch\n</code></pre> <ol> <li>Code Review</li> </ol> <p>Your pull request will be reviewed by the maintainers. They may suggest changes or improvements.</p> <ol> <li>Merge</li> </ol> <p>Once your pull request is approved, it will be merged into the main branch.</p>"},{"location":"contributing/#bug-reports-and-feature-requests","title":"Bug Reports and Feature Requests","text":"<p>If you find a bug or have a feature request, please create an issue on the GitHub issues page.</p> <p>When reporting a bug, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the bug</li> <li>Steps to reproduce the bug</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Any relevant logs or error messages</li> </ul> <p>When submitting a feature request, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the feature</li> <li>Any relevant use cases</li> <li>If possible, a sketch of how the feature might be implemented</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that ArchiPy has a code of conduct. By participating in this project, you agree to abide by its terms.</p>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Thank you for contributing to ArchiPy! Your efforts help make the project better for everyone.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#development-environment","title":"Development Environment","text":""},{"location":"development/#set-up","title":"Set Up","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Initialize the project:</li> </ol> <pre><code>make setup\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>make install\nmake install-dev  # For dev tools\npoetry run pre-commit install\n</code></pre>"},{"location":"development/#workflow","title":"Workflow","text":""},{"location":"development/#code-quality","title":"Code Quality","text":"<p>Run checks:</p> <pre><code>make check  # Runs ruff, black, mypy\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>Run tests:</p> <pre><code>make behave    # BDD tests\nmake ci        # Full pipeline\n</code></pre> <p>BDD tests use <code>behave</code> with feature files in <code>features/</code> and steps in <code>features/steps/</code>.</p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Follow Semantic Versioning:</p> <pre><code>make bump-patch  # Bug fixes\nmake bump-minor  # New features\nmake bump-major  # Breaking changes\n</code></pre> <p>Add a message:</p> <pre><code>make bump-minor message=\"Added new utility\"\n</code></pre>"},{"location":"development/#build-docs","title":"Build &amp; Docs","text":"<p>Build the package:</p> <pre><code>make build\nmake clean  # Remove artifacts\n</code></pre> <p>Build docs:</p> <pre><code>cd docs\nmake html\n</code></pre> <p>Update dependencies:</p> <pre><code>make update\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>ArchiPy provides a robust framework for structured Python development, focusing on standardization, testability, and productivity.</p>"},{"location":"features/#configuration-management","title":"Configuration Management","text":"<ul> <li>Standardized Configs: Use <code>base_config</code> and <code>config_template</code> for consistent setup.</li> <li>Injection: Seamlessly inject configurations into components.</li> </ul>"},{"location":"features/#adapters-mocks","title":"Adapters &amp; Mocks","text":"<ul> <li>Common Adapters: Pre-built for Redis, SQLAlchemy, email, and Kafka.</li> <li>Mocks: Testable mocks (e.g., <code>redis_mocks</code>, <code>sqlalchemy_mocks</code>) for isolated testing.</li> <li>Async Support: Synchronous and asynchronous implementations.</li> </ul>"},{"location":"features/#data-standardization","title":"Data Standardization","text":"<ul> <li>Base Entities: Standardized SQLAlchemy entities (<code>base_entities.py</code>).</li> <li>DTOs: Pydantic-based DTOs (e.g., <code>pagination_dto</code>, <code>error_dto</code>).</li> <li>Type Safety: Enforced via <code>pydantic</code> and <code>mypy</code>.</li> </ul>"},{"location":"features/#helper-utilities","title":"Helper Utilities","text":"<ul> <li>Utilities: Tools like <code>datetime_utils</code>, <code>jwt_utils</code>, <code>password_utils</code>, and <code>totp_utils</code>.</li> <li>Decorators: <code>retry</code>, <code>singleton</code>, <code>sqlalchemy_atomic</code>, etc.</li> <li>Interceptors: Rate limiting (FastAPI), tracing (gRPC).</li> <li>Enhanced Security: Cryptographically secure implementations with <code>secrets</code> module.</li> <li>Type Safety: Consistent type checking and casting for robust interfaces.</li> </ul>"},{"location":"features/#bdd-testing","title":"BDD Testing","text":"<ul> <li>Behave Integration: Pre-configured for sync/async scenarios.</li> <li>Feature Files: Examples like <code>app_utils.feature</code>, <code>totp_utils.feature</code>.</li> <li>Step Definitions: Comprehensive steps for testing (e.g., <code>jwt_utils_steps.py</code>).</li> </ul>"},{"location":"features/#best-practices-tooling","title":"Best Practices &amp; Tooling","text":"<ul> <li>Poetry: Dependency management for reproducible builds.</li> <li>Pre-commit: Automated checks with <code>ruff</code>, <code>black</code>, and <code>mypy</code>.</li> <li>Structure: Clean architecture with <code>pyproject.toml</code> for modern Python development.</li> </ul>"},{"location":"features/#modular-design","title":"Modular Design","text":"<ul> <li>Optional Dependencies: Install only what you need (e.g., <code>archipy[redis]</code>).</li> <li>Extensible: Add custom adapters and helpers easily.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li> <p>Python 3.13 or higher</p> <p>ArchiPy requires Python 3.13+. Check your version with:</p> <pre><code>python --version\n</code></pre> <p>If needed, download Python 3.13+.</p> </li> <li> <p>Poetry (for dependency management)</p> <p>Poetry manages dependencies and project setup. Install it via the official guide.</p> </li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>Install the core library:</p> <pre><code>pip install archipy\n</code></pre> <p>With optional dependencies (e.g., Redis, FastAPI):</p> <pre><code>pip install archipy[redis,fastapi]\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using Poetry","text":"<p>Add the core library:</p> <pre><code>poetry add archipy\n</code></pre> <p>With optional dependencies:</p> <pre><code>poetry add \"archipy[redis,fastapi]\"\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>ArchiPy supports modular features:</p> Feature Installation Command Redis <code>archipy[redis]</code> FastAPI <code>archipy[fastapi]</code> JWT <code>archipy[jwt]</code> Kavenegar <code>archipy[kavenegar]</code> Prometheus <code>archipy[prometheus]</code> Sentry <code>archipy[sentry]</code> Dependency Injection <code>archipy[dependency-injection]</code> Scheduler <code>archipy[scheduler]</code> gRPC <code>archipy[grpc]</code> PostgreSQL <code>archipy[postgres]</code> FakeRedis <code>archipy[fakeredis]</code> Full list See Usage section"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributors:</p> <pre><code># Clone the repository\ngit clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n\n# Set up the project\nmake setup\n\n# Install dependencies\nmake install\n\n# Optional: Install dev tools\nmake install-dev\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If issues arise, verify:</p> <ol> <li>Python version is 3.13+</li> <li><code>pip</code> or <code>poetry</code> is updated (e.g., <code>pip install --upgrade pip</code>)</li> <li>Build tools (<code>setuptools</code>, <code>wheel</code>) are installed</li> </ol> <p>IDE Integration</p> <p>For the best development experience, use an IDE that supports Python type hints, such as PyCharm or VS Code with the Python extension.</p>"},{"location":"license/","title":"License","text":"<p>ArchiPy is licensed under the terms of the license file included in the repository.</p> <p>For more details, see the LICENSE file.</p>"},{"location":"usage/","title":"Getting Started","text":"<p>This guide will help you start building applications with ArchiPy.</p>"},{"location":"usage/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, initialize your application with a configuration:</li> </ol> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    # Custom configuration\n    pass\n\n# Set as global config\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre> <ol> <li>Define your domain models:</li> </ol> <pre><code>from uuid import uuid4\nfrom sqlalchemy import Column, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom archipy.models.entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n    # Relationships\n    posts = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(BaseEntity):\n    __tablename__ = \"posts\"\n\n    title = Column(String(255))\n    content = Column(String(1000))\n\n    # Foreign keys\n    author_id = Column(UUID, ForeignKey(\"users.test_uuid\"))\n\n    # Relationships\n    author = relationship(\"User\", back_populates=\"posts\")\n</code></pre> <ol> <li>Set up your database adapter:</li> </ol> <pre><code>from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\nfrom archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyAdapter\n\n# Create session manager\nsession_manager = SessionManagerAdapter()\n\n# Create adapter\ndb_adapter = SqlAlchemyAdapter(session_manager)\n\n# Create tables (development only)\nBaseEntity.metadata.create_all(session_manager.engine)\n</code></pre> <ol> <li>Implement your repositories:</li> </ol> <pre><code>from sqlalchemy import select\n\nclass UserRepository:\n    def __init__(self, db_adapter):\n        self.db_adapter = db_adapter\n\n    def create(self, username, email):\n        user = User(test_uuid=uuid4(), username=username, email=email)\n        return self.db_adapter.create(user)\n\n    def get_by_username(self, username):\n        query = select(User).where(User.username == username)\n        users, _ = self.db_adapter.execute_search_query(User, query)\n        return users[0] if users else None\n</code></pre> <ol> <li>Implement your business logic:</li> </ol> <pre><code>class UserService:\n    def __init__(self, user_repository):\n        self.user_repository = user_repository\n\n    def register_user(self, username, email):\n        # Business logic here (validation, etc.)\n        return self.user_repository.create(username, email)\n</code></pre>"},{"location":"usage/#working-with-redis","title":"Working with Redis","text":"<p>For caching or other Redis operations:</p> <pre><code>from archipy.adapters.redis.adapters import RedisAdapter\n\n# Create Redis adapter\nredis_adapter = RedisAdapter()\n\n\n# Cache user data\ndef cache_user(user):\n    user_data = {\n        \"username\": user.username,\n        \"email\": user.email\n    }\n    redis_adapter.set(f\"user:{user.test_uuid}\", json.dumps(user_data), ex=3600)\n\n\n# Get cached user\ndef get_cached_user(user_id):\n    data = redis_adapter.get(f\"user:{user_id}\")\n    return json.loads(data) if data else None\n</code></pre>"},{"location":"usage/#working-with-fastapi","title":"Working with FastAPI","text":"<p>Integrate with FastAPI:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom archipy.helpers.utils.app_utils import AppUtils\n\n# Create FastAPI app\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Create dependencies\ndef get_user_service():\n    user_repo = UserRepository(db_adapter)\n    return UserService(user_repo)\n\n# Define routes\n@app.post(\"/users/\")\ndef create_user(username: str, email: str, service: UserService = Depends(get_user_service)):\n    try:\n        user = service.register_user(username, email)\n        return {\"id\": str(user.test_uuid), \"username\": user.username}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n</code></pre>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#configuration-management","title":"Configuration Management","text":"<p>Standardize and inject configurations:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Define a custom config\nclass MyAppConfig(BaseConfig):\n    database_url: str = \"sqlite:///example.db\"\n    redis_host: str = \"localhost\"\n\nconfig = MyAppConfig()\nprint(config.database_url)  # \"sqlite:///example.db\"\n</code></pre>"},{"location":"usage/#adapters-mocks","title":"Adapters &amp; Mocks","text":"<p>Use adapters for external systems with mocks for testing:</p> <pre><code>from archipy.adapters.redis.adapters import AsyncRedisAdapter\nfrom archipy.adapters.redis.mocks import AsyncRedisMock\n\n# Production use\nredis = AsyncRedisAdapter()\nawait redis.set(\"key\", \"value\", ex=3600)\nprint(await redis.get(\"key\"))  # \"value\"\n\n# Testing with mock\nmock_redis = AsyncRedisMock()\nawait mock_redis.set(\"key\", \"test\")\nprint(await mock_redis.get(\"key\"))  # \"test\"\n</code></pre>"},{"location":"usage/#entities-dtos","title":"Entities &amp; DTOs","text":"<p>Standardize data models:</p> <pre><code>from sqlalchemy import Column, Integer, String\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom archipy.models.dtos.base_dtos import BaseDTO\n\n# Entity\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100))\n\n# DTO\nclass UserDTO(BaseDTO):\n    id: int\n    name: str\n\nuser = UserDTO(id=1, name=\"Alice\")\nprint(user.model_dump())  # {'id': 1, 'name': 'Alice'}\n</code></pre>"},{"location":"usage/#helper-utilities","title":"Helper Utilities","text":"<p>Simplify tasks with utilities and decorators:</p> <pre><code>from archipy.helpers.utils.datetime_utils import get_utc_now\nfrom archipy.helpers.decorators.retry import retry\n\n# Utility\nnow = get_utc_now()\nprint(now)  # Current UTC time\n\n# Decorator\n@retry(max_attempts=3, delay=1)\ndef risky_operation():\n    # Simulated failure\n    raise ValueError(\"Try again\")\n\ntry:\n    risky_operation()\nexcept ValueError as e:\n    print(f\"Failed after retries: {e}\")\n</code></pre>"},{"location":"usage/#bdd-testing","title":"BDD Testing","text":"<p>Validate features with <code>behave</code>:</p> <pre><code># Run BDD tests\nmake behave\n</code></pre> <p>Example feature file (<code>features/app_utils.feature</code>):</p> <pre><code>Feature: Application Utilities\n  Scenario: Get UTC time\n    When I get the current UTC time\n    Then the result should be a valid datetime\n</code></pre>"},{"location":"usage/#async-operations","title":"Async Operations","text":"<p>Support for asynchronous workflows:</p> <pre><code>import asyncio\nfrom archipy.adapters.orm.sqlalchemy.adapters import AsyncSqlAlchemyAdapter\n\n\nasync def fetch_users():\n    adapter = AsyncSqlAlchemyAdapter(session_manager, User)\n    users = await adapter.execute_search_query(User, pagination=None, sort_info=None)\n    return users\n\n\nusers, total = asyncio.run(fetch_users())\nprint(users)  # List of User entities\n</code></pre>"},{"location":"usage/#available-commands","title":"Available Commands","text":"<p>Run <code>make help</code> for all commands. Common ones:</p> <ul> <li>Format Code: <code>make format</code></li> <li>Lint Code: <code>make lint</code></li> <li>Run BDD Tests: <code>make behave</code></li> <li>Build Project: <code>make build</code></li> <li>Clean Artifacts: <code>make clean</code></li> </ul>"},{"location":"api_reference/","title":"API Reference","text":"<p>Welcome to the ArchiPy API reference documentation. This section provides detailed information about all modules, classes, and functions in ArchiPy.</p>"},{"location":"api_reference/#core-modules","title":"Core Modules","text":""},{"location":"api_reference/#adapters","title":"Adapters","text":"<p>The adapters module provides standardized interfaces to external systems:</p> <ul> <li>Adapters Documentation</li> <li>ORM Adapters</li> <li>Redis Adapters</li> <li>Email Adapters</li> <li>Keycloak Adapters</li> <li>MinIO Adapters</li> <li>Kafka Adapters</li> </ul>"},{"location":"api_reference/#configs","title":"Configs","text":"<p>Configuration management and injection tools:</p> <ul> <li>Configs Documentation</li> <li>Base Config</li> <li>Config Templates</li> </ul>"},{"location":"api_reference/#helpers","title":"Helpers","text":"<p>Utility functions and support classes:</p> <ul> <li>Helpers Documentation</li> <li>Decorators</li> <li>Utils</li> <li>Metaclasses</li> <li>Interceptors</li> </ul>"},{"location":"api_reference/#models","title":"Models","text":"<p>Core data structures and types:</p> <ul> <li>Models Documentation</li> <li>Entities</li> <li>Data Transfer Objects</li> <li>Errors</li> <li>Types</li> </ul>"},{"location":"api_reference/#source-code-organization","title":"Source Code Organization","text":"<p>The ArchiPy source code is organized into the following structure:</p> <pre><code>archipy/\n\u251c\u2500\u2500 adapters/           # External system integrations\n\u2502   \u251c\u2500\u2500 email/         # Email service adapters\n\u2502   \u251c\u2500\u2500 keycloak/      # Keycloak authentication adapters\n\u2502   \u251c\u2500\u2500 kafka/         # Kafka message streaming adapters\n\u2502   \u251c\u2500\u2500 minio/         # MinIO object storage adapters\n\u2502   \u251c\u2500\u2500 orm/           # Database ORM adapters\n\u2502   \u2514\u2500\u2500 redis/         # Redis adapters\n\u251c\u2500\u2500 configs/           # Configuration management\n\u2502   \u251c\u2500\u2500 base_config.py\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 helpers/           # Utility functions\n\u2502   \u251c\u2500\u2500 decorators/\n\u2502   \u251c\u2500\u2500 interceptors/\n\u2502   \u251c\u2500\u2500 metaclasses/\n\u2502   \u2514\u2500\u2500 utils/\n\u2514\u2500\u2500 models/            # Core data structures\n    \u251c\u2500\u2500 dtos/\n    \u251c\u2500\u2500 entities/\n    \u251c\u2500\u2500 errors/\n    \u2514\u2500\u2500 types/\n</code></pre>"},{"location":"api_reference/#api-stability","title":"API Stability","text":"<p>ArchiPy follows semantic versioning and marks API stability as follows:</p> <ul> <li>\ud83d\udfe2 Stable: Production-ready APIs, covered by semantic versioning</li> <li>\ud83d\udfe1 Beta: APIs that are stabilizing but may have breaking changes</li> <li>\ud83d\udd34 Alpha: Experimental APIs that may change significantly</li> </ul> <p>See the Changelog for version history and breaking changes.</p>"},{"location":"api_reference/#contributing","title":"Contributing","text":"<p>For information about contributing to ArchiPy's development, please see:</p> <ul> <li>Contributing Guide</li> <li>Development Guide</li> <li>Documentation Guide</li> </ul>"},{"location":"api_reference/adapters/","title":"Adapters","text":"<p>The <code>adapters</code> module provides standardized interfaces to external systems and services. It follows the ports and adapters pattern (also known as hexagonal architecture) to decouple application logic from external dependencies.</p>"},{"location":"api_reference/adapters/#key-features","title":"Key Features","text":"<ul> <li>Consistent interfaces for all external services</li> <li>Built-in mock implementations for testing</li> <li>Port definitions for dependency inversion</li> <li>Ready-to-use implementations for common services</li> </ul>"},{"location":"api_reference/adapters/#available-adapters","title":"Available Adapters","text":""},{"location":"api_reference/adapters/#email","title":"Email","text":"<p>Email sending functionality with standardized interface.</p> <pre><code>from archipy.adapters.email import EmailAdapter, EmailPort\n\n# Configure email adapter\nemail_adapter = EmailAdapter(host=\"smtp.example.com\", port=587, username=\"user\", password=\"pass\")\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email\",\n    recipients=[\"recipient@example.com\"],\n)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters","title":"<code>archipy.adapters.email.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler","title":"<code>archipy.adapters.email.adapters.AttachmentHandler</code>","text":"<p>Enhanced attachment handler with better type safety and validation</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class AttachmentHandler:\n    \"\"\"Enhanced attachment handler with better type safety and validation\"\"\"\n\n    @staticmethod\n    def create_attachment(\n        source: str | bytes | BinaryIO | HttpUrl,\n        filename: str,\n        attachment_type: EmailAttachmentType,\n        content_type: str | None = None,\n        content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n        content_id: str | None = None,\n        max_size: int | None = None,\n    ) -&gt; EmailAttachmentDTO:\n        \"\"\"Create an attachment with validation\"\"\"\n        if max_size is None:\n            max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n        try:\n            processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n            return EmailAttachmentDTO(\n                content=processed_content,\n                filename=filename,\n                content_type=content_type,\n                content_disposition=content_disposition,\n                content_id=content_id,\n                attachment_type=attachment_type,\n                max_size=max_size,\n            )\n        except Exception as exception:\n            raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n\n    @staticmethod\n    def _process_source(source: str | bytes | BinaryIO | HttpUrl, attachment_type: EmailAttachmentType) -&gt; bytes:\n        \"\"\"Process different types of attachment sources\"\"\"\n        if attachment_type == EmailAttachmentType.FILE:\n            with open(source, \"rb\") as f:\n                return f.read()\n        elif attachment_type == EmailAttachmentType.BASE64:\n            return base64.b64decode(source)\n        elif attachment_type == EmailAttachmentType.URL:\n            response = requests.get(source)\n            response.raise_for_status()\n            return response.content\n        elif attachment_type == EmailAttachmentType.BINARY:\n            if isinstance(source, bytes):\n                return source\n            if hasattr(source, \"read\"):\n                return source.read()\n            raise ValueError(f\"Invalid binary source type: {type(source)}\")\n        raise ValueError(f\"Unsupported attachment type: {attachment_type}\")\n\n    @staticmethod\n    def process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n        \"\"\"Process and attach the attachment to the email message\"\"\"\n        content = AttachmentHandler._get_content(attachment)\n        part = AttachmentHandler._create_mime_part(content, attachment)\n\n        # Add headers\n        part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n        if attachment.content_id:\n            part.add_header(\"Content-ID\", attachment.content_id)\n\n        msg.attach(part)\n\n    @staticmethod\n    def _get_content(attachment: EmailAttachmentDTO) -&gt; bytes:\n        \"\"\"Get content as bytes from attachment\"\"\"\n        if isinstance(attachment.content, (str, bytes)):\n            return attachment.content if isinstance(attachment.content, bytes) else attachment.content.encode()\n        return attachment.content.read()\n\n    @staticmethod\n    def _create_mime_part(\n        content: bytes,\n        attachment: EmailAttachmentDTO,\n    ) -&gt; MIMEText | MIMEImage | MIMEAudio | MIMEBase:\n        \"\"\"Create appropriate MIME part based on content type\"\"\"\n        main_type, sub_type = attachment.content_type.split(\"/\", 1)\n\n        if main_type == \"text\":\n            return MIMEText(content.decode(), sub_type)\n        if main_type == \"image\":\n            return MIMEImage(content, _subtype=sub_type)\n        if main_type == \"audio\":\n            return MIMEAudio(content, _subtype=sub_type)\n        part = MIMEBase(main_type, sub_type)\n        part.set_payload(content)\n        encoders.encode_base64(part)\n        return part\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.create_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.create_attachment(source, filename, attachment_type, content_type=None, content_disposition=EmailAttachmentDispositionType.ATTACHMENT, content_id=None, max_size=None)</code>  <code>staticmethod</code>","text":"<p>Create an attachment with validation</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef create_attachment(\n    source: str | bytes | BinaryIO | HttpUrl,\n    filename: str,\n    attachment_type: EmailAttachmentType,\n    content_type: str | None = None,\n    content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n    content_id: str | None = None,\n    max_size: int | None = None,\n) -&gt; EmailAttachmentDTO:\n    \"\"\"Create an attachment with validation\"\"\"\n    if max_size is None:\n        max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n    try:\n        processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n        return EmailAttachmentDTO(\n            content=processed_content,\n            filename=filename,\n            content_type=content_type,\n            content_disposition=content_disposition,\n            content_id=content_id,\n            attachment_type=attachment_type,\n            max_size=max_size,\n        )\n    except Exception as exception:\n        raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.process_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.process_attachment(msg, attachment)</code>  <code>staticmethod</code>","text":"<p>Process and attach the attachment to the email message</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n    \"\"\"Process and attach the attachment to the email message\"\"\"\n    content = AttachmentHandler._get_content(attachment)\n    part = AttachmentHandler._create_mime_part(content, attachment)\n\n    # Add headers\n    part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n    if attachment.content_id:\n        part.add_header(\"Content-ID\", attachment.content_id)\n\n    msg.attach(part)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter","title":"<code>archipy.adapters.email.adapters.EmailAdapter</code>","text":"<p>               Bases: <code>EmailPort</code></p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class EmailAdapter(EmailPort):\n    def __init__(self, config: EmailConfig = None):\n        self.config = config or BaseConfig.global_config().EMAIL\n        self.connection_pool = EmailConnectionPool(self.config)\n\n    @override\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send email with advanced features and connection pooling\"\"\"\n        connection = None\n        try:\n            connection = self.connection_pool.get_connection()\n            msg = self._create_message(\n                to_email=to_email,\n                subject=subject,\n                body=body,\n                cc=cc,\n                bcc=bcc,\n                attachments=attachments,\n                html=html,\n                template=template,\n                template_vars=template_vars,\n            )\n\n            recipients = self._get_all_recipients(to_email, cc, bcc)\n\n            for attempt in range(self.config.MAX_RETRIES):\n                try:\n                    if connection.smtp_connection:\n                        connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                        logging.debug(f\"Email sent successfully to {to_email}\")\n                        return\n                    connection.connect()\n                except Exception as e:\n                    if attempt == self.config.MAX_RETRIES - 1:\n                        BaseUtils.capture_exception(e)\n                    connection.connect()  # Retry with fresh connection\n\n        except Exception as e:\n            BaseUtils.capture_exception(e)\n        finally:\n            if connection:\n                self.connection_pool.return_connection(connection)\n\n    def _create_message(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; MIMEMultipart:\n        msg = MIMEMultipart()\n        msg[\"From\"] = self.config.EMAIL_USERNAME\n        msg[\"To\"] = to_email if isinstance(to_email, str) else \", \".join(to_email)\n        msg[\"Subject\"] = subject\n\n        if cc:\n            msg[\"Cc\"] = cc if isinstance(cc, str) else \", \".join(cc)\n        if bcc:\n            msg[\"Bcc\"] = bcc if isinstance(bcc, str) else \", \".join(bcc)\n\n        if template:\n            body = Template(template).render(**(template_vars or {}))\n\n        msg.attach(MIMEText(body, \"html\" if html else \"plain\"))\n\n        if attachments:\n            for attachment in attachments:\n                if isinstance(attachment, str):\n                    # Treat as file path\n                    attachment_obj = AttachmentHandler.create_attachment(\n                        source=attachment,\n                        filename=os.path.basename(attachment),\n                        attachment_type=EmailAttachmentType.FILE,\n                    )\n                else:\n                    attachment_obj = attachment\n                AttachmentHandler.process_attachment(msg, attachment_obj)\n\n        return msg\n\n    @staticmethod\n    def _get_all_recipients(\n        to_email: EmailStr | list[EmailStr],\n        cc: EmailStr | list[EmailStr] | None,\n        bcc: EmailStr | list[EmailStr] | None,\n    ) -&gt; list[str]:\n        \"\"\"Get list of all recipients\"\"\"\n        recipients = []\n\n        # Add primary recipients\n        if isinstance(to_email, str):\n            recipients.append(to_email)\n        else:\n            recipients.extend(to_email)\n\n        # Add CC recipients\n        if cc:\n            if isinstance(cc, str):\n                recipients.append(cc)\n            else:\n                recipients.extend(cc)\n\n        # Add BCC recipients\n        if bcc:\n            if isinstance(bcc, str):\n                recipients.append(bcc)\n            else:\n                recipients.extend(bcc)\n\n        return recipients\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter.send_email","title":"<code>archipy.adapters.email.adapters.EmailAdapter.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>","text":"<p>Send email with advanced features and connection pooling</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@override\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send email with advanced features and connection pooling\"\"\"\n    connection = None\n    try:\n        connection = self.connection_pool.get_connection()\n        msg = self._create_message(\n            to_email=to_email,\n            subject=subject,\n            body=body,\n            cc=cc,\n            bcc=bcc,\n            attachments=attachments,\n            html=html,\n            template=template,\n            template_vars=template_vars,\n        )\n\n        recipients = self._get_all_recipients(to_email, cc, bcc)\n\n        for attempt in range(self.config.MAX_RETRIES):\n            try:\n                if connection.smtp_connection:\n                    connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                    logging.debug(f\"Email sent successfully to {to_email}\")\n                    return\n                connection.connect()\n            except Exception as e:\n                if attempt == self.config.MAX_RETRIES - 1:\n                    BaseUtils.capture_exception(e)\n                connection.connect()  # Retry with fresh connection\n\n    except Exception as e:\n        BaseUtils.capture_exception(e)\n    finally:\n        if connection:\n            self.connection_pool.return_connection(connection)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports","title":"<code>archipy.adapters.email.ports</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort","title":"<code>archipy.adapters.email.ports.EmailPort</code>","text":"<p>Interface for email sending operations.</p> <p>This interface defines the contract for email adapters, ensuring a consistent approach to sending emails across different implementations. It provides a comprehensive set of features including support for:</p> <ul> <li>Multiple recipients (To, CC, BCC)</li> <li>HTML and plain text content</li> <li>File and in-memory attachments</li> <li>Template-based email rendering</li> </ul> <p>Implementing classes should handle the details of connecting to an email service, managing connections, and ensuring reliable delivery.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n...     def __init__(self, config):\n...         self.config = config\n...\n...     def send_email(\n...         self,\n...         to_email,\n...         subject,\n...         body,\n...         cc=None,\n...         bcc=None,\n...         attachments=None,\n...         html=False,\n...         template=None,\n...         template_vars=None\n...     ):\n...         # Implementation details...\n...         pass\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>class EmailPort:\n    \"\"\"Interface for email sending operations.\n\n    This interface defines the contract for email adapters, ensuring\n    a consistent approach to sending emails across different implementations.\n    It provides a comprehensive set of features including support for:\n\n    - Multiple recipients (To, CC, BCC)\n    - HTML and plain text content\n    - File and in-memory attachments\n    - Template-based email rendering\n\n    Implementing classes should handle the details of connecting to an\n    email service, managing connections, and ensuring reliable delivery.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n        ...     def __init__(self, config):\n        ...         self.config = config\n        ...\n        ...     def send_email(\n        ...         self,\n        ...         to_email,\n        ...         subject,\n        ...         body,\n        ...         cc=None,\n        ...         bcc=None,\n        ...         attachments=None,\n        ...         html=False,\n        ...         template=None,\n        ...         template_vars=None\n        ...     ):\n        ...         # Implementation details...\n        ...         pass\n    \"\"\"\n\n    @abstractmethod\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send an email with various options and features.\n\n        This method handles the composition and delivery of an email with\n        support for multiple recipients, HTML content, templates, and attachments.\n\n        Args:\n            to_email: Primary recipient(s) of the email\n            subject: Email subject line\n            body: Email body content (either plain text or HTML)\n            cc: Carbon copy recipient(s)\n            bcc: Blind carbon copy recipient(s)\n            attachments: List of file paths or EmailAttachmentDTO objects\n            html: If True, treats body as HTML content, otherwise plain text\n            template: A template string to render using template_vars\n            template_vars: Variables to use when rendering the template\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; # Simple text email\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Hello\",\n            ...     body=\"This is a test email\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # HTML email with attachment\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n            ...     subject=\"Report\",\n            ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n            ...     html=True,\n            ...     attachments=[\"path/to/report.pdf\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Template-based email\n            &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Account Expiration\",\n            ...     body=\"\",  # Body will be rendered from template\n            ...     template=template,\n            ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n            ... )\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort.send_email","title":"<code>archipy.adapters.email.ports.EmailPort.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>  <code>abstractmethod</code>","text":"<p>Send an email with various options and features.</p> <p>This method handles the composition and delivery of an email with support for multiple recipients, HTML content, templates, and attachments.</p> <p>Parameters:</p> Name Type Description Default <code>to_email</code> <code>EmailStr | list[EmailStr]</code> <p>Primary recipient(s) of the email</p> required <code>subject</code> <code>str</code> <p>Email subject line</p> required <code>body</code> <code>str</code> <p>Email body content (either plain text or HTML)</p> required <code>cc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Carbon copy recipient(s)</p> <code>None</code> <code>bcc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Blind carbon copy recipient(s)</p> <code>None</code> <code>attachments</code> <code>list[str | EmailAttachmentDTO] | None</code> <p>List of file paths or EmailAttachmentDTO objects</p> <code>None</code> <code>html</code> <code>bool</code> <p>If True, treats body as HTML content, otherwise plain text</p> <code>False</code> <code>template</code> <code>str | None</code> <p>A template string to render using template_vars</p> <code>None</code> <code>template_vars</code> <code>dict | None</code> <p>Variables to use when rendering the template</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Simple text email\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Hello\",\n...     body=\"This is a test email\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # HTML email with attachment\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n...     subject=\"Report\",\n...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n...     html=True,\n...     attachments=[\"path/to/report.pdf\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Template-based email\n&gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Account Expiration\",\n...     body=\"\",  # Body will be rendered from template\n...     template=template,\n...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n... )\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>@abstractmethod\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send an email with various options and features.\n\n    This method handles the composition and delivery of an email with\n    support for multiple recipients, HTML content, templates, and attachments.\n\n    Args:\n        to_email: Primary recipient(s) of the email\n        subject: Email subject line\n        body: Email body content (either plain text or HTML)\n        cc: Carbon copy recipient(s)\n        bcc: Blind carbon copy recipient(s)\n        attachments: List of file paths or EmailAttachmentDTO objects\n        html: If True, treats body as HTML content, otherwise plain text\n        template: A template string to render using template_vars\n        template_vars: Variables to use when rendering the template\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; # Simple text email\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Hello\",\n        ...     body=\"This is a test email\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # HTML email with attachment\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n        ...     subject=\"Report\",\n        ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n        ...     html=True,\n        ...     attachments=[\"path/to/report.pdf\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Template-based email\n        &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Account Expiration\",\n        ...     body=\"\",  # Body will be rendered from template\n        ...     template=template,\n        ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n        ... )\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#keycloak","title":"Keycloak","text":"<p>Keycloak integration for authentication and authorization services.</p> <pre><code>from archipy.adapters.keycloak import KeycloakAdapter, AsyncKeycloakAdapter\n\n# Create a Keycloak adapter (synchronous)\nkeycloak = KeycloakAdapter()  # Uses global config by default\n\n# Authenticate a user\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Validate token\nis_valid = keycloak.validate_token(token[\"access_token\"])\n\n# Check user roles\nhas_admin = keycloak.has_role(token[\"access_token\"], \"admin\")\n\n# Async usage example\nimport asyncio\n\nasync def auth_example():\n    # Create async Keycloak adapter\n    async_keycloak = AsyncKeycloakAdapter()\n\n    # Get token asynchronously\n    token = await async_keycloak.get_token(\"username\", \"password\")\n\n    # Get user info\n    user_info = await async_keycloak.get_userinfo(token[\"access_token\"])\n    return user_info\n\n# Run the async example\nuser_info = asyncio.run(auth_example())\n</code></pre> <p>For detailed examples and usage guidelines, see the Keycloak Adapter Examples.</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters","title":"<code>archipy.adapters.keycloak.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter</code>","text":"<p>               Bases: <code>KeycloakPort</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class KeycloakAdapter(KeycloakPort):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self._openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter = None\n        self._admin_token_expiry = 0\n\n        # Initialize admin client with service account if client_secret is provided\n        if self.configs.CLIENT_SECRET_KEY:\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Get token using client credentials\n            token = self._openid_adapter.token(grant_type=\"client_credentials\")\n\n            # Set token expiry time (current time + expires_in - buffer)\n            # Using a 30-second buffer to ensure we refresh before expiration\n            self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n            # Create admin client with the token\n            self._admin_adapter = KeycloakAdmin(\n                server_url=self.configs.SERVER_URL,\n                realm_name=self.configs.REALM_NAME,\n                token=token,\n                verify=self.configs.VERIFY_SSL,\n                timeout=self.configs.TIMEOUT,\n            )\n            logger.debug(\"Admin client initialized successfully\")\n        except KeycloakError:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            ValueError: If admin client is not available\n        \"\"\"\n        if not self.configs.CLIENT_SECRET_KEY:\n            raise ValueError(\"Admin client not available, provide client_secret_key to use admin features\")\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise ValueError(\"Failed to initialize admin client\")\n\n        return self._admin_adapter\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = self._openid_adapter.public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except Exception as e:\n            raise ValueError(f\"Failed to get public key: {e!s}\")\n\n    @override\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        try:\n            return self._openid_adapter.token(grant_type=\"password\", username=username, password=password)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get token: {e!s}\")\n\n    @override\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token refresh fails\n        \"\"\"\n        try:\n            return self._openid_adapter.refresh_token(refresh_token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to refresh token: {e!s}\")\n\n    @override\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            self._openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n            return True\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n\n    @override\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not self.validate_token(token):\n            raise ValueError(\"Invalid token provided\")\n        try:\n            return self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user info: {e!s}\")\n\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=100)  # Cache for 30 seconds\n    def _get_userinfo_cached(self, token: str) -&gt; KeycloakUserType:\n        return self._openid_adapter.userinfo(token)\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user by username: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user by email: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user roles: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client roles: {e!s}\")\n\n    @override\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = client.get(\"roles\", [])\n                if role_name in client_roles:\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(roles):\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = set(client.get(\"roles\", []))\n                if role_names.intersection(client_roles):\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                all_roles.update(client.get(\"roles\", []))\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = self.admin_adapter.create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n\n            return user_id\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to create user: {e!s}\")\n\n    @override\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to update user: {e!s}\")\n\n    @override\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to reset password: {e!s}\")\n\n    @override\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Assign role to user\n            self.admin_adapter.assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to assign realm role: {e!s}\")\n\n    @override\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Remove role from user\n            self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to remove realm role: {e!s}\")\n\n    @override\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = self.admin_adapter.get_client_id(client_id)\n            # Get role representation\n            role = self.admin_adapter.get_client_role(client, role_name)\n            # Assign role to user\n            self.admin_adapter.assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to assign client role: {e!s}\")\n\n    @override\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            self.admin_adapter.create_realm_role(role_data)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            created_role = self.admin_adapter.get_realm_role(role_name)\n            return created_role\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to create realm role: {e!s}\")\n\n    @override\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to delete realm role: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = self.get_client_id(self.configs.CLIENT_ID)\n            service_account_id = self.admin_adapter.get_client_service_account_user(client_id).get(\"id\")\n            return service_account_id\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get service account ID: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return self._openid_adapter.well_known()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get well-known config: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return self._openid_adapter.certs()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get certificates: {e!s}\")\n\n    @override\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return self._openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n\n    @override\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return self._openid_adapter.token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to search users: {e!s}\")\n\n    @override\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = self._openid_adapter.uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n            return False\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception:\n            return False\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client secret: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_id(client_name)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client ID: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get realm roles: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_role(role_name)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get realm role: {e!s}\")\n\n    @override\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client_id(client_id)\n            role = self.admin_adapter.get_client_role(client, role_name)\n            self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to remove client role: {e!s}\")\n\n    @override\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            self.admin_adapter.user_logout(user_id)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n\n    @override\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            self._openid_adapter.logout(refresh_token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to logout: {e!s}\")\n\n    @override\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return self._openid_adapter.introspect(token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to introspect token: {e!s}\")\n\n    @override\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return self._openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get token info: {e!s}\")\n\n    @override\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            self.admin_adapter.delete_user(user_id=user_id)\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except Exception as e:\n            raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If admin client is not available</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self._openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter = None\n    self._admin_token_expiry = 0\n\n    # Initialize admin client with service account if client_secret is provided\n    if self.configs.CLIENT_SECRET_KEY:\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key()</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>PublicKeyType</code> <p>JWK key object used to verify signatures</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\ndef get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = self._openid_adapter.public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except Exception as e:\n        raise ValueError(f\"Failed to get public key: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token(username, password)</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    try:\n        return self._openid_adapter.token(grant_type=\"password\", username=username, password=password)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token(refresh_token)</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token refresh fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token refresh fails\n    \"\"\"\n    try:\n        return self._openid_adapter.refresh_token(refresh_token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to refresh token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token(token)</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        self._openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n        return True\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo(token)</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not self.validate_token(token):\n        raise ValueError(\"Invalid token provided\")\n    try:\n        return self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id(user_id)</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username(username)</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user by username: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email(email)</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user by email: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles(user_id)</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role(token, role_name)</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = client.get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles(token, role_names)</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(roles):\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = set(client.get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles(token, role_names)</code>","text":"<p>Check if a user has all of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            all_roles.update(client.get(\"roles\", []))\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user(user_data)</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = self.admin_adapter.create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n\n        return user_id\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to create user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user(user_id, user_data)</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to update user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password(user_id, password, temporary=False)</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to reset password: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role(user_id, role_name)</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Assign role to user\n        self.admin_adapter.assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to assign realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role(user_id, role_name)</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Remove role from user\n        self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to remove realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = self.admin_adapter.get_client_id(client_id)\n        # Get role representation\n        role = self.admin_adapter.get_client_role(client, role_name)\n        # Assign role to user\n        self.admin_adapter.assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to assign client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role(role_name, description=None)</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        self.admin_adapter.create_realm_role(role_data)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        created_role = self.admin_adapter.get_realm_role(role_name)\n        return created_role\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to create realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role(role_name)</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to delete realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id()</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = self.get_client_id(self.configs.CLIENT_ID)\n        service_account_id = self.admin_adapter.get_client_service_account_user(client_id).get(\"id\")\n        return service_account_id\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get service account ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config()</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return self._openid_adapter.well_known()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get well-known config: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs()</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return self._openid_adapter.certs()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get certificates: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code(code, redirect_uri)</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return self._openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token()</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return self._openid_adapter.token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users(query, max_results=100)</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType]</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to search users: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions(token, resource, scope)</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = self._openid_adapter.uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n        return False\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret(client_id)</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client secret: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id(client_name)</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_id(client_name)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles()</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get realm roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role(role_name)</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_role(role_name)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client_id(client_id)\n        role = self.admin_adapter.get_client_role(client, role_name)\n        self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to remove client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions(user_id)</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        self.admin_adapter.user_logout(user_id)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.logout(refresh_token)</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        self._openid_adapter.logout(refresh_token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to logout: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token(token)</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return self._openid_adapter.introspect(token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to introspect token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info(token)</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return self._openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get token info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user(user_id)</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        self.admin_adapter.delete_user(user_id=user_id)\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except Exception as e:\n        raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter</code>","text":"<p>               Bases: <code>AsyncKeycloakPort</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class AsyncKeycloakAdapter(AsyncKeycloakPort):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self.openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter = None\n        self._admin_token_expiry = 0\n\n        # Initialize admin client with service account if client_secret is provided\n        if self.configs.CLIENT_SECRET_KEY:\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Get token using client credentials\n            token = self.openid_adapter.token(grant_type=\"client_credentials\")\n\n            # Set token expiry time (current time + expires_in - buffer)\n            # Using a 30-second buffer to ensure we refresh before expiration\n            self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n            # Create admin client with the token\n            self._admin_adapter = KeycloakAdmin(\n                server_url=self.configs.SERVER_URL,\n                realm_name=self.configs.REALM_NAME,\n                token=token,\n                verify=self.configs.VERIFY_SSL,\n                timeout=self.configs.TIMEOUT,\n            )\n            logger.debug(\"Admin client initialized successfully\")\n        except KeycloakError:\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            ValueError: If admin client is not available\n        \"\"\"\n        if not self.configs.CLIENT_SECRET_KEY:\n            raise ValueError(\"Admin client not available, provide client_secret_key to use admin features\")\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise ValueError(\"Failed to initialize admin client\")\n\n        return self._admin_adapter\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    async def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = await self.openid_adapter.a_public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except Exception as e:\n            raise ValueError(f\"Failed to get public key: {e!s}\")\n\n    @override\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get token: {e!s}\")\n\n    @override\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token refresh fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_refresh_token(refresh_token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to refresh token: {e!s}\")\n\n    @override\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n            return True\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n\n    @override\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not await self.validate_token(token):\n            raise ValueError(\"Invalid token provided\")\n        try:\n            return await self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user info: {e!s}\")\n\n    @alru_cache(ttl=30, maxsize=100)  # Cache for 30 seconds\n    async def _get_userinfo_cached(self, token: str) -&gt; KeycloakUserType:\n        return await self.openid_adapter.a_userinfo(token)\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user by username: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user by email: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get user roles: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client roles: {e!s}\")\n\n    @override\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = client.get(\"roles\", [])\n                if role_name in client_roles:\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    async def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(roles):\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = set(client.get(\"roles\", []))\n                if role_names.intersection(client_roles):\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    async def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                all_roles.update(client.get(\"roles\", []))\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = await self.admin_adapter.a_create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n\n            return user_id\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to create user: {e!s}\")\n\n    @override\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to update user: {e!s}\")\n\n    @override\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to reset password: {e!s}\")\n\n    @override\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to assign realm role: {e!s}\")\n\n    @override\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Remove role from user\n            await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to remove realm role: {e!s}\")\n\n    @override\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            # Get role representation\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to assign client role: {e!s}\")\n\n    @override\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            await self.admin_adapter.a_create_realm_role(role_data)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            created_role = await self.admin_adapter.a_get_realm_role(role_name)\n            return created_role\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to create realm role: {e!s}\")\n\n    @override\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to delete realm role: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = await self.get_client_id(self.configs.CLIENT_ID)\n            service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n            return service_account.get(\"id\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get service account ID: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_well_known()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get well-known config: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_certs()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get certificates: {e!s}\")\n\n    @override\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return await self.openid_adapter.a_token(\n                grant_type=\"authorization_code\",\n                code=code,\n                redirect_uri=redirect_uri,\n            )\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n\n    @override\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n\n    @override\n    @alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to search users: {e!s}\")\n\n    @override\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = await self.openid_adapter.a_uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n            return False\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception:\n            return False\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client secret: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_id(client_name)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get client ID: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get realm roles: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_role(role_name)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get realm role: {e!s}\")\n\n    @override\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to remove client role: {e!s}\")\n\n    @override\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_user_logout(user_id)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n\n    @override\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            await self.openid_adapter.a_logout(refresh_token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to logout: {e!s}\")\n\n    @override\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_introspect(token)\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to introspect token: {e!s}\")\n\n    @override\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n        except KeycloakError as e:\n            raise ValueError(f\"Failed to get token info: {e!s}\")\n\n    @override\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_delete_user(user_id=user_id)\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except Exception as e:\n            raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If admin client is not available</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self.openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter = None\n    self._admin_token_expiry = 0\n\n    # Initialize admin client with service account if client_secret is provided\n    if self.configs.CLIENT_SECRET_KEY:\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key()</code>  <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>PublicKeyType</code> <p>JWK key object used to verify signatures</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\nasync def get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = await self.openid_adapter.a_public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except Exception as e:\n        raise ValueError(f\"Failed to get public key: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token(username, password)</code>  <code>async</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token(refresh_token)</code>  <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token refresh fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token refresh fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_refresh_token(refresh_token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to refresh token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token(token)</code>  <code>async</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n        return True\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo(token)</code>  <code>async</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not await self.validate_token(token):\n        raise ValueError(\"Invalid token provided\")\n    try:\n        return await self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id(user_id)</code>  <code>async</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username(username)</code>  <code>async</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user by username: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email(email)</code>  <code>async</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user by email: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles(user_id)</code>  <code>async</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get user roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>  <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role(token, role_name)</code>  <code>async</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = client.get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(roles):\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = set(client.get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            all_roles.update(client.get(\"roles\", []))\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user(user_data)</code>  <code>async</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = await self.admin_adapter.a_create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n\n        return user_id\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to create user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user(user_id, user_data)</code>  <code>async</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to update user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password(user_id, password, temporary=False)</code>  <code>async</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to reset password: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to assign realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Remove role from user\n        await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to remove realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        # Get role representation\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to assign client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role(role_name, description=None)</code>  <code>async</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        await self.admin_adapter.a_create_realm_role(role_data)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        created_role = await self.admin_adapter.a_get_realm_role(role_name)\n        return created_role\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to create realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role(role_name)</code>  <code>async</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to delete realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id()</code>  <code>async</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = await self.get_client_id(self.configs.CLIENT_ID)\n        service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n        return service_account.get(\"id\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get service account ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config()</code>  <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_well_known()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get well-known config: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs()</code>  <code>async</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_certs()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get certificates: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code(code, redirect_uri)</code>  <code>async</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return await self.openid_adapter.a_token(\n            grant_type=\"authorization_code\",\n            code=code,\n            redirect_uri=redirect_uri,\n        )\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token()</code>  <code>async</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users(query, max_results=100)</code>  <code>async</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType]</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to search users: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions(token, resource, scope)</code>  <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = await self.openid_adapter.a_uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n        return False\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret(client_id)</code>  <code>async</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client secret: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id(client_name)</code>  <code>async</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_id(client_name)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get client ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles()</code>  <code>async</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get realm roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role(role_name)</code>  <code>async</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_role(role_name)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to remove client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_user_logout(user_id)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout(refresh_token)</code>  <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        await self.openid_adapter.a_logout(refresh_token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to logout: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token(token)</code>  <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_introspect(token)\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to introspect token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info(token)</code>  <code>async</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n    except KeycloakError as e:\n        raise ValueError(f\"Failed to get token info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user(user_id)</code>  <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_delete_user(user_id=user_id)\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except Exception as e:\n        raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports","title":"<code>archipy.adapters.keycloak.ports</code>","text":"<p>Keycloak port definitions for ArchiPy.</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort</code>","text":"<p>Interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class KeycloakPort:\n    \"\"\"Interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.validate_token(token)</code>  <code>abstractmethod</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_public_key()</code>  <code>abstractmethod</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_certs()</code>  <code>abstractmethod</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort</code>","text":"<p>Asynchronous interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for async Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class AsyncKeycloakPort:\n    \"\"\"Asynchronous interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for async Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    async def get_public_key(self) -&gt; PublicKeyType:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_public_key(self) -&gt; PublicKeyType:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#minio","title":"MinIO","text":"<p>MinIO integration for S3-compatible object storage operations.</p> <pre><code>from archipy.adapters.minio import MinioAdapter\n\n# Create a MinIO adapter\nminio = MinioAdapter()  # Uses global config by default\n\n# Create a bucket\nif not minio.bucket_exists(\"my-bucket\"):\n    minio.make_bucket(\"my-bucket\")\n\n# Upload a file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/local/file.pdf\")\n\n# Generate a download URL (valid for 1 hour)\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\")\n</code></pre> <p>For detailed examples and usage guidelines, see the MinIO Adapter Examples.</p>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters","title":"<code>archipy.adapters.minio.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter","title":"<code>archipy.adapters.minio.adapters.MinioAdapter</code>","text":"<p>               Bases: <code>MinioPort</code></p> <p>Concrete implementation of the MinioPort interface using the minio library.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>class MinioAdapter(MinioPort):\n    \"\"\"Concrete implementation of the MinioPort interface using the minio library.\"\"\"\n\n    def __init__(self, minio_configs: MinioConfig | None = None) -&gt; None:\n        \"\"\"Initialize MinioAdapter with configuration.\n\n        Args:\n            minio_configs: Optional MinIO configuration. If None, global config is used.\n        \"\"\"\n        # Determine config source (explicit or from global config)\n        if minio_configs is not None:\n            self.configs = minio_configs\n        else:\n            # First get global config, then extract MINIO config\n            global_config: Any = BaseConfig.global_config()\n            if not hasattr(global_config, \"MINIO\"):\n                raise InvalidArgumentError(argument_name=\"MINIO\")\n            self.configs = cast(MinioConfig, global_config.MINIO)\n\n        # Ensure we have a valid endpoint value\n        endpoint = str(self.configs.ENDPOINT or \"\")\n        if not endpoint:\n            raise InvalidArgumentError(argument_name=\"endpoint\")\n\n        self._adapter = Minio(\n            endpoint,\n            access_key=self.configs.ACCESS_KEY,\n            secret_key=self.configs.SECRET_KEY,\n            session_token=self.configs.SESSION_TOKEN,\n            secure=self.configs.SECURE,\n            region=self.configs.REGION,\n        )\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def bucket_exists(self, bucket_name: str) -&gt; bool:\n        \"\"\"Check if a bucket exists.\"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            return self._adapter.bucket_exists(bucket_name)\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                return False\n            raise InternalError(details=f\"Failed to check bucket existence: {e}\") from e\n\n    @override\n    def make_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Create a new bucket.\"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            self._adapter.make_bucket(bucket_name)\n            self.clear_all_caches()  # Clear cache since bucket list changed\n        except S3Error as e:\n            if \"BucketAlreadyOwnedByYou\" in str(e) or \"BucketAlreadyExists\" in str(e):\n                raise AlreadyExistsError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to create bucket\"}) from e\n            raise InternalError(details=f\"Failed to create bucket: {e}\") from e\n\n    @override\n    def remove_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Remove a bucket.\"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            self._adapter.remove_bucket(bucket_name)\n            self.clear_all_caches()  # Clear cache since bucket list changed\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                raise NotFoundError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to remove bucket\"}) from e\n            raise InternalError(details=f\"Failed to remove bucket: {e}\") from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def list_buckets(self) -&gt; list[MinioBucketType]:\n        \"\"\"List all buckets.\"\"\"\n        try:\n            buckets = self._adapter.list_buckets()\n            return [{\"name\": b.name, \"creation_date\": b.creation_date} for b in buckets]\n        except S3Error as e:\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to list buckets\"}) from e\n            raise InternalError(details=f\"Failed to list buckets: {e}\") from e\n\n    @override\n    def put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Upload a file to a bucket.\"\"\"\n        try:\n            if not bucket_name or not object_name or not file_path:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name, object_name or file_path\"\n                        if not all([bucket_name, object_name, file_path])\n                        else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                    ),\n                )\n            self._adapter.fput_object(bucket_name, object_name, file_path)\n            if hasattr(self.list_objects, \"clear_cache\"):\n                self.list_objects.clear_cache()  # Clear object list cache\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                raise NotFoundError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to upload object\"}) from e\n            raise InternalError(details=f\"Failed to upload object: {e}\") from e\n\n    @override\n    def get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Download an object to a file.\"\"\"\n        try:\n            if not bucket_name or not object_name or not file_path:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name, object_name or file_path\"\n                        if not all([bucket_name, object_name, file_path])\n                        else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                    ),\n                )\n            self._adapter.fget_object(bucket_name, object_name, file_path)\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n                raise NotFoundError(resource_type=\"object\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to download object\"}) from e\n            raise InternalError(details=f\"Failed to download object: {e}\") from e\n\n    @override\n    def remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n        \"\"\"Remove an object from a bucket.\"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            self._adapter.remove_object(bucket_name, object_name)\n            if hasattr(self.list_objects, \"clear_cache\"):\n                self.list_objects.clear_cache()  # Clear object list cache\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n                raise NotFoundError(resource_type=\"object\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to remove object\"}) from e\n            raise InternalError(details=f\"Failed to remove object: {e}\") from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def list_objects(\n        self,\n        bucket_name: str,\n        prefix: str = \"\",\n        *,\n        recursive: bool = False,\n    ) -&gt; list[MinioObjectType]:\n        \"\"\"List objects in a bucket.\"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            objects = self._adapter.list_objects(bucket_name, prefix=prefix, recursive=recursive)\n            return [\n                {\"object_name\": obj.object_name, \"size\": obj.size, \"last_modified\": obj.last_modified}\n                for obj in objects\n            ]\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                raise NotFoundError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to list objects\"}) from e\n            raise InternalError(details=f\"Failed to list objects: {e}\") from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n        \"\"\"Get object metadata.\"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            obj = self._adapter.stat_object(bucket_name, object_name)\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n                raise NotFoundError(resource_type=\"object\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to get object stats\"}) from e\n            raise InternalError(details=f\"Failed to get object stats: {e}\") from e\n        else:\n            return {\n                \"object_name\": obj.object_name,\n                \"size\": obj.size,\n                \"last_modified\": obj.last_modified,\n                \"content_type\": obj.content_type,\n                \"etag\": obj.etag,\n            }\n\n    @override\n    def presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            return self._adapter.presigned_get_object(bucket_name, object_name, expires=timedelta(seconds=expires))\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n                raise NotFoundError(resource_type=\"object\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(\n                    additional_data={\"details\": \"Permission denied to generate presigned URL\"},\n                ) from e\n            raise InternalError(details=f\"Failed to generate presigned GET URL: {e}\") from e\n\n    @override\n    def presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n        try:\n            if not bucket_name or not object_name:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or object_name\"\n                        if not all([bucket_name, object_name])\n                        else \"bucket_name\" if not bucket_name else \"object_name\"\n                    ),\n                )\n            return self._adapter.presigned_put_object(bucket_name, object_name, expires=timedelta(seconds=expires))\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                raise NotFoundError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(\n                    additional_data={\"details\": \"Permission denied to generate presigned PUT URL\"},\n                ) from e\n            raise InternalError(details=f\"Failed to generate presigned PUT URL: {e}\") from e\n\n    @override\n    def set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n        \"\"\"Set bucket policy.\"\"\"\n        try:\n            if not bucket_name or not policy:\n                raise InvalidArgumentError(\n                    argument_name=(\n                        \"bucket_name or policy\"\n                        if not all([bucket_name, policy])\n                        else \"bucket_name\" if not bucket_name else \"policy\"\n                    ),\n                )\n            self._adapter.set_bucket_policy(bucket_name, policy)\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                raise NotFoundError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(\n                    additional_data={\"details\": \"Permission denied to set bucket policy\"},\n                ) from e\n            raise InternalError(details=f\"Failed to set bucket policy: {e}\") from e\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n        \"\"\"Get bucket policy.\"\"\"\n        try:\n            if not bucket_name:\n                raise InvalidArgumentError(argument_name=\"bucket_name\")\n            policy = self._adapter.get_bucket_policy(bucket_name)\n        except S3Error as e:\n            if \"NoSuchBucket\" in str(e):\n                raise NotFoundError(resource_type=\"bucket\") from e\n            if \"AccessDenied\" in str(e):\n                raise PermissionDeniedError(\n                    additional_data={\"details\": \"Permission denied to get bucket policy\"},\n                ) from e\n            raise InternalError(details=f\"Failed to get bucket policy: {e}\") from e\n        else:\n            return {\"policy\": policy}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.__init__","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.__init__(minio_configs=None)</code>","text":"<p>Initialize MinioAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>minio_configs</code> <code>MinioConfig | None</code> <p>Optional MinIO configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>def __init__(self, minio_configs: MinioConfig | None = None) -&gt; None:\n    \"\"\"Initialize MinioAdapter with configuration.\n\n    Args:\n        minio_configs: Optional MinIO configuration. If None, global config is used.\n    \"\"\"\n    # Determine config source (explicit or from global config)\n    if minio_configs is not None:\n        self.configs = minio_configs\n    else:\n        # First get global config, then extract MINIO config\n        global_config: Any = BaseConfig.global_config()\n        if not hasattr(global_config, \"MINIO\"):\n            raise InvalidArgumentError(argument_name=\"MINIO\")\n        self.configs = cast(MinioConfig, global_config.MINIO)\n\n    # Ensure we have a valid endpoint value\n    endpoint = str(self.configs.ENDPOINT or \"\")\n    if not endpoint:\n        raise InvalidArgumentError(argument_name=\"endpoint\")\n\n    self._adapter = Minio(\n        endpoint,\n        access_key=self.configs.ACCESS_KEY,\n        secret_key=self.configs.SECRET_KEY,\n        session_token=self.configs.SESSION_TOKEN,\n        secure=self.configs.SECURE,\n        region=self.configs.REGION,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.clear_all_caches","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.bucket_exists","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.bucket_exists(bucket_name)</code>","text":"<p>Check if a bucket exists.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef bucket_exists(self, bucket_name: str) -&gt; bool:\n    \"\"\"Check if a bucket exists.\"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        return self._adapter.bucket_exists(bucket_name)\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            return False\n        raise InternalError(details=f\"Failed to check bucket existence: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.make_bucket","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.make_bucket(bucket_name)</code>","text":"<p>Create a new bucket.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef make_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Create a new bucket.\"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        self._adapter.make_bucket(bucket_name)\n        self.clear_all_caches()  # Clear cache since bucket list changed\n    except S3Error as e:\n        if \"BucketAlreadyOwnedByYou\" in str(e) or \"BucketAlreadyExists\" in str(e):\n            raise AlreadyExistsError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to create bucket\"}) from e\n        raise InternalError(details=f\"Failed to create bucket: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.remove_bucket","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.remove_bucket(bucket_name)</code>","text":"<p>Remove a bucket.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef remove_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Remove a bucket.\"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        self._adapter.remove_bucket(bucket_name)\n        self.clear_all_caches()  # Clear cache since bucket list changed\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            raise NotFoundError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to remove bucket\"}) from e\n        raise InternalError(details=f\"Failed to remove bucket: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.list_buckets","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.list_buckets()</code>","text":"<p>List all buckets.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef list_buckets(self) -&gt; list[MinioBucketType]:\n    \"\"\"List all buckets.\"\"\"\n    try:\n        buckets = self._adapter.list_buckets()\n        return [{\"name\": b.name, \"creation_date\": b.creation_date} for b in buckets]\n    except S3Error as e:\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to list buckets\"}) from e\n        raise InternalError(details=f\"Failed to list buckets: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.put_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.put_object(bucket_name, object_name, file_path)</code>","text":"<p>Upload a file to a bucket.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Upload a file to a bucket.\"\"\"\n    try:\n        if not bucket_name or not object_name or not file_path:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name, object_name or file_path\"\n                    if not all([bucket_name, object_name, file_path])\n                    else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                ),\n            )\n        self._adapter.fput_object(bucket_name, object_name, file_path)\n        if hasattr(self.list_objects, \"clear_cache\"):\n            self.list_objects.clear_cache()  # Clear object list cache\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            raise NotFoundError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to upload object\"}) from e\n        raise InternalError(details=f\"Failed to upload object: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.get_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.get_object(bucket_name, object_name, file_path)</code>","text":"<p>Download an object to a file.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Download an object to a file.\"\"\"\n    try:\n        if not bucket_name or not object_name or not file_path:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name, object_name or file_path\"\n                    if not all([bucket_name, object_name, file_path])\n                    else \"bucket_name\" if not bucket_name else \"object_name\" if not object_name else \"file_path\"\n                ),\n            )\n        self._adapter.fget_object(bucket_name, object_name, file_path)\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n            raise NotFoundError(resource_type=\"object\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to download object\"}) from e\n        raise InternalError(details=f\"Failed to download object: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.remove_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.remove_object(bucket_name, object_name)</code>","text":"<p>Remove an object from a bucket.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n    \"\"\"Remove an object from a bucket.\"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        self._adapter.remove_object(bucket_name, object_name)\n        if hasattr(self.list_objects, \"clear_cache\"):\n            self.list_objects.clear_cache()  # Clear object list cache\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n            raise NotFoundError(resource_type=\"object\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to remove object\"}) from e\n        raise InternalError(details=f\"Failed to remove object: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.list_objects","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.list_objects(bucket_name, prefix='', *, recursive=False)</code>","text":"<p>List objects in a bucket.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef list_objects(\n    self,\n    bucket_name: str,\n    prefix: str = \"\",\n    *,\n    recursive: bool = False,\n) -&gt; list[MinioObjectType]:\n    \"\"\"List objects in a bucket.\"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        objects = self._adapter.list_objects(bucket_name, prefix=prefix, recursive=recursive)\n        return [\n            {\"object_name\": obj.object_name, \"size\": obj.size, \"last_modified\": obj.last_modified}\n            for obj in objects\n        ]\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            raise NotFoundError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to list objects\"}) from e\n        raise InternalError(details=f\"Failed to list objects: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.stat_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.stat_object(bucket_name, object_name)</code>","text":"<p>Get object metadata.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n    \"\"\"Get object metadata.\"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        obj = self._adapter.stat_object(bucket_name, object_name)\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n            raise NotFoundError(resource_type=\"object\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(additional_data={\"details\": \"Permission denied to get object stats\"}) from e\n        raise InternalError(details=f\"Failed to get object stats: {e}\") from e\n    else:\n        return {\n            \"object_name\": obj.object_name,\n            \"size\": obj.size,\n            \"last_modified\": obj.last_modified,\n            \"content_type\": obj.content_type,\n            \"etag\": obj.etag,\n        }\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.presigned_get_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.presigned_get_object(bucket_name, object_name, expires=3600)</code>","text":"<p>Generate a presigned URL for downloading an object.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        return self._adapter.presigned_get_object(bucket_name, object_name, expires=timedelta(seconds=expires))\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e) or \"NoSuchKey\" in str(e):\n            raise NotFoundError(resource_type=\"object\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(\n                additional_data={\"details\": \"Permission denied to generate presigned URL\"},\n            ) from e\n        raise InternalError(details=f\"Failed to generate presigned GET URL: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.presigned_put_object","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.presigned_put_object(bucket_name, object_name, expires=3600)</code>","text":"<p>Generate a presigned URL for uploading an object.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n    try:\n        if not bucket_name or not object_name:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or object_name\"\n                    if not all([bucket_name, object_name])\n                    else \"bucket_name\" if not bucket_name else \"object_name\"\n                ),\n            )\n        return self._adapter.presigned_put_object(bucket_name, object_name, expires=timedelta(seconds=expires))\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            raise NotFoundError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(\n                additional_data={\"details\": \"Permission denied to generate presigned PUT URL\"},\n            ) from e\n        raise InternalError(details=f\"Failed to generate presigned PUT URL: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.set_bucket_policy","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.set_bucket_policy(bucket_name, policy)</code>","text":"<p>Set bucket policy.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\ndef set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n    \"\"\"Set bucket policy.\"\"\"\n    try:\n        if not bucket_name or not policy:\n            raise InvalidArgumentError(\n                argument_name=(\n                    \"bucket_name or policy\"\n                    if not all([bucket_name, policy])\n                    else \"bucket_name\" if not bucket_name else \"policy\"\n                ),\n            )\n        self._adapter.set_bucket_policy(bucket_name, policy)\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            raise NotFoundError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(\n                additional_data={\"details\": \"Permission denied to set bucket policy\"},\n            ) from e\n        raise InternalError(details=f\"Failed to set bucket policy: {e}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.adapters.MinioAdapter.get_bucket_policy","title":"<code>archipy.adapters.minio.adapters.MinioAdapter.get_bucket_policy(bucket_name)</code>","text":"<p>Get bucket policy.</p> Source code in <code>archipy/adapters/minio/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n    \"\"\"Get bucket policy.\"\"\"\n    try:\n        if not bucket_name:\n            raise InvalidArgumentError(argument_name=\"bucket_name\")\n        policy = self._adapter.get_bucket_policy(bucket_name)\n    except S3Error as e:\n        if \"NoSuchBucket\" in str(e):\n            raise NotFoundError(resource_type=\"bucket\") from e\n        if \"AccessDenied\" in str(e):\n            raise PermissionDeniedError(\n                additional_data={\"details\": \"Permission denied to get bucket policy\"},\n            ) from e\n        raise InternalError(details=f\"Failed to get bucket policy: {e}\") from e\n    else:\n        return {\"policy\": policy}\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports","title":"<code>archipy.adapters.minio.ports</code>","text":"<p>MinIO port definitions for ArchiPy.</p>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort","title":"<code>archipy.adapters.minio.ports.MinioPort</code>","text":"<p>Interface for MinIO operations providing a standardized access pattern.</p> <p>This interface defines the contract for MinIO adapters, ensuring consistent implementation of object storage operations across different adapters.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>class MinioPort:\n    \"\"\"Interface for MinIO operations providing a standardized access pattern.\n\n    This interface defines the contract for MinIO adapters, ensuring consistent\n    implementation of object storage operations across different adapters.\n    \"\"\"\n\n    # Bucket Operations\n    @abstractmethod\n    def bucket_exists(self, bucket_name: str) -&gt; bool:\n        \"\"\"Check if a bucket exists.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def make_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Create a new bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_bucket(self, bucket_name: str) -&gt; None:\n        \"\"\"Remove a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_buckets(self) -&gt; list[MinioBucketType]:\n        \"\"\"List all buckets.\"\"\"\n        raise NotImplementedError\n\n    # Object Operations\n    @abstractmethod\n    def put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Upload a file to a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n        \"\"\"Download an object to a file.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n        \"\"\"Remove an object from a bucket.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_objects(\n        self,\n        bucket_name: str,\n        prefix: str = \"\",\n        *,  # Force recursive to be keyword-only to avoid boolean flag issues\n        recursive: bool = False,\n    ) -&gt; list[MinioObjectType]:\n        \"\"\"List objects in a bucket.\n\n        Args:\n            bucket_name: The name of the bucket to list objects from\n            prefix: Optional prefix to filter objects by\n            recursive: Whether to list objects recursively (include sub-directories)\n\n        Returns:\n            A list of MinioObjectType objects\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n        \"\"\"Get object metadata.\"\"\"\n        raise NotImplementedError\n\n    # Presigned URL Operations\n    @abstractmethod\n    def presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n        \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n        raise NotImplementedError\n\n    # Policy Operations\n    @abstractmethod\n    def set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n        \"\"\"Set bucket policy.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n        \"\"\"Get bucket policy.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.bucket_exists","title":"<code>archipy.adapters.minio.ports.MinioPort.bucket_exists(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a bucket exists.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef bucket_exists(self, bucket_name: str) -&gt; bool:\n    \"\"\"Check if a bucket exists.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.make_bucket","title":"<code>archipy.adapters.minio.ports.MinioPort.make_bucket(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Create a new bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef make_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Create a new bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.remove_bucket","title":"<code>archipy.adapters.minio.ports.MinioPort.remove_bucket(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef remove_bucket(self, bucket_name: str) -&gt; None:\n    \"\"\"Remove a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.list_buckets","title":"<code>archipy.adapters.minio.ports.MinioPort.list_buckets()</code>  <code>abstractmethod</code>","text":"<p>List all buckets.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef list_buckets(self) -&gt; list[MinioBucketType]:\n    \"\"\"List all buckets.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.put_object","title":"<code>archipy.adapters.minio.ports.MinioPort.put_object(bucket_name, object_name, file_path)</code>  <code>abstractmethod</code>","text":"<p>Upload a file to a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef put_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Upload a file to a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.get_object","title":"<code>archipy.adapters.minio.ports.MinioPort.get_object(bucket_name, object_name, file_path)</code>  <code>abstractmethod</code>","text":"<p>Download an object to a file.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef get_object(self, bucket_name: str, object_name: str, file_path: str) -&gt; None:\n    \"\"\"Download an object to a file.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.remove_object","title":"<code>archipy.adapters.minio.ports.MinioPort.remove_object(bucket_name, object_name)</code>  <code>abstractmethod</code>","text":"<p>Remove an object from a bucket.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef remove_object(self, bucket_name: str, object_name: str) -&gt; None:\n    \"\"\"Remove an object from a bucket.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.list_objects","title":"<code>archipy.adapters.minio.ports.MinioPort.list_objects(bucket_name, prefix='', *, recursive=False)</code>  <code>abstractmethod</code>","text":"<p>List objects in a bucket.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>The name of the bucket to list objects from</p> required <code>prefix</code> <code>str</code> <p>Optional prefix to filter objects by</p> <code>''</code> <code>recursive</code> <code>bool</code> <p>Whether to list objects recursively (include sub-directories)</p> <code>False</code> <p>Returns:</p> Type Description <code>list[MinioObjectType]</code> <p>A list of MinioObjectType objects</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef list_objects(\n    self,\n    bucket_name: str,\n    prefix: str = \"\",\n    *,  # Force recursive to be keyword-only to avoid boolean flag issues\n    recursive: bool = False,\n) -&gt; list[MinioObjectType]:\n    \"\"\"List objects in a bucket.\n\n    Args:\n        bucket_name: The name of the bucket to list objects from\n        prefix: Optional prefix to filter objects by\n        recursive: Whether to list objects recursively (include sub-directories)\n\n    Returns:\n        A list of MinioObjectType objects\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.stat_object","title":"<code>archipy.adapters.minio.ports.MinioPort.stat_object(bucket_name, object_name)</code>  <code>abstractmethod</code>","text":"<p>Get object metadata.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef stat_object(self, bucket_name: str, object_name: str) -&gt; MinioObjectType:\n    \"\"\"Get object metadata.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.presigned_get_object","title":"<code>archipy.adapters.minio.ports.MinioPort.presigned_get_object(bucket_name, object_name, expires=3600)</code>  <code>abstractmethod</code>","text":"<p>Generate a presigned URL for downloading an object.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef presigned_get_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for downloading an object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.presigned_put_object","title":"<code>archipy.adapters.minio.ports.MinioPort.presigned_put_object(bucket_name, object_name, expires=3600)</code>  <code>abstractmethod</code>","text":"<p>Generate a presigned URL for uploading an object.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef presigned_put_object(self, bucket_name: str, object_name: str, expires: int = 3600) -&gt; str:\n    \"\"\"Generate a presigned URL for uploading an object.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.set_bucket_policy","title":"<code>archipy.adapters.minio.ports.MinioPort.set_bucket_policy(bucket_name, policy)</code>  <code>abstractmethod</code>","text":"<p>Set bucket policy.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef set_bucket_policy(self, bucket_name: str, policy: str) -&gt; None:\n    \"\"\"Set bucket policy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.minio.ports.MinioPort.get_bucket_policy","title":"<code>archipy.adapters.minio.ports.MinioPort.get_bucket_policy(bucket_name)</code>  <code>abstractmethod</code>","text":"<p>Get bucket policy.</p> Source code in <code>archipy/adapters/minio/ports.py</code> <pre><code>@abstractmethod\ndef get_bucket_policy(self, bucket_name: str) -&gt; MinioPolicyType:\n    \"\"\"Get bucket policy.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#orm","title":"ORM","text":"<p>Object-Relational Mapping adapters, primarily for SQLAlchemy integration.</p> <pre><code>from archipy.adapters.orm.sqlalchemy import SQLAlchemyAdapter, SQLAlchemySessionManager\n\n# Create session manager\nsession_manager = SQLAlchemySessionManager(connection_string=\"postgresql://user:pass@localhost/db\")\n\n# Create an ORM adapter\norm_adapter = SQLAlchemyAdapter(session_manager=session_manager)\n\n# Use the adapter\nusers = orm_adapter.query(User).filter(User.active == True).all()\n</code></pre>"},{"location":"api_reference/adapters/#sqlalchemy-components","title":"SQLAlchemy Components","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters","title":"<code>archipy.adapters.orm.sqlalchemy.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyFilterMixin","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyFilterMixin</code>","text":"<p>Mixin providing filtering capabilities for SQLAlchemy queries.</p> <p>This mixin provides methods to apply various filters to SQLAlchemy queries, supporting a wide range of comparison operators for different data types.</p> <p>The filtering functionality supports: - Equality/inequality comparisons - Greater than/less than operations - String operations (LIKE, ILIKE, startswith, endswith) - List operations (IN, NOT IN) - NULL checks</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class SqlAlchemyFilterMixin:\n    \"\"\"Mixin providing filtering capabilities for SQLAlchemy queries.\n\n    This mixin provides methods to apply various filters to SQLAlchemy queries,\n    supporting a wide range of comparison operators for different data types.\n\n    The filtering functionality supports:\n    - Equality/inequality comparisons\n    - Greater than/less than operations\n    - String operations (LIKE, ILIKE, startswith, endswith)\n    - List operations (IN, NOT IN)\n    - NULL checks\n    \"\"\"\n\n    @staticmethod\n    def _apply_filter(\n        query: Select | Update | Delete,\n        field: InstrumentedAttribute,\n        value: Any,\n        operation: FilterOperationType,\n    ) -&gt; Select | Update | Delete:\n        \"\"\"Apply a filter to a SQLAlchemy query.\n\n        This method applies different types of filters based on the specified\n        operation type, allowing for flexible query building.\n\n        Args:\n            query: The SQLAlchemy query to apply the filter to\n            field: The model attribute/column to filter on\n            value: The value to compare against\n            operation: The type of filter operation to apply\n\n        Returns:\n            The updated query with the filter applied\n        \"\"\"\n        if value is not None or operation in [FilterOperationType.IS_NULL, FilterOperationType.IS_NOT_NULL]:\n            if operation == FilterOperationType.EQUAL:\n                return query.where(field == value)\n            if operation == FilterOperationType.NOT_EQUAL:\n                return query.where(field != value)\n            if operation == FilterOperationType.LESS_THAN:\n                return query.where(field &lt; value)\n            if operation == FilterOperationType.LESS_THAN_OR_EQUAL:\n                return query.where(field &lt;= value)\n            if operation == FilterOperationType.GREATER_THAN:\n                return query.where(field &gt; value)\n            if operation == FilterOperationType.GREATER_THAN_OR_EQUAL:\n                return query.where(field &gt;= value)\n            if operation == FilterOperationType.IN_LIST:\n                return query.where(field.in_(value))\n            if operation == FilterOperationType.NOT_IN_LIST:\n                return query.where(~field.in_(value))\n            if operation == FilterOperationType.LIKE:\n                return query.where(field.like(f\"%{value}%\"))\n            if operation == FilterOperationType.ILIKE:\n                return query.where(field.ilike(f\"%{value}%\"))\n            if operation == FilterOperationType.STARTS_WITH:\n                return query.where(field.startswith(value))\n            if operation == FilterOperationType.ENDS_WITH:\n                return query.where(field.endswith(value))\n            if operation == FilterOperationType.CONTAINS:\n                return query.where(field.contains(value))\n            if operation == FilterOperationType.IS_NULL:\n                return query.where(field.is_(None))\n            if operation == FilterOperationType.IS_NOT_NULL:\n                return query.where(field.isnot(None))\n        return query\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyPaginationMixin","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyPaginationMixin</code>","text":"<p>Mixin providing pagination capabilities for SQLAlchemy queries.</p> <p>This mixin defines methods for applying pagination to SQLAlchemy queries, supporting common pagination operations like limiting results and applying offsets.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class SqlAlchemyPaginationMixin:\n    \"\"\"Mixin providing pagination capabilities for SQLAlchemy queries.\n\n    This mixin defines methods for applying pagination to SQLAlchemy queries,\n    supporting common pagination operations like limiting results and applying offsets.\n    \"\"\"\n\n    @staticmethod\n    def _apply_pagination(query: Select, pagination: PaginationDTO | None) -&gt; Select:\n        if pagination is None:\n            return query\n        return query.limit(pagination.page_size).offset(pagination.offset)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemySortMixin","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemySortMixin</code>","text":"<p>Mixin providing sorting capabilities for SQLAlchemy queries.</p> <p>This mixin defines methods for applying various sorting operations to SQLAlchemy queries, supporting dynamic column selection and ordering direction.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class SqlAlchemySortMixin:\n    \"\"\"Mixin providing sorting capabilities for SQLAlchemy queries.\n\n    This mixin defines methods for applying various sorting operations to SQLAlchemy queries,\n    supporting dynamic column selection and ordering direction.\n    \"\"\"\n\n    @staticmethod\n    def _apply_sorting(entity: type[BaseEntity], query: Select, sort_info: SortDTO | None) -&gt; Select:\n        if sort_info is None:\n            return query\n        if isinstance(sort_info.column, str):\n            sort_column = getattr(entity, sort_info.column)\n        elif isinstance(sort_info.column, Enum):\n            sort_column = getattr(entity, sort_info.column.name.lower())\n        else:\n            sort_column = sort_info.column\n\n        order_value: str = sort_info.order.value if isinstance(sort_info.order, Enum) else sort_info.order\n        if order_value == SortOrderType.ASCENDING.value:\n            return query.order_by(sort_column.asc())\n        elif order_value == SortOrderType.DESCENDING.value:\n            return query.order_by(sort_column.desc())\n        else:\n            raise InvalidArgumentError(argument_name=\"sort_info.order\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter</code>","text":"<p>               Bases: <code>SqlAlchemyPort</code>, <code>SqlAlchemyPaginationMixin</code>, <code>SqlAlchemySortMixin</code></p> <p>Database adapter for SQLAlchemy ORM operations.</p> <p>This adapter provides a standardized interface for performing database operations using SQLAlchemy ORM. It implements common operations like create, read, update, delete (CRUD), along with advanced features for pagination, sorting, and filtering.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class SqlAlchemyAdapter(SqlAlchemyPort, SqlAlchemyPaginationMixin, SqlAlchemySortMixin):\n    \"\"\"Database adapter for SQLAlchemy ORM operations.\n\n    This adapter provides a standardized interface for performing database operations\n    using SQLAlchemy ORM. It implements common operations like create, read, update,\n    delete (CRUD), along with advanced features for pagination, sorting, and filtering.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for SQLAlchemy.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initializes the SQLAlchemy adapter.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n        \"\"\"\n        # Get configurations from global config if not provided\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.session_manager = SessionManagerAdapter(configs)\n\n    @override\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        try:\n            if sort_info is None:\n                sort_info = SortDTO.default()\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n\n            result_set = session.execute(paginated_query)\n            results = list(result_set.scalars().all())\n\n            count_query = select(func.count()).select_from(query.subquery())\n            count_result = session.execute(count_query)\n            total_count = count_result.scalar_one()\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Database query failed: {e!s}\",\n            ) from e\n        else:\n            return results, total_count\n\n    @override\n    def get_session(self) -&gt; Session:\n        return self.session_manager.get_session()\n\n    @override\n    def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database.\n\n        Args:\n            entity (BaseEntity): The entity to be created.\n\n        Returns:\n            BaseEntity | None: The created entity with updated attributes\n                (e.g., generated ID), or None if creation failed.\n\n        Raises:\n            InvalidEntityTypeError: If the provided entity is not a BaseEntity.\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        try:\n            session = self.get_session()\n            session.add(entity)\n            session.flush()\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Entity creation failed: {e!s}\",\n            ) from e\n        else:\n            return entity\n\n    @override\n    def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in a single database operation.\n\n        Args:\n            entities: List of entity objects to create.\n\n        Returns:\n            The list of created entities with updated attributes (e.g., generated IDs),\n            or None if creation failed.\n\n        Raises:\n            InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n            InternalError: If the database operation fails.\n        \"\"\"\n        # Check that all entities are valid\n        for entity in entities:\n            if not isinstance(entity, BaseEntity):\n                raise InvalidEntityTypeError(entity, BaseEntity)\n\n        try:\n            session = self.get_session()\n            session.add_all(entities)\n            session.flush()\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Bulk create operation failed: {e!s}\",\n            ) from e\n        else:\n            return entities\n\n    @override\n    def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID.\n\n        Args:\n            entity_type (type): The entity class to query.\n            entity_uuid (UUID): The UUID of the entity to retrieve.\n\n        Returns:\n            Any: The retrieved entity or None if not found.\n\n        Raises:\n            InvalidEntityTypeError: If entity_type is not a subclass of BaseEntity\n                or if entity_uuid is not a UUID.\n        \"\"\"\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(entity_type, BaseEntity)\n        if not isinstance(entity_uuid, UUID):\n            raise InvalidEntityTypeError(entity_uuid, UUID)\n        try:\n            session = self.get_session()\n            return session.get(entity_type, entity_uuid)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Entity retrieval by UUID failed: {e!s}\",\n            ) from e\n\n    @override\n    def delete(self, entity: BaseEntity) -&gt; None:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        try:\n            session = self.get_session()\n            session.delete(entity)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Entity deletion failed: {e!s}\",\n            ) from e\n\n    @override\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities in a sequence of operations.\n\n        Args:\n            entities: List of entity objects to delete.\n\n        Raises:\n            InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n            InternalError: If the database operation fails.\n        \"\"\"\n        try:\n            for entity in entities:\n                self.delete(entity)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Bulk delete operation failed: {e!s}\",\n            ) from e\n\n    @override\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Executes a raw SQL statement.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The execution result.\n\n        Raises:\n            InternalError: If the statement execution fails.\n        \"\"\"\n        try:\n            session = self.get_session()\n            return session.execute(statement, params)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Statement execution failed: {e!s}\",\n            ) from e\n\n    @override\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Executes a statement and returns the scalar result.\n\n        This is a convenience method that executes a statement and\n        returns the scalar result directly.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The scalar result of executing the statement.\n\n        Raises:\n            InternalError: If the statement execution fails.\n        \"\"\"\n        try:\n            session = self.get_session()\n            return session.scalars(statement, params)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Scalar query failed: {e!s}\",\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.__init__","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initializes the SQLAlchemy adapter.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config.</p> <code>None</code> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initializes the SQLAlchemy adapter.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n    \"\"\"\n    # Get configurations from global config if not provided\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    self.session_manager = SessionManagerAdapter(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.create","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.create(entity)</code>","text":"<p>Creates a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to be created.</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>BaseEntity | None: The created entity with updated attributes (e.g., generated ID), or None if creation failed.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the provided entity is not a BaseEntity.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database.\n\n    Args:\n        entity (BaseEntity): The entity to be created.\n\n    Returns:\n        BaseEntity | None: The created entity with updated attributes\n            (e.g., generated ID), or None if creation failed.\n\n    Raises:\n        InvalidEntityTypeError: If the provided entity is not a BaseEntity.\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(entity, BaseEntity)\n    try:\n        session = self.get_session()\n        session.add(entity)\n        session.flush()\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Entity creation failed: {e!s}\",\n        ) from e\n    else:\n        return entity\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.bulk_create","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.bulk_create(entities)</code>","text":"<p>Creates multiple entities in a single database operation.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entity objects to create.</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities with updated attributes (e.g., generated IDs),</p> <code>list[BaseEntity] | None</code> <p>or None if creation failed.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any of the provided entities is not a BaseEntity.</p> <code>InternalError</code> <p>If the database operation fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in a single database operation.\n\n    Args:\n        entities: List of entity objects to create.\n\n    Returns:\n        The list of created entities with updated attributes (e.g., generated IDs),\n        or None if creation failed.\n\n    Raises:\n        InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n        InternalError: If the database operation fails.\n    \"\"\"\n    # Check that all entities are valid\n    for entity in entities:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n\n    try:\n        session = self.get_session()\n        session.add_all(entities)\n        session.flush()\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Bulk create operation failed: {e!s}\",\n        ) from e\n    else:\n        return entities\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.get_by_uuid","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.get_by_uuid(entity_type, entity_uuid)</code>","text":"<p>Retrieves an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The entity class to query.</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>BaseEntity | None</code> <p>The retrieved entity or None if not found.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If entity_type is not a subclass of BaseEntity or if entity_uuid is not a UUID.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID.\n\n    Args:\n        entity_type (type): The entity class to query.\n        entity_uuid (UUID): The UUID of the entity to retrieve.\n\n    Returns:\n        Any: The retrieved entity or None if not found.\n\n    Raises:\n        InvalidEntityTypeError: If entity_type is not a subclass of BaseEntity\n            or if entity_uuid is not a UUID.\n    \"\"\"\n    if not issubclass(entity_type, BaseEntity):\n        raise InvalidEntityTypeError(entity_type, BaseEntity)\n    if not isinstance(entity_uuid, UUID):\n        raise InvalidEntityTypeError(entity_uuid, UUID)\n    try:\n        session = self.get_session()\n        return session.get(entity_type, entity_uuid)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Entity retrieval by UUID failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.bulk_delete","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.bulk_delete(entities)</code>","text":"<p>Deletes multiple entities in a sequence of operations.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entity objects to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any of the provided entities is not a BaseEntity.</p> <code>InternalError</code> <p>If the database operation fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities in a sequence of operations.\n\n    Args:\n        entities: List of entity objects to delete.\n\n    Raises:\n        InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n        InternalError: If the database operation fails.\n    \"\"\"\n    try:\n        for entity in entities:\n            self.delete(entity)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Bulk delete operation failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.execute","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.execute(statement, params=None)</code>","text":"<p>Executes a raw SQL statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The execution result.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If the statement execution fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Executes a raw SQL statement.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The execution result.\n\n    Raises:\n        InternalError: If the statement execution fails.\n    \"\"\"\n    try:\n        session = self.get_session()\n        return session.execute(statement, params)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Statement execution failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.scalars","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.scalars(statement, params=None)</code>","text":"<p>Executes a statement and returns the scalar result.</p> <p>This is a convenience method that executes a statement and returns the scalar result directly.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar result of executing the statement.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If the statement execution fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Executes a statement and returns the scalar result.\n\n    This is a convenience method that executes a statement and\n    returns the scalar result directly.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The scalar result of executing the statement.\n\n    Raises:\n        InternalError: If the statement execution fails.\n    \"\"\"\n    try:\n        session = self.get_session()\n        return session.scalars(statement, params)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Scalar query failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncSqlAlchemyPort</code>, <code>SqlAlchemyPaginationMixin</code>, <code>SqlAlchemySortMixin</code></p> <p>Asynchronous database adapter for SQLAlchemy ORM operations.</p> <p>This adapter provides an asynchronous interface for performing database operations using SQLAlchemy's async capabilities. It implements common operations like create, read, update, delete (CRUD), along with advanced features for pagination, sorting, and filtering.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class AsyncSqlAlchemyAdapter(AsyncSqlAlchemyPort, SqlAlchemyPaginationMixin, SqlAlchemySortMixin):\n    \"\"\"Asynchronous database adapter for SQLAlchemy ORM operations.\n\n    This adapter provides an asynchronous interface for performing database operations\n    using SQLAlchemy's async capabilities. It implements common operations like\n    create, read, update, delete (CRUD), along with advanced features for pagination,\n    sorting, and filtering.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for SQLAlchemy.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initializes the async SQLAlchemy adapter.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n        \"\"\"\n        # Get configurations from global config if not provided\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.session_manager = AsyncSessionManagerAdapter(configs)\n\n    @override\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Execute a search query with pagination and sorting.\n\n        This method executes a SELECT query with pagination and sorting applied,\n        and returns both the results and the total count of matching records.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Pagination settings (page number and page size)\n            sort_info: Sorting information (column and direction)\n\n        Returns:\n            A tuple containing:\n                - List of entities matching the query\n                - Total count of matching records (ignoring pagination)\n\n        Raises:\n            InvalidEntityTypeError: If the entity type is invalid\n            InternalError: If the database query fails for any other reason\n        \"\"\"\n        try:\n            if sort_info is None:\n                sort_info = SortDTO.default()\n\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n\n            result_set = await session.execute(paginated_query)\n            results = list(result_set.scalars().all())\n\n            count_query = select(func.count()).select_from(query.subquery())\n            count_result = await session.execute(count_query)\n            total_count = count_result.scalar_one()\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(details=f\"Database query failed: {e!s}\") from e\n        else:\n            return results, total_count\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        return self.session_manager.get_session()\n\n    @override\n    async def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        try:\n            session: AsyncSession = self.get_session()\n            session.add(entity)\n            await session.flush()\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async entity creation failed: {e!s}\",\n            ) from e\n        else:\n            return entity\n\n    @override\n    async def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in a single asynchronous database operation.\n\n        Args:\n            entities: List of entity objects to create.\n\n        Returns:\n            The list of created entities with updated attributes (e.g., generated IDs),\n            or None if creation failed.\n\n        Raises:\n            InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n            InternalError: If the database operation fails.\n        \"\"\"\n        # Check that all entities are valid\n        for entity in entities:\n            if not isinstance(entity, BaseEntity):\n                raise InvalidEntityTypeError(entity, BaseEntity)\n\n        try:\n            session = self.get_session()\n            session.add_all(entities)\n            await session.flush()\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async bulk create operation failed: {e!s}\",\n            ) from e\n        else:\n            return entities\n\n    @override\n    async def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; Any | None:\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(entity_type, BaseEntity)\n        if not isinstance(entity_uuid, UUID):\n            raise InvalidEntityTypeError(entity_uuid, UUID)\n        try:\n            session = self.get_session()\n            return await session.get(entity_type, entity_uuid)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async entity retrieval by UUID failed: {e!s}\",\n            ) from e\n\n    @override\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        try:\n            session = self.get_session()\n            await session.delete(entity)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async entity deletion failed: {e!s}\",\n            ) from e\n\n    @override\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities in a sequence of asynchronous operations.\n\n        Args:\n            entities: List of entity objects to delete.\n\n        Raises:\n            InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n            InternalError: If the database operation fails.\n        \"\"\"\n        try:\n            for entity in entities:\n                await self.delete(entity)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async bulk delete operation failed: {e!s}\",\n            ) from e\n\n    @override\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        \"\"\"Executes a raw SQL statement asynchronously.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The asynchronous execution result.\n\n        Raises:\n            InternalError: If the statement execution fails.\n        \"\"\"\n        try:\n            session = self.get_session()\n            return await session.execute(statement, params)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async statement execution failed: {e!s}\",\n            ) from e\n\n    @override\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n        This is a convenience method that executes a statement and\n        returns the scalar result directly using async operations.\n\n        Args:\n            statement: The SQLAlchemy statement to execute.\n            params: Optional parameters for the statement.\n\n        Returns:\n            The scalar result of executing the statement asynchronously.\n\n        Raises:\n            InternalError: If the statement execution fails.\n        \"\"\"\n        try:\n            session = self.get_session()\n            return await session.scalars(statement, params)\n        except Exception as e:\n            # Convert generic exceptions to InternalError\n            raise InternalError(\n                details=f\"Async scalar query failed: {e!s}\",\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.__init__","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.__init__(orm_config=None)</code>","text":"<p>Initializes the async SQLAlchemy adapter.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config.</p> <code>None</code> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initializes the async SQLAlchemy adapter.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n    \"\"\"\n    # Get configurations from global config if not provided\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    self.session_manager = AsyncSessionManagerAdapter(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.execute_search_query","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.execute_search_query(entity, query, pagination, sort_info=None)</code>  <code>async</code>","text":"<p>Execute a search query with pagination and sorting.</p> <p>This method executes a SELECT query with pagination and sorting applied, and returns both the results and the total count of matching records.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Pagination settings (page number and page size)</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Sorting information (column and direction)</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing: - List of entities matching the query - Total count of matching records (ignoring pagination)</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the entity type is invalid</p> <code>InternalError</code> <p>If the database query fails for any other reason</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Execute a search query with pagination and sorting.\n\n    This method executes a SELECT query with pagination and sorting applied,\n    and returns both the results and the total count of matching records.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Pagination settings (page number and page size)\n        sort_info: Sorting information (column and direction)\n\n    Returns:\n        A tuple containing:\n            - List of entities matching the query\n            - Total count of matching records (ignoring pagination)\n\n    Raises:\n        InvalidEntityTypeError: If the entity type is invalid\n        InternalError: If the database query fails for any other reason\n    \"\"\"\n    try:\n        if sort_info is None:\n            sort_info = SortDTO.default()\n\n        session = self.get_session()\n        sorted_query = self._apply_sorting(entity, query, sort_info)\n        paginated_query = self._apply_pagination(sorted_query, pagination)\n\n        result_set = await session.execute(paginated_query)\n        results = list(result_set.scalars().all())\n\n        count_query = select(func.count()).select_from(query.subquery())\n        count_result = await session.execute(count_query)\n        total_count = count_result.scalar_one()\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(details=f\"Database query failed: {e!s}\") from e\n    else:\n        return results, total_count\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.bulk_create","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.bulk_create(entities)</code>  <code>async</code>","text":"<p>Creates multiple entities in a single asynchronous database operation.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entity objects to create.</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities with updated attributes (e.g., generated IDs),</p> <code>list[BaseEntity] | None</code> <p>or None if creation failed.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any of the provided entities is not a BaseEntity.</p> <code>InternalError</code> <p>If the database operation fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in a single asynchronous database operation.\n\n    Args:\n        entities: List of entity objects to create.\n\n    Returns:\n        The list of created entities with updated attributes (e.g., generated IDs),\n        or None if creation failed.\n\n    Raises:\n        InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n        InternalError: If the database operation fails.\n    \"\"\"\n    # Check that all entities are valid\n    for entity in entities:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n\n    try:\n        session = self.get_session()\n        session.add_all(entities)\n        await session.flush()\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Async bulk create operation failed: {e!s}\",\n        ) from e\n    else:\n        return entities\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.bulk_delete","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.bulk_delete(entities)</code>  <code>async</code>","text":"<p>Deletes multiple entities in a sequence of asynchronous operations.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entity objects to delete.</p> required <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If any of the provided entities is not a BaseEntity.</p> <code>InternalError</code> <p>If the database operation fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities in a sequence of asynchronous operations.\n\n    Args:\n        entities: List of entity objects to delete.\n\n    Raises:\n        InvalidEntityTypeError: If any of the provided entities is not a BaseEntity.\n        InternalError: If the database operation fails.\n    \"\"\"\n    try:\n        for entity in entities:\n            await self.delete(entity)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Async bulk delete operation failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.execute","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.execute(statement, params=None)</code>  <code>async</code>","text":"<p>Executes a raw SQL statement asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[Any]</code> <p>The asynchronous execution result.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If the statement execution fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n    \"\"\"Executes a raw SQL statement asynchronously.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The asynchronous execution result.\n\n    Raises:\n        InternalError: If the statement execution fails.\n    \"\"\"\n    try:\n        session = self.get_session()\n        return await session.execute(statement, params)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Async statement execution failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.scalars","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.scalars(statement, params=None)</code>  <code>async</code>","text":"<p>Executes a statement and returns the scalar result asynchronously.</p> <p>This is a convenience method that executes a statement and returns the scalar result directly using async operations.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQLAlchemy statement to execute.</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the statement.</p> <code>None</code> <p>Returns:</p> Type Description <code>ScalarResult[Any]</code> <p>The scalar result of executing the statement asynchronously.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If the statement execution fails.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n    \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n    This is a convenience method that executes a statement and\n    returns the scalar result directly using async operations.\n\n    Args:\n        statement: The SQLAlchemy statement to execute.\n        params: Optional parameters for the statement.\n\n    Returns:\n        The scalar result of executing the statement asynchronously.\n\n    Raises:\n        InternalError: If the statement execution fails.\n    \"\"\"\n    try:\n        session = self.get_session()\n        return await session.scalars(statement, params)\n    except Exception as e:\n        # Convert generic exceptions to InternalError\n        raise InternalError(\n            details=f\"Async scalar query failed: {e!s}\",\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter</code>","text":"<p>               Bases: <code>SessionManagerPort</code></p> <p>Manages SQLAlchemy database sessions for synchronous operations.</p> <p>This adapter creates and manages database sessions using SQLAlchemy's session management system. It implements the Singleton pattern to ensure a single instance exists throughout the application lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for the ORM. If None, retrieves from global config. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\n&gt;&gt;&gt; from archipy.configs.config_template import SqlAlchemyConfig\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using default global configuration\n&gt;&gt;&gt; manager = SessionManagerAdapter()\n&gt;&gt;&gt; session = manager.get_session()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using custom configuration\n&gt;&gt;&gt; custom_config = SqlAlchemyConfig(DATABASE=\"custom_db\", HOST=\"localhost\")\n&gt;&gt;&gt; custom_manager = SessionManagerAdapter(custom_config)\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>class SessionManagerAdapter(SessionManagerPort, metaclass=Singleton):\n    \"\"\"Manages SQLAlchemy database sessions for synchronous operations.\n\n    This adapter creates and manages database sessions using SQLAlchemy's\n    session management system. It implements the Singleton pattern to ensure\n    a single instance exists throughout the application lifecycle.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for the ORM.\n            If None, retrieves from global config. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\n        &gt;&gt;&gt; from archipy.configs.config_template import SqlAlchemyConfig\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using default global configuration\n        &gt;&gt;&gt; manager = SessionManagerAdapter()\n        &gt;&gt;&gt; session = manager.get_session()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using custom configuration\n        &gt;&gt;&gt; custom_config = SqlAlchemyConfig(DATABASE=\"custom_db\", HOST=\"localhost\")\n        &gt;&gt;&gt; custom_manager = SessionManagerAdapter(custom_config)\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initializes the session manager.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.engine = self._create_engine(configs)\n        self._session_generator = self._get_session_generator()\n\n    @override\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieves a SQLAlchemy session from the session factory.\n\n        The session is scoped to the current context to ensure thread safety.\n\n        Returns:\n            Session: A SQLAlchemy session instance that can be used for\n                database operations.\n\n        Examples:\n            &gt;&gt;&gt; session = session_manager.get_session()\n            &gt;&gt;&gt; user = session.query(User).filter_by(id=1).first()\n        \"\"\"\n        return self._session_generator()  # type: ignore[no-any-return]\n\n    @override\n    def remove_session(self) -&gt; None:\n        \"\"\"Removes the current session from the registry.\n\n        This should be called when you're done with a session to prevent\n        resource leaks, particularly at the end of web requests.\n\n        Examples:\n            &gt;&gt;&gt; session = session_manager.get_session()\n            &gt;&gt;&gt; # Use session for operations\n            &gt;&gt;&gt; session_manager.remove_session()\n        \"\"\"\n        self._session_generator.remove()\n\n    def _get_session_generator(self) -&gt; scoped_session:\n        session_maker = sessionmaker(self.engine)\n        return scoped_session(session_maker)\n\n    @staticmethod\n    def _create_engine(configs: SqlAlchemyConfig) -&gt; Engine:\n        url = URL.create(\n            drivername=configs.DRIVER_NAME,\n            username=configs.USERNAME,\n            password=configs.PASSWORD,\n            host=configs.HOST,\n            port=configs.PORT,\n            database=configs.DATABASE,\n        )\n        return create_engine(\n            url,\n            isolation_level=configs.ISOLATION_LEVEL,\n            echo=configs.ECHO,\n            echo_pool=configs.ECHO_POOL,\n            enable_from_linting=configs.ENABLE_FROM_LINTING,\n            hide_parameters=configs.HIDE_PARAMETERS,\n            pool_pre_ping=configs.POOL_PRE_PING,\n            pool_size=configs.POOL_SIZE,\n            pool_recycle=configs.POOL_RECYCLE_SECONDS,\n            pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n            pool_timeout=configs.POOL_TIMEOUT,\n            pool_use_lifo=configs.POOL_USE_LIFO,\n            query_cache_size=configs.QUERY_CACHE_SIZE,\n            max_overflow=configs.POOL_MAX_OVERFLOW,\n        )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.__init__","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.__init__(orm_config=None)</code>","text":"<p>Initializes the session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config.</p> <code>None</code> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initializes the session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    self.engine = self._create_engine(configs)\n    self._session_generator = self._get_session_generator()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.get_session","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.get_session()</code>","text":"<p>Retrieves a SQLAlchemy session from the session factory.</p> <p>The session is scoped to the current context to ensure thread safety.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session instance that can be used for database operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; session = session_manager.get_session()\n&gt;&gt;&gt; user = session.query(User).filter_by(id=1).first()\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieves a SQLAlchemy session from the session factory.\n\n    The session is scoped to the current context to ensure thread safety.\n\n    Returns:\n        Session: A SQLAlchemy session instance that can be used for\n            database operations.\n\n    Examples:\n        &gt;&gt;&gt; session = session_manager.get_session()\n        &gt;&gt;&gt; user = session.query(User).filter_by(id=1).first()\n    \"\"\"\n    return self._session_generator()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.remove_session","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.remove_session()</code>","text":"<p>Removes the current session from the registry.</p> <p>This should be called when you're done with a session to prevent resource leaks, particularly at the end of web requests.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; session = session_manager.get_session()\n&gt;&gt;&gt; # Use session for operations\n&gt;&gt;&gt; session_manager.remove_session()\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>@override\ndef remove_session(self) -&gt; None:\n    \"\"\"Removes the current session from the registry.\n\n    This should be called when you're done with a session to prevent\n    resource leaks, particularly at the end of web requests.\n\n    Examples:\n        &gt;&gt;&gt; session = session_manager.get_session()\n        &gt;&gt;&gt; # Use session for operations\n        &gt;&gt;&gt; session_manager.remove_session()\n    \"\"\"\n    self._session_generator.remove()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter</code>","text":"<p>               Bases: <code>AsyncSessionManagerPort</code></p> <p>Manages SQLAlchemy database sessions for asynchronous operations.</p> <p>This adapter creates and manages asynchronous database sessions using SQLAlchemy's async session management system. It implements the Singleton pattern to ensure a single instance exists throughout the application lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for the ORM. If None, retrieves from global config. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.session_manager_adapters import AsyncSessionManagerAdapter\n&gt;&gt;&gt; from archipy.configs.config_template import SqlAlchemyConfig\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using default global configuration\n&gt;&gt;&gt; manager = AsyncSessionManagerAdapter()\n&gt;&gt;&gt; session = manager.get_session()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using custom configuration\n&gt;&gt;&gt; custom_config = SqlAlchemyConfig(DATABASE=\"custom_db\", HOST=\"localhost\")\n&gt;&gt;&gt; custom_manager = AsyncSessionManagerAdapter(custom_config)\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>class AsyncSessionManagerAdapter(AsyncSessionManagerPort, metaclass=Singleton):\n    \"\"\"Manages SQLAlchemy database sessions for asynchronous operations.\n\n    This adapter creates and manages asynchronous database sessions using SQLAlchemy's\n    async session management system. It implements the Singleton pattern to ensure\n    a single instance exists throughout the application lifecycle.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for the ORM.\n            If None, retrieves from global config. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.session_manager_adapters import AsyncSessionManagerAdapter\n        &gt;&gt;&gt; from archipy.configs.config_template import SqlAlchemyConfig\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using default global configuration\n        &gt;&gt;&gt; manager = AsyncSessionManagerAdapter()\n        &gt;&gt;&gt; session = manager.get_session()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using custom configuration\n        &gt;&gt;&gt; custom_config = SqlAlchemyConfig(DATABASE=\"custom_db\", HOST=\"localhost\")\n        &gt;&gt;&gt; custom_manager = AsyncSessionManagerAdapter(custom_config)\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        \"\"\"Initializes the async session manager.\n\n        Args:\n            orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n        \"\"\"\n        configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.engine = self._create_async_engine(configs)\n        self._session_generator = self._get_session_generator()\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Retrieves an async SQLAlchemy session from the session factory.\n\n        The session is scoped to the current async task to ensure task safety.\n\n        Returns:\n            AsyncSession: An async SQLAlchemy session instance that can be used for\n                database operations.\n\n        Examples:\n            &gt;&gt;&gt; session = await session_manager.get_session()\n            &gt;&gt;&gt; user = await session.get(User, 1)\n        \"\"\"\n        return self._session_generator()  # type: ignore[no-any-return]\n\n    @override\n    async def remove_session(self) -&gt; None:\n        \"\"\"Removes the current async session from the registry.\n\n        This should be called when you're done with a session to prevent\n        resource leaks, particularly at the end of async web requests.\n\n        Examples:\n            &gt;&gt;&gt; session = session_manager.get_session()\n            &gt;&gt;&gt; # Use session for operations\n            &gt;&gt;&gt; await session_manager.remove_session()\n        \"\"\"\n        await self._session_generator.remove()\n\n    def _get_session_generator(self) -&gt; async_scoped_session:\n        \"\"\"Creates and returns a scoped session factory for async sessions.\n\n        Returns:\n            An async_scoped_session instance scoped to the current task.\n        \"\"\"\n        session_maker: async_sessionmaker = async_sessionmaker(self.engine)\n        return async_scoped_session(session_maker, current_task)\n\n    @staticmethod\n    def _create_async_engine(configs: SqlAlchemyConfig) -&gt; AsyncEngine:\n        \"\"\"Creates an async SQLAlchemy engine from configuration.\n\n        Args:\n            configs: The SQLAlchemy configuration.\n\n        Returns:\n            An AsyncEngine instance configured according to the provided config.\n        \"\"\"\n        url = URL.create(\n            drivername=configs.DRIVER_NAME,\n            username=configs.USERNAME,\n            password=configs.PASSWORD,\n            host=configs.HOST,\n            port=configs.PORT,\n            database=configs.DATABASE,\n        )\n        return create_async_engine(\n            url,\n            isolation_level=configs.ISOLATION_LEVEL,\n            echo=configs.ECHO,\n            echo_pool=configs.ECHO_POOL,\n            enable_from_linting=configs.ENABLE_FROM_LINTING,\n            hide_parameters=configs.HIDE_PARAMETERS,\n            pool_pre_ping=configs.POOL_PRE_PING,\n            pool_size=configs.POOL_SIZE,\n            pool_recycle=configs.POOL_RECYCLE_SECONDS,\n            pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n            pool_timeout=configs.POOL_TIMEOUT,\n            pool_use_lifo=configs.POOL_USE_LIFO,\n            query_cache_size=configs.QUERY_CACHE_SIZE,\n            max_overflow=configs.POOL_MAX_OVERFLOW,\n        )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter.__init__","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter.__init__(orm_config=None)</code>","text":"<p>Initializes the async session manager.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig | None</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config.</p> <code>None</code> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n    \"\"\"Initializes the async session manager.\n\n    Args:\n        orm_config: Configuration for SQLAlchemy. If None, retrieves from global config.\n    \"\"\"\n    configs = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n    self.engine = self._create_async_engine(configs)\n    self._session_generator = self._get_session_generator()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter.get_session","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter.get_session()</code>","text":"<p>Retrieves an async SQLAlchemy session from the session factory.</p> <p>The session is scoped to the current async task to ensure task safety.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>An async SQLAlchemy session instance that can be used for database operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; session = await session_manager.get_session()\n&gt;&gt;&gt; user = await session.get(User, 1)\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Retrieves an async SQLAlchemy session from the session factory.\n\n    The session is scoped to the current async task to ensure task safety.\n\n    Returns:\n        AsyncSession: An async SQLAlchemy session instance that can be used for\n            database operations.\n\n    Examples:\n        &gt;&gt;&gt; session = await session_manager.get_session()\n        &gt;&gt;&gt; user = await session.get(User, 1)\n    \"\"\"\n    return self._session_generator()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter.remove_session","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.AsyncSessionManagerAdapter.remove_session()</code>  <code>async</code>","text":"<p>Removes the current async session from the registry.</p> <p>This should be called when you're done with a session to prevent resource leaks, particularly at the end of async web requests.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; session = session_manager.get_session()\n&gt;&gt;&gt; # Use session for operations\n&gt;&gt;&gt; await session_manager.remove_session()\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>@override\nasync def remove_session(self) -&gt; None:\n    \"\"\"Removes the current async session from the registry.\n\n    This should be called when you're done with a session to prevent\n    resource leaks, particularly at the end of async web requests.\n\n    Examples:\n        &gt;&gt;&gt; session = session_manager.get_session()\n        &gt;&gt;&gt; # Use session for operations\n        &gt;&gt;&gt; await session_manager.remove_session()\n    \"\"\"\n    await self._session_generator.remove()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports","title":"<code>archipy.adapters.orm.sqlalchemy.ports</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort</code>","text":"<p>Abstract interface defining synchronous SQLAlchemy database operations.</p> <p>This interface defines the contract that all synchronous SQLAlchemy adapters must implement, providing standard methods for database operations like create, read, update, delete (CRUD), as well as search and transaction management.</p> <p>Implementations of this interface are responsible for handling the specific details of database interactions and connection management.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>class SqlAlchemyPort:\n    \"\"\"Abstract interface defining synchronous SQLAlchemy database operations.\n\n    This interface defines the contract that all synchronous SQLAlchemy adapters must\n    implement, providing standard methods for database operations like create,\n    read, update, delete (CRUD), as well as search and transaction management.\n\n    Implementations of this interface are responsible for handling the specific\n    details of database interactions and connection management.\n    \"\"\"\n\n    @abstractmethod\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieves a SQLAlchemy session for database operations.\n\n        Returns:\n            Session: A SQLAlchemy session object\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Executes a search query with pagination and sorting.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Optional pagination settings\n            sort_info: Optional sorting information\n\n        Returns:\n            A tuple containing the list of entities and the total count\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database.\n\n        Args:\n            entity: The entity to create\n\n        Returns:\n            The created entity (with updated attributes) or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in the database.\n\n        Args:\n            entities: List of entities to create\n\n        Returns:\n            The list of created entities or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID.\n\n        Args:\n            entity_type: The type of entity to retrieve\n            entity_uuid: The UUID of the entity\n\n        Returns:\n            The entity if found, None otherwise\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Deletes an entity from the database.\n\n        Args:\n            entity: The entity to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities from the database.\n\n        Args:\n            entities: List of entities to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a raw SQL statement.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The result of the execution\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a statement and returns the scalar result.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The scalar result of the execution\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.get_session","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.get_session()</code>  <code>abstractmethod</code>","text":"<p>Retrieves a SQLAlchemy session for database operations.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session object</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieves a SQLAlchemy session for database operations.\n\n    Returns:\n        Session: A SQLAlchemy session object\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.execute_search_query","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.execute_search_query(entity, query, pagination=None, sort_info=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a search query with pagination and sorting.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings</p> <code>None</code> <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing the list of entities and the total count</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None = None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Executes a search query with pagination and sorting.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Optional pagination settings\n        sort_info: Optional sorting information\n\n    Returns:\n        A tuple containing the list of entities and the total count\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.create","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.create(entity)</code>  <code>abstractmethod</code>","text":"<p>Creates a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity (with updated attributes) or None if creation failed</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database.\n\n    Args:\n        entity: The entity to create\n\n    Returns:\n        The created entity (with updated attributes) or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.bulk_create","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.bulk_create(entities)</code>  <code>abstractmethod</code>","text":"<p>Creates multiple entities in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities or None if creation failed</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in the database.\n\n    Args:\n        entities: List of entities to create\n\n    Returns:\n        The list of created entities or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.get_by_uuid","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.get_by_uuid(entity_type, entity_uuid)</code>  <code>abstractmethod</code>","text":"<p>Retrieves an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID.\n\n    Args:\n        entity_type: The type of entity to retrieve\n        entity_uuid: The UUID of the entity\n\n    Returns:\n        The entity if found, None otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.delete","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.delete(entity)</code>  <code>abstractmethod</code>","text":"<p>Deletes an entity from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete</p> required Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Deletes an entity from the database.\n\n    Args:\n        entity: The entity to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.bulk_delete","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.bulk_delete(entities)</code>  <code>abstractmethod</code>","text":"<p>Deletes multiple entities from the database.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete</p> required Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities from the database.\n\n    Args:\n        entities: List of entities to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.execute","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.execute(statement, params=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a raw SQL statement.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the execution</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a raw SQL statement.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.scalars","title":"<code>archipy.adapters.orm.sqlalchemy.ports.SqlAlchemyPort.scalars(statement, params=None)</code>  <code>abstractmethod</code>","text":"<p>Executes a statement and returns the scalar result.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The scalar result of the execution</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a statement and returns the scalar result.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The scalar result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort</code>","text":"<p>Abstract interface defining asynchronous SQLAlchemy database operations.</p> <p>This interface defines the contract that all asynchronous SQLAlchemy adapters must implement, providing standard methods for database operations like create, read, update, delete (CRUD), as well as search and transaction management.</p> <p>Implementations of this interface are responsible for handling the specific details of asynchronous database interactions and connection management.</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>class AsyncSqlAlchemyPort:\n    \"\"\"Abstract interface defining asynchronous SQLAlchemy database operations.\n\n    This interface defines the contract that all asynchronous SQLAlchemy adapters must\n    implement, providing standard methods for database operations like create,\n    read, update, delete (CRUD), as well as search and transaction management.\n\n    Implementations of this interface are responsible for handling the specific\n    details of asynchronous database interactions and connection management.\n    \"\"\"\n\n    @abstractmethod\n    def get_session(self) -&gt; AsyncSession:\n        \"\"\"Retrieves an asynchronous SQLAlchemy session for database operations.\n\n        Returns:\n            AsyncSession: An asynchronous SQLAlchemy session object\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = None,\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Executes a search query with pagination and sorting asynchronously.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Optional pagination settings\n            sort_info: Optional sorting information\n\n        Returns:\n            A tuple containing the list of entities and the total count\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database asynchronously.\n\n        Args:\n            entity: The entity to create\n\n        Returns:\n            The created entity (with updated attributes) or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        \"\"\"Creates multiple entities in the database asynchronously.\n\n        Args:\n            entities: List of entities to create\n\n        Returns:\n            The list of created entities or None if creation failed\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n        \"\"\"Retrieves an entity by its UUID asynchronously.\n\n        Args:\n            entity_type: The type of entity to retrieve\n            entity_uuid: The UUID of the entity\n\n        Returns:\n            The entity if found, None otherwise\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        \"\"\"Deletes an entity from the database asynchronously.\n\n        Args:\n            entity: The entity to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        \"\"\"Deletes multiple entities from the database asynchronously.\n\n        Args:\n            entities: List of entities to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a raw SQL statement asynchronously.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The result of the execution\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n        \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n        Args:\n            statement: The SQL statement to execute\n            params: Optional parameters for the SQL statement\n\n        Returns:\n            The scalar result of the execution\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.get_session","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.get_session()</code>  <code>abstractmethod</code>","text":"<p>Retrieves an asynchronous SQLAlchemy session for database operations.</p> <p>Returns:</p> Name Type Description <code>AsyncSession</code> <code>AsyncSession</code> <p>An asynchronous SQLAlchemy session object</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\ndef get_session(self) -&gt; AsyncSession:\n    \"\"\"Retrieves an asynchronous SQLAlchemy session for database operations.\n\n    Returns:\n        AsyncSession: An asynchronous SQLAlchemy session object\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.execute_search_query","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.execute_search_query(entity, query, pagination, sort_info=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a search query with pagination and sorting asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Optional pagination settings</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Optional sorting information</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing the list of entities and the total count</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = None,\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Executes a search query with pagination and sorting asynchronously.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Optional pagination settings\n        sort_info: Optional sorting information\n\n    Returns:\n        A tuple containing the list of entities and the total count\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.create","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.create(entity)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Creates a new entity in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to create</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The created entity (with updated attributes) or None if creation failed</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database asynchronously.\n\n    Args:\n        entity: The entity to create\n\n    Returns:\n        The created entity (with updated attributes) or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.bulk_create","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.bulk_create(entities)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Creates multiple entities in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to create</p> required <p>Returns:</p> Type Description <code>list[BaseEntity] | None</code> <p>The list of created entities or None if creation failed</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n    \"\"\"Creates multiple entities in the database asynchronously.\n\n    Args:\n        entities: List of entities to create\n\n    Returns:\n        The list of created entities or None if creation failed\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.get_by_uuid","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.get_by_uuid(entity_type, entity_uuid)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves an entity by its UUID asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The type of entity to retrieve</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>The entity if found, None otherwise</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; BaseEntity | None:\n    \"\"\"Retrieves an entity by its UUID asynchronously.\n\n    Args:\n        entity_type: The type of entity to retrieve\n        entity_uuid: The UUID of the entity\n\n    Returns:\n        The entity if found, None otherwise\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.delete","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.delete(entity)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes an entity from the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to delete</p> required Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def delete(self, entity: BaseEntity) -&gt; None:\n    \"\"\"Deletes an entity from the database asynchronously.\n\n    Args:\n        entity: The entity to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.bulk_delete","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.bulk_delete(entities)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes multiple entities from the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>list[BaseEntity]</code> <p>List of entities to delete</p> required Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n    \"\"\"Deletes multiple entities from the database asynchronously.\n\n    Args:\n        entities: List of entities to delete\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.execute","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.execute(statement, params=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a raw SQL statement asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the execution</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a raw SQL statement asynchronously.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.scalars","title":"<code>archipy.adapters.orm.sqlalchemy.ports.AsyncSqlAlchemyPort.scalars(statement, params=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Executes a statement and returns the scalar result asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The SQL statement to execute</p> required <code>params</code> <code>AnyExecuteParams | None</code> <p>Optional parameters for the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The scalar result of the execution</p> Source code in <code>archipy/adapters/orm/sqlalchemy/ports.py</code> <pre><code>@abstractmethod\nasync def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Any:\n    \"\"\"Executes a statement and returns the scalar result asynchronously.\n\n    Args:\n        statement: The SQL statement to execute\n        params: Optional parameters for the SQL statement\n\n    Returns:\n        The scalar result of the execution\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#redis","title":"Redis","text":"<p>Redis integration for caching and key-value storage.</p> <pre><code>from archipy.adapters.redis import RedisAdapter, AsyncRedisAdapter\n\n# Create a Redis adapter\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n# Set value\nredis.set(\"key\", \"value\", ex=3600)  # expires in 1 hour\n\n# Get value\nvalue = redis.get(\"key\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters","title":"<code>archipy.adapters.redis.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter</code>","text":"<p>               Bases: <code>RedisPort</code></p> <p>Adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the RedisPort interface to provide a consistent way to interact with Redis, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class RedisAdapter(RedisPort):\n    \"\"\"Adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the RedisPort interface to provide a consistent\n    way to interact with Redis, abstracting the underlying Redis client\n    implementation. It supports all common Redis operations including key-value\n    operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        \"\"\"Initialize the RedisAdapter with configuration settings.\n\n        Args:\n            redis_config (RedisConfig, optional): Configuration settings for Redis.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        \"\"\"Set up Redis clients for master and slave connections.\n\n        Args:\n            configs (RedisConfig): Configuration settings for Redis.\n        \"\"\"\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: Redis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: Redis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; Redis:\n        \"\"\"Create a Redis client with the specified configuration.\n\n        Args:\n            host (str): Redis host address.\n            configs (RedisConfig): Configuration settings for Redis.\n\n        Returns:\n            Redis: Configured Redis client instance.\n        \"\"\"\n        return Redis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in milliseconds for a key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in milliseconds.\n        \"\"\"\n        return self.read_only_client.pttl(name)\n\n    @override\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increment the integer value of a key by the given amount.\n\n        Args:\n            name (RedisKeyType): The key name.\n            amount (int): Amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after increment.\n        \"\"\"\n        return self.client.incrby(name, amount)\n\n    @override\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key with optional expiration and conditions.\n\n        Args:\n            name (RedisKeyType): The key name.\n            value (RedisSetType): The value to set.\n            ex (RedisExpiryType | None): Expire time in seconds.\n            px (RedisExpiryType | None): Expire time in milliseconds.\n            nx (bool): Only set if key doesn't exist.\n            xx (bool): Only set if key exists.\n            keepttl (bool): Retain the TTL from the previous value.\n            get (bool): Return the old value.\n            exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n            pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n        Returns:\n            RedisResponseType: Result of the operation.\n        \"\"\"\n        return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key.\n\n        Args:\n            key (str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None if not exists.\n        \"\"\"\n        return self.read_only_client.get(key)\n\n    @override\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get the values of multiple keys.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: List of values.\n        \"\"\"\n        return self.read_only_client.mget(keys, *args)\n\n    @override\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Set multiple keys to their respective values.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n        Returns:\n            RedisResponseType: Always returns 'OK'.\n        \"\"\"\n        return self.client.mset(mapping)\n\n    @override\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Find all keys matching the given pattern.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of matching keys.\n        \"\"\"\n        return self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key and return its old value.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The new value.\n\n        Returns:\n            RedisResponseType: The previous value or None.\n        \"\"\"\n        return self.client.getset(key, value)\n\n    @override\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key and delete it.\n\n        Args:\n            key (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None.\n        \"\"\"\n        return self.client.getdel(key)\n\n    @override\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Check if one or more keys exist.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys that exist.\n        \"\"\"\n        return self.read_only_client.exists(*names)\n\n    @override\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Delete one or more keys.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys deleted.\n        \"\"\"\n        return self.client.delete(*names)\n\n    @override\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Append a value to a key.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: Length of the string after append.\n        \"\"\"\n        return self.client.append(key, value)\n\n    @override\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in seconds for a key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in seconds.\n        \"\"\"\n        return self.read_only_client.ttl(name)\n\n    @override\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determine the type stored at key.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Type of the key's value.\n        \"\"\"\n        return self.read_only_client.type(name)\n\n    @override\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the length of a list.\n\n        Args:\n            name (str): The key name of the list.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list.\n        \"\"\"\n        return self.read_only_client.llen(name)\n\n    @override\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from the left of a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return self.client.lpop(name, count)\n\n    @override\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to the left of a list.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return self.client.lpush(name, *values)\n\n    @override\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Get a range of elements from a list.\n\n        Args:\n            name (str): The key name of the list.\n            start (int): Start index.\n            end (int): End index.\n\n        Returns:\n            RedisListResponseType: List of elements in the specified range.\n        \"\"\"\n        return self.read_only_client.lrange(name, start, end)\n\n    @override\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove elements from a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int): Number of occurrences to remove.\n            value (str): Value to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements removed.\n        \"\"\"\n        return self.client.lrem(name, count, value)\n\n    @override\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Set the value of an element in a list by its index.\n\n        Args:\n            name (str): The key name of the list.\n            index (int): Index of the element.\n            value (str): New value.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        return bool(self.client.lset(name, index, value))\n\n    @override\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from the right of a list.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return self.client.rpop(name, count)\n\n    @override\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to the right of a list.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return self.client.rpush(name, *values)\n\n    @override\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan keys in the database incrementally.\n\n        Args:\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys to return. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of keys.\n        \"\"\"\n        return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Iterate over keys in the database.\n\n        Args:\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys to return. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            Iterator: Iterator over matching keys.\n        \"\"\"\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan members of a set incrementally.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of members.\n        \"\"\"\n        return self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Iterate over members of a set.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            Iterator: Iterator over set members.\n        \"\"\"\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Add members to a set.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements added.\n        \"\"\"\n        return self.client.sadd(name, *values)\n\n    @override\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the number of members in a set.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of members.\n        \"\"\"\n        return self.client.scard(name)\n\n    @override\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if a value is a member of a set.\n\n        Args:\n            name (str): The set key name.\n            value (str): Value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if value is a member, False otherwise.\n        \"\"\"\n        result = self.read_only_client.sismember(name, value)\n        return result\n\n    @override\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Get all members of a set.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisSetResponseType: Set of all members.\n        \"\"\"\n        return self.read_only_client.smembers(name)\n\n    @override\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Remove and return random members from a set.\n\n        Args:\n            name (str): The set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            bytes | float | int | str | list | None: Popped member(s) or None.\n        \"\"\"\n        return self.client.spop(name, count)\n\n    @override\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove members from a set.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of members removed.\n        \"\"\"\n        return self.client.srem(name, *values)\n\n    @override\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Get the union of multiple sets.\n\n        Args:\n            keys (RedisKeyType): First set key.\n            *args (bytes | str): Additional set keys.\n\n        Returns:\n            RedisSetResponseType: Set containing union of all sets.\n        \"\"\"\n        result = self.client.sunion(keys, *args)\n        return set(result) if result else set()\n\n    @override\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Add members to a sorted set with scores.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n            nx (bool): Only add new elements. Defaults to False.\n            xx (bool): Only update existing elements. Defaults to False.\n            ch (bool): Return number of changed elements. Defaults to False.\n            incr (bool): Increment existing scores. Defaults to False.\n            gt (bool): Only update if score is greater. Defaults to False.\n            lt (bool): Only update if score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: Number of elements added or modified.\n        \"\"\"\n        return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the number of members in a sorted set.\n\n        Args:\n            name (bytes | str): The sorted set key name.\n\n        Returns:\n            RedisResponseType: Number of members.\n        \"\"\"\n        return self.client.zcard(name)\n\n    @override\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Count members in a sorted set with scores in range.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n\n        Returns:\n            RedisResponseType: Number of members in range.\n        \"\"\"\n        return self.client.zcount(name, min, max)\n\n    @override\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Remove and return members with highest scores from sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return self.client.zpopmax(name, count)\n\n    @override\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Remove and return members with lowest scores from sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return self.client.zpopmin(name, count)\n\n    @override\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get a range of members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index or score.\n            end (int): End index or score.\n            desc (bool): Sort in descending order. Defaults to False.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): Range by score. Defaults to False.\n            bylex (bool): Range by lexicographical order. Defaults to False.\n            offset (int | None): Offset for byscore/bylex. Defaults to None.\n            num (int | None): Count for byscore/bylex. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get a range of members from a sorted set in reverse order.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index.\n            end (int): End index.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get members from a sorted set by score range.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n            start (int | None): Offset. Defaults to None.\n            num (int | None): Count. Defaults to None.\n            withscores (bool): Include scores in result. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get the rank of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to find rank for.\n\n        Returns:\n            RedisResponseType: Rank of the member or None if not found.\n        \"\"\"\n        return self.client.zrank(name, value)\n\n    @override\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Remove members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: Number of members removed.\n        \"\"\"\n        return self.client.zrem(name, *values)\n\n    @override\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to get score for.\n\n        Returns:\n            RedisResponseType: Score of the member or None if not found.\n        \"\"\"\n        return self.client.zscore(name, value)\n\n    @override\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Delete fields from a hash.\n\n        Args:\n            name (str): The hash key name.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields deleted.\n        \"\"\"\n        return self.client.hdel(name, *keys)\n\n    @override\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if a field exists in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if field exists, False otherwise.\n        \"\"\"\n        return self.read_only_client.hexists(name, key)\n\n    @override\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Get the value of a field in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: Value of the field or None.\n        \"\"\"\n        return self.read_only_client.hget(name, key)\n\n    @override\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Get all fields and values in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            Awaitable[dict] | dict: Dictionary of field-value pairs.\n        \"\"\"\n        return self.read_only_client.hgetall(name)\n\n    @override\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of field names.\n        \"\"\"\n        return self.read_only_client.hkeys(name)\n\n    @override\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the number of fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields.\n        \"\"\"\n        return self.read_only_client.hlen(name)\n\n    @override\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Set fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n            key (str | bytes | None): Single field name. Defaults to None.\n            value (str | bytes | None): Single field value. Defaults to None.\n            mapping (dict | None): Dictionary of field-value pairs. Defaults to None.\n            items (list | None): List of field-value pairs. Defaults to None.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields set.\n        \"\"\"\n        return self.client.hset(name, key, value, mapping, items)\n\n    @override\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Get values of multiple fields in a hash.\n\n        Args:\n            name (str): The hash key name.\n            keys (list): List of field names.\n            *args (str | bytes): Additional field names.\n\n        Returns:\n            RedisListResponseType: List of field values.\n        \"\"\"\n        return self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all values in a hash.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of values.\n        \"\"\"\n        return self.read_only_client.hvals(name)\n\n    @override\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publish a message to a channel.\n\n        Args:\n            channel (RedisKeyType): Channel name.\n            message (bytes | str): Message to publish.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Number of subscribers that received the message.\n        \"\"\"\n        return self.client.publish(channel, message, **kwargs)\n\n    @override\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"List active channels matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of channel names.\n        \"\"\"\n        return self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increment the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            amount (float): Amount to increment by.\n            value (bytes | str | float): Member to increment.\n\n        Returns:\n            RedisResponseType: New score of the member.\n        \"\"\"\n        return self.client.zincrby(name, amount, value)\n\n    @override\n    def pubsub(self, **kwargs: Any) -&gt; PubSub:\n        \"\"\"Get a PubSub object for subscribing to channels.\n\n        Args:\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            PubSub: PubSub object.\n        \"\"\"\n        return self.client.pubsub(**kwargs)\n\n    @override\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n        \"\"\"Get a pipeline object for executing multiple commands.\n\n        Args:\n            transaction (Any): Whether to use transactions. Defaults to True.\n            shard_hint (Any): Hint for sharding. Defaults to None.\n\n        Returns:\n            Pipeline: Pipeline object.\n        \"\"\"\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    def ping(self) -&gt; RedisResponseType:\n        \"\"\"Ping the Redis server.\n\n        Returns:\n            RedisResponseType: 'PONG' if successful.\n        \"\"\"\n        return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.__init__","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.__init__(redis_config=None)</code>","text":"<p>Initialize the RedisAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n    \"\"\"Initialize the RedisAdapter with configuration settings.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n    self._set_clients(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pttl","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pttl(name)</code>","text":"<p>Get the time to live in milliseconds for a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in milliseconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in milliseconds for a key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in milliseconds.\n    \"\"\"\n    return self.read_only_client.pttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.incrby","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.incrby(name, amount=1)</code>","text":"<p>Increment the integer value of a key by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>amount</code> <code>int</code> <p>Amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after increment.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increment the integer value of a key by the given amount.\n\n    Args:\n        name (RedisKeyType): The key name.\n        amount (int): Amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after increment.\n    \"\"\"\n    return self.client.incrby(name, amount)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.set","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>","text":"<p>Set the value of a key with optional expiration and conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set.</p> required <code>ex</code> <code>RedisExpiryType | None</code> <p>Expire time in seconds.</p> <code>None</code> <code>px</code> <code>RedisExpiryType | None</code> <p>Expire time in milliseconds.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>Only set if key doesn't exist.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only set if key exists.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>Retain the TTL from the previous value.</p> <code>False</code> <code>get</code> <code>bool</code> <p>Return the old value.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in seconds.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in milliseconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Result of the operation.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key with optional expiration and conditions.\n\n    Args:\n        name (RedisKeyType): The key name.\n        value (RedisSetType): The value to set.\n        ex (RedisExpiryType | None): Expire time in seconds.\n        px (RedisExpiryType | None): Expire time in milliseconds.\n        nx (bool): Only set if key doesn't exist.\n        xx (bool): Only set if key exists.\n        keepttl (bool): Retain the TTL from the previous value.\n        get (bool): Return the old value.\n        exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n        pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n    Returns:\n        RedisResponseType: Result of the operation.\n    \"\"\"\n    return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.get","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.get(key)</code>","text":"<p>Get the value of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None if not exists.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key.\n\n    Args:\n        key (str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None if not exists.\n    \"\"\"\n    return self.read_only_client.get(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.mget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.mget(keys, *args)</code>","text":"<p>Get the values of multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>Single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Get the values of multiple keys.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: List of values.\n    \"\"\"\n    return self.read_only_client.mget(keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.mset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.mset(mapping)</code>","text":"<p>Set multiple keys to their respective values.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Dictionary of key-value pairs.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Always returns 'OK'.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Set multiple keys to their respective values.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n    Returns:\n        RedisResponseType: Always returns 'OK'.\n    \"\"\"\n    return self.client.mset(mapping)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.keys","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.keys(pattern='*', **kwargs)</code>","text":"<p>Find all keys matching the given pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Find all keys matching the given pattern.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of matching keys.\n    \"\"\"\n    return self.read_only_client.keys(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.getset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.getset(key, value)</code>","text":"<p>Set the value of a key and return its old value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The previous value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key and return its old value.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The new value.\n\n    Returns:\n        RedisResponseType: The previous value or None.\n    \"\"\"\n    return self.client.getset(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.getdel","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.getdel(key)</code>","text":"<p>Get the value of a key and delete it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key and delete it.\n\n    Args:\n        key (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None.\n    \"\"\"\n    return self.client.getdel(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.exists","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.exists(*names)</code>","text":"<p>Check if one or more keys exist.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys that exist.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Check if one or more keys exist.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys that exist.\n    \"\"\"\n    return self.read_only_client.exists(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.delete","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.delete(*names)</code>","text":"<p>Delete one or more keys.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Delete one or more keys.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys deleted.\n    \"\"\"\n    return self.client.delete(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.append","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.append(key, value)</code>","text":"<p>Append a value to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Length of the string after append.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Append a value to a key.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: Length of the string after append.\n    \"\"\"\n    return self.client.append(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.ttl","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.ttl(name)</code>","text":"<p>Get the time to live in seconds for a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in seconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in seconds for a key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in seconds.\n    \"\"\"\n    return self.read_only_client.ttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.type","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.type(name)</code>","text":"<p>Determine the type stored at key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Type of the key's value.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determine the type stored at key.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Type of the key's value.\n    \"\"\"\n    return self.read_only_client.type(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.llen","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.llen(name)</code>","text":"<p>Get the length of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the length of a list.\n\n    Args:\n        name (str): The key name of the list.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list.\n    \"\"\"\n    return self.read_only_client.llen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lpop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lpop(name, count=None)</code>","text":"<p>Remove and return elements from the left of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from the left of a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return self.client.lpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lpush","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lpush(name, *values)</code>","text":"<p>Push elements to the left of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to the left of a list.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return self.client.lpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lrange(name, start, end)</code>","text":"<p>Get a range of elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of elements in the specified range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Get a range of elements from a list.\n\n    Args:\n        name (str): The key name of the list.\n        start (int): Start index.\n        end (int): End index.\n\n    Returns:\n        RedisListResponseType: List of elements in the specified range.\n    \"\"\"\n    return self.read_only_client.lrange(name, start, end)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lrem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lrem(name, count, value)</code>","text":"<p>Remove elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove.</p> required <code>value</code> <code>str</code> <p>Value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove elements from a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int): Number of occurrences to remove.\n        value (str): Value to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements removed.\n    \"\"\"\n    return self.client.lrem(name, count, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.lset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.lset(name, index, value)</code>","text":"<p>Set the value of an element in a list by its index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>index</code> <code>int</code> <p>Index of the element.</p> required <code>value</code> <code>str</code> <p>New value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Set the value of an element in a list by its index.\n\n    Args:\n        name (str): The key name of the list.\n        index (int): Index of the element.\n        value (str): New value.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    return bool(self.client.lset(name, index, value))\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.rpop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.rpop(name, count=None)</code>","text":"<p>Remove and return elements from the right of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from the right of a list.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return self.client.rpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.rpush","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.rpush(name, *values)</code>","text":"<p>Push elements to the right of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to the right of a list.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return self.client.rpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scan","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>","text":"<p>Scan keys in the database incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys to return. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Scan keys in the database incrementally.\n\n    Args:\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys to return. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of keys.\n    \"\"\"\n    return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scan_iter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scan_iter(match=None, count=None, _type=None, **kwargs)</code>","text":"<p>Iterate over keys in the database.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys to return. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>Iterator over matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Iterate over keys in the database.\n\n    Args:\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys to return. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        Iterator: Iterator over matching keys.\n    \"\"\"\n    return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sscan","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sscan(name, cursor=0, match=None, count=None)</code>","text":"<p>Scan members of a set incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Scan members of a set incrementally.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of members.\n    \"\"\"\n    return self.read_only_client.sscan(name, cursor, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sscan_iter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sscan_iter(name, match=None, count=None)</code>","text":"<p>Iterate over members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>Iterator over set members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Iterate over members of a set.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        Iterator: Iterator over set members.\n    \"\"\"\n    return self.read_only_client.sscan_iter(name, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sadd","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sadd(name, *values)</code>","text":"<p>Add members to a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements added.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Add members to a set.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements added.\n    \"\"\"\n    return self.client.sadd(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.scard","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.scard(name)</code>","text":"<p>Get the number of members in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the number of members in a set.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of members.\n    \"\"\"\n    return self.client.scard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sismember","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sismember(name, value)</code>","text":"<p>Check if a value is a member of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>value</code> <code>str</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if value is a member, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if a value is a member of a set.\n\n    Args:\n        name (str): The set key name.\n        value (str): Value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if value is a member, False otherwise.\n    \"\"\"\n    result = self.read_only_client.sismember(name, value)\n    return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.smembers","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.smembers(name)</code>","text":"<p>Get all members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set of all members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Get all members of a set.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisSetResponseType: Set of all members.\n    \"\"\"\n    return self.read_only_client.smembers(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.spop","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.spop(name, count=None)</code>","text":"<p>Remove and return random members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: Popped member(s) or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Remove and return random members from a set.\n\n    Args:\n        name (str): The set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        bytes | float | int | str | list | None: Popped member(s) or None.\n    \"\"\"\n    return self.client.spop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.srem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.srem(name, *values)</code>","text":"<p>Remove members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove members from a set.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of members removed.\n    \"\"\"\n    return self.client.srem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.sunion","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.sunion(keys, *args)</code>","text":"<p>Get the union of multiple sets.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>First set key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional set keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set containing union of all sets.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Get the union of multiple sets.\n\n    Args:\n        keys (RedisKeyType): First set key.\n        *args (bytes | str): Additional set keys.\n\n    Returns:\n        RedisSetResponseType: Set containing union of all sets.\n    \"\"\"\n    result = self.client.sunion(keys, *args)\n    return set(result) if result else set()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zadd","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>","text":"<p>Add members to a sorted set with scores.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Member-score pairs.</p> required <code>nx</code> <code>bool</code> <p>Only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>Return number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>Increment existing scores. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>Only update if score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>Only update if score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of elements added or modified.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Add members to a sorted set with scores.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n        nx (bool): Only add new elements. Defaults to False.\n        xx (bool): Only update existing elements. Defaults to False.\n        ch (bool): Return number of changed elements. Defaults to False.\n        incr (bool): Increment existing scores. Defaults to False.\n        gt (bool): Only update if score is greater. Defaults to False.\n        lt (bool): Only update if score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: Number of elements added or modified.\n    \"\"\"\n    return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zcard","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zcard(name)</code>","text":"<p>Get the number of members in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The sorted set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the number of members in a sorted set.\n\n    Args:\n        name (bytes | str): The sorted set key name.\n\n    Returns:\n        RedisResponseType: Number of members.\n    \"\"\"\n    return self.client.zcard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zcount","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zcount(name, min, max)</code>","text":"<p>Count members in a sorted set with scores in range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Count members in a sorted set with scores in range.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n\n    Returns:\n        RedisResponseType: Number of members in range.\n    \"\"\"\n    return self.client.zcount(name, min, max)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zpopmax","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zpopmax(name, count=None)</code>","text":"<p>Remove and return members with highest scores from sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Remove and return members with highest scores from sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return self.client.zpopmax(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zpopmin","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zpopmin(name, count=None)</code>","text":"<p>Remove and return members with lowest scores from sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Remove and return members with lowest scores from sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return self.client.zpopmin(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>","text":"<p>Get a range of members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index or score.</p> required <code>end</code> <code>int</code> <p>End index or score.</p> required <code>desc</code> <code>bool</code> <p>Sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>Range by score. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>Range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int | None</code> <p>Offset for byscore/bylex. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count for byscore/bylex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Get a range of members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index or score.\n        end (int): End index or score.\n        desc (bool): Sort in descending order. Defaults to False.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): Range by score. Defaults to False.\n        bylex (bool): Range by lexicographical order. Defaults to False.\n        offset (int | None): Offset for byscore/bylex. Defaults to None.\n        num (int | None): Count for byscore/bylex. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrange(\n        name,\n        start,\n        end,\n        desc,\n        withscores,\n        score_cast_func,\n        byscore,\n        bylex,\n        offset,\n        num,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrevrange","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>","text":"<p>Get a range of members from a sorted set in reverse order.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get a range of members from a sorted set in reverse order.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index.\n        end (int): End index.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrevrange(name, start, end, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrangebyscore","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>","text":"<p>Get members from a sorted set by score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <code>start</code> <code>int | None</code> <p>Offset. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count. Defaults to None.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>Include scores in result. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get members from a sorted set by score range.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n        start (int | None): Offset. Defaults to None.\n        num (int | None): Count. Defaults to None.\n        withscores (bool): Include scores in result. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrank","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrank(name, value)</code>","text":"<p>Get the rank of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to find rank for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Rank of the member or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get the rank of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to find rank for.\n\n    Returns:\n        RedisResponseType: Rank of the member or None if not found.\n    \"\"\"\n    return self.client.zrank(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zrem","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zrem(name, *values)</code>","text":"<p>Remove members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Remove members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: Number of members removed.\n    \"\"\"\n    return self.client.zrem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zscore","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zscore(name, value)</code>","text":"<p>Get the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to get score for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Score of the member or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to get score for.\n\n    Returns:\n        RedisResponseType: Score of the member or None if not found.\n    \"\"\"\n    return self.client.zscore(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hdel","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hdel(name, *keys)</code>","text":"<p>Delete fields from a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Delete fields from a hash.\n\n    Args:\n        name (str): The hash key name.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields deleted.\n    \"\"\"\n    return self.client.hdel(name, *keys)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hexists","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hexists(name, key)</code>","text":"<p>Check if a field exists in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if field exists, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if a field exists in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if field exists, False otherwise.\n    \"\"\"\n    return self.read_only_client.hexists(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hget(name, key)</code>","text":"<p>Get the value of a field in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: Value of the field or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Get the value of a field in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: Value of the field or None.\n    \"\"\"\n    return self.read_only_client.hget(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hgetall","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hgetall(name)</code>","text":"<p>Get all fields and values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: Dictionary of field-value pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Get all fields and values in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        Awaitable[dict] | dict: Dictionary of field-value pairs.\n    \"\"\"\n    return self.read_only_client.hgetall(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hkeys","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hkeys(name)</code>","text":"<p>Get all fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of field names.\n    \"\"\"\n    return self.read_only_client.hkeys(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hlen","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hlen(name)</code>","text":"<p>Get the number of fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the number of fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields.\n    \"\"\"\n    return self.read_only_client.hlen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hset","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hset(name, key=None, value=None, mapping=None, items=None)</code>","text":"<p>Set fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str | bytes | None</code> <p>Single field name. Defaults to None.</p> <code>None</code> <code>value</code> <code>str | bytes | None</code> <p>Single field value. Defaults to None.</p> <code>None</code> <code>mapping</code> <code>dict | None</code> <p>Dictionary of field-value pairs. Defaults to None.</p> <code>None</code> <code>items</code> <code>list | None</code> <p>List of field-value pairs. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields set.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Set fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n        key (str | bytes | None): Single field name. Defaults to None.\n        value (str | bytes | None): Single field value. Defaults to None.\n        mapping (dict | None): Dictionary of field-value pairs. Defaults to None.\n        items (list | None): List of field-value pairs. Defaults to None.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields set.\n    \"\"\"\n    return self.client.hset(name, key, value, mapping, items)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hmget","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hmget(name, keys, *args)</code>","text":"<p>Get values of multiple fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>keys</code> <code>list</code> <p>List of field names.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional field names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Get values of multiple fields in a hash.\n\n    Args:\n        name (str): The hash key name.\n        keys (list): List of field names.\n        *args (str | bytes): Additional field names.\n\n    Returns:\n        RedisListResponseType: List of field values.\n    \"\"\"\n    return self.read_only_client.hmget(name, keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.hvals","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.hvals(name)</code>","text":"<p>Get all values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all values in a hash.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of values.\n    \"\"\"\n    return self.read_only_client.hvals(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.publish","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.publish(channel, message, **kwargs)</code>","text":"<p>Publish a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>Channel name.</p> required <code>message</code> <code>bytes | str</code> <p>Message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of subscribers that received the message.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publish a message to a channel.\n\n    Args:\n        channel (RedisKeyType): Channel name.\n        message (bytes | str): Message to publish.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Number of subscribers that received the message.\n    \"\"\"\n    return self.client.publish(channel, message, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pubsub_channels","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pubsub_channels(pattern='*', **kwargs)</code>","text":"<p>List active channels matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of channel names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"List active channels matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of channel names.\n    \"\"\"\n    return self.client.pubsub_channels(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.zincrby","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.zincrby(name, amount, value)</code>","text":"<p>Increment the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>amount</code> <code>float</code> <p>Amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>New score of the member.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increment the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        amount (float): Amount to increment by.\n        value (bytes | str | float): Member to increment.\n\n    Returns:\n        RedisResponseType: New score of the member.\n    \"\"\"\n    return self.client.zincrby(name, amount, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.pubsub","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.pubsub(**kwargs)</code>","text":"<p>Get a PubSub object for subscribing to channels.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>PubSub</code> <code>PubSub</code> <p>PubSub object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef pubsub(self, **kwargs: Any) -&gt; PubSub:\n    \"\"\"Get a PubSub object for subscribing to channels.\n\n    Args:\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        PubSub: PubSub object.\n    \"\"\"\n    return self.client.pubsub(**kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.get_pipeline","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.get_pipeline(transaction=True, shard_hint=None)</code>","text":"<p>Get a pipeline object for executing multiple commands.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>Whether to use transactions. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Pipeline</code> <code>Pipeline</code> <p>Pipeline object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n    \"\"\"Get a pipeline object for executing multiple commands.\n\n    Args:\n        transaction (Any): Whether to use transactions. Defaults to True.\n        shard_hint (Any): Hint for sharding. Defaults to None.\n\n    Returns:\n        Pipeline: Pipeline object.\n    \"\"\"\n    return self.client.pipeline(transaction, shard_hint)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter.ping","title":"<code>archipy.adapters.redis.adapters.RedisAdapter.ping()</code>","text":"<p>Ping the Redis server.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>'PONG' if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\ndef ping(self) -&gt; RedisResponseType:\n    \"\"\"Ping the Redis server.\n\n    Returns:\n        RedisResponseType: 'PONG' if successful.\n    \"\"\"\n    return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter</code>","text":"<p>               Bases: <code>AsyncRedisPort</code></p> <p>Async adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the AsyncRedisPort interface to provide a consistent way to interact with Redis asynchronously, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class AsyncRedisAdapter(AsyncRedisPort):\n    \"\"\"Async adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the AsyncRedisPort interface to provide a consistent\n    way to interact with Redis asynchronously, abstracting the underlying Redis\n    client implementation. It supports all common Redis operations including\n    key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        \"\"\"Initialize the AsyncRedisAdapter with configuration settings.\n\n        Args:\n            redis_config (RedisConfig, optional): Configuration settings for Redis.\n                If None, retrieves from global config. Defaults to None.\n        \"\"\"\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        \"\"\"Set up async Redis clients for master and slave connections.\n\n        Args:\n            configs (RedisConfig): Configuration settings for Redis.\n        \"\"\"\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: AsyncRedis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: AsyncRedis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; AsyncRedis:\n        \"\"\"Create an async Redis client with the specified configuration.\n\n        Args:\n            host (str): Redis host address.\n            configs (RedisConfig): Configuration settings for Redis.\n\n        Returns:\n            AsyncRedis: Configured async Redis client instance.\n        \"\"\"\n        return AsyncRedis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    async def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in milliseconds for a key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in milliseconds.\n        \"\"\"\n        return await self.read_only_client.pttl(name)\n\n    @override\n    async def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increment the integer value of a key by the given amount asynchronously.\n\n        Args:\n            name (RedisKeyType): The key name.\n            amount (int): Amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after increment.\n        \"\"\"\n        return await self.client.incrby(name, amount)\n\n    @override\n    async def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Set the value of a key with optional expiration asynchronously.\n\n        Args:\n            name (RedisKeyType): The key name.\n            value (RedisSetType): The value to set.\n            ex (RedisExpiryType | None): Expire time in seconds.\n            px (RedisExpiryType | None): Expire time in milliseconds.\n            nx (bool): Only set if key doesn't exist.\n            xx (bool): Only set if key exists.\n            keepttl (bool): Retain the TTL from the previous value.\n            get (bool): Return the old value.\n            exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n            pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n        Returns:\n            RedisResponseType: Result of the operation.\n        \"\"\"\n        return await self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    async def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Get the value of a key asynchronously.\n\n        Args:\n            key (str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None if not exists.\n        \"\"\"\n        return await self.read_only_client.get(key)\n\n    @override\n    async def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get the values of multiple keys asynchronously.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: List of values.\n        \"\"\"\n        return await self.read_only_client.mget(keys, *args)\n\n    @override\n    async def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Set multiple keys to their values asynchronously.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n        Returns:\n            RedisResponseType: Always returns 'OK'.\n        \"\"\"\n        return await self.client.mset(mapping)\n\n    @override\n    async def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Find all keys matching the pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of matching keys.\n        \"\"\"\n        return await self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    async def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Set a key's value and return its old value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The new value.\n\n        Returns:\n            RedisResponseType: The previous value or None.\n        \"\"\"\n        return await self.client.getset(key, value)\n\n    @override\n    async def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get a key's value and delete it asynchronously.\n\n        Args:\n            key (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: The value of the key or None.\n        \"\"\"\n        return await self.client.getdel(key)\n\n    @override\n    async def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Check if keys exist asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys that exist.\n        \"\"\"\n        return await self.read_only_client.exists(*names)\n\n    @override\n    async def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Delete keys asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of key names.\n\n        Returns:\n            RedisResponseType: Number of keys deleted.\n        \"\"\"\n        return await self.client.delete(*names)\n\n    @override\n    async def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Append a value to a key asynchronously.\n\n        Args:\n            key (RedisKeyType): The key name.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: Length of the string after append.\n        \"\"\"\n        return await self.client.append(key, value)\n\n    @override\n    async def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get the time to live in seconds for a key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Time to live in seconds.\n        \"\"\"\n        return await self.read_only_client.ttl(name)\n\n    @override\n    async def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determine the type stored at key asynchronously.\n\n        Args:\n            name (bytes | str): The key name.\n\n        Returns:\n            RedisResponseType: Type of the key's value.\n        \"\"\"\n        return await self.read_only_client.type(name)\n\n    @override\n    async def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get the length of a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list.\n        \"\"\"\n        return await self.read_only_client.llen(name)\n\n    @override\n    async def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from list left asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return await self.client.lpop(name, count)\n\n    @override\n    async def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to list left asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return await self.client.lpush(name, *values)\n\n    @override\n    async def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Get a range of elements from a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            start (int): Start index.\n            end (int): End index.\n\n        Returns:\n            RedisListResponseType: List of elements in range.\n        \"\"\"\n        return await self.read_only_client.lrange(name, start, end)\n\n    @override\n    async def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove elements from a list asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int): Number of occurrences to remove.\n            value (str): Value to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements removed.\n        \"\"\"\n        return await self.client.lrem(name, count, value)\n\n    @override\n    async def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Set list element by index asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            index (int): Index of the element.\n            value (str): New value.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        result = await self.client.lset(name, index, value)\n        return bool(result)\n\n    @override\n    async def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Remove and return elements from list right asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            count (int | None): Number of elements to pop. Defaults to None.\n\n        Returns:\n            Any: Popped element(s) or None if list is empty.\n        \"\"\"\n        return await self.client.rpop(name, count)\n\n    @override\n    async def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Push elements to list right asynchronously.\n\n        Args:\n            name (str): The key name of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: Length of the list after push.\n        \"\"\"\n        return await self.client.rpush(name, *values)\n\n    @override\n    async def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan keys in database incrementally asynchronously.\n\n        Args:\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of keys.\n        \"\"\"\n        return await self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    async def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator[Any]:\n        \"\"\"Iterate over keys in database asynchronously.\n\n        Args:\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of keys. Defaults to None.\n            _type (str | None): Filter by type. Defaults to None.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            Iterator[Any]: Iterator over matching keys.\n        \"\"\"\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    async def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Scan set members incrementally asynchronously.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            cursor (int): Cursor position. Defaults to 0.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            RedisResponseType: Tuple of cursor and list of members.\n        \"\"\"\n        return await self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    async def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator[Any]:\n        \"\"\"Iterate over set members asynchronously.\n\n        Args:\n            name (RedisKeyType): The set key name.\n            match (bytes | str | None): Pattern to match. Defaults to None.\n            count (int | None): Hint for number of elements. Defaults to None.\n\n        Returns:\n            Iterator[Any]: Iterator over set members.\n        \"\"\"\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    async def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Add members to a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: Number of elements added.\n        \"\"\"\n        return await self.client.sadd(name, *values)\n\n    @override\n    async def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get number of members in a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of members.\n        \"\"\"\n        return await self.client.scard(name)\n\n    @override\n    async def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if value is in set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            value (str): Value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if value is member, False otherwise.\n        \"\"\"\n        result = await self.read_only_client.sismember(name, value)\n        return result\n\n    @override\n    async def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Get all members of a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n\n        Returns:\n            RedisSetResponseType: Set of all members.\n        \"\"\"\n        return await self.read_only_client.smembers(name)\n\n    @override\n    async def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Remove and return random set members asynchronously.\n\n        Args:\n            name (str): The set key name.\n            count (int | None): Number of members to pop. Defaults to None.\n\n        Returns:\n            bytes | float | int | str | list | None: Popped member(s) or None.\n        \"\"\"\n        return await self.client.spop(name, count)\n\n    @override\n    async def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Remove members from a set asynchronously.\n\n        Args:\n            name (str): The set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: Number of members removed.\n        \"\"\"\n        return await self.client.srem(name, *values)\n\n    @override\n    async def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Get union of multiple sets asynchronously.\n\n        Args:\n            keys (RedisKeyType): First set key.\n            *args (bytes | str): Additional set keys.\n\n        Returns:\n            RedisSetResponseType: Set containing union of all sets.\n        \"\"\"\n        result = await self.client.sunion(keys, *args)\n        return set(result) if result else set()\n\n    @override\n    async def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Add members to sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n            nx (bool): Only add new elements. Defaults to False.\n            xx (bool): Only update existing. Defaults to False.\n            ch (bool): Return changed count. Defaults to False.\n            incr (bool): Increment scores. Defaults to False.\n            gt (bool): Only if greater. Defaults to False.\n            lt (bool): Only if less. Defaults to False.\n\n        Returns:\n            RedisResponseType: Number of elements added or modified.\n        \"\"\"\n        return await self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    async def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Get number of members in sorted set asynchronously.\n\n        Args:\n            name (bytes | str): The sorted set key name.\n\n        Returns:\n            RedisResponseType: Number of members.\n        \"\"\"\n        return await self.client.zcard(name)\n\n    @override\n    async def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Count members in score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n\n        Returns:\n            RedisResponseType: Number of members in range.\n        \"\"\"\n        return await self.client.zcount(name, min, max)\n\n    @override\n    async def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Pop highest scored members asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return await self.client.zpopmax(name, count)\n\n    @override\n    async def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Pop lowest scored members asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            count (int | None): Number to pop. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of popped member-score pairs.\n        \"\"\"\n        return await self.client.zpopmin(name, count)\n\n    @override\n    async def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get range from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index or score.\n            end (int): End index or score.\n            desc (bool): Descending order. Defaults to False.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n            byscore (bool): Range by score. Defaults to False.\n            bylex (bool): Range by lex. Defaults to False.\n            offset (int | None): Offset for byscore/bylex. Defaults to None.\n            num (int | None): Count for byscore/bylex. Defaults to None.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    async def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get reverse range from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            start (int): Start index.\n            end (int): End index.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    async def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Get members by score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            min (float | str): Minimum score.\n            max (float | str): Maximum score.\n            start (int | None): Offset. Defaults to None.\n            num (int | None): Count. Defaults to None.\n            withscores (bool): Include scores. Defaults to False.\n            score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n        Returns:\n            RedisResponseType: List of members or member-score pairs.\n        \"\"\"\n        return await self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    async def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get rank of member in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to find rank for.\n\n        Returns:\n            RedisResponseType: Rank or None if not found.\n        \"\"\"\n        return await self.client.zrank(name, value)\n\n    @override\n    async def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Remove members from sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: Number of members removed.\n        \"\"\"\n        return await self.client.zrem(name, *values)\n\n    @override\n    async def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Get score of member in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            value (bytes | str | float): Member to get score for.\n\n        Returns:\n            RedisResponseType: Score or None if not found.\n        \"\"\"\n        return await self.client.zscore(name, value)\n\n    @override\n    async def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Delete fields from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields deleted.\n        \"\"\"\n        return await self.client.hdel(name, *keys)\n\n    @override\n    async def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Check if field exists in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if exists, False otherwise.\n        \"\"\"\n        return await self.read_only_client.hexists(name, key)\n\n    @override\n    async def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Get field value from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str): Field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: Value or None.\n        \"\"\"\n        return await self.read_only_client.hget(name, key)\n\n    @override\n    async def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Get all fields and values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            Awaitable[dict] | dict: Dictionary of field-value pairs.\n        \"\"\"\n        return await self.read_only_client.hgetall(name)\n\n    @override\n    async def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all fields from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of field names.\n        \"\"\"\n        return await self.read_only_client.hkeys(name)\n\n    @override\n    async def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Get number of fields in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields.\n        \"\"\"\n        return await self.read_only_client.hlen(name)\n\n    @override\n    async def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Set fields in hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            key (str | bytes | None): Single field name. Defaults to None.\n            value (str | bytes | None): Single field value. Defaults to None.\n            mapping (dict | None): Field-value pairs dict. Defaults to None.\n            items (list | None): Field-value pairs list. Defaults to None.\n\n        Returns:\n            RedisIntegerResponseType: Number of fields set.\n        \"\"\"\n        return await self.client.hset(name, key, value, mapping, items)\n\n    @override\n    async def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Get multiple field values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n            keys (list): List of field names.\n            *args (str | bytes): Additional field names.\n\n        Returns:\n            RedisListResponseType: List of field values.\n        \"\"\"\n        return await self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    async def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Get all values from hash asynchronously.\n\n        Args:\n            name (str): The hash key name.\n\n        Returns:\n            RedisListResponseType: List of values.\n        \"\"\"\n        return await self.read_only_client.hvals(name)\n\n    @override\n    async def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publish message to channel asynchronously.\n\n        Args:\n            channel (RedisKeyType): Channel name.\n            message (bytes | str): Message to publish.\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: Number of subscribers received message.\n        \"\"\"\n        return await self.client.publish(channel, message, **kwargs)\n\n    @override\n    async def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"List active channels matching pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): Pattern to match. Defaults to \"*\".\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            RedisResponseType: List of channel names.\n        \"\"\"\n        return await self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    async def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increment member score in sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The sorted set key name.\n            amount (float): Amount to increment by.\n            value (bytes | str | float): Member to increment.\n\n        Returns:\n            RedisResponseType: New score of the member.\n        \"\"\"\n        return await self.client.zincrby(name, amount, value)\n\n    @override\n    async def pubsub(self, **kwargs: Any) -&gt; AsyncPubSub:\n        \"\"\"Get PubSub object for channel subscription asynchronously.\n\n        Args:\n            **kwargs (Any): Additional arguments.\n\n        Returns:\n            AsyncPubSub: PubSub object.\n        \"\"\"\n        return self.client.pubsub(**kwargs)\n\n    @override\n    async def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; AsyncPipeline:\n        \"\"\"Get pipeline for multiple commands asynchronously.\n\n        Args:\n            transaction (Any): Use transactions. Defaults to True.\n            shard_hint (Any): Sharding hint. Defaults to None.\n\n        Returns:\n            AsyncPipeline: Pipeline object.\n        \"\"\"\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    async def ping(self) -&gt; RedisResponseType:\n        \"\"\"Ping the Redis server asynchronously.\n\n        Returns:\n            RedisResponseType: 'PONG' if successful.\n        \"\"\"\n        return await self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.__init__","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.__init__(redis_config=None)</code>","text":"<p>Initialize the AsyncRedisAdapter with configuration settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n    \"\"\"Initialize the AsyncRedisAdapter with configuration settings.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n    \"\"\"\n    configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n    self._set_clients(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pttl","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pttl(name)</code>  <code>async</code>","text":"<p>Get the time to live in milliseconds for a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in milliseconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in milliseconds for a key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in milliseconds.\n    \"\"\"\n    return await self.read_only_client.pttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.incrby","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.incrby(name, amount=1)</code>  <code>async</code>","text":"<p>Increment the integer value of a key by the given amount asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>amount</code> <code>int</code> <p>Amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after increment.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increment the integer value of a key by the given amount asynchronously.\n\n    Args:\n        name (RedisKeyType): The key name.\n        amount (int): Amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after increment.\n    \"\"\"\n    return await self.client.incrby(name, amount)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.set","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>async</code>","text":"<p>Set the value of a key with optional expiration asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set.</p> required <code>ex</code> <code>RedisExpiryType | None</code> <p>Expire time in seconds.</p> <code>None</code> <code>px</code> <code>RedisExpiryType | None</code> <p>Expire time in milliseconds.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>Only set if key doesn't exist.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only set if key exists.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>Retain the TTL from the previous value.</p> <code>False</code> <code>get</code> <code>bool</code> <p>Return the old value.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in seconds.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType | None</code> <p>Absolute expiration time in milliseconds.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Result of the operation.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Set the value of a key with optional expiration asynchronously.\n\n    Args:\n        name (RedisKeyType): The key name.\n        value (RedisSetType): The value to set.\n        ex (RedisExpiryType | None): Expire time in seconds.\n        px (RedisExpiryType | None): Expire time in milliseconds.\n        nx (bool): Only set if key doesn't exist.\n        xx (bool): Only set if key exists.\n        keepttl (bool): Retain the TTL from the previous value.\n        get (bool): Return the old value.\n        exat (RedisAbsExpiryType | None): Absolute expiration time in seconds.\n        pxat (RedisAbsExpiryType | None): Absolute expiration time in milliseconds.\n\n    Returns:\n        RedisResponseType: Result of the operation.\n    \"\"\"\n    return await self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.get","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.get(key)</code>  <code>async</code>","text":"<p>Get the value of a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None if not exists.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Get the value of a key asynchronously.\n\n    Args:\n        key (str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None if not exists.\n    \"\"\"\n    return await self.read_only_client.get(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.mget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.mget(keys, *args)</code>  <code>async</code>","text":"<p>Get the values of multiple keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>Single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Get the values of multiple keys asynchronously.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): Single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: List of values.\n    \"\"\"\n    return await self.read_only_client.mget(keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.mset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.mset(mapping)</code>  <code>async</code>","text":"<p>Set multiple keys to their values asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Dictionary of key-value pairs.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Always returns 'OK'.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Set multiple keys to their values asynchronously.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Dictionary of key-value pairs.\n\n    Returns:\n        RedisResponseType: Always returns 'OK'.\n    \"\"\"\n    return await self.client.mset(mapping)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.keys","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.keys(pattern='*', **kwargs)</code>  <code>async</code>","text":"<p>Find all keys matching the pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Find all keys matching the pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of matching keys.\n    \"\"\"\n    return await self.read_only_client.keys(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.getset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.getset(key, value)</code>  <code>async</code>","text":"<p>Set a key's value and return its old value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The previous value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Set a key's value and return its old value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The new value.\n\n    Returns:\n        RedisResponseType: The previous value or None.\n    \"\"\"\n    return await self.client.getset(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.getdel","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.getdel(key)</code>  <code>async</code>","text":"<p>Get a key's value and delete it asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get a key's value and delete it asynchronously.\n\n    Args:\n        key (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: The value of the key or None.\n    \"\"\"\n    return await self.client.getdel(key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.exists","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.exists(*names)</code>  <code>async</code>","text":"<p>Check if keys exist asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys that exist.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Check if keys exist asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys that exist.\n    \"\"\"\n    return await self.read_only_client.exists(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.delete","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.delete(*names)</code>  <code>async</code>","text":"<p>Delete keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of keys deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Delete keys asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of key names.\n\n    Returns:\n        RedisResponseType: Number of keys deleted.\n    \"\"\"\n    return await self.client.delete(*names)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.append","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.append(key, value)</code>  <code>async</code>","text":"<p>Append a value to a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Length of the string after append.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Append a value to a key asynchronously.\n\n    Args:\n        key (RedisKeyType): The key name.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: Length of the string after append.\n    \"\"\"\n    return await self.client.append(key, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.ttl","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.ttl(name)</code>  <code>async</code>","text":"<p>Get the time to live in seconds for a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Time to live in seconds.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get the time to live in seconds for a key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Time to live in seconds.\n    \"\"\"\n    return await self.read_only_client.ttl(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.type","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.type(name)</code>  <code>async</code>","text":"<p>Determine the type stored at key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Type of the key's value.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determine the type stored at key asynchronously.\n\n    Args:\n        name (bytes | str): The key name.\n\n    Returns:\n        RedisResponseType: Type of the key's value.\n    \"\"\"\n    return await self.read_only_client.type(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.llen","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.llen(name)</code>  <code>async</code>","text":"<p>Get the length of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get the length of a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list.\n    \"\"\"\n    return await self.read_only_client.llen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lpop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lpop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return elements from list left asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from list left asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return await self.client.lpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lpush","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lpush(name, *values)</code>  <code>async</code>","text":"<p>Push elements to list left asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to list left asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return await self.client.lpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lrange(name, start, end)</code>  <code>async</code>","text":"<p>Get a range of elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of elements in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Get a range of elements from a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        start (int): Start index.\n        end (int): End index.\n\n    Returns:\n        RedisListResponseType: List of elements in range.\n    \"\"\"\n    return await self.read_only_client.lrange(name, start, end)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lrem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lrem(name, count, value)</code>  <code>async</code>","text":"<p>Remove elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove.</p> required <code>value</code> <code>str</code> <p>Value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove elements from a list asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int): Number of occurrences to remove.\n        value (str): Value to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements removed.\n    \"\"\"\n    return await self.client.lrem(name, count, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.lset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.lset(name, index, value)</code>  <code>async</code>","text":"<p>Set list element by index asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>index</code> <code>int</code> <p>Index of the element.</p> required <code>value</code> <code>str</code> <p>New value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Set list element by index asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        index (int): Index of the element.\n        value (str): New value.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    result = await self.client.lset(name, index, value)\n    return bool(result)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.rpop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.rpop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return elements from list right asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>count</code> <code>int | None</code> <p>Number of elements to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Popped element(s) or None if list is empty.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Remove and return elements from list right asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        count (int | None): Number of elements to pop. Defaults to None.\n\n    Returns:\n        Any: Popped element(s) or None if list is empty.\n    \"\"\"\n    return await self.client.rpop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.rpush","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.rpush(name, *values)</code>  <code>async</code>","text":"<p>Push elements to list right asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key name of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Length of the list after push.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Push elements to list right asynchronously.\n\n    Args:\n        name (str): The key name of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: Length of the list after push.\n    \"\"\"\n    return await self.client.rpush(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scan","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>async</code>","text":"<p>Scan keys in database incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Scan keys in database incrementally asynchronously.\n\n    Args:\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of keys.\n    \"\"\"\n    return await self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scan_iter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>async</code>","text":"<p>Iterate over keys in database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of keys. Defaults to None.</p> <code>None</code> <code>_type</code> <code>str | None</code> <p>Filter by type. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterator[Any]</code> <p>Iterator[Any]: Iterator over matching keys.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[Any]:\n    \"\"\"Iterate over keys in database asynchronously.\n\n    Args:\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of keys. Defaults to None.\n        _type (str | None): Filter by type. Defaults to None.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        Iterator[Any]: Iterator over matching keys.\n    \"\"\"\n    return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan(name, cursor=0, match=None, count=None)</code>  <code>async</code>","text":"<p>Scan set members incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>cursor</code> <code>int</code> <p>Cursor position. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Tuple of cursor and list of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Scan set members incrementally asynchronously.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        cursor (int): Cursor position. Defaults to 0.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        RedisResponseType: Tuple of cursor and list of members.\n    \"\"\"\n    return await self.read_only_client.sscan(name, cursor, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan_iter","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sscan_iter(name, match=None, count=None)</code>  <code>async</code>","text":"<p>Iterate over set members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The set key name.</p> required <code>match</code> <code>bytes | str | None</code> <p>Pattern to match. Defaults to None.</p> <code>None</code> <code>count</code> <code>int | None</code> <p>Hint for number of elements. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Any]</code> <p>Iterator[Any]: Iterator over set members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator[Any]:\n    \"\"\"Iterate over set members asynchronously.\n\n    Args:\n        name (RedisKeyType): The set key name.\n        match (bytes | str | None): Pattern to match. Defaults to None.\n        count (int | None): Hint for number of elements. Defaults to None.\n\n    Returns:\n        Iterator[Any]: Iterator over set members.\n    \"\"\"\n    return self.read_only_client.sscan_iter(name, match, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sadd","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sadd(name, *values)</code>  <code>async</code>","text":"<p>Add members to a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of elements added.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Add members to a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: Number of elements added.\n    \"\"\"\n    return await self.client.sadd(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.scard","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.scard(name)</code>  <code>async</code>","text":"<p>Get number of members in a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get number of members in a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of members.\n    \"\"\"\n    return await self.client.scard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sismember","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sismember(name, value)</code>  <code>async</code>","text":"<p>Check if value is in set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>value</code> <code>str</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if value is member, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if value is in set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        value (str): Value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if value is member, False otherwise.\n    \"\"\"\n    result = await self.read_only_client.sismember(name, value)\n    return result\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.smembers","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.smembers(name)</code>  <code>async</code>","text":"<p>Get all members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set of all members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Get all members of a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n\n    Returns:\n        RedisSetResponseType: Set of all members.\n    \"\"\"\n    return await self.read_only_client.smembers(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.spop","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.spop(name, count=None)</code>  <code>async</code>","text":"<p>Remove and return random set members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>count</code> <code>int | None</code> <p>Number of members to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: Popped member(s) or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Remove and return random set members asynchronously.\n\n    Args:\n        name (str): The set key name.\n        count (int | None): Number of members to pop. Defaults to None.\n\n    Returns:\n        bytes | float | int | str | list | None: Popped member(s) or None.\n    \"\"\"\n    return await self.client.spop(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.srem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.srem(name, *values)</code>  <code>async</code>","text":"<p>Remove members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Remove members from a set asynchronously.\n\n    Args:\n        name (str): The set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: Number of members removed.\n    \"\"\"\n    return await self.client.srem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.sunion","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.sunion(keys, *args)</code>  <code>async</code>","text":"<p>Get union of multiple sets asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>First set key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional set keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>Set containing union of all sets.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Get union of multiple sets asynchronously.\n\n    Args:\n        keys (RedisKeyType): First set key.\n        *args (bytes | str): Additional set keys.\n\n    Returns:\n        RedisSetResponseType: Set containing union of all sets.\n    \"\"\"\n    result = await self.client.sunion(keys, *args)\n    return set(result) if result else set()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zadd","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>async</code>","text":"<p>Add members to sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>Member-score pairs.</p> required <code>nx</code> <code>bool</code> <p>Only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>Only update existing. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>Return changed count. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>Increment scores. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>Only if greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>Only if less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of elements added or modified.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Add members to sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): Member-score pairs.\n        nx (bool): Only add new elements. Defaults to False.\n        xx (bool): Only update existing. Defaults to False.\n        ch (bool): Return changed count. Defaults to False.\n        incr (bool): Increment scores. Defaults to False.\n        gt (bool): Only if greater. Defaults to False.\n        lt (bool): Only if less. Defaults to False.\n\n    Returns:\n        RedisResponseType: Number of elements added or modified.\n    \"\"\"\n    return await self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zcard","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zcard(name)</code>  <code>async</code>","text":"<p>Get number of members in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The sorted set key name.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Get number of members in sorted set asynchronously.\n\n    Args:\n        name (bytes | str): The sorted set key name.\n\n    Returns:\n        RedisResponseType: Number of members.\n    \"\"\"\n    return await self.client.zcard(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zcount","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zcount(name, min, max)</code>  <code>async</code>","text":"<p>Count members in score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members in range.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Count members in score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n\n    Returns:\n        RedisResponseType: Number of members in range.\n    \"\"\"\n    return await self.client.zcount(name, min, max)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmax","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmax(name, count=None)</code>  <code>async</code>","text":"<p>Pop highest scored members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Pop highest scored members asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return await self.client.zpopmax(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmin","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zpopmin(name, count=None)</code>  <code>async</code>","text":"<p>Pop lowest scored members asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>count</code> <code>int | None</code> <p>Number to pop. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of popped member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Pop lowest scored members asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        count (int | None): Number to pop. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of popped member-score pairs.\n    \"\"\"\n    return await self.client.zpopmin(name, count)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>async</code>","text":"<p>Get range from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index or score.</p> required <code>end</code> <code>int</code> <p>End index or score.</p> required <code>desc</code> <code>bool</code> <p>Descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>Range by score. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>Range by lex. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int | None</code> <p>Offset for byscore/bylex. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count for byscore/bylex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Get range from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index or score.\n        end (int): End index or score.\n        desc (bool): Descending order. Defaults to False.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n        byscore (bool): Range by score. Defaults to False.\n        bylex (bool): Range by lex. Defaults to False.\n        offset (int | None): Offset for byscore/bylex. Defaults to None.\n        num (int | None): Count for byscore/bylex. Defaults to None.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrange(\n        name,\n        start,\n        end,\n        desc,\n        withscores,\n        score_cast_func,\n        byscore,\n        bylex,\n        offset,\n        num,\n    )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrevrange","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>async</code>","text":"<p>Get reverse range from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>start</code> <code>int</code> <p>Start index.</p> required <code>end</code> <code>int</code> <p>End index.</p> required <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get reverse range from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        start (int): Start index.\n        end (int): End index.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrevrange(name, start, end, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrangebyscore","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>async</code>","text":"<p>Get members by score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>min</code> <code>float | str</code> <p>Minimum score.</p> required <code>max</code> <code>float | str</code> <p>Maximum score.</p> required <code>start</code> <code>int | None</code> <p>Offset. Defaults to None.</p> <code>None</code> <code>num</code> <code>int | None</code> <p>Count. Defaults to None.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>Include scores. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Score cast function. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of members or member-score pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Get members by score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        min (float | str): Minimum score.\n        max (float | str): Maximum score.\n        start (int | None): Offset. Defaults to None.\n        num (int | None): Count. Defaults to None.\n        withscores (bool): Include scores. Defaults to False.\n        score_cast_func (RedisScoreCastType): Score cast function. Defaults to float.\n\n    Returns:\n        RedisResponseType: List of members or member-score pairs.\n    \"\"\"\n    return await self.client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrank","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrank(name, value)</code>  <code>async</code>","text":"<p>Get rank of member in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to find rank for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Rank or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get rank of member in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to find rank for.\n\n    Returns:\n        RedisResponseType: Rank or None if not found.\n    \"\"\"\n    return await self.client.zrank(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zrem","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zrem(name, *values)</code>  <code>async</code>","text":"<p>Remove members from sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of members removed.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Remove members from sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: Number of members removed.\n    \"\"\"\n    return await self.client.zrem(name, *values)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zscore","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zscore(name, value)</code>  <code>async</code>","text":"<p>Get score of member in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to get score for.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Score or None if not found.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Get score of member in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        value (bytes | str | float): Member to get score for.\n\n    Returns:\n        RedisResponseType: Score or None if not found.\n    \"\"\"\n    return await self.client.zscore(name, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hdel","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hdel(name, *keys)</code>  <code>async</code>","text":"<p>Delete fields from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields deleted.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Delete fields from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields deleted.\n    \"\"\"\n    return await self.client.hdel(name, *keys)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hexists","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hexists(name, key)</code>  <code>async</code>","text":"<p>Check if field exists in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if exists, False otherwise.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Check if field exists in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if exists, False otherwise.\n    \"\"\"\n    return await self.read_only_client.hexists(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hget(name, key)</code>  <code>async</code>","text":"<p>Get field value from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str</code> <p>Field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: Value or None.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Get field value from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str): Field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: Value or None.\n    \"\"\"\n    return await self.read_only_client.hget(name, key)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hgetall","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hgetall(name)</code>  <code>async</code>","text":"<p>Get all fields and values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: Dictionary of field-value pairs.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Get all fields and values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        Awaitable[dict] | dict: Dictionary of field-value pairs.\n    \"\"\"\n    return await self.read_only_client.hgetall(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hkeys","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hkeys(name)</code>  <code>async</code>","text":"<p>Get all fields from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all fields from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of field names.\n    \"\"\"\n    return await self.read_only_client.hkeys(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hlen","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hlen(name)</code>  <code>async</code>","text":"<p>Get number of fields in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Get number of fields in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields.\n    \"\"\"\n    return await self.read_only_client.hlen(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hset","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>async</code>","text":"<p>Set fields in hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>key</code> <code>str | bytes | None</code> <p>Single field name. Defaults to None.</p> <code>None</code> <code>value</code> <code>str | bytes | None</code> <p>Single field value. Defaults to None.</p> <code>None</code> <code>mapping</code> <code>dict | None</code> <p>Field-value pairs dict. Defaults to None.</p> <code>None</code> <code>items</code> <code>list | None</code> <p>Field-value pairs list. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>Number of fields set.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Set fields in hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        key (str | bytes | None): Single field name. Defaults to None.\n        value (str | bytes | None): Single field value. Defaults to None.\n        mapping (dict | None): Field-value pairs dict. Defaults to None.\n        items (list | None): Field-value pairs list. Defaults to None.\n\n    Returns:\n        RedisIntegerResponseType: Number of fields set.\n    \"\"\"\n    return await self.client.hset(name, key, value, mapping, items)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hmget","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hmget(name, keys, *args)</code>  <code>async</code>","text":"<p>Get multiple field values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <code>keys</code> <code>list</code> <p>List of field names.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional field names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of field values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Get multiple field values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n        keys (list): List of field names.\n        *args (str | bytes): Additional field names.\n\n    Returns:\n        RedisListResponseType: List of field values.\n    \"\"\"\n    return await self.read_only_client.hmget(name, keys, *args)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.hvals","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.hvals(name)</code>  <code>async</code>","text":"<p>Get all values from hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The hash key name.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>List of values.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Get all values from hash asynchronously.\n\n    Args:\n        name (str): The hash key name.\n\n    Returns:\n        RedisListResponseType: List of values.\n    \"\"\"\n    return await self.read_only_client.hvals(name)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.publish","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.publish(channel, message, **kwargs)</code>  <code>async</code>","text":"<p>Publish message to channel asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>Channel name.</p> required <code>message</code> <code>bytes | str</code> <p>Message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Number of subscribers received message.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publish message to channel asynchronously.\n\n    Args:\n        channel (RedisKeyType): Channel name.\n        message (bytes | str): Message to publish.\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: Number of subscribers received message.\n    \"\"\"\n    return await self.client.publish(channel, message, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub_channels","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub_channels(pattern='*', **kwargs)</code>  <code>async</code>","text":"<p>List active channels matching pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>Pattern to match. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>List of channel names.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"List active channels matching pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): Pattern to match. Defaults to \"*\".\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        RedisResponseType: List of channel names.\n    \"\"\"\n    return await self.client.pubsub_channels(pattern, **kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.zincrby","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.zincrby(name, amount, value)</code>  <code>async</code>","text":"<p>Increment member score in sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The sorted set key name.</p> required <code>amount</code> <code>float</code> <p>Amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>Member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>New score of the member.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increment member score in sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The sorted set key name.\n        amount (float): Amount to increment by.\n        value (bytes | str | float): Member to increment.\n\n    Returns:\n        RedisResponseType: New score of the member.\n    \"\"\"\n    return await self.client.zincrby(name, amount, value)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.pubsub(**kwargs)</code>  <code>async</code>","text":"<p>Get PubSub object for channel subscription asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>AsyncPubSub</code> <code>PubSub</code> <p>PubSub object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def pubsub(self, **kwargs: Any) -&gt; AsyncPubSub:\n    \"\"\"Get PubSub object for channel subscription asynchronously.\n\n    Args:\n        **kwargs (Any): Additional arguments.\n\n    Returns:\n        AsyncPubSub: PubSub object.\n    \"\"\"\n    return self.client.pubsub(**kwargs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.get_pipeline","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.get_pipeline(transaction=True, shard_hint=None)</code>  <code>async</code>","text":"<p>Get pipeline for multiple commands asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>Use transactions. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Sharding hint. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AsyncPipeline</code> <code>Pipeline</code> <p>Pipeline object.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; AsyncPipeline:\n    \"\"\"Get pipeline for multiple commands asynchronously.\n\n    Args:\n        transaction (Any): Use transactions. Defaults to True.\n        shard_hint (Any): Sharding hint. Defaults to None.\n\n    Returns:\n        AsyncPipeline: Pipeline object.\n    \"\"\"\n    return self.client.pipeline(transaction, shard_hint)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.AsyncRedisAdapter.ping","title":"<code>archipy.adapters.redis.adapters.AsyncRedisAdapter.ping()</code>  <code>async</code>","text":"<p>Ping the Redis server asynchronously.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>'PONG' if successful.</p> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>@override\nasync def ping(self) -&gt; RedisResponseType:\n    \"\"\"Ping the Redis server asynchronously.\n\n    Returns:\n        RedisResponseType: 'PONG' if successful.\n    \"\"\"\n    return await self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports","title":"<code>archipy.adapters.redis.ports</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort","title":"<code>archipy.adapters.redis.ports.RedisPort</code>","text":"<p>Interface for Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping a Redis client library.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class RedisPort:\n    \"\"\"Interface for Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping a Redis client library.\n    \"\"\"\n\n    @abstractmethod\n    def ping(self) -&gt; RedisResponseType:\n        \"\"\"Tests the connection to the Redis server.\n\n        Returns:\n            RedisResponseType: The response from the server, typically \"PONG\".\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in milliseconds.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increments the integer value of a key by the given amount.\n\n        Args:\n            name (RedisKeyType): The key to increment.\n            amount (int): The amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after incrementing.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value with optional expiration and conditions.\n\n        Args:\n            name (RedisKeyType): The key to set.\n            value (RedisSetType): The value to set for the key.\n            ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n            px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n            nx (bool): If True, set only if the key does not exist. Defaults to False.\n            xx (bool): If True, set only if the key already exists. Defaults to False.\n            keepttl (bool): If True, retain the existing TTL. Defaults to False.\n            get (bool): If True, return the old value before setting. Defaults to False.\n            exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n            pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n        Returns:\n            RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Retrieves the value of a key.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets the values of multiple keys.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: A list of values corresponding to the keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Sets multiple keys to their respective values.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n        Returns:\n            RedisResponseType: Typically \"OK\" on success.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Returns all keys matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of matching keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value and returns its old value.\n\n        Args:\n            key (RedisKeyType): The key to set.\n            value (bytes | str | float): The new value to set.\n\n        Returns:\n            RedisResponseType: The old value of the key, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the value of a key and deletes it.\n\n        Args:\n            key (bytes | str): The key to get and delete.\n\n        Returns:\n            RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Checks if one or more keys exist.\n\n        Args:\n            *names (bytes | str): Variable number of keys to check.\n\n        Returns:\n            RedisResponseType: The number of keys that exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Deletes one or more keys.\n\n        Args:\n            *names (bytes | str): Variable number of keys to delete.\n\n        Returns:\n            RedisResponseType: The number of keys deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Appends a value to a key's string value.\n\n        Args:\n            key (RedisKeyType): The key to append to.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: The length of the string after appending.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in seconds.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determines the type of value stored at a key.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the length of a list.\n\n        Args:\n            name (str): The key of the list.\n\n        Returns:\n            RedisIntegerResponseType: The number of items in the list.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the first element(s) of a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the start of a list.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Gets a range of elements from a list.\n\n        Args:\n            name (str): The key of the list.\n            start (int): The starting index (inclusive).\n            end (int): The ending index (inclusive).\n\n        Returns:\n            RedisListResponseType: A list of elements in the specified range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes occurrences of a value from a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int): Number of occurrences to remove (0 for all).\n            value (str): The value to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of elements removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Sets the value of an element in a list by index.\n\n        Args:\n            name (str): The key of the list.\n            index (int): The index to set.\n            value (str): The new value.\n\n        Returns:\n            bool: True if successful.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the last element(s) of a list.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the end of a list.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over keys in the database incrementally.\n\n        Args:\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over keys in the database.\n\n        Args:\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Iterator: An iterator yielding keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over members of a set incrementally.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over members of a set.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            Iterator: An iterator yielding set members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Adds one or more members to a set.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of members in a set.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisIntegerResponseType: The cardinality (size) of the set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a value is a member of a set.\n\n        Args:\n            name (str): The key of the set.\n            value (str): The value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Gets all members of a set.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisSetResponseType: A set of all members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Removes and returns one or more random members from a set.\n\n        Args:\n            name (str): The key of the set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes one or more members from a set.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Gets the union of multiple sets.\n\n        Args:\n            keys (RedisKeyType): Name of the first key.\n            *args (bytes | str): Additional key names.\n\n        Returns:\n            RedisSetResponseType: A set containing members of the resulting union.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Adds members with scores to a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n            nx (bool): If True, only add new elements. Defaults to False.\n            xx (bool): If True, only update existing elements. Defaults to False.\n            ch (bool): If True, return the number of changed elements. Defaults to False.\n            incr (bool): If True, increment scores instead of setting. Defaults to False.\n            gt (bool): If True, only update if new score is greater. Defaults to False.\n            lt (bool): If True, only update if new score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: The number of elements added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the number of members in a sorted set.\n\n        Args:\n            name (bytes | str): The key of the sorted set.\n\n        Returns:\n            RedisResponseType: The cardinality (size) of the sorted set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Counts members in a sorted set within a score range.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n\n        Returns:\n            RedisResponseType: The number of members within the score range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the highest scores from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the lowest scores from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index or score (depending on byscore).\n            end (int): The ending index or score (depending on byscore).\n            desc (bool): If True, sort in descending order. Defaults to False.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): If True, range by score instead of rank. Defaults to False.\n            bylex (bool): If True, range by lexicographical order. Defaults to False.\n            offset (int, optional): Offset for byscore or bylex.\n            num (int, optional): Number of elements for byscore or bylex.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set in reverse order.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index.\n            end (int): The ending index.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets members from a sorted set by score range.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n            start (int, optional): Starting offset.\n            num (int, optional): Number of elements to return.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the rank of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to find.\n\n        Returns:\n            RedisResponseType: The rank (index) of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Removes one or more members from a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to check.\n\n        Returns:\n            RedisResponseType: The score of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Deletes one or more fields from a hash.\n\n        Args:\n            name (str): The key of the hash.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a field exists in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Gets the value of a field in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Gets all fields and values in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Sets one or more fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            key (str | bytes, optional): A single field to set.\n            value (str | bytes, optional): The value for the single field.\n            mapping (dict, optional): A dictionary of field/value pairs.\n            items (list, optional): A list of field/value pairs.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Gets the values of multiple fields in a hash.\n\n        Args:\n            name (str): The key of the hash.\n            keys (list): A list of fields to get.\n            *args (str | bytes): Additional fields to get.\n\n        Returns:\n            RedisListResponseType: A list of values for the specified fields.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all values in a hash.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of values in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publishes a message to a channel.\n\n        Args:\n            channel (RedisKeyType): The channel to publish to.\n            message (bytes | str): The message to publish.\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: The number of subscribers that received the message.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Lists active channels matching a pattern.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of active channels.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increments the score of a member in a sorted set.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            amount (float): The amount to increment by.\n            value (bytes | str | float): The member to increment.\n\n        Returns:\n            RedisResponseType: The new score of the member.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Returns a pub/sub object for subscribing to channels.\n\n        Args:\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Any: A pub/sub object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        \"\"\"Returns a pipeline object for batching commands.\n\n        Args:\n            transaction (Any): If True, execute commands in a transaction. Defaults to True.\n            shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n        Returns:\n            Any: A pipeline object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.ping","title":"<code>archipy.adapters.redis.ports.RedisPort.ping()</code>  <code>abstractmethod</code>","text":"<p>Tests the connection to the Redis server.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The response from the server, typically \"PONG\".</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef ping(self) -&gt; RedisResponseType:\n    \"\"\"Tests the connection to the Redis server.\n\n    Returns:\n        RedisResponseType: The response from the server, typically \"PONG\".\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pttl","title":"<code>archipy.adapters.redis.ports.RedisPort.pttl(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the remaining time to live of a key in milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in milliseconds.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.incrby","title":"<code>archipy.adapters.redis.ports.RedisPort.incrby(name, amount=1)</code>  <code>abstractmethod</code>","text":"<p>Increments the integer value of a key by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to increment.</p> required <code>amount</code> <code>int</code> <p>The amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after incrementing.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increments the integer value of a key by the given amount.\n\n    Args:\n        name (RedisKeyType): The key to increment.\n        amount (int): The amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after incrementing.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.set","title":"<code>archipy.adapters.redis.ports.RedisPort.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>abstractmethod</code>","text":"<p>Sets a key to a value with optional expiration and conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set for the key.</p> required <code>ex</code> <code>RedisExpiryType</code> <p>Expiration time in seconds or timedelta.</p> <code>None</code> <code>px</code> <code>RedisExpiryType</code> <p>Expiration time in milliseconds or timedelta.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>If True, set only if the key does not exist. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, set only if the key already exists. Defaults to False.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>If True, retain the existing TTL. Defaults to False.</p> <code>False</code> <code>get</code> <code>bool</code> <p>If True, return the old value before setting. Defaults to False.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time as Unix timestamp or datetime.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time in milliseconds or datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The result of the operation, often \"OK\" or the old value if get=True.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value with optional expiration and conditions.\n\n    Args:\n        name (RedisKeyType): The key to set.\n        value (RedisSetType): The value to set for the key.\n        ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n        px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n        nx (bool): If True, set only if the key does not exist. Defaults to False.\n        xx (bool): If True, set only if the key already exists. Defaults to False.\n        keepttl (bool): If True, retain the existing TTL. Defaults to False.\n        get (bool): If True, return the old value before setting. Defaults to False.\n        exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n        pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n    Returns:\n        RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.get","title":"<code>archipy.adapters.redis.ports.RedisPort.get(key)</code>  <code>abstractmethod</code>","text":"<p>Retrieves the value of a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value associated with the key, or None if the key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Retrieves the value of a key.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.mget","title":"<code>archipy.adapters.redis.ports.RedisPort.mget(keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the values of multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>A single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of values corresponding to the keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Gets the values of multiple keys.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: A list of values corresponding to the keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.mset","title":"<code>archipy.adapters.redis.ports.RedisPort.mset(mapping)</code>  <code>abstractmethod</code>","text":"<p>Sets multiple keys to their respective values.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of keys to values.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Typically \"OK\" on success.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Sets multiple keys to their respective values.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n    Returns:\n        RedisResponseType: Typically \"OK\" on success.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.keys","title":"<code>archipy.adapters.redis.ports.RedisPort.keys(pattern='*', **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns all keys matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of matching keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Returns all keys matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of matching keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.getset","title":"<code>archipy.adapters.redis.ports.RedisPort.getset(key, value)</code>  <code>abstractmethod</code>","text":"<p>Sets a key to a value and returns its old value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value to set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The old value of the key, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value and returns its old value.\n\n    Args:\n        key (RedisKeyType): The key to set.\n        value (bytes | str | float): The new value to set.\n\n    Returns:\n        RedisResponseType: The old value of the key, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.getdel","title":"<code>archipy.adapters.redis.ports.RedisPort.getdel(key)</code>  <code>abstractmethod</code>","text":"<p>Gets the value of a key and deletes it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to get and delete.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key before deletion, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the value of a key and deletes it.\n\n    Args:\n        key (bytes | str): The key to get and delete.\n\n    Returns:\n        RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.exists","title":"<code>archipy.adapters.redis.ports.RedisPort.exists(*names)</code>  <code>abstractmethod</code>","text":"<p>Checks if one or more keys exist.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to check.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys that exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Checks if one or more keys exist.\n\n    Args:\n        *names (bytes | str): Variable number of keys to check.\n\n    Returns:\n        RedisResponseType: The number of keys that exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.delete","title":"<code>archipy.adapters.redis.ports.RedisPort.delete(*names)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more keys.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Deletes one or more keys.\n\n    Args:\n        *names (bytes | str): Variable number of keys to delete.\n\n    Returns:\n        RedisResponseType: The number of keys deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.append","title":"<code>archipy.adapters.redis.ports.RedisPort.append(key, value)</code>  <code>abstractmethod</code>","text":"<p>Appends a value to a key's string value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to append to.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The length of the string after appending.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Appends a value to a key's string value.\n\n    Args:\n        key (RedisKeyType): The key to append to.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: The length of the string after appending.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.ttl","title":"<code>archipy.adapters.redis.ports.RedisPort.ttl(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the remaining time to live of a key in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in seconds.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.type","title":"<code>archipy.adapters.redis.ports.RedisPort.type(name)</code>  <code>abstractmethod</code>","text":"<p>Determines the type of value stored at a key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The type of the key's value (e.g., \"string\", \"list\", etc.).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determines the type of value stored at a key.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.llen","title":"<code>archipy.adapters.redis.ports.RedisPort.llen(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the length of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of items in the list.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the length of a list.\n\n    Args:\n        name (str): The key of the list.\n\n    Returns:\n        RedisIntegerResponseType: The number of items in the list.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lpop","title":"<code>archipy.adapters.redis.ports.RedisPort.lpop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns the first element(s) of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the first element(s) of a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lpush","title":"<code>archipy.adapters.redis.ports.RedisPort.lpush(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Pushes one or more values to the start of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the start of a list.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lrange","title":"<code>archipy.adapters.redis.ports.RedisPort.lrange(name, start, end)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of elements from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting index (inclusive).</p> required <code>end</code> <code>int</code> <p>The ending index (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of elements in the specified range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Gets a range of elements from a list.\n\n    Args:\n        name (str): The key of the list.\n        start (int): The starting index (inclusive).\n        end (int): The ending index (inclusive).\n\n    Returns:\n        RedisListResponseType: A list of elements in the specified range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lrem","title":"<code>archipy.adapters.redis.ports.RedisPort.lrem(name, count, value)</code>  <code>abstractmethod</code>","text":"<p>Removes occurrences of a value from a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove (0 for all).</p> required <code>value</code> <code>str</code> <p>The value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of elements removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes occurrences of a value from a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int): Number of occurrences to remove (0 for all).\n        value (str): The value to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of elements removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.lset","title":"<code>archipy.adapters.redis.ports.RedisPort.lset(name, index, value)</code>  <code>abstractmethod</code>","text":"<p>Sets the value of an element in a list by index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index to set.</p> required <code>value</code> <code>str</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Sets the value of an element in a list by index.\n\n    Args:\n        name (str): The key of the list.\n        index (int): The index to set.\n        value (str): The new value.\n\n    Returns:\n        bool: True if successful.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.rpop","title":"<code>archipy.adapters.redis.ports.RedisPort.rpop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns the last element(s) of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the last element(s) of a list.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.rpush","title":"<code>archipy.adapters.redis.ports.RedisPort.rpush(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Pushes one or more values to the end of a list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the end of a list.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scan","title":"<code>archipy.adapters.redis.ports.RedisPort.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Iterates over keys in the database incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_keys).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over keys in the database incrementally.\n\n    Args:\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scan_iter","title":"<code>archipy.adapters.redis.ports.RedisPort.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Provides an iterator over keys in the database.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over keys in the database.\n\n    Args:\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Iterator: An iterator yielding keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sscan","title":"<code>archipy.adapters.redis.ports.RedisPort.sscan(name, cursor=0, match=None, count=None)</code>  <code>abstractmethod</code>","text":"<p>Iterates over members of a set incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_members).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over members of a set incrementally.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sscan_iter","title":"<code>archipy.adapters.redis.ports.RedisPort.sscan_iter(name, match=None, count=None)</code>  <code>abstractmethod</code>","text":"<p>Provides an iterator over members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding set members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over members of a set.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        Iterator: An iterator yielding set members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sadd","title":"<code>archipy.adapters.redis.ports.RedisPort.sadd(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Adds one or more members to a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members added (excluding duplicates).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Adds one or more members to a set.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.scard","title":"<code>archipy.adapters.redis.ports.RedisPort.scard(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of members in a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The cardinality (size) of the set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of members in a set.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisIntegerResponseType: The cardinality (size) of the set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sismember","title":"<code>archipy.adapters.redis.ports.RedisPort.sismember(name, value)</code>  <code>abstractmethod</code>","text":"<p>Checks if a value is a member of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the value is a member, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a value is a member of a set.\n\n    Args:\n        name (str): The key of the set.\n        value (str): The value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.smembers","title":"<code>archipy.adapters.redis.ports.RedisPort.smembers(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all members of a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set of all members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Gets all members of a set.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisSetResponseType: A set of all members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.spop","title":"<code>archipy.adapters.redis.ports.RedisPort.spop(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns one or more random members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Removes and returns one or more random members from a set.\n\n    Args:\n        name (str): The key of the set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.srem","title":"<code>archipy.adapters.redis.ports.RedisPort.srem(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Removes one or more members from a set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes one or more members from a set.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.sunion","title":"<code>archipy.adapters.redis.ports.RedisPort.sunion(keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the union of multiple sets.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>Name of the first key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set containing members of the resulting union.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Gets the union of multiple sets.\n\n    Args:\n        keys (RedisKeyType): Name of the first key.\n        *args (bytes | str): Additional key names.\n\n    Returns:\n        RedisSetResponseType: A set containing members of the resulting union.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zadd","title":"<code>archipy.adapters.redis.ports.RedisPort.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>abstractmethod</code>","text":"<p>Adds members with scores to a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of members to scores.</p> required <code>nx</code> <code>bool</code> <p>If True, only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>If True, return the number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>If True, increment scores instead of setting. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>If True, only update if new score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>If True, only update if new score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of elements added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Adds members with scores to a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n        nx (bool): If True, only add new elements. Defaults to False.\n        xx (bool): If True, only update existing elements. Defaults to False.\n        ch (bool): If True, return the number of changed elements. Defaults to False.\n        incr (bool): If True, increment scores instead of setting. Defaults to False.\n        gt (bool): If True, only update if new score is greater. Defaults to False.\n        lt (bool): If True, only update if new score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: The number of elements added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zcard","title":"<code>archipy.adapters.redis.ports.RedisPort.zcard(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of members in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The cardinality (size) of the sorted set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the number of members in a sorted set.\n\n    Args:\n        name (bytes | str): The key of the sorted set.\n\n    Returns:\n        RedisResponseType: The cardinality (size) of the sorted set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zcount","title":"<code>archipy.adapters.redis.ports.RedisPort.zcount(name, min, max)</code>  <code>abstractmethod</code>","text":"<p>Counts members in a sorted set within a score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members within the score range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Counts members in a sorted set within a score range.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n\n    Returns:\n        RedisResponseType: The number of members within the score range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zpopmax","title":"<code>archipy.adapters.redis.ports.RedisPort.zpopmax(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns members with the highest scores from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the highest scores from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zpopmin","title":"<code>archipy.adapters.redis.ports.RedisPort.zpopmin(name, count=None)</code>  <code>abstractmethod</code>","text":"<p>Removes and returns members with the lowest scores from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the lowest scores from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrange","title":"<code>archipy.adapters.redis.ports.RedisPort.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index or score (depending on byscore).</p> required <code>end</code> <code>int</code> <p>The ending index or score (depending on byscore).</p> required <code>desc</code> <code>bool</code> <p>If True, sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>If True, range by score instead of rank. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>If True, range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int</code> <p>Offset for byscore or bylex.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements for byscore or bylex.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index or score (depending on byscore).\n        end (int): The ending index or score (depending on byscore).\n        desc (bool): If True, sort in descending order. Defaults to False.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): If True, range by score instead of rank. Defaults to False.\n        bylex (bool): If True, range by lexicographical order. Defaults to False.\n        offset (int, optional): Offset for byscore or bylex.\n        num (int, optional): Number of elements for byscore or bylex.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrevrange","title":"<code>archipy.adapters.redis.ports.RedisPort.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code>","text":"<p>Gets a range of members from a sorted set in reverse order.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set in reverse order.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index.\n        end (int): The ending index.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrangebyscore","title":"<code>archipy.adapters.redis.ports.RedisPort.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code>","text":"<p>Gets members from a sorted set by score range.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <code>start</code> <code>int</code> <p>Starting offset.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements to return.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets members from a sorted set by score range.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n        start (int, optional): Starting offset.\n        num (int, optional): Number of elements to return.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrank","title":"<code>archipy.adapters.redis.ports.RedisPort.zrank(name, value)</code>  <code>abstractmethod</code>","text":"<p>Gets the rank of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to find.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The rank (index) of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the rank of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to find.\n\n    Returns:\n        RedisResponseType: The rank (index) of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zrem","title":"<code>archipy.adapters.redis.ports.RedisPort.zrem(name, *values)</code>  <code>abstractmethod</code>","text":"<p>Removes one or more members from a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Removes one or more members from a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zscore","title":"<code>archipy.adapters.redis.ports.RedisPort.zscore(name, value)</code>  <code>abstractmethod</code>","text":"<p>Gets the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The score of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to check.\n\n    Returns:\n        RedisResponseType: The score of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hdel","title":"<code>archipy.adapters.redis.ports.RedisPort.hdel(name, *keys)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more fields from a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Deletes one or more fields from a hash.\n\n    Args:\n        name (str): The key of the hash.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hexists","title":"<code>archipy.adapters.redis.ports.RedisPort.hexists(name, key)</code>  <code>abstractmethod</code>","text":"<p>Checks if a field exists in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the field exists, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a field exists in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hget","title":"<code>archipy.adapters.redis.ports.RedisPort.hget(name, key)</code>  <code>abstractmethod</code>","text":"<p>Gets the value of a field in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: The value of the field, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Gets the value of a field in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hgetall","title":"<code>archipy.adapters.redis.ports.RedisPort.hgetall(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all fields and values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: A dictionary of field/value pairs.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Gets all fields and values in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hkeys","title":"<code>archipy.adapters.redis.ports.RedisPort.hkeys(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hlen","title":"<code>archipy.adapters.redis.ports.RedisPort.hlen(name)</code>  <code>abstractmethod</code>","text":"<p>Gets the number of fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hset","title":"<code>archipy.adapters.redis.ports.RedisPort.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>abstractmethod</code>","text":"<p>Sets one or more fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str | bytes</code> <p>A single field to set.</p> <code>None</code> <code>value</code> <code>str | bytes</code> <p>The value for the single field.</p> <code>None</code> <code>mapping</code> <code>dict</code> <p>A dictionary of field/value pairs.</p> <code>None</code> <code>items</code> <code>list</code> <p>A list of field/value pairs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Sets one or more fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        key (str | bytes, optional): A single field to set.\n        value (str | bytes, optional): The value for the single field.\n        mapping (dict, optional): A dictionary of field/value pairs.\n        items (list, optional): A list of field/value pairs.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hmget","title":"<code>archipy.adapters.redis.ports.RedisPort.hmget(name, keys, *args)</code>  <code>abstractmethod</code>","text":"<p>Gets the values of multiple fields in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>keys</code> <code>list</code> <p>A list of fields to get.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional fields to get.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values for the specified fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Gets the values of multiple fields in a hash.\n\n    Args:\n        name (str): The key of the hash.\n        keys (list): A list of fields to get.\n        *args (str | bytes): Additional fields to get.\n\n    Returns:\n        RedisListResponseType: A list of values for the specified fields.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.hvals","title":"<code>archipy.adapters.redis.ports.RedisPort.hvals(name)</code>  <code>abstractmethod</code>","text":"<p>Gets all values in a hash.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all values in a hash.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of values in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.publish","title":"<code>archipy.adapters.redis.ports.RedisPort.publish(channel, message, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Publishes a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>The channel to publish to.</p> required <code>message</code> <code>bytes | str</code> <p>The message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of subscribers that received the message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publishes a message to a channel.\n\n    Args:\n        channel (RedisKeyType): The channel to publish to.\n        message (bytes | str): The message to publish.\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: The number of subscribers that received the message.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pubsub_channels","title":"<code>archipy.adapters.redis.ports.RedisPort.pubsub_channels(pattern='*', **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Lists active channels matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of active channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Lists active channels matching a pattern.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of active channels.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.zincrby","title":"<code>archipy.adapters.redis.ports.RedisPort.zincrby(name, amount, value)</code>  <code>abstractmethod</code>","text":"<p>Increments the score of a member in a sorted set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>amount</code> <code>float</code> <p>The amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new score of the member.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increments the score of a member in a sorted set.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        amount (float): The amount to increment by.\n        value (bytes | str | float): The member to increment.\n\n    Returns:\n        RedisResponseType: The new score of the member.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.pubsub","title":"<code>archipy.adapters.redis.ports.RedisPort.pubsub(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns a pub/sub object for subscribing to channels.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pub/sub object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef pubsub(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns a pub/sub object for subscribing to channels.\n\n    Args:\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Any: A pub/sub object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort.get_pipeline","title":"<code>archipy.adapters.redis.ports.RedisPort.get_pipeline(transaction=True, shard_hint=None)</code>  <code>abstractmethod</code>","text":"<p>Returns a pipeline object for batching commands.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>If True, execute commands in a transaction. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding in clustered Redis.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pipeline object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\ndef get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n    \"\"\"Returns a pipeline object for batching commands.\n\n    Args:\n        transaction (Any): If True, execute commands in a transaction. Defaults to True.\n        shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n    Returns:\n        Any: A pipeline object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort</code>","text":"<p>Interface for asynchronous Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for asynchronous Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping an asynchronous Redis client library.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class AsyncRedisPort:\n    \"\"\"Interface for asynchronous Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for asynchronous Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping an asynchronous Redis client library.\n    \"\"\"\n\n    @abstractmethod\n    async def ping(self) -&gt; RedisResponseType:\n        \"\"\"Tests the connection to the Redis server asynchronously.\n\n        Returns:\n            RedisResponseType: The response from the server, typically \"PONG\".\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in milliseconds asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        \"\"\"Increments the integer value of a key by the given amount asynchronously.\n\n        Args:\n            name (RedisKeyType): The key to increment.\n            amount (int): The amount to increment by. Defaults to 1.\n\n        Returns:\n            RedisResponseType: The new value after incrementing.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value with optional expiration and conditions asynchronously.\n\n        Args:\n            name (RedisKeyType): The key to set.\n            value (RedisSetType): The value to set for the key.\n            ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n            px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n            nx (bool): If True, set only if the key does not exist. Defaults to False.\n            xx (bool): If True, set only if the key already exists. Defaults to False.\n            keepttl (bool): If True, retain the existing TTL. Defaults to False.\n            get (bool): If True, return the old value before setting. Defaults to False.\n            exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n            pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n        Returns:\n            RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get(self, key: str) -&gt; RedisResponseType:\n        \"\"\"Retrieves the value of a key asynchronously.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets the values of multiple keys asynchronously.\n\n        Args:\n            keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n            *args (bytes | str): Additional keys.\n\n        Returns:\n            RedisResponseType: A list of values corresponding to the keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        \"\"\"Sets multiple keys to their respective values asynchronously.\n\n        Args:\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n        Returns:\n            RedisResponseType: Typically \"OK\" on success.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Returns all keys matching a pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of matching keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Sets a key to a value and returns its old value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key to set.\n            value (bytes | str | float): The new value to set.\n\n        Returns:\n            RedisResponseType: The old value of the key, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the value of a key and deletes it asynchronously.\n\n        Args:\n            key (bytes | str): The key to get and delete.\n\n        Returns:\n            RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Checks if one or more keys exist asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of keys to check.\n\n        Returns:\n            RedisResponseType: The number of keys that exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Deletes one or more keys asynchronously.\n\n        Args:\n            *names (bytes | str): Variable number of keys to delete.\n\n        Returns:\n            RedisResponseType: The number of keys deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Appends a value to a key's string value asynchronously.\n\n        Args:\n            key (RedisKeyType): The key to append to.\n            value (bytes | str | float): The value to append.\n\n        Returns:\n            RedisResponseType: The length of the string after appending.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the remaining time to live of a key in seconds asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def type(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Determines the type of value stored at a key asynchronously.\n\n        Args:\n            name (bytes | str): The key to check.\n\n        Returns:\n            RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the length of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n\n        Returns:\n            RedisIntegerResponseType: The number of items in the list.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the first element(s) of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the start of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        \"\"\"Gets a range of elements from a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            start (int): The starting index (inclusive).\n            end (int): The ending index (inclusive).\n\n        Returns:\n            RedisListResponseType: A list of elements in the specified range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes occurrences of a value from a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int): Number of occurrences to remove (0 for all).\n            value (str): The value to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of elements removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def lset(self, name: str, index: int, value: str) -&gt; bool:\n        \"\"\"Sets the value of an element in a list by index asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            index (int): The index to set.\n            value (str): The new value.\n\n        Returns:\n            bool: True if successful.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        \"\"\"Removes and returns the last element(s) of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n        Returns:\n            Any: The popped element(s), or None if the list is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Pushes one or more values to the end of a list asynchronously.\n\n        Args:\n            name (str): The key of the list.\n            *values (bytes | str | float): Values to push.\n\n        Returns:\n            RedisIntegerResponseType: The length of the list after the push.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over keys in the database incrementally asynchronously.\n\n        Args:\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over keys in the database asynchronously.\n\n        Args:\n            match (bytes | str, optional): Pattern to match keys against.\n            count (int, optional): Hint for number of keys to return per iteration.\n            _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Iterator: An iterator yielding keys.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Iterates over members of a set incrementally asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            cursor (int): The cursor position to start scanning. Defaults to 0.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        \"\"\"Provides an iterator over members of a set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the set.\n            match (bytes | str, optional): Pattern to match members against.\n            count (int, optional): Hint for number of members to return per iteration.\n\n        Returns:\n            Iterator: An iterator yielding set members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Adds one or more members to a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to add.\n\n        Returns:\n            RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of members in a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisIntegerResponseType: The cardinality (size) of the set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a value is a member of a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            value (str): The value to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def smembers(self, name: str) -&gt; RedisSetResponseType:\n        \"\"\"Gets all members of a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n\n        Returns:\n            RedisSetResponseType: A set of all members.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        \"\"\"Removes and returns one or more random members from a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        \"\"\"Removes one or more members from a set asynchronously.\n\n        Args:\n            name (str): The key of the set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisIntegerResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n        \"\"\"Gets the union of multiple sets asynchronously.\n\n        Args:\n            keys (RedisKeyType): Name of the first key.\n            *args (bytes | str): Additional key names.\n\n        Returns:\n            RedisSetResponseType: A set containing members of the resulting union.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        \"\"\"Adds members with scores to a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n            nx (bool): If True, only add new elements. Defaults to False.\n            xx (bool): If True, only update existing elements. Defaults to False.\n            ch (bool): If True, return the number of changed elements. Defaults to False.\n            incr (bool): If True, increment scores instead of setting. Defaults to False.\n            gt (bool): If True, only update if new score is greater. Defaults to False.\n            lt (bool): If True, only update if new score is less. Defaults to False.\n\n        Returns:\n            RedisResponseType: The number of elements added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        \"\"\"Gets the number of members in a sorted set asynchronously.\n\n        Args:\n            name (bytes | str): The key of the sorted set.\n\n        Returns:\n            RedisResponseType: The cardinality (size) of the sorted set.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        \"\"\"Counts members in a sorted set within a score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n\n        Returns:\n            RedisResponseType: The number of members within the score range.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the highest scores from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        \"\"\"Removes and returns members with the lowest scores from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n        Returns:\n            RedisResponseType: A list of (member, score) tuples popped.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index or score (depending on byscore).\n            end (int): The ending index or score (depending on byscore).\n            desc (bool): If True, sort in descending order. Defaults to False.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n            byscore (bool): If True, range by score instead of rank. Defaults to False.\n            bylex (bool): If True, range by lexicographical order. Defaults to False.\n            offset (int, optional): Offset for byscore or bylex.\n            num (int, optional): Number of elements for byscore or bylex.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets a range of members from a sorted set in reverse order asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            start (int): The starting index.\n            end (int): The ending index.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        \"\"\"Gets members from a sorted set by score range asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            min (float | str): The minimum score (inclusive).\n            max (float | str): The maximum score (inclusive).\n            start (int, optional): Starting offset.\n            num (int, optional): Number of elements to return.\n            withscores (bool): If True, return scores with members. Defaults to False.\n            score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n        Returns:\n            RedisResponseType: A list of members (and scores if withscores=True).\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the rank of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to find.\n\n        Returns:\n            RedisResponseType: The rank (index) of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Removes one or more members from a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            *values (bytes | str | float): Members to remove.\n\n        Returns:\n            RedisResponseType: The number of members removed.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Gets the score of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            value (bytes | str | float): The member to check.\n\n        Returns:\n            RedisResponseType: The score of the member, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        \"\"\"Deletes one or more fields from a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            *keys (str | bytes): Fields to delete.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields deleted.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        \"\"\"Checks if a field exists in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to check.\n\n        Returns:\n            Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        \"\"\"Gets the value of a field in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str): The field to get.\n\n        Returns:\n            Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        \"\"\"Gets all fields and values in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hkeys(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        \"\"\"Gets the number of fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        \"\"\"Sets one or more fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            key (str | bytes, optional): A single field to set.\n            value (str | bytes, optional): The value for the single field.\n            mapping (dict, optional): A dictionary of field/value pairs.\n            items (list, optional): A list of field/value pairs.\n\n        Returns:\n            RedisIntegerResponseType: The number of fields added or updated.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        \"\"\"Gets the values of multiple fields in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n            keys (list): A list of fields to get.\n            *args (str | bytes): Additional fields to get.\n\n        Returns:\n            RedisListResponseType: A list of values for the specified fields.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def hvals(self, name: str) -&gt; RedisListResponseType:\n        \"\"\"Gets all values in a hash asynchronously.\n\n        Args:\n            name (str): The key of the hash.\n\n        Returns:\n            RedisListResponseType: A list of values in the hash.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Publishes a message to a channel asynchronously.\n\n        Args:\n            channel (RedisKeyType): The channel to publish to.\n            message (bytes | str): The message to publish.\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: The number of subscribers that received the message.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        \"\"\"Lists active channels matching a pattern asynchronously.\n\n        Args:\n            pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            RedisResponseType: A list of active channels.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        \"\"\"Increments the score of a member in a sorted set asynchronously.\n\n        Args:\n            name (RedisKeyType): The key of the sorted set.\n            amount (float): The amount to increment by.\n            value (bytes | str | float): The member to increment.\n\n        Returns:\n            RedisResponseType: The new score of the member.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def pubsub(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Returns a pub/sub object for subscribing to channels asynchronously.\n\n        Args:\n            **kwargs (Any): Additional arguments for the underlying implementation.\n\n        Returns:\n            Any: A pub/sub object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        \"\"\"Returns a pipeline object for batching commands asynchronously.\n\n        Args:\n            transaction (Any): If True, execute commands in a transaction. Defaults to True.\n            shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n        Returns:\n            Any: A pipeline object.\n\n        Raises:\n            NotImplementedError: If not implemented by the subclass.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.ping","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.ping()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Tests the connection to the Redis server asynchronously.</p> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The response from the server, typically \"PONG\".</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def ping(self) -&gt; RedisResponseType:\n    \"\"\"Tests the connection to the Redis server asynchronously.\n\n    Returns:\n        RedisResponseType: The response from the server, typically \"PONG\".\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pttl","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pttl(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the remaining time to live of a key in milliseconds asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in milliseconds asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in milliseconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.incrby","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.incrby(name, amount=1)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Increments the integer value of a key by the given amount asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to increment.</p> required <code>amount</code> <code>int</code> <p>The amount to increment by. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new value after incrementing.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n    \"\"\"Increments the integer value of a key by the given amount asynchronously.\n\n    Args:\n        name (RedisKeyType): The key to increment.\n        amount (int): The amount to increment by. Defaults to 1.\n\n    Returns:\n        RedisResponseType: The new value after incrementing.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.set","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.set(name, value, ex=None, px=None, nx=False, xx=False, keepttl=False, get=False, exat=None, pxat=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets a key to a value with optional expiration and conditions asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>RedisSetType</code> <p>The value to set for the key.</p> required <code>ex</code> <code>RedisExpiryType</code> <p>Expiration time in seconds or timedelta.</p> <code>None</code> <code>px</code> <code>RedisExpiryType</code> <p>Expiration time in milliseconds or timedelta.</p> <code>None</code> <code>nx</code> <code>bool</code> <p>If True, set only if the key does not exist. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, set only if the key already exists. Defaults to False.</p> <code>False</code> <code>keepttl</code> <code>bool</code> <p>If True, retain the existing TTL. Defaults to False.</p> <code>False</code> <code>get</code> <code>bool</code> <p>If True, return the old value before setting. Defaults to False.</p> <code>False</code> <code>exat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time as Unix timestamp or datetime.</p> <code>None</code> <code>pxat</code> <code>RedisAbsExpiryType</code> <p>Absolute expiration time in milliseconds or datetime.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The result of the operation, often \"OK\" or the old value if get=True.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def set(\n    self,\n    name: RedisKeyType,\n    value: RedisSetType,\n    ex: RedisExpiryType | None = None,\n    px: RedisExpiryType | None = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: RedisAbsExpiryType | None = None,\n    pxat: RedisAbsExpiryType | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value with optional expiration and conditions asynchronously.\n\n    Args:\n        name (RedisKeyType): The key to set.\n        value (RedisSetType): The value to set for the key.\n        ex (RedisExpiryType, optional): Expiration time in seconds or timedelta.\n        px (RedisExpiryType, optional): Expiration time in milliseconds or timedelta.\n        nx (bool): If True, set only if the key does not exist. Defaults to False.\n        xx (bool): If True, set only if the key already exists. Defaults to False.\n        keepttl (bool): If True, retain the existing TTL. Defaults to False.\n        get (bool): If True, return the old value before setting. Defaults to False.\n        exat (RedisAbsExpiryType, optional): Absolute expiration time as Unix timestamp or datetime.\n        pxat (RedisAbsExpiryType, optional): Absolute expiration time in milliseconds or datetime.\n\n    Returns:\n        RedisResponseType: The result of the operation, often \"OK\" or the old value if get=True.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.get","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.get(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieves the value of a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value associated with the key, or None if the key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def get(self, key: str) -&gt; RedisResponseType:\n    \"\"\"Retrieves the value of a key asynchronously.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        RedisResponseType: The value associated with the key, or None if the key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.mget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.mget(keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the values of multiple keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType | Iterable[RedisKeyType]</code> <p>A single key or iterable of keys.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional keys.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of values corresponding to the keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def mget(\n    self,\n    keys: RedisKeyType | Iterable[RedisKeyType],\n    *args: bytes | str,\n) -&gt; RedisResponseType:\n    \"\"\"Gets the values of multiple keys asynchronously.\n\n    Args:\n        keys (RedisKeyType | Iterable[RedisKeyType]): A single key or iterable of keys.\n        *args (bytes | str): Additional keys.\n\n    Returns:\n        RedisResponseType: A list of values corresponding to the keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.mset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.mset(mapping)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets multiple keys to their respective values asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of keys to values.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>Typically \"OK\" on success.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n    \"\"\"Sets multiple keys to their respective values asynchronously.\n\n    Args:\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of keys to values.\n\n    Returns:\n        RedisResponseType: Typically \"OK\" on success.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.keys","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.keys(pattern='*', **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns all keys matching a pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match keys against. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of matching keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Returns all keys matching a pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match keys against. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of matching keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.getset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.getset(key, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets a key to a value and returns its old value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The new value to set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The old value of the key, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Sets a key to a value and returns its old value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key to set.\n        value (bytes | str | float): The new value to set.\n\n    Returns:\n        RedisResponseType: The old value of the key, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.getdel","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.getdel(key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the value of a key and deletes it asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | str</code> <p>The key to get and delete.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The value of the key before deletion, or None if it didn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the value of a key and deletes it asynchronously.\n\n    Args:\n        key (bytes | str): The key to get and delete.\n\n    Returns:\n        RedisResponseType: The value of the key before deletion, or None if it didn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.exists","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.exists(*names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if one or more keys exist asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to check.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys that exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Checks if one or more keys exist asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of keys to check.\n\n    Returns:\n        RedisResponseType: The number of keys that exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.delete","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.delete(*names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes one or more keys asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>bytes | str</code> <p>Variable number of keys to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of keys deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Deletes one or more keys asynchronously.\n\n    Args:\n        *names (bytes | str): Variable number of keys to delete.\n\n    Returns:\n        RedisResponseType: The number of keys deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.append","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.append(key, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Appends a value to a key's string value asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>RedisKeyType</code> <p>The key to append to.</p> required <code>value</code> <code>bytes | str | float</code> <p>The value to append.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The length of the string after appending.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Appends a value to a key's string value asynchronously.\n\n    Args:\n        key (RedisKeyType): The key to append to.\n        value (bytes | str | float): The value to append.\n\n    Returns:\n        RedisResponseType: The length of the string after appending.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.ttl","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.ttl(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the remaining time to live of a key in seconds asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the remaining time to live of a key in seconds asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The time to live in seconds, or -1 if no TTL, -2 if key doesn't exist.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.type","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.type(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Determines the type of value stored at a key asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The type of the key's value (e.g., \"string\", \"list\", etc.).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def type(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Determines the type of value stored at a key asynchronously.\n\n    Args:\n        name (bytes | str): The key to check.\n\n    Returns:\n        RedisResponseType: The type of the key's value (e.g., \"string\", \"list\", etc.).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.llen","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.llen(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the length of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of items in the list.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def llen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the length of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n\n    Returns:\n        RedisIntegerResponseType: The number of items in the list.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lpop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lpop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns the first element(s) of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the first element(s) of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lpush","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lpush(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Pushes one or more values to the start of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the start of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lrange(name, start, end)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of elements from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>start</code> <code>int</code> <p>The starting index (inclusive).</p> required <code>end</code> <code>int</code> <p>The ending index (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of elements in the specified range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n    \"\"\"Gets a range of elements from a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        start (int): The starting index (inclusive).\n        end (int): The ending index (inclusive).\n\n    Returns:\n        RedisListResponseType: A list of elements in the specified range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lrem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lrem(name, count, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes occurrences of a value from a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of occurrences to remove (0 for all).</p> required <code>value</code> <code>str</code> <p>The value to remove.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of elements removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes occurrences of a value from a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int): Number of occurrences to remove (0 for all).\n        value (str): The value to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of elements removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.lset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.lset(name, index, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets the value of an element in a list by index asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>index</code> <code>int</code> <p>The index to set.</p> required <code>value</code> <code>str</code> <p>The new value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def lset(self, name: str, index: int, value: str) -&gt; bool:\n    \"\"\"Sets the value of an element in a list by index asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        index (int): The index to set.\n        value (str): The new value.\n\n    Returns:\n        bool: True if successful.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.rpop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.rpop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns the last element(s) of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>count</code> <code>int</code> <p>Number of elements to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The popped element(s), or None if the list is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def rpop(self, name: str, count: int | None = None) -&gt; Any:\n    \"\"\"Removes and returns the last element(s) of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        count (int, optional): Number of elements to pop. Defaults to None (pops 1).\n\n    Returns:\n        Any: The popped element(s), or None if the list is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.rpush","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.rpush(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Pushes one or more values to the end of a list asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the list.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Values to push.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The length of the list after the push.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Pushes one or more values to the end of a list asynchronously.\n\n    Args:\n        name (str): The key of the list.\n        *values (bytes | str | float): Values to push.\n\n    Returns:\n        RedisIntegerResponseType: The length of the list after the push.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scan","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scan(cursor=0, match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Iterates over keys in the database incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_keys).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scan(\n    self,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over keys in the database incrementally asynchronously.\n\n    Args:\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_keys).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scan_iter","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scan_iter(match=None, count=None, _type=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Provides an iterator over keys in the database asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>bytes | str</code> <p>Pattern to match keys against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of keys to return per iteration.</p> <code>None</code> <code>_type</code> <code>str</code> <p>Filter by type (e.g., \"string\", \"list\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding keys.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scan_iter(\n    self,\n    match: bytes | str | None = None,\n    count: int | None = None,\n    _type: str | None = None,\n    **kwargs: Any,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over keys in the database asynchronously.\n\n    Args:\n        match (bytes | str, optional): Pattern to match keys against.\n        count (int, optional): Hint for number of keys to return per iteration.\n        _type (str, optional): Filter by type (e.g., \"string\", \"list\").\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Iterator: An iterator yielding keys.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sscan","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sscan(name, cursor=0, match=None, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Iterates over members of a set incrementally asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>cursor</code> <code>int</code> <p>The cursor position to start scanning. Defaults to 0.</p> <code>0</code> <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A tuple of (new_cursor, list_of_members).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sscan(\n    self,\n    name: RedisKeyType,\n    cursor: int = 0,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Iterates over members of a set incrementally asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        cursor (int): The cursor position to start scanning. Defaults to 0.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        RedisResponseType: A tuple of (new_cursor, list_of_members).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sscan_iter","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sscan_iter(name, match=None, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Provides an iterator over members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the set.</p> required <code>match</code> <code>bytes | str</code> <p>Pattern to match members against.</p> <code>None</code> <code>count</code> <code>int</code> <p>Hint for number of members to return per iteration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An iterator yielding set members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sscan_iter(\n    self,\n    name: RedisKeyType,\n    match: bytes | str | None = None,\n    count: int | None = None,\n) -&gt; Iterator:\n    \"\"\"Provides an iterator over members of a set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the set.\n        match (bytes | str, optional): Pattern to match members against.\n        count (int, optional): Hint for number of members to return per iteration.\n\n    Returns:\n        Iterator: An iterator yielding set members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sadd","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sadd(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds one or more members to a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to add.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members added (excluding duplicates).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Adds one or more members to a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to add.\n\n    Returns:\n        RedisIntegerResponseType: The number of members added (excluding duplicates).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.scard","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.scard(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of members in a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The cardinality (size) of the set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def scard(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of members in a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisIntegerResponseType: The cardinality (size) of the set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sismember","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sismember(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if a value is a member of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the value is a member, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a value is a member of a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        value (str): The value to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the value is a member, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.smembers","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.smembers(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all members of a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set of all members.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def smembers(self, name: str) -&gt; RedisSetResponseType:\n    \"\"\"Gets all members of a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n\n    Returns:\n        RedisSetResponseType: A set of all members.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.spop","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.spop(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns one or more random members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | float | int | str | list | None</code> <p>bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n    \"\"\"Removes and returns one or more random members from a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        bytes | float | int | str | list | None: The popped member(s), or None if the set is empty.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.srem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.srem(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes one or more members from a set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n    \"\"\"Removes one or more members from a set asynchronously.\n\n    Args:\n        name (str): The key of the set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisIntegerResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.sunion","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.sunion(keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the union of multiple sets asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>RedisKeyType</code> <p>Name of the first key.</p> required <code>*args</code> <code>bytes | str</code> <p>Additional key names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisSetResponseType</code> <code>RedisSetResponseType</code> <p>A set containing members of the resulting union.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; RedisSetResponseType:\n    \"\"\"Gets the union of multiple sets asynchronously.\n\n    Args:\n        keys (RedisKeyType): Name of the first key.\n        *args (bytes | str): Additional key names.\n\n    Returns:\n        RedisSetResponseType: A set containing members of the resulting union.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zadd","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zadd(name, mapping, nx=False, xx=False, ch=False, incr=False, gt=False, lt=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Adds members with scores to a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>mapping</code> <code>Mapping[RedisKeyType, bytes | str | float]</code> <p>A mapping of members to scores.</p> required <code>nx</code> <code>bool</code> <p>If True, only add new elements. Defaults to False.</p> <code>False</code> <code>xx</code> <code>bool</code> <p>If True, only update existing elements. Defaults to False.</p> <code>False</code> <code>ch</code> <code>bool</code> <p>If True, return the number of changed elements. Defaults to False.</p> <code>False</code> <code>incr</code> <code>bool</code> <p>If True, increment scores instead of setting. Defaults to False.</p> <code>False</code> <code>gt</code> <code>bool</code> <p>If True, only update if new score is greater. Defaults to False.</p> <code>False</code> <code>lt</code> <code>bool</code> <p>If True, only update if new score is less. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of elements added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zadd(\n    self,\n    name: RedisKeyType,\n    mapping: Mapping[RedisKeyType, bytes | str | float],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; RedisResponseType:\n    \"\"\"Adds members with scores to a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        mapping (Mapping[RedisKeyType, bytes | str | float]): A mapping of members to scores.\n        nx (bool): If True, only add new elements. Defaults to False.\n        xx (bool): If True, only update existing elements. Defaults to False.\n        ch (bool): If True, return the number of changed elements. Defaults to False.\n        incr (bool): If True, increment scores instead of setting. Defaults to False.\n        gt (bool): If True, only update if new score is greater. Defaults to False.\n        lt (bool): If True, only update if new score is less. Defaults to False.\n\n    Returns:\n        RedisResponseType: The number of elements added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zcard","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zcard(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of members in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>bytes | str</code> <p>The key of the sorted set.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The cardinality (size) of the sorted set.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n    \"\"\"Gets the number of members in a sorted set asynchronously.\n\n    Args:\n        name (bytes | str): The key of the sorted set.\n\n    Returns:\n        RedisResponseType: The cardinality (size) of the sorted set.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zcount","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zcount(name, min, max)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Counts members in a sorted set within a score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members within the score range.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n    \"\"\"Counts members in a sorted set within a score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n\n    Returns:\n        RedisResponseType: The number of members within the score range.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zpopmax","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zpopmax(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns members with the highest scores from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the highest scores from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zpopmin","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zpopmin(name, count=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes and returns members with the lowest scores from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>count</code> <code>int</code> <p>Number of members to pop. Defaults to None (pops 1).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of (member, score) tuples popped.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n    \"\"\"Removes and returns members with the lowest scores from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        count (int, optional): Number of members to pop. Defaults to None (pops 1).\n\n    Returns:\n        RedisResponseType: A list of (member, score) tuples popped.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float, byscore=False, bylex=False, offset=None, num=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of members from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index or score (depending on byscore).</p> required <code>end</code> <code>int</code> <p>The ending index or score (depending on byscore).</p> required <code>desc</code> <code>bool</code> <p>If True, sort in descending order. Defaults to False.</p> <code>False</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <code>byscore</code> <code>bool</code> <p>If True, range by score instead of rank. Defaults to False.</p> <code>False</code> <code>bylex</code> <code>bool</code> <p>If True, range by lexicographical order. Defaults to False.</p> <code>False</code> <code>offset</code> <code>int</code> <p>Offset for byscore or bylex.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements for byscore or bylex.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int | None = None,\n    num: int | None = None,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index or score (depending on byscore).\n        end (int): The ending index or score (depending on byscore).\n        desc (bool): If True, sort in descending order. Defaults to False.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n        byscore (bool): If True, range by score instead of rank. Defaults to False.\n        bylex (bool): If True, range by lexicographical order. Defaults to False.\n        offset (int, optional): Offset for byscore or bylex.\n        num (int, optional): Number of elements for byscore or bylex.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrevrange","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrevrange(name, start, end, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets a range of members from a sorted set in reverse order asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>start</code> <code>int</code> <p>The starting index.</p> required <code>end</code> <code>int</code> <p>The ending index.</p> required <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrevrange(\n    self,\n    name: RedisKeyType,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets a range of members from a sorted set in reverse order asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        start (int): The starting index.\n        end (int): The ending index.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrangebyscore","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets members from a sorted set by score range asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>min</code> <code>float | str</code> <p>The minimum score (inclusive).</p> required <code>max</code> <code>float | str</code> <p>The maximum score (inclusive).</p> required <code>start</code> <code>int</code> <p>Starting offset.</p> <code>None</code> <code>num</code> <code>int</code> <p>Number of elements to return.</p> <code>None</code> <code>withscores</code> <code>bool</code> <p>If True, return scores with members. Defaults to False.</p> <code>False</code> <code>score_cast_func</code> <code>RedisScoreCastType</code> <p>Function to cast scores. Defaults to float.</p> <code>float</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of members (and scores if withscores=True).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrangebyscore(\n    self,\n    name: RedisKeyType,\n    min: float | str,\n    max: float | str,\n    start: int | None = None,\n    num: int | None = None,\n    withscores: bool = False,\n    score_cast_func: RedisScoreCastType = float,\n) -&gt; RedisResponseType:\n    \"\"\"Gets members from a sorted set by score range asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        min (float | str): The minimum score (inclusive).\n        max (float | str): The maximum score (inclusive).\n        start (int, optional): Starting offset.\n        num (int, optional): Number of elements to return.\n        withscores (bool): If True, return scores with members. Defaults to False.\n        score_cast_func (RedisScoreCastType): Function to cast scores. Defaults to float.\n\n    Returns:\n        RedisResponseType: A list of members (and scores if withscores=True).\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrank","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrank(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the rank of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to find.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The rank (index) of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the rank of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to find.\n\n    Returns:\n        RedisResponseType: The rank (index) of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zrem","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zrem(name, *values)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Removes one or more members from a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>*values</code> <code>bytes | str | float</code> <p>Members to remove.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of members removed.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Removes one or more members from a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        *values (bytes | str | float): Members to remove.\n\n    Returns:\n        RedisResponseType: The number of members removed.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zscore","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zscore(name, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the score of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to check.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The score of the member, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Gets the score of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        value (bytes | str | float): The member to check.\n\n    Returns:\n        RedisResponseType: The score of the member, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hdel","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hdel(name, *keys)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Deletes one or more fields from a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>*keys</code> <code>str | bytes</code> <p>Fields to delete.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields deleted.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n    \"\"\"Deletes one or more fields from a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        *keys (str | bytes): Fields to delete.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields deleted.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hexists","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hexists(name, key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Checks if a field exists in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to check.</p> required <p>Returns:</p> Type Description <code>Awaitable[bool] | bool</code> <p>Awaitable[bool] | bool: True if the field exists, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n    \"\"\"Checks if a field exists in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to check.\n\n    Returns:\n        Awaitable[bool] | bool: True if the field exists, False otherwise.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hget(name, key)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the value of a field in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str</code> <p>The field to get.</p> required <p>Returns:</p> Type Description <code>Awaitable[str | None] | str | None</code> <p>Awaitable[str | None] | str | None: The value of the field, or None if not found.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n    \"\"\"Gets the value of a field in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str): The field to get.\n\n    Returns:\n        Awaitable[str | None] | str | None: The value of the field, or None if not found.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hgetall","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hgetall(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all fields and values in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Type Description <code>Awaitable[dict] | dict</code> <p>Awaitable[dict] | dict: A dictionary of field/value pairs.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n    \"\"\"Gets all fields and values in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        Awaitable[dict] | dict: A dictionary of field/value pairs.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hkeys","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hkeys(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hkeys(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hlen","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hlen(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the number of fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n    \"\"\"Gets the number of fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hset","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hset(name, key=None, value=None, mapping=None, items=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Sets one or more fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>key</code> <code>str | bytes</code> <p>A single field to set.</p> <code>None</code> <code>value</code> <code>str | bytes</code> <p>The value for the single field.</p> <code>None</code> <code>mapping</code> <code>dict</code> <p>A dictionary of field/value pairs.</p> <code>None</code> <code>items</code> <code>list</code> <p>A list of field/value pairs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RedisIntegerResponseType</code> <code>RedisIntegerResponseType</code> <p>The number of fields added or updated.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hset(\n    self,\n    name: str,\n    key: str | bytes | None = None,\n    value: str | bytes | None = None,\n    mapping: dict | None = None,\n    items: list | None = None,\n) -&gt; RedisIntegerResponseType:\n    \"\"\"Sets one or more fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        key (str | bytes, optional): A single field to set.\n        value (str | bytes, optional): The value for the single field.\n        mapping (dict, optional): A dictionary of field/value pairs.\n        items (list, optional): A list of field/value pairs.\n\n    Returns:\n        RedisIntegerResponseType: The number of fields added or updated.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hmget","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hmget(name, keys, *args)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets the values of multiple fields in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <code>keys</code> <code>list</code> <p>A list of fields to get.</p> required <code>*args</code> <code>str | bytes</code> <p>Additional fields to get.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values for the specified fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n    \"\"\"Gets the values of multiple fields in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n        keys (list): A list of fields to get.\n        *args (str | bytes): Additional fields to get.\n\n    Returns:\n        RedisListResponseType: A list of values for the specified fields.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.hvals","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.hvals(name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Gets all values in a hash asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The key of the hash.</p> required <p>Returns:</p> Name Type Description <code>RedisListResponseType</code> <code>RedisListResponseType</code> <p>A list of values in the hash.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def hvals(self, name: str) -&gt; RedisListResponseType:\n    \"\"\"Gets all values in a hash asynchronously.\n\n    Args:\n        name (str): The key of the hash.\n\n    Returns:\n        RedisListResponseType: A list of values in the hash.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.publish","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.publish(channel, message, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Publishes a message to a channel asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RedisKeyType</code> <p>The channel to publish to.</p> required <code>message</code> <code>bytes | str</code> <p>The message to publish.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The number of subscribers that received the message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Publishes a message to a channel asynchronously.\n\n    Args:\n        channel (RedisKeyType): The channel to publish to.\n        message (bytes | str): The message to publish.\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: The number of subscribers that received the message.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pubsub_channels","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pubsub_channels(pattern='*', **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Lists active channels matching a pattern asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>RedisPatternType</code> <p>The pattern to match channels. Defaults to \"*\".</p> <code>'*'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>A list of active channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n    \"\"\"Lists active channels matching a pattern asynchronously.\n\n    Args:\n        pattern (RedisPatternType): The pattern to match channels. Defaults to \"*\".\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        RedisResponseType: A list of active channels.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.zincrby","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.zincrby(name, amount, value)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Increments the score of a member in a sorted set asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>RedisKeyType</code> <p>The key of the sorted set.</p> required <code>amount</code> <code>float</code> <p>The amount to increment by.</p> required <code>value</code> <code>bytes | str | float</code> <p>The member to increment.</p> required <p>Returns:</p> Name Type Description <code>RedisResponseType</code> <code>RedisResponseType</code> <p>The new score of the member.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n    \"\"\"Increments the score of a member in a sorted set asynchronously.\n\n    Args:\n        name (RedisKeyType): The key of the sorted set.\n        amount (float): The amount to increment by.\n        value (bytes | str | float): The member to increment.\n\n    Returns:\n        RedisResponseType: The new score of the member.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.pubsub","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.pubsub(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns a pub/sub object for subscribing to channels asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments for the underlying implementation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pub/sub object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def pubsub(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Returns a pub/sub object for subscribing to channels asynchronously.\n\n    Args:\n        **kwargs (Any): Additional arguments for the underlying implementation.\n\n    Returns:\n        Any: A pub/sub object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.AsyncRedisPort.get_pipeline","title":"<code>archipy.adapters.redis.ports.AsyncRedisPort.get_pipeline(transaction=True, shard_hint=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Returns a pipeline object for batching commands asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>transaction</code> <code>Any</code> <p>If True, execute commands in a transaction. Defaults to True.</p> <code>True</code> <code>shard_hint</code> <code>Any</code> <p>Hint for sharding in clustered Redis.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>A pipeline object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by the subclass.</p> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>@abstractmethod\nasync def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n    \"\"\"Returns a pipeline object for batching commands asynchronously.\n\n    Args:\n        transaction (Any): If True, execute commands in a transaction. Defaults to True.\n        shard_hint (Any, optional): Hint for sharding in clustered Redis.\n\n    Returns:\n        Any: A pipeline object.\n\n    Raises:\n        NotImplementedError: If not implemented by the subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.mocks","title":"<code>archipy.adapters.redis.mocks</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.redis.mocks.RedisMock","title":"<code>archipy.adapters.redis.mocks.RedisMock</code>","text":"<p>               Bases: <code>RedisAdapter</code></p> <p>A Redis adapter implementation using fakeredis for testing.</p> Source code in <code>archipy/adapters/redis/mocks.py</code> <pre><code>class RedisMock(RedisAdapter):\n    \"\"\"A Redis adapter implementation using fakeredis for testing.\"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        # Skip the parent's __init__ which would create real Redis connections\n        self.client = fakeredis.FakeRedis(decode_responses=True)\n        self.read_only_client = self.client\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        # Override to prevent actual connection setup\n        pass\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; Redis:\n        # Override to return fakeredis instead\n        return fakeredis.FakeRedis(decode_responses=configs.DECODE_RESPONSES)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.mocks.AsyncRedisMock","title":"<code>archipy.adapters.redis.mocks.AsyncRedisMock</code>","text":"<p>               Bases: <code>AsyncRedisAdapter</code></p> <p>An async Redis adapter implementation using fakeredis for testing.</p> Source code in <code>archipy/adapters/redis/mocks.py</code> <pre><code>class AsyncRedisMock(AsyncRedisAdapter):\n    \"\"\"An async Redis adapter implementation using fakeredis for testing.\"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        # Skip the parent's __init__ which would create real Redis connections\n        self.client = AsyncMock()\n        self.read_only_client = self.client\n        self._setup_async_methods()\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        # Override to prevent actual connection setup\n        pass\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; AsyncRedis:\n        # Override to return a mocked async client\n        return AsyncMock()\n\n    def _setup_async_methods(self) -&gt; None:\n        \"\"\"Set up all async methods to use a synchronous fakeredis under the hood.\"\"\"\n        # Create a synchronous fakeredis instance to handle the actual operations\n        self._fake_redis = fakeredis.FakeRedis(decode_responses=True)\n\n        # For each async method, implement it to use the synchronous fakeredis\n        for method_name in dir(AsyncRedisPort):\n            if not method_name.startswith(\"_\") and method_name not in (\"pubsub\", \"get_pipeline\"):\n                sync_method = getattr(self._fake_redis, method_name, None)\n                if sync_method and callable(sync_method):\n                    async_method = self._create_async_wrapper(method_name, sync_method)\n                    setattr(self.client, method_name, async_method)\n                    setattr(self.read_only_client, method_name, async_method)\n\n    def _create_async_wrapper(\n        self,\n        method_name: str,\n        sync_method: Callable[..., Any],\n    ) -&gt; Callable[..., Awaitable[RedisResponseType]]:\n        \"\"\"Create an async wrapper around a synchronous method.\"\"\"\n\n        async def wrapper(*args: Any, **kwargs: Any) -&gt; RedisResponseType:\n            # Remove 'self' from args when calling the sync method\n            if args and args[0] is self:\n                args = args[1:]\n            return cast(RedisResponseType, sync_method(*args, **kwargs))\n\n        return wrapper\n</code></pre>"},{"location":"api_reference/adapters/#kafka","title":"Kafka","text":"<p>Kafka integration for message streaming and event-driven architectures.</p> <pre><code>from archipy.adapters.kafka import KafkaAdapter\n\n# Create a Kafka adapter\nkafka = KafkaAdapter()  # Uses global config by default\n\n# Publish a message\nkafka.publish(\"my-topic\", \"Hello, Kafka!\")\n\n# Consume messages\ndef process_message(message: dict[str, Any]) -&gt; None:\n    print(f\"Received: {message['value']}\")\n\nkafka.consume(\"my-topic\", process_message)\n</code></pre> <p>For detailed examples and usage guidelines, see the Kafka Adapter Examples.</p>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters","title":"<code>archipy.adapters.kafka.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter</code>","text":"<p>               Bases: <code>KafkaAdminPort</code></p> <p>Synchronous Kafka admin adapter.</p> <p>This adapter provides synchronous administrative operations for Kafka topics. It implements the KafkaAdminPort interface and handles topic creation, deletion, and listing operations.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaAdminAdapter(KafkaAdminPort):\n    \"\"\"Synchronous Kafka admin adapter.\n\n    This adapter provides synchronous administrative operations for Kafka topics.\n    It implements the KafkaAdminPort interface and handles topic creation, deletion,\n    and listing operations.\n    \"\"\"\n\n    def __init__(self, kafka_configs: KafkaConfig | None = None) -&gt; None:\n        \"\"\"Initializes the admin adapter with Kafka configuration.\n\n        Args:\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            InternalError: If there is an error initializing the admin client.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\"bootstrap.servers\": broker_list_csv}\n            if configs.USER_NAME and configs.PASSWORD and configs.CERT_PEM:\n                config |= {\n                    \"sasl.username\": configs.USER_NAME,\n                    \"sasl.password\": configs.PASSWORD,\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanisms\": configs.SASL_MECHANISMS,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                    \"ssl.ca.pem\": configs.CERT_PEM,\n                }\n            self.adapter: AdminClient = AdminClient(config)\n        except Exception as e:\n            raise InternalError(details=str(e), lang=LanguageType.FA) from e\n\n    @override\n    def create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n        \"\"\"Creates a new Kafka topic.\n\n        Args:\n            topic (str): Name of the topic to create.\n            num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n            replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n        Raises:\n            InternalError: If there is an error creating the topic.\n        \"\"\"\n        try:\n            new_topic = NewTopic(topic, num_partitions, replication_factor)\n            self.adapter.create_topics([new_topic])\n        except Exception as e:\n            raise InternalError(details=f\"Failed to create topic {topic}\", lang=LanguageType.FA) from e\n\n    @override\n    def delete_topic(self, topics: list[str]) -&gt; None:\n        \"\"\"Deletes one or more Kafka topics.\n\n        Args:\n            topics (list[str]): List of topic names to delete.\n\n        Raises:\n            InternalError: If there is an error deleting the topics.\n        \"\"\"\n        try:\n            self.adapter.delete_topics(topics)\n            logger.debug(\"Deleted topics\", topics)\n        except Exception as e:\n            raise InternalError(details=\"Failed to delete topics\", lang=LanguageType.FA) from e\n\n    @override\n    def list_topics(\n        self,\n        topic: str | None = None,\n        timeout: int = 1,\n    ) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            UnavailableError: If the Kafka service is unavailable.\n        \"\"\"\n        try:\n            return self.adapter.list_topics(topic=topic, timeout=timeout)\n        except Exception as e:\n            raise UnavailableError(service=\"Kafka\", lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.__init__(kafka_configs=None)</code>","text":"<p>Initializes the admin adapter with Kafka configuration.</p> <p>Parameters:</p> Name Type Description Default <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error initializing the admin client.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(self, kafka_configs: KafkaConfig | None = None) -&gt; None:\n    \"\"\"Initializes the admin adapter with Kafka configuration.\n\n    Args:\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        InternalError: If there is an error initializing the admin client.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    try:\n        broker_list_csv = \",\".join(configs.BROKERS_LIST)\n        config = {\"bootstrap.servers\": broker_list_csv}\n        if configs.USER_NAME and configs.PASSWORD and configs.CERT_PEM:\n            config |= {\n                \"sasl.username\": configs.USER_NAME,\n                \"sasl.password\": configs.PASSWORD,\n                \"security.protocol\": configs.SECURITY_PROTOCOL,\n                \"sasl.mechanisms\": configs.SASL_MECHANISMS,\n                \"ssl.endpoint.identification.algorithm\": \"none\",\n                \"ssl.ca.pem\": configs.CERT_PEM,\n            }\n        self.adapter: AdminClient = AdminClient(config)\n    except Exception as e:\n        raise InternalError(details=str(e), lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.create_topic","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.create_topic(topic, num_partitions=1, replication_factor=1)</code>","text":"<p>Creates a new Kafka topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required <code>num_partitions</code> <code>int</code> <p>Number of partitions for the topic. Defaults to 1.</p> <code>1</code> <code>replication_factor</code> <code>int</code> <p>Replication factor for the topic. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error creating the topic.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n    \"\"\"Creates a new Kafka topic.\n\n    Args:\n        topic (str): Name of the topic to create.\n        num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n        replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n    Raises:\n        InternalError: If there is an error creating the topic.\n    \"\"\"\n    try:\n        new_topic = NewTopic(topic, num_partitions, replication_factor)\n        self.adapter.create_topics([new_topic])\n    except Exception as e:\n        raise InternalError(details=f\"Failed to create topic {topic}\", lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.delete_topic","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.delete_topic(topics)</code>","text":"<p>Deletes one or more Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>list[str]</code> <p>List of topic names to delete.</p> required <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error deleting the topics.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef delete_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Deletes one or more Kafka topics.\n\n    Args:\n        topics (list[str]): List of topic names to delete.\n\n    Raises:\n        InternalError: If there is an error deleting the topics.\n    \"\"\"\n    try:\n        self.adapter.delete_topics(topics)\n        logger.debug(\"Deleted topics\", topics)\n    except Exception as e:\n        raise InternalError(details=\"Failed to delete topics\", lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaAdminAdapter.list_topics","title":"<code>archipy.adapters.kafka.adapters.KafkaAdminAdapter.list_topics(topic=None, timeout=1)</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If the Kafka service is unavailable.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef list_topics(\n    self,\n    topic: str | None = None,\n    timeout: int = 1,\n) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        UnavailableError: If the Kafka service is unavailable.\n    \"\"\"\n    try:\n        return self.adapter.list_topics(topic=topic, timeout=timeout)\n    except Exception as e:\n        raise UnavailableError(service=\"Kafka\", lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter</code>","text":"<p>               Bases: <code>KafkaConsumerPort</code></p> <p>Synchronous Kafka consumer adapter.</p> <p>This adapter provides synchronous message consumption from Kafka topics. It implements the KafkaConsumerPort interface and handles message polling, batch consumption, and offset management.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaConsumerAdapter(KafkaConsumerPort):\n    \"\"\"Synchronous Kafka consumer adapter.\n\n    This adapter provides synchronous message consumption from Kafka topics.\n    It implements the KafkaConsumerPort interface and handles message polling,\n    batch consumption, and offset management.\n    \"\"\"\n\n    def __init__(\n        self,\n        group_id: str,\n        topic_list: list[str] | None = None,\n        partition_list: list[TopicPartition] | None = None,\n        kafka_configs: KafkaConfig | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the consumer adapter with Kafka configuration and subscription.\n\n        Args:\n            group_id (str): Consumer group ID.\n            topic_list (list[str] | None, optional): List of topics to subscribe to.\n                Defaults to None.\n            partition_list (list[TopicPartition] | None, optional): List of partitions\n                to assign. Defaults to None.\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            InvalidArgumentError: If both topic_list and partition_list are provided or\n                neither is provided.\n            InternalError: If there is an error initializing the consumer.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        self._adapter: Consumer = self._get_adapter(group_id, configs)\n        if topic_list and not partition_list:\n            self.subscribe(topic_list)\n        elif not topic_list and partition_list:\n            self.assign(partition_list)\n        else:\n            logger.error(\"Invalid topic or partition list\")\n            raise InvalidArgumentError(\n                argument_name=\"topic_list or partition_list\",\n                lang=LanguageType.FA,\n            )\n\n    @staticmethod\n    def _get_adapter(group_id: str, configs: KafkaConfig) -&gt; Consumer:\n        \"\"\"Creates and configures a Kafka Consumer instance.\n\n        Args:\n            group_id (str): Consumer group ID.\n            configs (KafkaConfig): Kafka configuration.\n\n        Returns:\n            Consumer: Configured Kafka Consumer instance.\n\n        Raises:\n            InternalError: If there is an error creating the consumer.\n        \"\"\"\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\n                \"bootstrap.servers\": broker_list_csv,\n                \"group.id\": group_id,\n                \"session.timeout.ms\": configs.SESSION_TIMEOUT_MS,\n                \"auto.offset.reset\": configs.AUTO_OFFSET_RESET,\n                \"enable.auto.commit\": configs.ENABLE_AUTO_COMMIT,\n            }\n            if configs.USER_NAME and configs.PASSWORD and configs.CERT_PEM:\n                config |= {\n                    \"sasl.username\": configs.USER_NAME,\n                    \"sasl.password\": configs.PASSWORD,\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanisms\": configs.SASL_MECHANISMS,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                    \"ssl.ca.pem\": configs.CERT_PEM,\n                }\n            return Consumer(config)\n        except Exception as e:\n            raise InternalError(details=str(e), lang=LanguageType.FA) from e\n\n    @override\n    def batch_consume(self, messages_number: int = 500, timeout: int = 1) -&gt; list[Message]:\n        \"\"\"Consumes a batch of messages from subscribed topics.\n\n        Args:\n            messages_number (int, optional): Maximum number of messages to consume.\n                Defaults to 500.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            list[Message]: List of consumed messages.\n\n        Raises:\n            InternalError: If there is an error consuming messages.\n        \"\"\"\n        try:\n            result_list: list[Message] = []\n            messages: list[Message] = self._adapter.consume(num_messages=messages_number, timeout=timeout)\n            for message in messages:\n                if message.error():\n                    logger.error(\"Consumer error\", message.error())\n                    continue\n                logger.debug(\"Message consumed\", message)\n                message.set_value(message.value())\n                result_list.append(message)\n                self.commit(message, asynchronous=True)\n            else:\n                return result_list\n        except Exception as e:\n            raise InternalError(details=\"Failed to consume batch\", lang=LanguageType.FA) from e\n\n    @override\n    def poll(self, timeout: int = 1) -&gt; Message | None:\n        \"\"\"Polls for a single message from subscribed topics.\n\n        Args:\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            Message | None: The consumed message or None if no message was received.\n\n        Raises:\n            InternalError: If there is an error polling for messages.\n        \"\"\"\n        try:\n            message: Message | None = self._adapter.poll(timeout)\n            if message is None:\n                logger.debug(\"No message received\")\n                return None\n            if message.error():\n                logger.error(\"Consumer error\", message.error())\n                return None\n            logger.debug(\"Message consumed\", message)\n            message.set_value(message.value())\n        except Exception as e:\n            raise InternalError(details=\"Failed to poll message\", lang=LanguageType.FA) from e\n        else:\n            return message\n\n    @override\n    def commit(self, message: Message, asynchronous: bool = True) -&gt; None | list[TopicPartition]:\n        \"\"\"Commits the offset of a consumed message.\n\n        Args:\n            message (Message): The message whose offset should be committed.\n            asynchronous (bool, optional): Whether to commit asynchronously.\n                Defaults to True.\n\n        Returns:\n            None | list[TopicPartition]: None for synchronous commits, or list of committed\n                partitions for asynchronous commits.\n\n        Raises:\n            InternalError: If there is an error committing the message offset.\n        \"\"\"\n        try:\n            return self._adapter.commit(message=message, asynchronous=asynchronous)\n        except Exception as e:\n            raise InternalError(details=\"Failed to commit message\", lang=LanguageType.FA) from e\n\n    @override\n    def subscribe(self, topic_list: list[str]) -&gt; None:\n        \"\"\"Subscribes to a list of topics.\n\n        Args:\n            topic_list (list[str]): List of topic names to subscribe to.\n\n        Raises:\n            InternalError: If there is an error subscribing to topics.\n        \"\"\"\n        try:\n            self._adapter.subscribe(topic_list)\n            logger.debug(\"Subscribed to topics\", topic_list)\n        except Exception as e:\n            raise InternalError(\n                details=\"Failed to subscribe to topics\",\n                lang=LanguageType.FA,\n            ) from e\n\n    @override\n    def assign(self, partition_list: list[TopicPartition]) -&gt; None:\n        \"\"\"Assigns specific partitions to the consumer.\n\n        Args:\n            partition_list (list[TopicPartition]): List of partitions to assign.\n\n        Raises:\n            InternalError: If there is an error assigning partitions.\n        \"\"\"\n        try:\n            self._adapter.assign(partition_list)\n            for partition in partition_list:\n                self._adapter.seek(partition)\n            logger.debug(\"Assigned partitions\", partition_list)\n        except Exception as e:\n            raise InternalError(\n                details=\"Failed to assign partitions\",\n                lang=LanguageType.FA,\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.__init__(group_id, topic_list=None, partition_list=None, kafka_configs=None)</code>","text":"<p>Initializes the consumer adapter with Kafka configuration and subscription.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Consumer group ID.</p> required <code>topic_list</code> <code>list[str] | None</code> <p>List of topics to subscribe to. Defaults to None.</p> <code>None</code> <code>partition_list</code> <code>list[TopicPartition] | None</code> <p>List of partitions to assign. Defaults to None.</p> <code>None</code> <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidArgumentError</code> <p>If both topic_list and partition_list are provided or neither is provided.</p> <code>InternalError</code> <p>If there is an error initializing the consumer.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(\n    self,\n    group_id: str,\n    topic_list: list[str] | None = None,\n    partition_list: list[TopicPartition] | None = None,\n    kafka_configs: KafkaConfig | None = None,\n) -&gt; None:\n    \"\"\"Initializes the consumer adapter with Kafka configuration and subscription.\n\n    Args:\n        group_id (str): Consumer group ID.\n        topic_list (list[str] | None, optional): List of topics to subscribe to.\n            Defaults to None.\n        partition_list (list[TopicPartition] | None, optional): List of partitions\n            to assign. Defaults to None.\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        InvalidArgumentError: If both topic_list and partition_list are provided or\n            neither is provided.\n        InternalError: If there is an error initializing the consumer.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    self._adapter: Consumer = self._get_adapter(group_id, configs)\n    if topic_list and not partition_list:\n        self.subscribe(topic_list)\n    elif not topic_list and partition_list:\n        self.assign(partition_list)\n    else:\n        logger.error(\"Invalid topic or partition list\")\n        raise InvalidArgumentError(\n            argument_name=\"topic_list or partition_list\",\n            lang=LanguageType.FA,\n        )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.batch_consume","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.batch_consume(messages_number=500, timeout=1)</code>","text":"<p>Consumes a batch of messages from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>messages_number</code> <code>int</code> <p>Maximum number of messages to consume. Defaults to 500.</p> <code>500</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[Message]</code> <p>list[Message]: List of consumed messages.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error consuming messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef batch_consume(self, messages_number: int = 500, timeout: int = 1) -&gt; list[Message]:\n    \"\"\"Consumes a batch of messages from subscribed topics.\n\n    Args:\n        messages_number (int, optional): Maximum number of messages to consume.\n            Defaults to 500.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        list[Message]: List of consumed messages.\n\n    Raises:\n        InternalError: If there is an error consuming messages.\n    \"\"\"\n    try:\n        result_list: list[Message] = []\n        messages: list[Message] = self._adapter.consume(num_messages=messages_number, timeout=timeout)\n        for message in messages:\n            if message.error():\n                logger.error(\"Consumer error\", message.error())\n                continue\n            logger.debug(\"Message consumed\", message)\n            message.set_value(message.value())\n            result_list.append(message)\n            self.commit(message, asynchronous=True)\n        else:\n            return result_list\n    except Exception as e:\n        raise InternalError(details=\"Failed to consume batch\", lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.poll","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.poll(timeout=1)</code>","text":"<p>Polls for a single message from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Message | None</code> <p>Message | None: The consumed message or None if no message was received.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error polling for messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef poll(self, timeout: int = 1) -&gt; Message | None:\n    \"\"\"Polls for a single message from subscribed topics.\n\n    Args:\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        Message | None: The consumed message or None if no message was received.\n\n    Raises:\n        InternalError: If there is an error polling for messages.\n    \"\"\"\n    try:\n        message: Message | None = self._adapter.poll(timeout)\n        if message is None:\n            logger.debug(\"No message received\")\n            return None\n        if message.error():\n            logger.error(\"Consumer error\", message.error())\n            return None\n        logger.debug(\"Message consumed\", message)\n        message.set_value(message.value())\n    except Exception as e:\n        raise InternalError(details=\"Failed to poll message\", lang=LanguageType.FA) from e\n    else:\n        return message\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.commit","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.commit(message, asynchronous=True)</code>","text":"<p>Commits the offset of a consumed message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message whose offset should be committed.</p> required <code>asynchronous</code> <code>bool</code> <p>Whether to commit asynchronously. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None | list[TopicPartition]</code> <p>None | list[TopicPartition]: None for synchronous commits, or list of committed partitions for asynchronous commits.</p> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error committing the message offset.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef commit(self, message: Message, asynchronous: bool = True) -&gt; None | list[TopicPartition]:\n    \"\"\"Commits the offset of a consumed message.\n\n    Args:\n        message (Message): The message whose offset should be committed.\n        asynchronous (bool, optional): Whether to commit asynchronously.\n            Defaults to True.\n\n    Returns:\n        None | list[TopicPartition]: None for synchronous commits, or list of committed\n            partitions for asynchronous commits.\n\n    Raises:\n        InternalError: If there is an error committing the message offset.\n    \"\"\"\n    try:\n        return self._adapter.commit(message=message, asynchronous=asynchronous)\n    except Exception as e:\n        raise InternalError(details=\"Failed to commit message\", lang=LanguageType.FA) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.subscribe","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.subscribe(topic_list)</code>","text":"<p>Subscribes to a list of topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic_list</code> <code>list[str]</code> <p>List of topic names to subscribe to.</p> required <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error subscribing to topics.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef subscribe(self, topic_list: list[str]) -&gt; None:\n    \"\"\"Subscribes to a list of topics.\n\n    Args:\n        topic_list (list[str]): List of topic names to subscribe to.\n\n    Raises:\n        InternalError: If there is an error subscribing to topics.\n    \"\"\"\n    try:\n        self._adapter.subscribe(topic_list)\n        logger.debug(\"Subscribed to topics\", topic_list)\n    except Exception as e:\n        raise InternalError(\n            details=\"Failed to subscribe to topics\",\n            lang=LanguageType.FA,\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaConsumerAdapter.assign","title":"<code>archipy.adapters.kafka.adapters.KafkaConsumerAdapter.assign(partition_list)</code>","text":"<p>Assigns specific partitions to the consumer.</p> <p>Parameters:</p> Name Type Description Default <code>partition_list</code> <code>list[TopicPartition]</code> <p>List of partitions to assign.</p> required <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error assigning partitions.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef assign(self, partition_list: list[TopicPartition]) -&gt; None:\n    \"\"\"Assigns specific partitions to the consumer.\n\n    Args:\n        partition_list (list[TopicPartition]): List of partitions to assign.\n\n    Raises:\n        InternalError: If there is an error assigning partitions.\n    \"\"\"\n    try:\n        self._adapter.assign(partition_list)\n        for partition in partition_list:\n            self._adapter.seek(partition)\n        logger.debug(\"Assigned partitions\", partition_list)\n    except Exception as e:\n        raise InternalError(\n            details=\"Failed to assign partitions\",\n            lang=LanguageType.FA,\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter</code>","text":"<p>               Bases: <code>KafkaProducerPort</code></p> <p>Synchronous Kafka producer adapter.</p> <p>This adapter provides synchronous message production to Kafka topics. It implements the KafkaProducerPort interface and handles message production, flushing, and health validation.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>class KafkaProducerAdapter(KafkaProducerPort):\n    \"\"\"Synchronous Kafka producer adapter.\n\n    This adapter provides synchronous message production to Kafka topics.\n    It implements the KafkaProducerPort interface and handles message production,\n    flushing, and health validation.\n    \"\"\"\n\n    def __init__(self, topic_name: str, kafka_configs: KafkaConfig | None = None) -&gt; None:\n        \"\"\"Initializes the producer adapter with Kafka configuration and topic.\n\n        Args:\n            topic_name (str): Topic to produce to.\n            kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n                uses global config. Defaults to None.\n\n        Raises:\n            InternalError: If there is an error initializing the producer.\n        \"\"\"\n        configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n        self.topic = topic_name\n        self._adapter: Producer = self._get_adapter(configs)\n\n    @staticmethod\n    def _get_adapter(configs: KafkaConfig) -&gt; Producer:\n        \"\"\"Creates and configures a Kafka Producer instance.\n\n        Args:\n            configs (KafkaConfig): Kafka configuration.\n\n        Returns:\n            Producer: Configured Kafka Producer instance.\n\n        Raises:\n            InternalError: If there is an error creating the producer.\n        \"\"\"\n        try:\n            broker_list_csv = \",\".join(configs.BROKERS_LIST)\n            config = {\n                \"bootstrap.servers\": broker_list_csv,\n                \"queue.buffering.max.ms\": configs.MAX_BUFFER_MS,\n                \"queue.buffering.max.messages\": configs.MAX_BUFFER_SIZE,\n                \"acks\": configs.ACKNOWLEDGE_COUNT,\n                \"request.timeout.ms\": configs.REQUEST_ACK_TIMEOUT_MS,\n                \"delivery.timeout.ms\": configs.DELIVERY_MESSAGE_TIMEOUT_MS,\n            }\n            if configs.USER_NAME and configs.PASSWORD and configs.CERT_PEM:\n                config |= {\n                    \"sasl.username\": configs.USER_NAME,\n                    \"sasl.password\": configs.PASSWORD,\n                    \"security.protocol\": configs.SECURITY_PROTOCOL,\n                    \"sasl.mechanisms\": configs.SASL_MECHANISMS,\n                    \"ssl.endpoint.identification.algorithm\": \"none\",\n                    \"ssl.ca.pem\": configs.CERT_PEM,\n                }\n            return Producer(config)\n        except Exception as e:\n            raise InternalError(details=str(e), lang=LanguageType.FA) from e\n\n    @staticmethod\n    def _pre_process_message(message: str | bytes) -&gt; bytes:\n        \"\"\"Converts a message to bytes if it's a string.\n\n        Args:\n            message (str | bytes): The message to process.\n\n        Returns:\n            bytes: The message in bytes format.\n        \"\"\"\n        return message if isinstance(message, bytes) else message.encode(\"utf-8\")\n\n    @staticmethod\n    def _delivery_callback(error: KafkaError | None, message: Message) -&gt; None:\n        \"\"\"Handles the delivery result of a produced message.\n\n        Args:\n            error (KafkaError | None): Error if the delivery failed, None if successful.\n            message (Message): The message that was delivered.\n\n        Raises:\n            InternalError: If the message delivery failed.\n        \"\"\"\n        if error:\n            logger.error(\"Message failed delivery\", error)\n            logger.debug(\"Message = %s\", message)\n            raise InternalError(\n                details=\"Message failed delivery\",\n                lang=LanguageType.FA,\n            )\n        logger.debug(\"Message delivered\", message)\n\n    @override\n    def produce(self, message: str | bytes) -&gt; None:\n        \"\"\"Produces a message to the configured topic.\n\n        Args:\n            message (str | bytes): The message to produce.\n\n        Raises:\n            InternalError: If there is an error producing the message.\n        \"\"\"\n        try:\n            processed_message = self._pre_process_message(message)\n            self._adapter.produce(self.topic, processed_message, on_delivery=self._delivery_callback)\n        except Exception as e:\n            raise InternalError(\n                details=\"Failed to produce message\",\n                lang=LanguageType.FA,\n            ) from e\n\n    @override\n    def flush(self, timeout: int | None = None) -&gt; None:\n        \"\"\"Flushes any pending messages to the broker.\n\n        Args:\n            timeout (int | None, optional): Maximum time to wait for messages to be delivered.\n                If None, wait indefinitely. Defaults to None.\n\n        Raises:\n            InternalError: If there is an error flushing messages.\n        \"\"\"\n        try:\n            self._adapter.flush(timeout=timeout)\n        except Exception as e:\n            raise InternalError(\n                details=\"Failed to flush messages\",\n                lang=LanguageType.FA,\n            ) from e\n\n    @override\n    def validate_healthiness(self) -&gt; None:\n        \"\"\"Validates the health of the producer connection.\n\n        Raises:\n            UnavailableError: If the Kafka service is unavailable.\n        \"\"\"\n        try:\n            self.list_topics(self.topic, timeout=1)\n        except Exception as e:\n            raise UnavailableError(\n                service=\"Kafka\",\n                lang=LanguageType.FA,\n            ) from e\n\n    @override\n    def list_topics(\n        self,\n        topic: str | None = None,\n        timeout: int = 1,\n    ) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            UnavailableError: If the Kafka service is unavailable.\n        \"\"\"\n        try:\n            topic = topic or self.topic\n            return self._adapter.list_topics(topic=topic, timeout=timeout)\n        except Exception as e:\n            raise UnavailableError(\n                service=\"Kafka\",\n                lang=LanguageType.FA,\n            ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.__init__","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.__init__(topic_name, kafka_configs=None)</code>","text":"<p>Initializes the producer adapter with Kafka configuration and topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic_name</code> <code>str</code> <p>Topic to produce to.</p> required <code>kafka_configs</code> <code>KafkaConfig | None</code> <p>Kafka configuration. If None, uses global config. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error initializing the producer.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>def __init__(self, topic_name: str, kafka_configs: KafkaConfig | None = None) -&gt; None:\n    \"\"\"Initializes the producer adapter with Kafka configuration and topic.\n\n    Args:\n        topic_name (str): Topic to produce to.\n        kafka_configs (KafkaConfig | None, optional): Kafka configuration. If None,\n            uses global config. Defaults to None.\n\n    Raises:\n        InternalError: If there is an error initializing the producer.\n    \"\"\"\n    configs: KafkaConfig = kafka_configs or BaseConfig.global_config().KAFKA\n    self.topic = topic_name\n    self._adapter: Producer = self._get_adapter(configs)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.produce","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.produce(message)</code>","text":"<p>Produces a message to the configured topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | bytes</code> <p>The message to produce.</p> required <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error producing the message.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef produce(self, message: str | bytes) -&gt; None:\n    \"\"\"Produces a message to the configured topic.\n\n    Args:\n        message (str | bytes): The message to produce.\n\n    Raises:\n        InternalError: If there is an error producing the message.\n    \"\"\"\n    try:\n        processed_message = self._pre_process_message(message)\n        self._adapter.produce(self.topic, processed_message, on_delivery=self._delivery_callback)\n    except Exception as e:\n        raise InternalError(\n            details=\"Failed to produce message\",\n            lang=LanguageType.FA,\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.flush","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.flush(timeout=None)</code>","text":"<p>Flushes any pending messages to the broker.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Maximum time to wait for messages to be delivered. If None, wait indefinitely. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>InternalError</code> <p>If there is an error flushing messages.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef flush(self, timeout: int | None = None) -&gt; None:\n    \"\"\"Flushes any pending messages to the broker.\n\n    Args:\n        timeout (int | None, optional): Maximum time to wait for messages to be delivered.\n            If None, wait indefinitely. Defaults to None.\n\n    Raises:\n        InternalError: If there is an error flushing messages.\n    \"\"\"\n    try:\n        self._adapter.flush(timeout=timeout)\n    except Exception as e:\n        raise InternalError(\n            details=\"Failed to flush messages\",\n            lang=LanguageType.FA,\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.validate_healthiness","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.validate_healthiness()</code>","text":"<p>Validates the health of the producer connection.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If the Kafka service is unavailable.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef validate_healthiness(self) -&gt; None:\n    \"\"\"Validates the health of the producer connection.\n\n    Raises:\n        UnavailableError: If the Kafka service is unavailable.\n    \"\"\"\n    try:\n        self.list_topics(self.topic, timeout=1)\n    except Exception as e:\n        raise UnavailableError(\n            service=\"Kafka\",\n            lang=LanguageType.FA,\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.adapters.KafkaProducerAdapter.list_topics","title":"<code>archipy.adapters.kafka.adapters.KafkaProducerAdapter.list_topics(topic=None, timeout=1)</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>UnavailableError</code> <p>If the Kafka service is unavailable.</p> Source code in <code>archipy/adapters/kafka/adapters.py</code> <pre><code>@override\ndef list_topics(\n    self,\n    topic: str | None = None,\n    timeout: int = 1,\n) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        UnavailableError: If the Kafka service is unavailable.\n    \"\"\"\n    try:\n        topic = topic or self.topic\n        return self._adapter.list_topics(topic=topic, timeout=timeout)\n    except Exception as e:\n        raise UnavailableError(\n            service=\"Kafka\",\n            lang=LanguageType.FA,\n        ) from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports","title":"<code>archipy.adapters.kafka.ports</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort</code>","text":"<p>Interface for Kafka admin operations.</p> <p>This interface defines the contract for performing administrative operations on Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaAdminPort:\n    \"\"\"Interface for Kafka admin operations.\n\n    This interface defines the contract for performing administrative operations on Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n        \"\"\"Creates a new Kafka topic.\n\n        Args:\n            topic (str): Name of the topic to create.\n            num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n            replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_topic(self, topics: list[str]) -&gt; None:\n        \"\"\"Deletes one or more Kafka topics.\n\n        Args:\n            topics (list[str]): List of topic names to delete.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None, optional): Specific topic to list. If None, lists all topics.\n                Defaults to None.\n            timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.create_topic","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.create_topic(topic, num_partitions=1, replication_factor=1)</code>  <code>abstractmethod</code>","text":"<p>Creates a new Kafka topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required <code>num_partitions</code> <code>int</code> <p>Number of partitions for the topic. Defaults to 1.</p> <code>1</code> <code>replication_factor</code> <code>int</code> <p>Replication factor for the topic. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef create_topic(self, topic: str, num_partitions: int = 1, replication_factor: int = 1) -&gt; None:\n    \"\"\"Creates a new Kafka topic.\n\n    Args:\n        topic (str): Name of the topic to create.\n        num_partitions (int, optional): Number of partitions for the topic. Defaults to 1.\n        replication_factor (int, optional): Replication factor for the topic. Defaults to 1.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.delete_topic","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.delete_topic(topics)</code>  <code>abstractmethod</code>","text":"<p>Deletes one or more Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topics</code> <code>list[str]</code> <p>List of topic names to delete.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef delete_topic(self, topics: list[str]) -&gt; None:\n    \"\"\"Deletes one or more Kafka topics.\n\n    Args:\n        topics (list[str]): List of topic names to delete.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaAdminPort.list_topics","title":"<code>archipy.adapters.kafka.ports.KafkaAdminPort.list_topics(topic=None, timeout=1)</code>  <code>abstractmethod</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef list_topics(self, topic: str | None = None, timeout: int = 1) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None, optional): Specific topic to list. If None, lists all topics.\n            Defaults to None.\n        timeout (int, optional): Timeout in seconds for the operation. Defaults to 1.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort</code>","text":"<p>Interface for Kafka consumer operations.</p> <p>This interface defines the contract for consuming messages from Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaConsumerPort:\n    \"\"\"Interface for Kafka consumer operations.\n\n    This interface defines the contract for consuming messages from Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def batch_consume(self, messages_number: int, timeout: int) -&gt; list[Message]:\n        \"\"\"Consumes a batch of messages from subscribed topics.\n\n        Args:\n            messages_number (int): Maximum number of messages to consume.\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            list[Message]: List of consumed messages.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def poll(self, timeout: int) -&gt; Message | None:\n        \"\"\"Polls for a single message from subscribed topics.\n\n        Args:\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            Message | None: The consumed message or None if no message was received.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def commit(self, message: Message, asynchronous: bool) -&gt; None | list[TopicPartition]:\n        \"\"\"Commits the offset of a consumed message.\n\n        Args:\n            message (Message): The message whose offset should be committed.\n            asynchronous (bool): Whether to commit asynchronously.\n\n        Returns:\n            None | list[TopicPartition]: None for synchronous commits, or list of committed\n                partitions for asynchronous commits.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def subscribe(self, topic_list: list[str]) -&gt; None:\n        \"\"\"Subscribes to a list of topics.\n\n        Args:\n            topic_list (list[str]): List of topic names to subscribe to.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign(self, partition_list: list[TopicPartition]) -&gt; None:\n        \"\"\"Assigns specific partitions to the consumer.\n\n        Args:\n            partition_list (list[TopicPartition]): List of partitions to assign.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.batch_consume","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.batch_consume(messages_number, timeout)</code>  <code>abstractmethod</code>","text":"<p>Consumes a batch of messages from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>messages_number</code> <code>int</code> <p>Maximum number of messages to consume.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Type Description <code>list[Message]</code> <p>list[Message]: List of consumed messages.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef batch_consume(self, messages_number: int, timeout: int) -&gt; list[Message]:\n    \"\"\"Consumes a batch of messages from subscribed topics.\n\n    Args:\n        messages_number (int): Maximum number of messages to consume.\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        list[Message]: List of consumed messages.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.poll","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.poll(timeout)</code>  <code>abstractmethod</code>","text":"<p>Polls for a single message from subscribed topics.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Type Description <code>Message | None</code> <p>Message | None: The consumed message or None if no message was received.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef poll(self, timeout: int) -&gt; Message | None:\n    \"\"\"Polls for a single message from subscribed topics.\n\n    Args:\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        Message | None: The consumed message or None if no message was received.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.commit","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.commit(message, asynchronous)</code>  <code>abstractmethod</code>","text":"<p>Commits the offset of a consumed message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message whose offset should be committed.</p> required <code>asynchronous</code> <code>bool</code> <p>Whether to commit asynchronously.</p> required <p>Returns:</p> Type Description <code>None | list[TopicPartition]</code> <p>None | list[TopicPartition]: None for synchronous commits, or list of committed partitions for asynchronous commits.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef commit(self, message: Message, asynchronous: bool) -&gt; None | list[TopicPartition]:\n    \"\"\"Commits the offset of a consumed message.\n\n    Args:\n        message (Message): The message whose offset should be committed.\n        asynchronous (bool): Whether to commit asynchronously.\n\n    Returns:\n        None | list[TopicPartition]: None for synchronous commits, or list of committed\n            partitions for asynchronous commits.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.subscribe","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.subscribe(topic_list)</code>  <code>abstractmethod</code>","text":"<p>Subscribes to a list of topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic_list</code> <code>list[str]</code> <p>List of topic names to subscribe to.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef subscribe(self, topic_list: list[str]) -&gt; None:\n    \"\"\"Subscribes to a list of topics.\n\n    Args:\n        topic_list (list[str]): List of topic names to subscribe to.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaConsumerPort.assign","title":"<code>archipy.adapters.kafka.ports.KafkaConsumerPort.assign(partition_list)</code>  <code>abstractmethod</code>","text":"<p>Assigns specific partitions to the consumer.</p> <p>Parameters:</p> Name Type Description Default <code>partition_list</code> <code>list[TopicPartition]</code> <p>List of partitions to assign.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef assign(self, partition_list: list[TopicPartition]) -&gt; None:\n    \"\"\"Assigns specific partitions to the consumer.\n\n    Args:\n        partition_list (list[TopicPartition]): List of partitions to assign.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort</code>","text":"<p>Interface for Kafka producer operations.</p> <p>This interface defines the contract for producing messages to Kafka topics.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>class KafkaProducerPort:\n    \"\"\"Interface for Kafka producer operations.\n\n    This interface defines the contract for producing messages to Kafka topics.\n    \"\"\"\n\n    @abstractmethod\n    def produce(self, message: str | bytes) -&gt; None:\n        \"\"\"Produces a message to the configured topic.\n\n        Args:\n            message (str | bytes): The message to produce.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def flush(self, timeout: int | None) -&gt; None:\n        \"\"\"Flushes any pending messages to the broker.\n\n        Args:\n            timeout (int | None): Maximum time to wait for messages to be delivered.\n                If None, wait indefinitely.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_healthiness(self) -&gt; None:\n        \"\"\"Validates the health of the producer connection.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def list_topics(self, topic: str | None, timeout: int) -&gt; ClusterMetadata:\n        \"\"\"Lists Kafka topics.\n\n        Args:\n            topic (str | None): Specific topic to list. If None, lists all topics.\n            timeout (int): Timeout in seconds for the operation.\n\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.produce","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.produce(message)</code>  <code>abstractmethod</code>","text":"<p>Produces a message to the configured topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | bytes</code> <p>The message to produce.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef produce(self, message: str | bytes) -&gt; None:\n    \"\"\"Produces a message to the configured topic.\n\n    Args:\n        message (str | bytes): The message to produce.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.flush","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.flush(timeout)</code>  <code>abstractmethod</code>","text":"<p>Flushes any pending messages to the broker.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int | None</code> <p>Maximum time to wait for messages to be delivered. If None, wait indefinitely.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef flush(self, timeout: int | None) -&gt; None:\n    \"\"\"Flushes any pending messages to the broker.\n\n    Args:\n        timeout (int | None): Maximum time to wait for messages to be delivered.\n            If None, wait indefinitely.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.validate_healthiness","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.validate_healthiness()</code>  <code>abstractmethod</code>","text":"<p>Validates the health of the producer connection.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef validate_healthiness(self) -&gt; None:\n    \"\"\"Validates the health of the producer connection.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.kafka.ports.KafkaProducerPort.list_topics","title":"<code>archipy.adapters.kafka.ports.KafkaProducerPort.list_topics(topic, timeout)</code>  <code>abstractmethod</code>","text":"<p>Lists Kafka topics.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str | None</code> <p>Specific topic to list. If None, lists all topics.</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds for the operation.</p> required <p>Returns:</p> Name Type Description <code>ClusterMetadata</code> <code>ClusterMetadata</code> <p>Metadata about the Kafka cluster and topics.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by the concrete class.</p> Source code in <code>archipy/adapters/kafka/ports.py</code> <pre><code>@abstractmethod\ndef list_topics(self, topic: str | None, timeout: int) -&gt; ClusterMetadata:\n    \"\"\"Lists Kafka topics.\n\n    Args:\n        topic (str | None): Specific topic to list. If None, lists all topics.\n        timeout (int): Timeout in seconds for the operation.\n\n    Returns:\n        ClusterMetadata: Metadata about the Kafka cluster and topics.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by the concrete class.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/configs/","title":"Configs","text":""},{"location":"api_reference/configs/#overview","title":"Overview","text":"<p>The configs module provides tools for standardized configuration management and injection, supporting consistent setup across services like databases, Redis, and email.</p>"},{"location":"api_reference/configs/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\npoetry add archipy\n</code></pre>"},{"location":"api_reference/configs/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/configs/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/configs/#api-stability","title":"API Stability","text":"Component Status Notes BaseConfig \ud83d\udfe2 Stable Production-ready Config Templates \ud83d\udfe2 Stable Production-ready Environment Types \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/configs/#examples","title":"Examples","text":"<p>For practical examples, see the Configuration Management Guide.</p>"},{"location":"api_reference/configs/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api_reference/configs/#base-config","title":"Base Config","text":"<p>Documentation for <code>archipy.configs.base_config</code> module.</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n</code></pre> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#config-templates","title":"Config Templates","text":"<p>Documentation for <code>archipy.configs.config_template</code> module.</p> <pre><code>from archipy.configs.config_template import SqlAlchemyConfig\n\nclass DatabaseConfig(SqlAlchemyConfig):\n    DB_POOL_SIZE: int = 5\n    DB_POOL_TIMEOUT: int = 30\n</code></pre> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/configs/#baseconfig","title":"BaseConfig","text":"<p>Class: <code>archipy.configs.base_config.BaseConfig</code></p> <p>Configures:</p> <ul> <li>Environment variable support</li> <li>Type validation</li> <li>Global configuration access</li> <li>Nested configuration support</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#sqlalchemyconfig","title":"SqlAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.SqlAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>Database connection settings</li> <li>Pool configuration</li> <li>Migration settings</li> <li>Debug options</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#redisconfig","title":"RedisConfig","text":"<p>Class: <code>archipy.configs.config_template.RedisConfig</code></p> <p>Configures:</p> <ul> <li>Connection settings</li> <li>Pool configuration</li> <li>SSL options</li> <li>Sentinel support</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#emailconfig","title":"EmailConfig","text":"<p>Class: <code>archipy.configs.config_template.EmailConfig</code></p> <p>Configures:</p> <ul> <li>SMTP settings</li> <li>Authentication</li> <li>TLS options</li> <li>Default headers</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#fastapiconfig","title":"FastAPIConfig","text":"<p>Class: <code>archipy.configs.config_template.FastAPIConfig</code></p> <p>Configures:</p> <ul> <li>API versioning</li> <li>CORS configuration</li> <li>Rate limiting</li> <li>Documentation</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#grpcconfig","title":"GrpcConfig","text":"<p>Class: <code>archipy.configs.config_template.GrpcConfig</code></p> <p>Configures:</p> <ul> <li>Server settings</li> <li>Client configuration</li> <li>Interceptors</li> <li>SSL/TLS options</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#sentryconfig","title":"SentryConfig","text":"<p>Class: <code>archipy.configs.config_template.SentryConfig</code></p> <p>Configures:</p> <ul> <li>DSN configuration</li> <li>Environment settings</li> <li>Sample rates</li> <li>Performance monitoring</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#elasticsearchconfig","title":"ElasticSearchConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticSearchConfig</code></p> <p>Configures:</p> <ul> <li>Cluster configuration</li> <li>Authentication</li> <li>Index settings</li> <li>Retry policies</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#elasticsearchapmconfig","title":"ElasticSearchAPMConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticSearchAPMConfig</code></p> <p>Configures:</p> <ul> <li>APM server settings</li> <li>Service name</li> <li>Transaction sampling</li> <li>Instrumentation</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#kafkaconfig","title":"KafkaConfig","text":"<p>Class: <code>archipy.configs.config_template.KafkaConfig</code></p> <p>Configures:</p> <ul> <li>Broker configuration</li> <li>Consumer groups</li> <li>Producer settings</li> <li>Security options</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#environmenttype","title":"EnvironmentType","text":"<p>Class: <code>archipy.configs.environment_type.EnvironmentType</code></p> <p>Configures:</p> <ul> <li>Environment types (DEV, STAGING, PROD)</li> <li>Environment-specific behaviors</li> <li>Configuration validation rules</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/","title":"Helpers","text":""},{"location":"api_reference/helpers/#overview","title":"Overview","text":"<p>The <code>helpers</code> module provides utility functions and classes to simplify common development tasks.</p>"},{"location":"api_reference/helpers/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\npoetry add archipy\n</code></pre> <p>For development features:</p> <pre><code># Add ArchiPy with development extras\npoetry add archipy -E dev\n</code></pre>"},{"location":"api_reference/helpers/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/helpers/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/helpers/#api-stability","title":"API Stability","text":"Component Status Notes Decorators \ud83d\udfe2 Stable Production-ready Utils \ud83d\udfe2 Stable Production-ready Interceptors \ud83d\udfe1 Beta API may change Metaclasses \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/helpers/#submodules","title":"Submodules","text":""},{"location":"api_reference/helpers/#utils","title":"Utils","text":"<p>See Utils Documentation for full documentation.</p> <p>General utility functions for common operations:</p> <ul> <li>String manipulation</li> <li>Date and time handling</li> <li>Error utilities</li> <li>File operations</li> <li>Password utilities</li> <li>JWT token handling</li> <li>TOTP generation</li> </ul>"},{"location":"api_reference/helpers/#decorators","title":"Decorators","text":"<p>See Decorators Documentation for full documentation.</p> <p>Function and class decorators for:</p> <ul> <li>Method deprecation</li> <li>Class deprecation</li> <li>Timing operations</li> <li>Retry logic</li> </ul>"},{"location":"api_reference/helpers/#interceptors","title":"Interceptors","text":"<p>See Interceptors Documentation for full documentation.</p> <p>Classes for cross-cutting concerns:</p> <ul> <li>Logging</li> <li>Performance monitoring</li> <li>Request/response tracking</li> </ul>"},{"location":"api_reference/helpers/#overview_1","title":"Overview","text":"<p>The helpers module offers utilities, decorators, and interceptors to enhance productivity and simplify common development tasks, such as retry logic, rate limiting, and tracing.</p> <p>See Examples: Examples Helpers</p>"},{"location":"api_reference/helpers/#decorators_1","title":"Decorators","text":"<p>Tip: See Examples Helpers Decorators for practical examples of decorators.</p>"},{"location":"api_reference/helpers/#retry-decorator","title":"Retry Decorator","text":"<p>Documentation for <code>archipy.helpers.decorators.retry</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#singleton-decorator","title":"Singleton Decorator","text":"<p>Documentation for <code>archipy.helpers.decorators.singleton</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#sqlalchemy-atomic-decorator","title":"SQLAlchemy Atomic Decorator","text":"<p>Documentation for <code>archipy.helpers.decorators.sqlalchemy_atomic</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#interceptors_1","title":"Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-interceptors","title":"FastAPI Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-rest-rate-limit-handler","title":"FastAPI Rest Rate Limit Handler","text":"<p>Documentation for <code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#grpc-interceptors","title":"gRPC Interceptors","text":""},{"location":"api_reference/helpers/#grpc-client-trace-interceptor","title":"gRPC Client Trace Interceptor","text":"<p>Documentation for <code>archipy.helpers.interceptors.grpc.trace.grpc_client_trace_interceptor</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#grpc-server-trace-interceptor","title":"gRPC Server Trace Interceptor","text":"<p>Documentation for <code>archipy.helpers.interceptors.grpc.trace.grpc_server_trace_interceptor</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#metaclasses","title":"Metaclasses","text":""},{"location":"api_reference/helpers/#singleton-metaclass","title":"Singleton Metaclass","text":"<p>Documentation for <code>archipy.helpers.metaclasses.singleton</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/helpers/#retry-decorator_1","title":"Retry Decorator","text":"<p>Function: <code>archipy.helpers.decorators.retry.retry</code> See documentation for details.</p>"},{"location":"api_reference/helpers/#singleton","title":"Singleton","text":"<p>Class: <code>archipy.helpers.metaclasses.singleton.Singleton</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#fastapirestratelimithandler","title":"FastAPIRestRateLimitHandler","text":"<p>Class: <code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/","title":"Models","text":""},{"location":"api_reference/models/#overview","title":"Overview","text":"<p>The models module standardizes data structures with base entities, DTOs, errors, and types, ensuring consistency across the application.</p>"},{"location":"api_reference/models/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>Note: For practical examples of using DTOs with utilities, see the Utils Examples.</p>"},{"location":"api_reference/models/#base-dtos","title":"Base DTOs","text":"<p>Documentation for <code>archipy.models.dtos.base_dtos</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#email-dtos","title":"Email DTOs","text":"<p>Documentation for <code>archipy.models.dtos.email_dtos</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#error-dto","title":"Error DTO","text":"<p>Documentation for <code>archipy.models.dtos.error_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#pagination-dto","title":"Pagination DTO","text":"<p>Documentation for <code>archipy.models.dtos.pagination_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#range-dtos","title":"Range DTOs","text":"<p>Documentation for <code>archipy.models.dtos.range_dtos</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#search-input-dto","title":"Search Input DTO","text":"<p>Documentation for <code>archipy.models.dtos.search_input_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#sort-dto","title":"Sort DTO","text":"<p>Documentation for <code>archipy.models.dtos.sort_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#entities","title":"Entities","text":""},{"location":"api_reference/models/#sqlalchemy-base-entities","title":"SQLAlchemy Base Entities","text":"<p>Documentation for <code>archipy.models.entities.sqlalchemy.base_entities</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#errors","title":"Errors","text":""},{"location":"api_reference/models/#custom-errors","title":"Custom Errors","text":"<p>Documentation for <code>archipy.models.errors.custom_errors</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#types","title":"Types","text":""},{"location":"api_reference/models/#base-types","title":"Base Types","text":"<p>Documentation for <code>archipy.models.types.base_types</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#email-types","title":"Email Types","text":"<p>Documentation for <code>archipy.models.types.email_types</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#exception-message-types","title":"Exception Message Types","text":"<p>Documentation for <code>archipy.models.types.exception_message_types</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#language-type","title":"Language Type","text":"<p>Documentation for <code>archipy.models.types.language_type</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#sort-order-type","title":"Sort Order Type","text":"<p>Documentation for <code>archipy.models.types.sort_order_type</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/models/#basedto","title":"BaseDTO","text":"<p>Class: <code>archipy.models.dtos.base_dtos.BaseDTO</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#baseentity","title":"BaseEntity","text":"<p>Class: <code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#baseerror","title":"BaseError","text":"<p>Class: <code>archipy.models.errors.custom_errors.BaseError</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/","title":"Utils","text":""},{"location":"api_reference/utils/#overview","title":"Overview","text":"<p>The utils module provides helper functions for common tasks, enhancing productivity in areas like datetime handling, JWT management, and password processing.</p> <p>See Examples: Examples Helpers Utils</p>"},{"location":"api_reference/utils/#utilities","title":"Utilities","text":""},{"location":"api_reference/utils/#datetime_utils","title":"datetime_utils","text":"<p>Documentation for <code>archipy.helpers.utils.datetime_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#file_utils","title":"file_utils","text":"<p>Documentation for <code>archipy.helpers.utils.file_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#jwt_utils","title":"jwt_utils","text":"<p>Documentation for <code>archipy.helpers.utils.jwt_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#password_utils","title":"password_utils","text":"<p>Documentation for <code>archipy.helpers.utils.password_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#string_utils","title":"string_utils","text":"<p>Documentation for <code>archipy.helpers.utils.string_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#totp_utils","title":"totp_utils","text":"<p>Documentation for <code>archipy.helpers.utils.totp_utils</code>. Includes all members, undocumented members, and shows inheritance.</p> <p>The TOTP utilities provide enhanced security features:</p> <ul> <li>HMAC-based implementation for time-based one-time passwords</li> <li>Configurable hash algorithms (SHA1, SHA256, SHA512)</li> <li>Secure key generation with master key protection</li> <li>Configurable verification window for time skew tolerance</li> <li>Comprehensive error handling with specific exception types</li> </ul>"},{"location":"api_reference/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Documentation for <code>archipy.helpers.utils.keycloak_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#key-functions","title":"Key Functions","text":""},{"location":"api_reference/utils/#get_utc_now","title":"get_utc_now","text":"<p>Function: <code>archipy.helpers.utils.datetime_utils.get_utc_now</code> See documentation for details.</p>"},{"location":"api_reference/utils/#generate_jwt","title":"generate_jwt","text":"<p>Function: <code>archipy.helpers.utils.jwt_utils.generate_jwt</code> See documentation for details.</p>"},{"location":"api_reference/utils/#hash_password","title":"hash_password","text":"<p>Function: <code>archipy.helpers.utils.password_utils.hash_password</code> See documentation for details.</p>"},{"location":"examples/bdd_testing/","title":"BDD Testing with ArchiPy","text":"<p>This page demonstrates how to use ArchiPy's integrated BDD testing capabilities with Behave.</p>"},{"location":"examples/bdd_testing/#basic-usage","title":"Basic Usage","text":"<p>ArchiPy provides a complete BDD testing setup using Behave. Here's how to use it:</p>"},{"location":"examples/bdd_testing/#feature-files","title":"Feature Files","text":"<p>Create feature files in the <code>features</code> directory with Gherkin syntax:</p> <pre><code># features/user_management.feature\nFeature: User Management\n  As a system administrator\n  I want to manage users\n  So that I can control system access\n\n  Scenario: Create a new user\n    Given I have admin privileges\n    When I create a user with username \"john\" and email \"john@example.com\"\n    Then the user should be saved in the database\n    And the user should have default permissions\n</code></pre>"},{"location":"examples/bdd_testing/#step-implementations","title":"Step Implementations","text":"<p>Implement the steps in Python files under <code>features/steps</code>:</p> <pre><code># features/steps/user_steps.py\nfrom behave import given, when, then\nfrom app.models import User\nfrom app.services import UserService\n\n@given('I have admin privileges')\ndef step_impl(context):\n    context.is_admin = True\n\n@when('I create a user with username \"{username}\" and email \"{email}\"')\ndef step_impl(context, username, email):\n    service = UserService()\n    context.user = service.create_user(username, email)\n\n@then('the user should be saved in the database')\ndef step_impl(context):\n    # Check user exists in DB\n    db_user = User.query.filter_by(username=context.user.username).first()\n    assert db_user is not None\n\n@then('the user should have default permissions')\ndef step_impl(context):\n    assert len(context.user.permissions) &gt; 0\n    assert 'user:read' in context.user.permissions\n</code></pre>"},{"location":"examples/bdd_testing/#running-tests","title":"Running Tests","text":"<p>Run BDD tests using the Makefile command:</p> <pre><code>make behave\n</code></pre> <p>To run a specific feature:</p> <pre><code>poetry run behave features/user_management.feature\n</code></pre> <p>To run a specific scenario by line number:</p> <pre><code>poetry run behave features/user_management.feature:7\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/config_management/","title":"Configuration Management","text":"<p>ArchiPy provides a robust configuration management system that ensures type safety, environment variable support, and consistent access patterns across your application.</p>"},{"location":"examples/config_management/#basic-configuration","title":"Basic Configuration","text":""},{"location":"examples/config_management/#defining-a-configuration","title":"Defining a Configuration","text":"<p>Create a configuration class by inheriting from <code>BaseConfig</code>:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(BaseConfig):\n    # Application settings\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n    DB_NAME: str = \"myapp\"\n    DB_USER: str = \"postgres\"\n    DB_PASSWORD: str = \"password\"\n\n    # Redis settings\n    REDIS_HOST: str = \"localhost\"\n    REDIS_PORT: int = 6379\n\n    # Environment\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEVELOPMENT\n\n    # API settings\n    API_PREFIX: str = \"/api/v1\"\n\n    # Logging\n    LOG_LEVEL: str = \"INFO\"\n</code></pre>"},{"location":"examples/config_management/#using-the-configuration","title":"Using the Configuration","text":"<pre><code># Create and set as global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n\n# Access configuration values from anywhere in your code\nfrom archipy.configs.base_config import BaseConfig\n\ncurrent_config = BaseConfig.global_config()\ndb_url = f\"postgresql://{current_config.DB_USER}:{current_config.DB_PASSWORD}@{current_config.DB_HOST}:{current_config.DB_PORT}/{current_config.DB_NAME}\"\n</code></pre>"},{"location":"examples/config_management/#environment-variables","title":"Environment Variables","text":"<p>ArchiPy configurations automatically load values from environment variables with the same name:</p> <pre><code># .env file\nAPP_NAME=ProductionService\nDB_HOST=db.example.com\nDB_PASSWORD=secure-password\nENVIRONMENT=PRODUCTION\n</code></pre> <p>The environment variables override the default values in your configuration class:</p> <pre><code>config = AppConfig()  # Will have values from environment variables\nprint(config.APP_NAME)  # \"ProductionService\"\nprint(config.ENVIRONMENT)  # EnvironmentType.PRODUCTION\n</code></pre>"},{"location":"examples/config_management/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>You can create environment-specific configurations:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass BaseAppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    # Common settings...\n\nclass DevelopmentConfig(BaseAppConfig):\n    DEBUG: bool = True\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEVELOPMENT\n    LOG_LEVEL: str = \"DEBUG\"\n\nclass ProductionConfig(BaseAppConfig):\n    DEBUG: bool = False\n    ENVIRONMENT: EnvironmentType = EnvironmentType.PRODUCTION\n    LOG_LEVEL: str = \"WARNING\"\n\n# Choose configuration based on environment\nimport os\nenv = os.getenv(\"ENVIRONMENT\", \"development\").lower()\n\nif env == \"production\":\n    config = ProductionConfig()\nelse:\n    config = DevelopmentConfig()\n\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"examples/config_management/#nested-configurations","title":"Nested Configurations","text":"<p>You can use nested Pydantic models for more complex configurations:</p> <pre><code>from pydantic import BaseModel\nfrom archipy.configs.base_config import BaseConfig\n\nclass DatabaseConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 5432\n    NAME: str = \"myapp\"\n    USER: str = \"postgres\"\n    PASSWORD: str = \"password\"\n\n    def connection_string(self) -&gt; str:\n        return f\"postgresql://{self.USER}:{self.PASSWORD}@{self.HOST}:{self.PORT}/{self.NAME}\"\n\nclass RedisConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 6379\n    DB: int = 0\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    DATABASE: DatabaseConfig = DatabaseConfig()\n    REDIS: RedisConfig = RedisConfig()\n\n# Usage\nconfig = AppConfig()\nprint(config.DATABASE.connection_string())\n</code></pre>"},{"location":"examples/config_management/#configuration-template","title":"Configuration Template","text":"<p>ArchiPy provides a template for common configurations:</p> <pre><code>from archipy.configs.config_template import ConfigTemplate\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(ConfigTemplate):\n    # Override only what you need\n    APP_NAME: str = \"MyCustomApp\"\n\n    # Use all the defaults from ConfigTemplate for the rest\n\nconfig = AppConfig()\nprint(config.ENVIRONMENT)  # Default value from ConfigTemplate\n</code></pre>"},{"location":"examples/config_management/#configuration-in-different-components","title":"Configuration in Different Components","text":""},{"location":"examples/config_management/#with-fastapi","title":"With FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with configuration\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Access config in endpoint\n@app.get(\"/config\")\ndef get_config_info():\n    config = BaseConfig.global_config()\n    return {\n        \"app_name\": config.APP_NAME,\n        \"environment\": config.ENVIRONMENT.value,\n        \"debug\": config.DEBUG\n    }\n</code></pre>"},{"location":"examples/config_management/#with-database-adapters","title":"With Database Adapters","text":"<pre><code>from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create session manager with config\nsession_manager = SessionManagerAdapter(\n    connection_string=config.DATABASE.connection_string(),\n    echo=config.DEBUG\n)\n</code></pre>"},{"location":"examples/config_management/#with-redis-adapters","title":"With Redis Adapters","text":"<pre><code>from archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create Redis adapter with config\nredis_adapter = RedisAdapter(\n    host=config.REDIS.HOST,\n    port=config.REDIS.PORT,\n    db=config.REDIS.DB\n)\n</code></pre>"},{"location":"examples/config_management/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use meaningful defaults: Configure sensible defaults that work in local development</p> </li> <li> <p>Never hardcode secrets: Always use environment variables for sensitive information</p> </li> <li> <p>Validate configurations: Use Pydantic validators for complex validation rules</p> </li> <li> <p>Document configuration options: Add clear docstrings to your configuration classes</p> </li> <li> <p>Keep configurations centralized: Avoid creating multiple configuration sources</p> </li> </ol>"},{"location":"examples/adapters/","title":"Adapter Examples","text":"<p>ArchiPy provides a variety of adapters to help interface with external systems, maintaining a clean separation between your business logic and external dependencies.</p>"},{"location":"examples/adapters/#available-adapters","title":"Available Adapters","text":"Adapter Purpose Example API Reference Email Email sending interface Connect to SMTP servers for sending emails API Keycloak Authentication &amp; authorization User management and access control with Keycloak API Kafka Message streaming Event-driven architectures with Apache Kafka API Minio Object storage S3-compatible object storage for files and documents API ORM Database access SQLAlchemy integration for database operations API Redis Key-value store Caching, pub/sub, and data storage with Redis API"},{"location":"examples/adapters/#adapter-architecture","title":"Adapter Architecture","text":"<p>ArchiPy follows the ports and adapters pattern (hexagonal architecture):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Domain Logic               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Ports                  \u2502\n\u2502          (Abstract Interfaces)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 implemented by\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Adapters                \u2502\n\u2502         (Concrete Implementations)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 connects to\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            External Systems            \u2502\n\u2502   (Databases, APIs, Message Queues)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/adapters/#testing-with-mock-adapters","title":"Testing with Mock Adapters","text":"<p>Each adapter in ArchiPy comes with a corresponding mock implementation for testing:</p> <pre><code># Production code\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"redis.example.com\", port=6379)\nredis.set(\"key\", \"value\")\n\n# Test code\nfrom archipy.adapters.redis import RedisMock\n\nredis_mock = RedisMock()\nredis_mock.set(\"key\", \"test_value\")\nassert redis_mock.get(\"key\") == \"test_value\"\n</code></pre>"},{"location":"examples/adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>Creating custom adapters is straightforward:</p> <ol> <li>Define a port (abstract interface)</li> <li>Implement the adapter class</li> <li>Optionally create a mock implementation</li> </ol> <p>See the Architecture guide for more details on creating custom adapters.</p>"},{"location":"examples/adapters/email/","title":"Email Adapter Examples","text":"<p>This page demonstrates how to use ArchiPy's email adapter functionality.</p>"},{"location":"examples/adapters/email/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.email import EmailAdapter\n\n# Configure email adapter\nemail_adapter = EmailAdapter(\n    host=\"smtp.example.com\",\n    port=587,\n    username=\"your-username\",\n    password=\"your-password\",\n    use_tls=True\n)\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email from ArchiPy\",\n    recipients=[\"recipient@example.com\"],\n    cc=[\"cc@example.com\"],\n    bcc=[\"bcc@example.com\"],\n    from_email=\"sender@example.com\"\n)\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/adapters/kafka/","title":"Kafka Adapter","text":"<p>The Kafka adapter provides a clean interface for interacting with Apache Kafka, supporting both synchronous and asynchronous operations.</p>"},{"location":"examples/adapters/kafka/#features","title":"Features","text":"<ul> <li>Topic operations (create, list, delete)</li> <li>Message publishing and consuming</li> <li>Consumer group management</li> <li>Built-in error handling and retry mechanisms</li> <li>Support for both sync and async operations</li> <li>Comprehensive logging and monitoring</li> </ul>"},{"location":"examples/adapters/kafka/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/kafka/#configuration","title":"Configuration","text":"<p>Configure Kafka in your application's config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Using environment variables\n# KAFKA__BOOTSTRAP_SERVERS=localhost:9092\n# KAFKA__CLIENT_ID=my-app\n# KAFKA__GROUP_ID=my-group\n</code></pre>"},{"location":"examples/adapters/kafka/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.kafka.adapters import KafkaAdapter, AsyncKafkaAdapter\n\n# Use global configuration\nkafka = KafkaAdapter()\n\n# Or provide specific configuration\nfrom archipy.configs.config_template import KafkaConfig\n\ncustom_config = KafkaConfig(\n    BOOTSTRAP_SERVERS=\"kafka1:9092,kafka2:9092\",\n    CLIENT_ID=\"custom-client\",\n    GROUP_ID=\"custom-group\"\n)\nkafka = KafkaAdapter(custom_config)\n</code></pre>"},{"location":"examples/adapters/kafka/#topic-operations","title":"Topic Operations","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create a topic\nkafka.create_topic(\"my-topic\", num_partitions=3, replication_factor=1)\n\n# List all topics\ntopics = kafka.list_topics()\nfor topic in topics:\n    logger.info(f\"Topic: {topic}\")\n\n# Delete a topic\nkafka.delete_topic(\"my-topic\")\n</code></pre>"},{"location":"examples/adapters/kafka/#publishing-messages","title":"Publishing Messages","text":"<pre><code>import logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Publish a simple message\nkafka.publish(\"my-topic\", \"Hello, Kafka!\")\n\n# Publish with key and headers\nheaders = {\"source\": \"my-app\", \"version\": \"1.0\"}\nkafka.publish(\"my-topic\", \"Hello, Kafka!\", key=\"message-1\", headers=headers)\n\n# Publish multiple messages\nmessages = [\n    {\"key\": \"msg1\", \"value\": \"Message 1\"},\n    {\"key\": \"msg2\", \"value\": \"Message 2\"}\n]\nkafka.publish_batch(\"my-topic\", messages)\n</code></pre>"},{"location":"examples/adapters/kafka/#consuming-messages","title":"Consuming Messages","text":"<pre><code>import logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Consume messages with a callback\ndef process_message(message: dict[str, Any]) -&gt; None:\n    logger.info(f\"Received message: {message['value']}\")\n\n# Start consuming\nkafka.consume(\"my-topic\", process_message)\n\n# Consume with specific partition and offset\nkafka.consume(\"my-topic\", process_message, partition=0, offset=0)\n\n# Consume with timeout\nkafka.consume(\"my-topic\", process_message, timeout_ms=5000)\n</code></pre>"},{"location":"examples/adapters/kafka/#async-operations","title":"Async Operations","text":"<pre><code>import asyncio\nimport logging\nfrom typing import Any\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nasync def async_example():\n    # Create async Kafka adapter\n    async_kafka = AsyncKafkaAdapter()\n\n    # Publish message asynchronously\n    await async_kafka.publish(\"my-topic\", \"Async message\")\n\n    # Consume messages asynchronously\n    async def process_async(message: dict[str, Any]) -&gt; None:\n        logger.info(f\"Received async message: {message['value']}\")\n\n    await async_kafka.consume(\"my-topic\", process_async)\n\n# Run the async example\nasyncio.run(async_example())\n</code></pre>"},{"location":"examples/adapters/kafka/#error-handling","title":"Error Handling","text":"<p>The KafkaAdapter uses ArchiPy's domain-specific exceptions for consistent error handling:</p> <pre><code>import logging\nfrom archipy.models.errors import (\n    AlreadyExistsError,\n    InternalError,\n    InvalidArgumentError,\n    NotFoundError,\n    PermissionDeniedError,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    kafka.create_topic(\"existing-topic\")\nexcept AlreadyExistsError:\n    logger.warning(\"Topic already exists\")\nexcept PermissionDeniedError:\n    logger.exception(\"Permission denied to create topic\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Invalid argument: {e}\")\nexcept InternalError as e:\n    logger.exception(f\"Internal error: {e}\")\n</code></pre>"},{"location":"examples/adapters/kafka/#consumer-group-management","title":"Consumer Group Management","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# List consumer groups\ngroups = kafka.list_consumer_groups()\nfor group in groups:\n    logger.info(f\"Group: {group['group_id']}, State: {group['state']}\")\n\n# Describe consumer group\ngroup_info = kafka.describe_consumer_group(\"my-group\")\nlogger.info(f\"Group members: {group_info['members']}\")\n\n# Delete consumer group\nkafka.delete_consumer_group(\"my-group\")\n</code></pre>"},{"location":"examples/adapters/kafka/#integration-with-web-applications","title":"Integration with Web Applications","text":""},{"location":"examples/adapters/kafka/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom archipy.adapters.kafka.adapters import KafkaAdapter\nfrom archipy.models.errors import InternalError\n\napp = FastAPI()\nkafka = KafkaAdapter()\n\nclass Message(BaseModel):\n    content: str\n    key: str | None = None\n\n@app.post(\"/publish/{topic}\")\nasync def publish_message(topic: str, message: Message):\n    try:\n        kafka.publish(topic, message.content, key=message.key)\n        return {\"message\": \"Message published successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/topics\")\nasync def list_topics():\n    try:\n        topics = kafka.list_topics()\n        return {\"topics\": topics}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"examples/adapters/kafka/#testing-with-bdd","title":"Testing with BDD","text":"<p>The Kafka adapter comes with BDD tests to verify functionality. Here's a sample feature file:</p> <pre><code>Feature: Kafka Operations Testing\n  As a developer\n  I want to test Kafka messaging operations\n  So that I can ensure reliable message delivery\n\n  Scenario: Publishing and consuming messages\n    Given I have a Kafka topic \"test-topic\"\n    When I publish a message \"Hello, Kafka!\" to \"test-topic\"\n    Then I should be able to consume the message from \"test-topic\"\n</code></pre>"},{"location":"examples/adapters/keycloak/","title":"Keycloak Adapter Usage Guide","text":"<p>The Keycloak adapter provides an interface for interacting with Keycloak's API to manage authentication and authorization. ArchiPy offers both synchronous and asynchronous implementations.</p> <p>For full API reference, see the Keycloak Adapters API Documentation.</p>"},{"location":"examples/adapters/keycloak/#configuration","title":"Configuration","text":"<p>First, configure your Keycloak settings in your application config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.config_template import KeycloakConfig\n\nclass AppConfig(BaseConfig):\n    # Keycloak configuration\n    KEYCLOAK = KeycloakConfig(\n        SERVER_URL=\"https://keycloak.example.com\",\n        REALM_NAME=\"my-realm\",\n        CLIENT_ID=\"my-client\",\n        CLIENT_SECRET_KEY=\"client-secret\",  # Optional, required for admin operations\n        VERIFY_SSL=True,\n        TIMEOUT=10\n    )\n</code></pre>"},{"location":"examples/adapters/keycloak/#synchronous-adapter","title":"Synchronous Adapter","text":"<p>The synchronous adapter provides a blocking API for Keycloak operations.</p> <pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Using global configuration\nkeycloak = KeycloakAdapter()\n\n# Or with custom configuration\ncustom_config = KeycloakConfig(\n    SERVER_URL=\"https://keycloak.example.com\",\n    REALM_NAME=\"another-realm\",\n    CLIENT_ID=\"another-client\",\n    CLIENT_SECRET_KEY=\"client-secret\"\n)\nkeycloak = KeycloakAdapter(custom_config)\n\n# Authentication\ntry:\n    # Get token with username/password\n    token = keycloak.get_token(\"username\", \"password\")\n    access_token = token[\"access_token\"]\n    refresh_token = token[\"refresh_token\"]\n\n    # Refresh an existing token\n    new_token = keycloak.refresh_token(refresh_token)\n\n    # Validate a token\n    is_valid = keycloak.validate_token(access_token)\n\n    # Get user info from token\n    user_info = keycloak.get_userinfo(access_token)\n\n    # Get token using client credentials\n    client_token = keycloak.get_client_credentials_token()\n\n    # Logout (invalidate refresh token)\n    keycloak.logout(refresh_token)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# User operations (requires admin privileges)\ntry:\n    # Get user by ID\n    user = keycloak.get_user_by_id(\"user-uuid\")\n\n    # Get user by username\n    user = keycloak.get_user_by_username(\"johndoe\")\n\n    # Get user by email\n    user = keycloak.get_user_by_email(\"john@example.com\")\n\n    # Create a new user\n    user_data = {\n        \"username\": \"newuser\",\n        \"email\": \"newuser@example.com\",\n        \"enabled\": True,\n        \"firstName\": \"New\",\n        \"lastName\": \"User\",\n        \"credentials\": [{\n            \"type\": \"password\",\n            \"value\": \"initial-password\",\n            \"temporary\": True\n        }]\n    }\n    user_id = keycloak.create_user(user_data)\n\n    # Update a user\n    update_data = {\"firstName\": \"Updated\", \"email\": \"updated@example.com\"}\n    keycloak.update_user(user_id, update_data)\n\n    # Reset password\n    keycloak.reset_password(user_id, \"new-password\", temporary=True)\n\n    # Search for users\n    users = keycloak.search_users(\"john\", max_results=10)\n\n    # Clear all user sessions\n    keycloak.clear_user_sessions(user_id)\n\n    # Delete a user\n    keycloak.delete_user(user_id)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Role operations\ntry:\n    # Get user roles\n    roles = keycloak.get_user_roles(user_id)\n\n    # Get client roles for user\n    client_roles = keycloak.get_client_roles_for_user(user_id, \"client-id\")\n\n    # Check if user has role\n    has_role = keycloak.has_role(access_token, \"admin\")\n\n    # Check if user has any of the specified roles\n    has_any = keycloak.has_any_of_roles(access_token, {\"admin\", \"manager\"})\n\n    # Check if user has all specified roles\n    has_all = keycloak.has_all_roles(access_token, {\"user\", \"viewer\"})\n\n    # Assign realm role\n    keycloak.assign_realm_role(user_id, \"admin\")\n\n    # Remove realm role\n    keycloak.remove_realm_role(user_id, \"admin\")\n\n    # Assign client role\n    keycloak.assign_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Remove client role\n    keycloak.remove_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Get realm roles\n    all_roles = keycloak.get_realm_roles()\n\n    # Get a specific realm role\n    role = keycloak.get_realm_role(\"admin\")\n\n    # Create a realm role\n    new_role = keycloak.create_realm_role(\"new-role\", \"A new role description\")\n\n    # Delete a realm role\n    keycloak.delete_realm_role(\"new-role\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Client operations\ntry:\n    # Get client ID from name\n    client_id = keycloak.get_client_id(\"client-name\")\n\n    # Get client secret\n    secret = keycloak.get_client_secret(client_id)\n\n    # Get service account ID\n    service_account_id = keycloak.get_service_account_id()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# System operations\ntry:\n    # Get public key for token verification\n    public_key = keycloak.get_public_key()\n\n    # Get well-known OpenID configuration\n    config = keycloak.get_well_known_config()\n\n    # Get JWT certificates\n    certs = keycloak.get_certs()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Authorization\ntry:\n    # Exchange authorization code for token\n    token = keycloak.get_token_from_code(\"auth-code\", \"https://my-app.example.com/callback\")\n\n    # Check permissions\n    has_permission = keycloak.check_permissions(access_token, \"resource-name\", \"view\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n</code></pre>"},{"location":"examples/adapters/keycloak/#asynchronous-adapter","title":"Asynchronous Adapter","text":"<p>The asynchronous adapter provides a non-blocking API using <code>async/await</code> syntax:</p> <pre><code>import asyncio\nfrom archipy.adapters.keycloak.adapters import AsyncKeycloakAdapter\n\nasync def main():\n    # Initialize with global config\n    keycloak = AsyncKeycloakAdapter()\n\n    try:\n        # Get token\n        token = await keycloak.get_token(\"username\", \"password\")\n        access_token = token[\"access_token\"]\n\n        # Get user info\n        user_info = await keycloak.get_userinfo(access_token)\n        print(f\"Logged in as: {user_info.get('preferred_username')}\")\n\n        # Check if user has role\n        if await keycloak.has_role(access_token, \"admin\"):\n            print(\"User has admin role\")\n\n        # Search for users\n        users = await keycloak.search_users(\"john\")\n        print(f\"Found {len(users)} users matching 'john'\")\n\n        # Create a new user\n        user_data = {\n            \"username\": \"async_user\",\n            \"email\": \"async@example.com\",\n            \"enabled\": True,\n        }\n        user_id = await keycloak.create_user(user_data)\n        print(f\"Created user with ID: {user_id}\")\n\n        # Delete the user\n        await keycloak.delete_user(user_id)\n    except ValueError as e:\n        print(f\"Keycloak error: {e}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/keycloak/#caching","title":"Caching","text":"<p>Both adapters use TTL (Time-To-Live) caching for appropriate operations to improve performance. Cache durations are configured for each method based on how frequently the data typically changes:</p> <ul> <li>Public keys and certificate information: 1 hour</li> <li>User information from tokens: 30 seconds</li> <li>User details and role information: 5 minutes</li> </ul> <p>You can clear all caches if needed:</p> <pre><code># Sync adapter\nkeycloak = KeycloakAdapter()\nkeycloak.clear_all_caches()\n\n# Async adapter\nasync_keycloak = AsyncKeycloakAdapter()\nasync_keycloak.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/keycloak/#security-considerations","title":"Security Considerations","text":"<ul> <li>Token validation is performed without caching to ensure security.</li> <li>The adapter automatically refreshes admin tokens before they expire.</li> <li>Write operations (like user creation/updates) automatically clear relevant caches.</li> <li>For production use, prefer the authorization code flow over direct username/password authentication.</li> </ul>"},{"location":"examples/adapters/minio/","title":"Minio Adapter","text":"<p>The Minio adapter provides a clean interface for interacting with MinIO and S3-compatible object storage services.</p>"},{"location":"examples/adapters/minio/#features","title":"Features","text":"<ul> <li>Bucket operations (create, list, delete)</li> <li>Object operations (upload, download, delete)</li> <li>Presigned URL generation</li> <li>Bucket policy management</li> <li>Built-in caching for performance optimization</li> <li>Comprehensive error handling with domain-specific exceptions</li> </ul>"},{"location":"examples/adapters/minio/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/minio/#configuration","title":"Configuration","text":"<p>Configure MinIO in your application's config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Method 1: Using environment variables\n# MINIO__ENDPOINT=localhost:9000\n# MINIO__ACCESS_KEY=minioadmin\n# MINIO__SECRET_KEY=minioadmin\n\n# Method 2: Direct configuration\nBaseConfig.global_config().MINIO.ENDPOINT = \"localhost:9000\"\nBaseConfig.global_config().MINIO.ACCESS_KEY = \"minioadmin\"\nBaseConfig.global_config().MINIO.SECRET_KEY = \"minioadmin\"\nBaseConfig.global_config().MINIO.SECURE = False  # Set to True for HTTPS\n</code></pre>"},{"location":"examples/adapters/minio/#initializing-the-adapter","title":"Initializing the Adapter","text":"<pre><code>from archipy.adapters.minio.adapters import MinioAdapter\n\n# Use global configuration\nminio = MinioAdapter()\n\n# Or provide specific configuration\nfrom archipy.configs.config_template import MinioConfig\n\ncustom_config = MinioConfig(\n    ENDPOINT=\"play.min.io:9000\",\n    ACCESS_KEY=\"your-access-key\",\n    SECRET_KEY=\"your-secret-key\",\n    SECURE=True\n)\nminio = MinioAdapter(custom_config)\n</code></pre>"},{"location":"examples/adapters/minio/#bucket-operations","title":"Bucket Operations","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Check if bucket exists\nif not minio.bucket_exists(\"my-bucket\"):\n    # Create bucket\n    minio.make_bucket(\"my-bucket\")\n    logger.info(\"Bucket created successfully\")\n\n# List all buckets\nbuckets = minio.list_buckets()\nfor bucket in buckets:\n    logger.info(f\"Bucket: {bucket['name']}, Created: {bucket['creation_date']}\")\n\n# Remove bucket\nminio.remove_bucket(\"my-bucket\")\n</code></pre>"},{"location":"examples/adapters/minio/#working-with-objects","title":"Working with Objects","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Upload a file\nminio.put_object(\"my-bucket\", \"document.pdf\", \"/path/to/local/document.pdf\")\n\n# Download an object\nminio.get_object(\"my-bucket\", \"document.pdf\", \"/path/to/download/document.pdf\")\n\n# List objects in a bucket\nobjects = minio.list_objects(\"my-bucket\", prefix=\"documents/\", recursive=True)\nfor obj in objects:\n    logger.info(f\"Object: {obj['object_name']}, Size: {obj['size']} bytes\")\n\n# Get object metadata\nmetadata = minio.stat_object(\"my-bucket\", \"document.pdf\")\nlogger.info(f\"Content type: {metadata['content_type']}\")\nlogger.info(f\"Last modified: {metadata['last_modified']}\")\n\n# Remove an object\nminio.remove_object(\"my-bucket\", \"document.pdf\")\n</code></pre>"},{"location":"examples/adapters/minio/#generating-presigned-urls","title":"Generating Presigned URLs","text":"<pre><code>import logging\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Generate a presigned URL for downloading (valid for 1 hour by default)\ndownload_url = minio.presigned_get_object(\"my-bucket\", \"document.pdf\")\nlogger.info(f\"Download URL: {download_url}\")\n\n# Generate a presigned URL for uploading (with custom expiry time in seconds)\nupload_url = minio.presigned_put_object(\"my-bucket\", \"new-document.pdf\", expires=7200)  # 2 hours\nlogger.info(f\"Upload URL: {upload_url}\")\n</code></pre>"},{"location":"examples/adapters/minio/#managing-bucket-policies","title":"Managing Bucket Policies","text":"<pre><code>import logging\nimport json\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Set a read-only policy for a bucket\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\"AWS\": \"*\"},\n            \"Action\": [\"s3:GetObject\"],\n            \"Resource\": [f\"arn:aws:s3:::my-bucket/*\"]\n        }\n    ]\n}\nminio.set_bucket_policy(\"my-bucket\", json.dumps(policy))\n\n# Get bucket policy\npolicy_info = minio.get_bucket_policy(\"my-bucket\")\nlogger.info(f\"Bucket policy: {policy_info['policy']}\")\n</code></pre>"},{"location":"examples/adapters/minio/#error-handling","title":"Error Handling","text":"<p>The MinioAdapter uses ArchiPy's domain-specific exceptions for consistent error handling:</p> <pre><code>import logging\nfrom archipy.models.errors import (\n    AlreadyExistsError,\n    InternalError,\n    InvalidArgumentError,\n    NotFoundError,\n    PermissionDeniedError,\n)\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    minio.make_bucket(\"existing-bucket\")\nexcept AlreadyExistsError:\n    logger.warning(\"Bucket already exists\")\nexcept PermissionDeniedError:\n    logger.exception(\"Permission denied to create bucket\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Invalid argument: {e}\")\nexcept InternalError as e:\n    logger.exception(f\"Internal error: {e}\")\n</code></pre>"},{"location":"examples/adapters/minio/#performance-optimization","title":"Performance Optimization","text":"<p>The MinioAdapter includes TTL caching for frequently accessed operations:</p> <pre><code># Check if bucket exists (cached for 5 minutes)\nminio.bucket_exists(\"my-bucket\")\n\n# List buckets (cached for 5 minutes)\nminio.list_buckets()\n\n# Clear all caches if needed\nminio.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/minio/#integration-with-web-applications","title":"Integration with Web Applications","text":""},{"location":"examples/adapters/minio/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, File, UploadFile, HTTPException\nfrom fastapi.responses import RedirectResponse\nimport tempfile\nimport os\n\nfrom archipy.adapters.minio.adapters import MinioAdapter\nfrom archipy.models.errors import NotFoundError, PermissionDeniedError\n\napp = FastAPI()\nminio = MinioAdapter()\n\n@app.post(\"/upload/{bucket_name}\")\nasync def upload_file(bucket_name: str, file: UploadFile):\n    try:\n        # Save uploaded file to temporary location\n        with tempfile.NamedTemporaryFile(delete=False) as temp:\n            content = await file.read()\n            temp.write(content)\n            temp_path = temp.name\n\n        # Upload to MinIO\n        try:\n            minio.put_object(bucket_name, file.filename, temp_path)\n            return {\"message\": f\"File {file.filename} uploaded successfully\"}\n        finally:\n            os.unlink(temp_path)  # Clean up temp file\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/download/{bucket_name}/{object_name}\")\nasync def download_file(bucket_name: str, object_name: str):\n    try:\n        # Generate presigned URL\n        url = minio.presigned_get_object(bucket_name, object_name, expires=3600)\n        return RedirectResponse(url)\n    except NotFoundError:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    except PermissionDeniedError:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"examples/adapters/minio/#testing-with-bdd","title":"Testing with BDD","text":"<p>The Minio adapter comes with BDD tests to verify functionality. Here's a sample feature file:</p> <pre><code>Feature: MinIO Operations Testing\n  As a developer\n  I want to test MinIO storage operations\n  So that I can ensure reliable object storage functionality\n\n  Background:\n    Given a configured MinIO adapter\n\n  Scenario: Create and verify a bucket\n    When I create a bucket named \"test-bucket\"\n    Then the bucket \"test-bucket\" should exist\n    And the bucket list should include \"test-bucket\"\n\n  Scenario: Upload and retrieve object\n    Given a bucket named \"test-bucket\" exists\n    When I upload a file \"test.txt\" with content \"Hello World\" to bucket \"test-bucket\"\n    Then the object \"test.txt\" should exist in bucket \"test-bucket\"\n    And downloading \"test.txt\" from \"test-bucket\" should return content \"Hello World\"\n</code></pre>"},{"location":"examples/adapters/orm/","title":"ORM Adapter Examples","text":"<p>This page demonstrates how to use ArchiPy's ORM adapters with SQLAlchemy.</p>"},{"location":"examples/adapters/orm/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.orm.sqlalchemy import SQLAlchemyAdapter, SQLAlchemySessionManager\n\n# Create session manager\nsession_manager = SQLAlchemySessionManager(connection_string=\"postgresql://user:pass@localhost/db\")\n\n# Create an ORM adapter\norm_adapter = SQLAlchemyAdapter(session_manager=session_manager)\n\n# Use the adapter for database operations\nusers = orm_adapter.query(User).filter(User.active == True).all()\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/adapters/redis/","title":"Redis Adapter Examples","text":"<p>This guide demonstrates how to use the ArchiPy Redis adapter for common caching and key-value storage patterns.</p>"},{"location":"examples/adapters/redis/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/redis/#installation","title":"Installation","text":"<p>First, ensure you have the Redis dependencies installed:</p> <pre><code>pip install \"archipy[redis]\"\n# or\npoetry add \"archipy[redis]\"\n</code></pre>"},{"location":"examples/adapters/redis/#synchronous-redis-adapter","title":"Synchronous Redis Adapter","text":"<pre><code>from archipy.adapters.redis import RedisAdapter\n\n# Create a Redis adapter with connection details\nredis = RedisAdapter(\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,  # Optional\n    ssl=False,      # Optional\n    socket_timeout=5.0  # Optional\n)\n\n# Set and get values\nredis.set(\"user:123:name\", \"John Doe\")\nname = redis.get(\"user:123:name\")\nprint(f\"User name: {name}\")  # Output: User name: John Doe\n\n# Set with expiration (seconds)\nredis.set(\"session:456\", \"active\", ex=3600)  # Expires in 1 hour\n\n# Delete a key\nredis.delete(\"user:123:name\")\n\n# Check if key exists\nif redis.exists(\"session:456\"):\n    print(\"Session exists\")\n</code></pre>"},{"location":"examples/adapters/redis/#asynchronous-redis-adapter","title":"Asynchronous Redis Adapter","text":"<pre><code>import asyncio\nfrom archipy.adapters.redis import AsyncRedisAdapter\n\nasync def main():\n    # Create an async Redis adapter\n    redis = AsyncRedisAdapter(\n        host=\"localhost\",\n        port=6379,\n        db=0\n    )\n\n    # Async operations\n    await redis.set(\"counter\", \"1\")\n    await redis.incr(\"counter\")  # Increment\n    count = await redis.get(\"counter\")\n    print(f\"Counter: {count}\")  # Output: Counter: 2\n\n    # Cleanup\n    await redis.close()\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/redis/#caching-patterns","title":"Caching Patterns","text":""},{"location":"examples/adapters/redis/#function-result-caching","title":"Function Result Caching","text":"<pre><code>import json\nimport time\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\ndef cache_result(key, ttl=300):\n    \"\"\"Decorator to cache function results in Redis.\"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Create a cache key with function name and arguments\n            cache_key = f\"{key}:{func.__name__}:{hash(str(args) + str(kwargs))}\"\n\n            # Try to get from cache\n            cached = redis.get(cache_key)\n            if cached:\n                return json.loads(cached)\n\n            # Execute function and cache result\n            result = func(*args, **kwargs)\n            redis.set(cache_key, json.dumps(result), ex=ttl)\n            return result\n        return wrapper\n    return decorator\n\n# Example usage\n@cache_result(\"api\", ttl=60)\ndef expensive_api_call(item_id):\n    print(\"Executing expensive operation...\")\n    time.sleep(1)  # Simulate expensive operation\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\", \"data\": \"Some data\"}\n\n# First call will execute the function\nresult1 = expensive_api_call(123)\nprint(\"First call:\", result1)\n\n# Second call will retrieve from cache\nresult2 = expensive_api_call(123)\nprint(\"Second call:\", result2)\n</code></pre>"},{"location":"examples/adapters/redis/#mock-redis-for-testing","title":"Mock Redis for Testing","text":"<p>ArchiPy provides a Redis mock for unit testing that doesn't require a real Redis server:</p> <pre><code>import unittest\nfrom archipy.adapters.redis import RedisMock, RedisAdapter\n\nclass UserService:\n    def __init__(self, redis_adapter):\n        self.redis = redis_adapter\n\n    def get_user(self, user_id):\n        cached = self.redis.get(f\"user:{user_id}\")\n        if cached:\n            return cached\n\n        # In real code, we'd fetch from database if not in cache\n        user_data = f\"User {user_id} data\"\n        self.redis.set(f\"user:{user_id}\", user_data, ex=300)\n        return user_data\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self):\n        # Use the RedisMock instead of a real Redis connection\n        self.redis_mock = RedisMock()\n        self.user_service = UserService(self.redis_mock)\n\n    def test_get_user(self):\n        # Test first fetch (not cached)\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"User 123 data\")\n\n        # Test that it was cached\n        self.assertEqual(self.redis_mock.get(\"user:123\"), \"User 123 data\")\n\n        # Change the cached value to test cache hit\n        self.redis_mock.set(\"user:123\", \"Modified data\")\n\n        # Test cached fetch\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"Modified data\")\n\n# Run the test\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre>"},{"location":"examples/adapters/redis/#advanced-redis-features","title":"Advanced Redis Features","text":""},{"location":"examples/adapters/redis/#publishsubscribe","title":"Publish/Subscribe","text":"<pre><code>import threading\nimport time\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n# Subscriber thread\ndef subscribe_thread():\n    subscriber = RedisAdapter(host=\"localhost\", port=6379, db=0)\n    pubsub = subscriber.pubsub()\n\n    def message_handler(message):\n        if message[\"type\"] == \"message\":\n            print(f\"Received message: {message['data']}\")\n\n    pubsub.subscribe(**{\"channel:notifications\": message_handler})\n    pubsub.run_in_thread(sleep_time=0.5)\n\n    # Keep thread running for demo\n    time.sleep(10)\n    pubsub.close()\n\n# Start subscriber in background\nthread = threading.Thread(target=subscribe_thread)\nthread.start()\n\n# Wait for subscriber to initialize\ntime.sleep(1)\n\n# Publish messages\nfor i in range(5):\n    message = f\"Notification {i}\"\n    redis.publish(\"channel:notifications\", message)\n    time.sleep(1)\n\n# Wait for thread to complete\nthread.join()\n</code></pre>"},{"location":"examples/adapters/redis/#pipeline-for-multiple-operations","title":"Pipeline for Multiple Operations","text":"<pre><code>from archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n# Create a pipeline for atomic operations\npipe = redis.pipeline()\npipe.set(\"stats:visits\", 0)\npipe.set(\"stats:unique_users\", 0)\npipe.set(\"stats:conversion_rate\", \"0.0\")\npipe.execute()  # Execute all commands at once\n\n# Increment multiple counters atomically\npipe = redis.pipeline()\npipe.incr(\"stats:visits\")\npipe.incr(\"stats:unique_users\")\nresults = pipe.execute()\nprint(f\"Visits: {results[0]}, Unique users: {results[1]}\")\n</code></pre>"},{"location":"examples/helpers/","title":"Helper Examples","text":"<p>ArchiPy provides a variety of helper utilities to simplify common development tasks.</p>"},{"location":"examples/helpers/#available-helpers","title":"Available Helpers","text":"Helper Type Purpose Example Decorators Function and method enhancements Timing, retry, deprecation Interceptors Communication layer handlers gRPC tracing, rate limiting Metaclasses Custom class behavior Singletons, registries Utils General-purpose utilities Date/time, file, string handlers <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/decorators/","title":"Decorator Examples","text":"<p>This page demonstrates how to use ArchiPy's decorators.</p>"},{"location":"examples/helpers/decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.decorators.timing import timing_decorator\nfrom archipy.helpers.decorators.retry import retry\n\n\n# Measure function execution time\n@timing_decorator\ndef my_function():\n    # Function code\n    pass\n\n\n# Retry function on failure\n@retry(max_attempts=3, delay=1)\ndef external_api_call():\n    # Function that might fail\n    pass\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/interceptors/","title":"Interceptor Examples","text":"<p>This page demonstrates how to use ArchiPy's interceptors.</p>"},{"location":"examples/helpers/interceptors/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.interceptors.grpc.trace import GrpcServerTraceInterceptor\n\n# Create a gRPC server with tracing\ntracer = GrpcServerTraceInterceptor()\nserver = grpc.server(\n    futures.ThreadPoolExecutor(max_workers=10),\n    interceptors=[tracer]\n)\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/metaclasses/","title":"Metaclass Examples","text":"<p>This page demonstrates how to use ArchiPy's metaclasses.</p>"},{"location":"examples/helpers/metaclasses/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.metaclasses.singleton import Singleton\n\n# Create a singleton class\nclass Database(metaclass=Singleton):\n    def __init__(self, connection_string=None):\n        self.connection_string = connection_string\n        # Initialize connection\n\n    def query(self, sql):\n        # Execute query\n        pass\n\n# Usage\ndb1 = Database(\"postgresql://localhost:5432/mydb\")\ndb2 = Database()  # No new instance created\n\nprint(db1 is db2)  # True - same instance\nprint(db2.connection_string)  # \"postgresql://localhost:5432/mydb\"\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/utils/","title":"Utilities","text":"<p>Examples of ArchiPy's utility functions:</p>"},{"location":"examples/helpers/utils/#datetime_utils","title":"datetime_utils","text":"<p>Work with dates and times consistently:</p> <pre><code>from archipy.helpers.utils.datetime_utils import DatetimeUtils\n\n# Get current UTC time\nnow = DatetimeUtils.get_datetime_utc_now()\n\n# Format for storage/transmission\ndate_str = DatetimeUtils.get_string_datetime_from_datetime(now)\n\n# Parse date string\nparsed = DatetimeUtils.get_datetime_from_string_datetime(date_str)\n\n# Convert to Jalali (Persian) calendar\njalali_date = DatetimeUtils.convert_to_jalali(now)\n\n# Check if date is a holiday in Iran\nis_holiday = DatetimeUtils.is_holiday_in_iran(now)\n</code></pre>"},{"location":"examples/helpers/utils/#jwt_utils","title":"jwt_utils","text":"<p>Generate and verify JWT tokens:</p> <pre><code>import logging\nfrom archipy.helpers.utils.jwt_utils import JWTUtils\nfrom uuid import uuid4\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Generate a user access token\nuser_id = uuid4()\naccess_token = JWTUtils.create_access_token(user_id)\n\n# Generate a refresh token with additional claims\nadditional_claims = {\"user_role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\nrefresh_token = JWTUtils.create_refresh_token(user_id, additional_claims=additional_claims)\n\n# Verify a token\ntry:\n    payload = JWTUtils.verify_access_token(access_token)\n    logger.info(f\"Token valid for user: {payload['sub']}\")\nexcept (InvalidTokenError, TokenExpiredError) as e:\n    logger.exception(f\"Invalid token: {e}\")\n\n# Get token expiration time\nexpiry = JWTUtils.get_token_expiry(access_token)\nlogger.debug(f\"Token expires at: {expiry}\")\n\n# Extract user UUID from token payload\nuser_uuid = JWTUtils.extract_user_uuid(payload)\n</code></pre>"},{"location":"examples/helpers/utils/#password_utils","title":"password_utils","text":"<p>Secure password handling:</p> <pre><code>import logging\nfrom archipy.helpers.utils.password_utils import PasswordUtils\nfrom archipy.models.types.language_type import LanguageType\nfrom archipy.models.errors.custom_errors import InvalidPasswordError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Hash a password\npassword = \"SecureP@ssword123\"\nhashed = PasswordUtils.hash_password(password)\n\n# Verify password\nis_valid = PasswordUtils.verify_password(password, hashed)\nlogger.info(f\"Password valid: {is_valid}\")\n\n# Generate a secure password that meets policy requirements\nsecure_password = PasswordUtils.generate_password()\nlogger.info(f\"Generated password: {secure_password}\")\n\n# Validate a password against policy\ntry:\n    PasswordUtils.validate_password(password, lang=LanguageType.EN)\n    logger.info(\"Password meets policy requirements\")\nexcept InvalidPasswordError as e:\n    logger.warning(f\"Invalid password: {e.requirements}\")\n\n# Check password against history\npassword_history = [hashed]  # Previous password hashes\ntry:\n    PasswordUtils.validate_password_history(\"NewSecureP@ssword123\", password_history)\n    logger.info(\"Password not previously used\")\nexcept InvalidPasswordError as e:\n    logger.warning(\"Password has been used recently\")\n</code></pre>"},{"location":"examples/helpers/utils/#file_utils","title":"file_utils","text":"<p>Handle files securely:</p> <pre><code>import logging\nfrom archipy.helpers.utils.file_utils import FileUtils\nfrom archipy.models.errors.custom_errors import InvalidArgumentError, OutOfRangeError\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Create a secure link to a file with expiration\ntry:\n    link = FileUtils.create_secure_link(\"/path/to/document.pdf\", minutes=60)\n    logger.info(f\"Secure link: {link}\")\nexcept (InvalidArgumentError, OutOfRangeError) as e:\n    logger.exception(f\"Error creating link: {e}\")\n\n# Validate file name against allowed extensions\ntry:\n    is_valid = FileUtils.validate_file_name(\"document.pdf\")\n    logger.info(f\"File is valid: {is_valid}\")\nexcept InvalidArgumentError as e:\n    logger.exception(f\"Error validating file: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#base_utils","title":"base_utils","text":"<p>Validate and sanitize data:</p> <pre><code>import logging\nfrom archipy.helpers.utils.base_utils import BaseUtils\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\n# Sanitize phone number\nphone = BaseUtils.sanitize_iranian_landline_or_phone_number(\"+989123456789\")\nlogger.info(f\"Sanitized phone: {phone}\")  # 09123456789\n\n# Validate Iranian national code\ntry:\n    BaseUtils.validate_iranian_national_code_pattern(\"1234567891\")\n    logger.info(\"National code is valid\")\nexcept Exception as e:\n    logger.exception(f\"Invalid national code: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#error_utils","title":"error_utils","text":"<p>Standardized exception handling:</p>"},{"location":"examples/helpers/utils/#app_utils","title":"app_utils","text":"<p>FastAPI application utilities:</p> <pre><code>from archipy.helpers.utils.app_utils import AppUtils, FastAPIUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with standard config\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Add custom exception handlers\nFastAPIUtils.setup_exception_handlers(app)\n\n\n# Set up CORS\nFastAPIUtils.setup_cors(\n    app,\n    allowed_origins=[\"https://example.com\"]\n)\n</code></pre>"},{"location":"examples/helpers/utils/#string_utils","title":"string_utils","text":"<p>String manipulation utilities:</p>"},{"location":"examples/helpers/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Authentication and authorization utilities with Keycloak integration:</p> <pre><code>if __name__ == '__main__':\n    import uvicorn\n    from uuid import UUID\n    from archipy.configs.base_config import BaseConfig\n    from archipy.helpers.utils.app_utils import AppUtils\n    from archipy.helpers.utils.keycloak_utils import KeycloakUtils\n    from archipy.models.types.language_type import LanguageType\n    from fastapi import Depends\n\n    # Initialize your app configuration\n    config = BaseConfig()\n    BaseConfig.set_global(config)\n    app = AppUtils.create_fastapi_app()\n\n    # Resource-based authorization for users with role and admin access\n    @app.get(\"/users/{user_uuid}/info\")\n    def get_user_info(user_uuid: UUID, user: dict = Depends(KeycloakUtils.fastapi_auth(\n        resource_type_param=\"user_uuid\",\n        resource_type=\"users\",\n        required_roles={\"user\"},\n        admin_roles={\"superusers\", \"administrators\"},\n        lang=LanguageType.EN,\n    ))):\n        return {\n            \"message\": f\"User info for {user_uuid}\",\n            \"username\": user.get(\"preferred_username\")\n        }\n\n    # Async version for employees with multiple acceptable roles\n    @app.get(\"/employees/{employee_uuid}/info\")\n    async def get_employee_info(employee_uuid: UUID, employee: dict = Depends(KeycloakUtils.async_fastapi_auth(\n        resource_type_param=\"employee_uuid\",\n        resource_type=\"employees\",\n        required_roles={\"employee\", \"manager\", \"user\"},\n        all_roles_required=False,  # User can have any of these roles\n        admin_roles={\"hr_admins\", \"system_admins\"},\n        lang=LanguageType.FA,\n    ))):\n        return {\n            \"message\": f\"Employee info for {employee_uuid}\",\n            \"username\": employee.get(\"preferred_username\")\n        }\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"examples/helpers/utils/#additional-resources","title":"Additional Resources","text":"<p>For more examples and detailed documentation:</p> <ul> <li>Helpers Overview</li> <li>Utils API Reference</li> <li>Configuration Examples</li> <li>Keycloak Adapter</li> </ul> <p>Note: This page contains examples of using ArchiPy's utility functions. For API details, see the Utils API Reference.</p>"}]}