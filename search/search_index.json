{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ArchiPy","text":"<p>Architecture + Python \u2013 Structured Development Simplified</p> <p>ArchiPy provides a clean architecture framework for Python applications that:</p> <ul> <li>Standardizes configuration management</li> <li>Offers pluggable adapters with testing mocks</li> <li>Enforces consistent data models</li> <li>Promotes maintainable code organization</li> <li>Simplifies testing with BDD support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install using pip\npip install archipy\n\n# Or with poetry\npoetry add archipy\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<p>ArchiPy is a comprehensive framework designed to streamline Python application development through clean architecture principles:</p> <ul> <li>Modular Adapters: Plug-and-play implementations with ready-to-use mocks for databases, Redis, email, and more</li> <li>Robust Configuration: Type-safe configuration management with environment variable support</li> <li>Standardized Models: Consistent data modeling with DTOs, entities, and well-defined types</li> <li>Development Helpers: Decorators, metaclasses, and utilities to accelerate development</li> <li>BDD Testing: Integrated Behave support for behavior-driven development</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>archipy/\n\u2502\n\u251c\u2500\u2500 adapters/          # Interfaces to external systems\n\u251c\u2500\u2500 configs/           # Configuration management\n\u251c\u2500\u2500 helpers/           # Development utilities\n\u2502   \u251c\u2500\u2500 decorators/    # Function/method decorators\n\u2502   \u251c\u2500\u2500 interceptors/  # Communication interceptors\n\u2502   \u251c\u2500\u2500 metaclasses/   # Class creators and modifiers\n\u2502   \u2514\u2500\u2500 utils/         # General-purpose utilities\n\u2514\u2500\u2500 models/            # Domain objects\n    \u251c\u2500\u2500 dtos/          # Data Transfer Objects\n    \u251c\u2500\u2500 entities/      # Business entities\n    \u251c\u2500\u2500 errors/        # Error definitions\n    \u2514\u2500\u2500 types/         # Type definitions\n</code></pre>"},{"location":"architecture/","title":"ArchiPy Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>ArchiPy is organized into four main modules, each serving a specific purpose in creating structured, maintainable Python applications:</p> <ol> <li>Adapters: External service integrations</li> <li>Configs: Configuration management</li> <li>Helpers: Utility functions and support classes</li> <li>Models: Core data structures</li> </ol> <p>This architecture follows clean architecture principles, separating concerns and ensuring that dependencies point inward toward the domain core.</p>"},{"location":"architecture/#modules","title":"Modules","text":""},{"location":"architecture/#adapters","title":"Adapters","text":"<p>The <code>adapters</code> module provides implementations for external service integrations, following the Ports and Adapters pattern (Hexagonal Architecture). This module includes:</p> <ul> <li>Database adapters (SQLAlchemy, Redis)</li> <li>Email service adapters</li> <li>External API clients</li> <li>File storage adapters</li> </ul> <p>Each adapter includes both concrete implementations and corresponding mocks for testing.</p>"},{"location":"architecture/#configs","title":"Configs","text":"<p>The <code>configs</code> module manages configuration loading, validation, and injection. It provides:</p> <ul> <li>Environment-based configuration</li> <li>Type-safe configuration through Pydantic models</li> <li>Centralized access to configuration values</li> <li>Support for various configuration sources (environment variables, files, etc.)</li> </ul>"},{"location":"architecture/#helpers","title":"Helpers","text":"<p>The <code>helpers</code> module contains utility functions and classes to simplify common development tasks. It includes several subgroups:</p> <ul> <li>Utils: General utility functions for dates, strings, errors, files, etc.</li> <li>Decorators: Function and class decorators for aspects like logging, timing, and deprecation</li> <li>Interceptors: Classes for cross-cutting concerns like logging, tracing, and validation</li> <li>Validators: Data validation utilities</li> </ul>"},{"location":"architecture/#models","title":"Models","text":"<p>The <code>models</code> module defines the core data structures used throughout the application:</p> <ul> <li>Entities: Domain model objects</li> <li>DTOs: Data Transfer Objects for API input/output</li> <li>Errors: Custom exception classes</li> <li>Types: Type definitions and enumerations</li> </ul>"},{"location":"architecture/#architectural-flow","title":"Architectural Flow","text":"<p>ArchiPy applications follow a clean architecture approach where:</p> <ol> <li>The Models module forms the core domain layer</li> <li>The Helpers module provides supporting functionality</li> <li>The Configs module manages application configuration</li> <li>The Adapters module interfaces with external systems</li> </ol> <p>This modular organization promotes separation of concerns, making ArchiPy applications easier to test, maintain, and extend over time.</p>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":"<p>ArchiPy is designed to standardize and simplify Python application development by providing a flexible set of building blocks that work across different architectural approaches. Rather than enforcing a single architectural pattern, ArchiPy offers components that can be applied to:</p> <ul> <li>Layered Architecture</li> <li>Hexagonal Architecture (Ports &amp; Adapters)</li> <li>Clean Architecture</li> <li>Domain-Driven Design</li> <li>Service-Oriented Architecture</li> <li>And more...</li> </ul> <p>These building blocks help maintain consistency, testability, and maintainability regardless of the specific architectural style chosen for your project.</p>"},{"location":"architecture/#core-building-blocks","title":"Core Building Blocks","text":""},{"location":"architecture/#configuration-management","title":"Configuration Management","text":"<p>ArchiPy provides a standardized way to manage configuration across your application:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    DATABASE = {\n        \"HOST\": \"localhost\",\n        \"PORT\": 5432,\n        \"USERNAME\": \"user\",\n        \"PASSWORD\": \"password\"\n    }\n\n    DEBUG = True\n\n# Set global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"architecture/#adapters-ports","title":"Adapters &amp; Ports","text":"<p>ArchiPy implements the ports and adapters pattern to isolate the application core from external dependencies:</p> <pre><code># Port: defines an interface (contract)\nfrom typing import Protocol\n\nclass UserRepositoryPort(Protocol):\n    def get_by_id(self, user_id: str) -&gt; User: ...\n    def create(self, user: User) -&gt; User: ...\n\n# Adapter: implements the interface for a specific technology\nclass SqlAlchemyUserRepository:\n    def __init__(self, db_adapter: SqlAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n# Application core uses the port, not the adapter\nclass UserService:\n    def __init__(self, repository: UserRepositoryPort):\n        self.repository = repository\n\n    def get_user(self, user_id: str) -&gt; User:\n        return self.repository.get_by_id(user_id)\n</code></pre>"},{"location":"architecture/#entity-models","title":"Entity Models","text":"<p>Standardized entity models provide a consistent approach to domain modeling:</p> <pre><code>from sqlalchemy import Column, String\nfrom archipy.models.entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    name = Column(String(100))\n    email = Column(String(255), unique=True)\n</code></pre>"},{"location":"architecture/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>Define consistent data structures for transferring data between layers:</p> <pre><code>from pydantic import BaseModel, EmailStr\nfrom archipy.models.dtos import BaseDTO\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: EmailStr\n\nclass UserResponseDTO(BaseDTO):\n    id: str\n    name: str\n    email: EmailStr\n    created_at: datetime\n</code></pre>"},{"location":"architecture/#example-architectures","title":"Example Architectures","text":""},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":"<p>ArchiPy can be used with a traditional layered architecture approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Presentation      \u2502  API, UI, CLI\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     Application       \u2502  Services, Workflows\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Domain          \u2502  Business Logic, Entities\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Infrastructure     \u2502  Adapters, Repositories, External Services\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#clean-architecture","title":"Clean Architecture","text":"<p>ArchiPy supports Clean Architecture principles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Entities                    \u2502\n\u2502     Domain models, business rules            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                  Use Cases                   \u2502\n\u2502     Application services, business workflows \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 Interfaces                   \u2502\n\u2502     Controllers, presenters, gateways        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                Frameworks                    \u2502\n\u2502     External libraries, UI, DB, devices      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#hexagonal-architecture","title":"Hexagonal Architecture","text":"<p>For projects using a Hexagonal (Ports &amp; Adapters) approach:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                   \u2502\n\u2502                 Application Core                  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2502           Domain Logic / Models             \u2502  \u2502\n\u2502  \u2502                                             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502  Input      \u2502         \u2502  Output Ports       \u2502  \u2502\n\u2502  \u2502  Ports      \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2502             \u2502         \u2502                     \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25b2                           \u25b2\n        \u2502                           \u2502\n        \u2502                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  \u2502      \u2502                     \u2502\n\u2502  Input Adapters  \u2502      \u2502  Output Adapters    \u2502\n\u2502  (Controllers)   \u2502      \u2502  (Repositories,     \u2502\n\u2502                  \u2502      \u2502   Clients, etc.)    \u2502\n\u2502                  \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#practical-implementation","title":"Practical Implementation","text":"<p>Let's see how a complete application might be structured using ArchiPy:</p> <pre><code>my_app/\n\u251c\u2500\u2500 configs/\n\u2502   \u2514\u2500\u2500 app_config.py          # Application configuration\n\u251c\u2500\u2500 adapters/\n\u2502   \u251c\u2500\u2500 db/                    # Database adapters\n\u2502   \u2514\u2500\u2500 api/                   # API adapters\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 models/                # Domain models\n\u2502   \u251c\u2500\u2500 ports/                 # Interface definitions\n\u2502   \u2514\u2500\u2500 services/              # Business logic\n\u251c\u2500\u2500 repositories/              # Data access\n\u251c\u2500\u2500 api/                       # API routes\n\u2514\u2500\u2500 main.py                    # Application entry point\n</code></pre>"},{"location":"architecture/#code-example","title":"Code Example","text":"<p>Here's how you might structure a FastAPI application using ArchiPy:</p> <pre><code># adapters/db/user_repository.py\nfrom archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyAdapter\nfrom core.models.user import User\n\n\nclass UserRepository:\n    def __init__(self, db_adapter: SqlAlchemyAdapter):\n        self.db_adapter = db_adapter\n\n    def get_user_by_id(self, user_id: str) -&gt; User:\n        return self.db_adapter.get_by_uuid(User, user_id)\n\n    def create_user(self, user: User) -&gt; User:\n        return self.db_adapter.create(user)\n\n\n# core/services/user_service.py\nfrom core.models.user import User\nfrom adapters.db.user_repository import UserRepository\n\n\nclass UserService:\n    def __init__(self, user_repository: UserRepository):\n        self.user_repository = user_repository\n\n    def register_user(self, name: str, email: str) -&gt; User:\n        # Business logic and validation here\n        user = User(name=name, email=email)\n        return self.user_repository.create_user(user)\n\n\n# api/users.py\nfrom fastapi import APIRouter, Depends\nfrom core.services.user_service import UserService\nfrom archipy.models.dtos import BaseDTO\n\nrouter = APIRouter()\n\n\nclass UserCreateDTO(BaseDTO):\n    name: str\n    email: str\n\n\n@router.post(\"/users/\")\ndef create_user(\n        data: UserCreateDTO,\n        user_service: UserService = Depends(get_user_service)\n):\n    user = user_service.register_user(data.name, data.email)\n    return {\"id\": str(user.test_uuid), \"name\": user.name, \"email\": user.email}\n\n\n# main.py\nfrom fastapi import FastAPI\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\napp.include_router(users_router)\n</code></pre> <p>By providing standardized building blocks rather than enforcing a specific architecture, ArchiPy helps teams maintain consistent development practices while allowing flexibility to choose the architectural pattern that best fits their needs.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to ArchiPy will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial project structure</li> <li>Core functionality for adapters, ports, and models</li> <li>SQLAlchemy integration</li> <li>Redis integration</li> <li>Email integration</li> <li>gRPC integration</li> <li>FastAPI integration</li> <li>Comprehensive error handling</li> <li>Utility classes and functions</li> <li>Configuration templates</li> <li>Testing framework</li> <li>Documentation</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>None</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>None</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>None</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>None</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>None</li> </ul>"},{"location":"changelog/#010-2024-02-25","title":"[0.1.0] - 2024-02-25","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"contributing-docs/","title":"ArchiPy Documentation","text":"<p>This directory contains the MkDocs-based documentation for ArchiPy.</p>"},{"location":"contributing-docs/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - Main configuration file for MkDocs</li> <li><code>docs/</code> - Markdown documentation files</li> <li><code>index.md</code> - Home page</li> <li><code>api_reference/</code> - API documentation</li> <li><code>examples/</code> - Usage examples</li> <li><code>assets/</code> - Images and other static assets</li> </ul>"},{"location":"contributing-docs/#converting-from-sphinx-to-mkdocs","title":"Converting from Sphinx to MkDocs","text":"<p>The documentation is being migrated from Sphinx (RST) to MkDocs (Markdown). To help with this process:</p> <ol> <li> <p>Run the conversion script:    <pre><code>python scripts/convert_docs.py\n</code></pre>    This script uses <code>pandoc</code> to convert RST files to Markdown.</p> </li> <li> <p>Manually review and improve the converted files.</p> </li> <li> <p>Preview the documentation:    <pre><code>make docs-serve\n</code></pre></p> </li> <li> <p>Build the documentation:    <pre><code>make docs-build\n</code></pre></p> </li> <li> <p>Deploy to GitHub Pages:    <pre><code>make docs-deploy\n</code></pre></p> </li> </ol>"},{"location":"contributing-docs/#writing-documentation-guidelines","title":"Writing Documentation Guidelines","text":"<ul> <li>Use Markdown syntax for all documentation files</li> <li>Follow the Google Python style for code examples</li> <li>Include type hints in code samples</li> <li>Group related documentation in directories</li> <li>Link between documentation pages using relative links</li> <li>Add admonitions (notes, warnings, tips) using the Material for MkDocs syntax:   <pre><code>!!! note\n    This is a note.\n</code></pre></li> </ul>"},{"location":"contributing-docs/#improving-documentation","title":"Improving Documentation","text":"<p>When improving the documentation:</p> <ol> <li>Focus on clarity and conciseness</li> <li>Include practical, runnable examples</li> <li>Explain \"why\" not just \"how\"</li> <li>Keep navigation logical and intuitive</li> <li>Use diagrams for complex concepts</li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>Welcome to ArchiPy! We're excited that you're interested in contributing. This document outlines the process for contributing to ArchiPy.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository</li> </ol> <p>Fork the ArchiPy repository on GitHub.</p> <ol> <li>Clone Your Fork</li> </ol> <pre><code>git clone https://github.com/YOUR-USERNAME/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Set Up Development Environment</li> </ol> <pre><code>make setup\nmake install\nmake install-dev\npoetry run pre-commit install\n</code></pre> <ol> <li>Create a Branch</li> </ol> <p>Create a branch for your feature or bugfix:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>ArchiPy follows a strict code style to maintain consistency across the codebase:</p> <ul> <li>Black: For code formatting</li> <li>Ruff: For linting</li> <li>Mypy: For type checking</li> </ul> <p>All code must pass these checks before being merged:</p> <pre><code>make check\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All contributions should include appropriate tests:</p> <ul> <li>Unit Tests: For testing individual components</li> <li>Integration Tests: For testing component interactions</li> <li>BDD Tests: For behavior-driven development</li> </ul> <p>Run the tests to ensure your changes don't break existing functionality:</p> <pre><code>make test\nmake behave\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All new features or changes should be documented:</p> <ul> <li>Docstrings: Update or add docstrings to document functions, classes, and methods</li> <li>Type Annotations: Include type annotations for all functions and methods</li> <li>Documentation Files: Update relevant documentation files if necessary</li> </ul> <p>Building the documentation locally:</p> <pre><code>cd docs\nmake html\n</code></pre>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>ArchiPy follows the Conventional Commits specification for commit messages:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre> <p>Common types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Formatting changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or modifying tests</li> <li><code>chore</code>: Maintenance tasks</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update Your Branch</li> </ol> <p>Before submitting a pull request, make sure your branch is up to date with the main branch:</p> <pre><code>git checkout main\ngit pull origin main\ngit checkout your-branch\ngit rebase main\n</code></pre> <ol> <li>Run All Checks</li> </ol> <p>Ensure all checks pass:</p> <pre><code>make check\nmake test\n</code></pre> <ol> <li>Submit Your Pull Request</li> </ol> <p>Push your branch to your fork and create a pull request:</p> <pre><code>git push origin your-branch\n</code></pre> <ol> <li>Code Review</li> </ol> <p>Your pull request will be reviewed by the maintainers. They may suggest changes or improvements.</p> <ol> <li>Merge</li> </ol> <p>Once your pull request is approved, it will be merged into the main branch.</p>"},{"location":"contributing/#bug-reports-and-feature-requests","title":"Bug Reports and Feature Requests","text":"<p>If you find a bug or have a feature request, please create an issue on the GitHub issues page.</p> <p>When reporting a bug, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the bug</li> <li>Steps to reproduce the bug</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Any relevant logs or error messages</li> </ul> <p>When submitting a feature request, please include:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the feature</li> <li>Any relevant use cases</li> <li>If possible, a sketch of how the feature might be implemented</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that ArchiPy has a code of conduct. By participating in this project, you agree to abide by its terms.</p>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Thank you for contributing to ArchiPy! Your efforts help make the project better for everyone.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#development-environment","title":"Development Environment","text":""},{"location":"development/#set-up","title":"Set Up","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n</code></pre> <ol> <li>Initialize the project:</li> </ol> <pre><code>make setup\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>make install\nmake install-dev  # For dev tools\npoetry run pre-commit install\n</code></pre>"},{"location":"development/#workflow","title":"Workflow","text":""},{"location":"development/#code-quality","title":"Code Quality","text":"<p>Run checks:</p> <pre><code>make check  # Runs ruff, black, mypy\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>Run tests:</p> <pre><code>make behave    # BDD tests\nmake ci        # Full pipeline\n</code></pre> <p>BDD tests use <code>behave</code> with feature files in <code>features/</code> and steps in <code>features/steps/</code>.</p>"},{"location":"development/#versioning","title":"Versioning","text":"<p>Follow Semantic Versioning:</p> <pre><code>make bump-patch  # Bug fixes\nmake bump-minor  # New features\nmake bump-major  # Breaking changes\n</code></pre> <p>Add a message:</p> <pre><code>make bump-minor message=\"Added new utility\"\n</code></pre>"},{"location":"development/#build-docs","title":"Build &amp; Docs","text":"<p>Build the package:</p> <pre><code>make build\nmake clean  # Remove artifacts\n</code></pre> <p>Build docs:</p> <pre><code>cd docs\nmake html\n</code></pre> <p>Update dependencies:</p> <pre><code>make update\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>ArchiPy provides a robust framework for structured Python development, focusing on standardization, testability, and productivity.</p>"},{"location":"features/#configuration-management","title":"Configuration Management","text":"<ul> <li>Standardized Configs: Use <code>base_config</code> and <code>config_template</code> for consistent setup.</li> <li>Injection: Seamlessly inject configurations into components.</li> </ul>"},{"location":"features/#adapters-mocks","title":"Adapters &amp; Mocks","text":"<ul> <li>Common Adapters: Pre-built for Redis, SQLAlchemy, and email.</li> <li>Mocks: Testable mocks (e.g., <code>redis_mocks</code>, <code>sqlalchemy_mocks</code>) for isolated testing.</li> <li>Async Support: Synchronous and asynchronous implementations.</li> </ul>"},{"location":"features/#data-standardization","title":"Data Standardization","text":"<ul> <li>Base Entities: Standardized SQLAlchemy entities (<code>base_entities.py</code>).</li> <li>DTOs: Pydantic-based DTOs (e.g., <code>pagination_dto</code>, <code>error_dto</code>).</li> <li>Type Safety: Enforced via <code>pydantic</code> and <code>mypy</code>.</li> </ul>"},{"location":"features/#helper-utilities","title":"Helper Utilities","text":"<ul> <li>Utilities: Tools like <code>datetime_utils</code>, <code>jwt_utils</code>, <code>password_utils</code>.</li> <li>Decorators: <code>retry</code>, <code>singleton</code>, <code>sqlalchemy_atomic</code>, etc.</li> <li>Interceptors: Rate limiting (FastAPI), tracing (gRPC).</li> </ul>"},{"location":"features/#bdd-testing","title":"BDD Testing","text":"<ul> <li>Behave Integration: Pre-configured for sync/async scenarios.</li> <li>Feature Files: Examples like <code>app_utils.feature</code>, <code>totp_utils.feature</code>.</li> <li>Step Definitions: Comprehensive steps for testing (e.g., <code>jwt_utils_steps.py</code>).</li> </ul>"},{"location":"features/#best-practices-tooling","title":"Best Practices &amp; Tooling","text":"<ul> <li>Poetry: Dependency management for reproducible builds.</li> <li>Pre-commit: Automated checks with <code>ruff</code>, <code>black</code>, and <code>mypy</code>.</li> <li>Structure: Clean architecture with <code>pyproject.toml</code> for modern Python development.</li> </ul>"},{"location":"features/#modular-design","title":"Modular Design","text":"<ul> <li>Optional Dependencies: Install only what you need (e.g., <code>archipy[redis]</code>).</li> <li>Extensible: Add custom adapters and helpers easily.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li> <p>Python 3.13 or higher</p> <p>ArchiPy requires Python 3.13+. Check your version with:</p> <pre><code>python --version\n</code></pre> <p>If needed, download Python 3.13+.</p> </li> <li> <p>Poetry (for dependency management)</p> <p>Poetry manages dependencies and project setup. Install it via the official guide.</p> </li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>Install the core library:</p> <pre><code>pip install archipy\n</code></pre> <p>With optional dependencies (e.g., Redis, FastAPI):</p> <pre><code>pip install archipy[redis,fastapi]\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using Poetry","text":"<p>Add the core library:</p> <pre><code>poetry add archipy\n</code></pre> <p>With optional dependencies:</p> <pre><code>poetry add \"archipy[redis,fastapi]\"\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>ArchiPy supports modular features:</p> Feature Installation Command Redis <code>archipy[redis]</code> FastAPI <code>archipy[fastapi]</code> JWT <code>archipy[jwt]</code> Kavenegar <code>archipy[kavenegar]</code> Prometheus <code>archipy[prometheus]</code> Sentry <code>archipy[sentry]</code> Dependency Injection <code>archipy[dependency-injection]</code> Scheduler <code>archipy[scheduler]</code> gRPC <code>archipy[grpc]</code> PostgreSQL <code>archipy[postgres]</code> FakeRedis <code>archipy[fakeredis]</code> Full list See Usage section"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributors:</p> <pre><code># Clone the repository\ngit clone https://github.com/SyntaxArc/ArchiPy.git\ncd ArchiPy\n\n# Set up the project\nmake setup\n\n# Install dependencies\nmake install\n\n# Optional: Install dev tools\nmake install-dev\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If issues arise, verify:</p> <ol> <li>Python version is 3.13+</li> <li><code>pip</code> or <code>poetry</code> is updated (e.g., <code>pip install --upgrade pip</code>)</li> <li>Build tools (<code>setuptools</code>, <code>wheel</code>) are installed</li> </ol> <p>IDE Integration</p> <p>For the best development experience, use an IDE that supports Python type hints, such as PyCharm or VS Code with the Python extension.</p>"},{"location":"license/","title":"License","text":"<p>ArchiPy is licensed under the terms of the license file included in the repository.</p> <p>For more details, see the LICENSE file.</p>"},{"location":"usage/","title":"Getting Started","text":"<p>This guide will help you start building applications with ArchiPy.</p>"},{"location":"usage/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, initialize your application with a configuration:</li> </ol> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    # Custom configuration\n    pass\n\n# Set as global config\nconfig = AppConfig()\nBaseConfig.set_global(config)\n</code></pre> <ol> <li>Define your domain models:</li> </ol> <pre><code>from uuid import uuid4\nfrom sqlalchemy import Column, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom archipy.models.entities import BaseEntity\n\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n\n    username = Column(String(100), unique=True)\n    email = Column(String(255), unique=True)\n\n    # Relationships\n    posts = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(BaseEntity):\n    __tablename__ = \"posts\"\n\n    title = Column(String(255))\n    content = Column(String(1000))\n\n    # Foreign keys\n    author_id = Column(UUID, ForeignKey(\"users.test_uuid\"))\n\n    # Relationships\n    author = relationship(\"User\", back_populates=\"posts\")\n</code></pre> <ol> <li>Set up your database adapter:</li> </ol> <pre><code>from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\nfrom archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyAdapter\n\n# Create session manager\nsession_manager = SessionManagerAdapter()\n\n# Create adapter\ndb_adapter = SqlAlchemyAdapter(session_manager)\n\n# Create tables (development only)\nBaseEntity.metadata.create_all(session_manager.engine)\n</code></pre> <ol> <li>Implement your repositories:</li> </ol> <pre><code>from sqlalchemy import select\n\nclass UserRepository:\n    def __init__(self, db_adapter):\n        self.db_adapter = db_adapter\n\n    def create(self, username, email):\n        user = User(test_uuid=uuid4(), username=username, email=email)\n        return self.db_adapter.create(user)\n\n    def get_by_username(self, username):\n        query = select(User).where(User.username == username)\n        users, _ = self.db_adapter.execute_search_query(User, query)\n        return users[0] if users else None\n</code></pre> <ol> <li>Implement your business logic:</li> </ol> <pre><code>class UserService:\n    def __init__(self, user_repository):\n        self.user_repository = user_repository\n\n    def register_user(self, username, email):\n        # Business logic here (validation, etc.)\n        return self.user_repository.create(username, email)\n</code></pre>"},{"location":"usage/#working-with-redis","title":"Working with Redis","text":"<p>For caching or other Redis operations:</p> <pre><code>from archipy.adapters.redis.adapters import RedisAdapter\n\n# Create Redis adapter\nredis_adapter = RedisAdapter()\n\n\n# Cache user data\ndef cache_user(user):\n    user_data = {\n        \"username\": user.username,\n        \"email\": user.email\n    }\n    redis_adapter.set(f\"user:{user.test_uuid}\", json.dumps(user_data), ex=3600)\n\n\n# Get cached user\ndef get_cached_user(user_id):\n    data = redis_adapter.get(f\"user:{user_id}\")\n    return json.loads(data) if data else None\n</code></pre>"},{"location":"usage/#working-with-fastapi","title":"Working with FastAPI","text":"<p>Integrate with FastAPI:</p> <pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom archipy.helpers.utils.app_utils import AppUtils\n\n# Create FastAPI app\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Create dependencies\ndef get_user_service():\n    user_repo = UserRepository(db_adapter)\n    return UserService(user_repo)\n\n# Define routes\n@app.post(\"/users/\")\ndef create_user(username: str, email: str, service: UserService = Depends(get_user_service)):\n    try:\n        user = service.register_user(username, email)\n        return {\"id\": str(user.test_uuid), \"username\": user.username}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n</code></pre>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#configuration-management","title":"Configuration Management","text":"<p>Standardize and inject configurations:</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\n# Define a custom config\nclass MyAppConfig(BaseConfig):\n    database_url: str = \"sqlite:///example.db\"\n    redis_host: str = \"localhost\"\n\nconfig = MyAppConfig()\nprint(config.database_url)  # \"sqlite:///example.db\"\n</code></pre>"},{"location":"usage/#adapters-mocks","title":"Adapters &amp; Mocks","text":"<p>Use adapters for external systems with mocks for testing:</p> <pre><code>from archipy.adapters.redis.adapters import AsyncRedisAdapter\nfrom archipy.adapters.redis.mocks import AsyncRedisMock\n\n# Production use\nredis = AsyncRedisAdapter()\nawait redis.set(\"key\", \"value\", ex=3600)\nprint(await redis.get(\"key\"))  # \"value\"\n\n# Testing with mock\nmock_redis = AsyncRedisMock()\nawait mock_redis.set(\"key\", \"test\")\nprint(await mock_redis.get(\"key\"))  # \"test\"\n</code></pre>"},{"location":"usage/#entities-dtos","title":"Entities &amp; DTOs","text":"<p>Standardize data models:</p> <pre><code>from sqlalchemy import Column, Integer, String\nfrom archipy.models.entities.sqlalchemy.base_entities import BaseEntity\nfrom archipy.models.dtos.base_dtos import BaseDTO\n\n# Entity\nclass User(BaseEntity):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100))\n\n# DTO\nclass UserDTO(BaseDTO):\n    id: int\n    name: str\n\nuser = UserDTO(id=1, name=\"Alice\")\nprint(user.model_dump())  # {'id': 1, 'name': 'Alice'}\n</code></pre>"},{"location":"usage/#helper-utilities","title":"Helper Utilities","text":"<p>Simplify tasks with utilities and decorators:</p> <pre><code>from archipy.helpers.utils.datetime_utils import get_utc_now\nfrom archipy.helpers.decorators.retry import retry\n\n# Utility\nnow = get_utc_now()\nprint(now)  # Current UTC time\n\n# Decorator\n@retry(max_attempts=3, delay=1)\ndef risky_operation():\n    # Simulated failure\n    raise ValueError(\"Try again\")\n\ntry:\n    risky_operation()\nexcept ValueError as e:\n    print(f\"Failed after retries: {e}\")\n</code></pre>"},{"location":"usage/#bdd-testing","title":"BDD Testing","text":"<p>Validate features with <code>behave</code>:</p> <pre><code># Run BDD tests\nmake behave\n</code></pre> <p>Example feature file (<code>features/app_utils.feature</code>):</p> <pre><code>Feature: Application Utilities\n  Scenario: Get UTC time\n    When I get the current UTC time\n    Then the result should be a valid datetime\n</code></pre>"},{"location":"usage/#async-operations","title":"Async Operations","text":"<p>Support for asynchronous workflows:</p> <pre><code>import asyncio\nfrom archipy.adapters.orm.sqlalchemy.adapters import AsyncSqlAlchemyAdapter\n\n\nasync def fetch_users():\n    adapter = AsyncSqlAlchemyAdapter(session_manager, User)\n    users = await adapter.execute_search_query(User, pagination=None, sort_info=None)\n    return users\n\n\nusers, total = asyncio.run(fetch_users())\nprint(users)  # List of User entities\n</code></pre>"},{"location":"usage/#available-commands","title":"Available Commands","text":"<p>Run <code>make help</code> for all commands. Common ones:</p> <ul> <li>Format Code: <code>make format</code></li> <li>Lint Code: <code>make lint</code></li> <li>Run BDD Tests: <code>make behave</code></li> <li>Build Project: <code>make build</code></li> <li>Clean Artifacts: <code>make clean</code></li> </ul>"},{"location":"api_reference/","title":"API Reference","text":"<p>Welcome to the ArchiPy API reference documentation. This section provides detailed information about all modules, classes, and functions in ArchiPy.</p>"},{"location":"api_reference/#core-modules","title":"Core Modules","text":""},{"location":"api_reference/#adapters","title":"Adapters","text":"<p>The adapters module provides standardized interfaces to external systems:</p> <ul> <li>Adapters Documentation</li> <li>ORM Adapters</li> <li>Redis Adapters</li> <li>Email Adapters</li> <li>Keycloak Adapters</li> </ul>"},{"location":"api_reference/#configs","title":"Configs","text":"<p>Configuration management and injection tools:</p> <ul> <li>Configs Documentation</li> <li>Base Config</li> <li>Config Templates</li> </ul>"},{"location":"api_reference/#helpers","title":"Helpers","text":"<p>Utility functions and support classes:</p> <ul> <li>Helpers Documentation</li> <li>Decorators</li> <li>Utils</li> <li>Metaclasses</li> <li>Interceptors</li> </ul>"},{"location":"api_reference/#models","title":"Models","text":"<p>Core data structures and types:</p> <ul> <li>Models Documentation</li> <li>Entities</li> <li>Data Transfer Objects</li> <li>Errors</li> <li>Types</li> </ul>"},{"location":"api_reference/#source-code-organization","title":"Source Code Organization","text":"<p>The ArchiPy source code is organized into the following structure:</p> <pre><code>archipy/\n\u251c\u2500\u2500 adapters/           # External system integrations\n\u2502   \u251c\u2500\u2500 email/         # Email service adapters\n\u2502   \u251c\u2500\u2500 keycloak/      # Keycloak authentication adapters\n\u2502   \u251c\u2500\u2500 orm/           # Database ORM adapters\n\u2502   \u2514\u2500\u2500 redis/         # Redis adapters\n\u251c\u2500\u2500 configs/           # Configuration management\n\u2502   \u251c\u2500\u2500 base_config.py\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 helpers/           # Utility functions\n\u2502   \u251c\u2500\u2500 decorators/\n\u2502   \u251c\u2500\u2500 interceptors/\n\u2502   \u251c\u2500\u2500 metaclasses/\n\u2502   \u2514\u2500\u2500 utils/\n\u2514\u2500\u2500 models/            # Core data structures\n    \u251c\u2500\u2500 dtos/\n    \u251c\u2500\u2500 entities/\n    \u251c\u2500\u2500 errors/\n    \u2514\u2500\u2500 types/\n</code></pre>"},{"location":"api_reference/#api-stability","title":"API Stability","text":"<p>ArchiPy follows semantic versioning and marks API stability as follows:</p> <ul> <li>\ud83d\udfe2 Stable: Production-ready APIs, covered by semantic versioning</li> <li>\ud83d\udfe1 Beta: APIs that are stabilizing but may have breaking changes</li> <li>\ud83d\udd34 Alpha: Experimental APIs that may change significantly</li> </ul> <p>See the Changelog for version history and breaking changes.</p>"},{"location":"api_reference/#contributing","title":"Contributing","text":"<p>For information about contributing to ArchiPy's development, please see:</p> <ul> <li>Contributing Guide</li> <li>Development Guide</li> <li>Documentation Guide</li> </ul>"},{"location":"api_reference/adapters/","title":"Adapters","text":"<p>The <code>adapters</code> module provides standardized interfaces to external systems and services. It follows the ports and adapters pattern (also known as hexagonal architecture) to decouple application logic from external dependencies.</p>"},{"location":"api_reference/adapters/#key-features","title":"Key Features","text":"<ul> <li>Consistent interfaces for all external services</li> <li>Built-in mock implementations for testing</li> <li>Port definitions for dependency inversion</li> <li>Ready-to-use implementations for common services</li> </ul>"},{"location":"api_reference/adapters/#available-adapters","title":"Available Adapters","text":""},{"location":"api_reference/adapters/#email","title":"Email","text":"<p>Email sending functionality with standardized interface.</p> <pre><code>from archipy.adapters.email import EmailAdapter, EmailPort\n\n# Configure email adapter\nemail_adapter = EmailAdapter(host=\"smtp.example.com\", port=587, username=\"user\", password=\"pass\")\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email\",\n    recipients=[\"recipient@example.com\"],\n)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters","title":"<code>archipy.adapters.email.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler","title":"<code>archipy.adapters.email.adapters.AttachmentHandler</code>","text":"<p>Enhanced attachment handler with better type safety and validation</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class AttachmentHandler:\n    \"\"\"Enhanced attachment handler with better type safety and validation\"\"\"\n\n    @staticmethod\n    def create_attachment(\n        source: str | bytes | BinaryIO | HttpUrl,\n        filename: str,\n        attachment_type: EmailAttachmentType,\n        content_type: str | None = None,\n        content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n        content_id: str | None = None,\n        max_size: int | None = None,\n    ) -&gt; EmailAttachmentDTO:\n        \"\"\"Create an attachment with validation\"\"\"\n        if max_size is None:\n            max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n        try:\n            processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n            return EmailAttachmentDTO(\n                content=processed_content,\n                filename=filename,\n                content_type=content_type,\n                content_disposition=content_disposition,\n                content_id=content_id,\n                attachment_type=attachment_type,\n                max_size=max_size,\n            )\n        except Exception as exception:\n            raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n\n    @staticmethod\n    def _process_source(source: str | bytes | BinaryIO | HttpUrl, attachment_type: EmailAttachmentType) -&gt; bytes:\n        \"\"\"Process different types of attachment sources\"\"\"\n        if attachment_type == EmailAttachmentType.FILE:\n            with open(source, \"rb\") as f:\n                return f.read()\n        elif attachment_type == EmailAttachmentType.BASE64:\n            return base64.b64decode(source)\n        elif attachment_type == EmailAttachmentType.URL:\n            response = requests.get(source)\n            response.raise_for_status()\n            return response.content\n        elif attachment_type == EmailAttachmentType.BINARY:\n            if isinstance(source, bytes):\n                return source\n            if hasattr(source, \"read\"):\n                return source.read()\n            raise ValueError(f\"Invalid binary source type: {type(source)}\")\n        raise ValueError(f\"Unsupported attachment type: {attachment_type}\")\n\n    @staticmethod\n    def process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n        \"\"\"Process and attach the attachment to the email message\"\"\"\n        content = AttachmentHandler._get_content(attachment)\n        part = AttachmentHandler._create_mime_part(content, attachment)\n\n        # Add headers\n        part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n        if attachment.content_id:\n            part.add_header(\"Content-ID\", attachment.content_id)\n\n        msg.attach(part)\n\n    @staticmethod\n    def _get_content(attachment: EmailAttachmentDTO) -&gt; bytes:\n        \"\"\"Get content as bytes from attachment\"\"\"\n        if isinstance(attachment.content, (str, bytes)):\n            return attachment.content if isinstance(attachment.content, bytes) else attachment.content.encode()\n        return attachment.content.read()\n\n    @staticmethod\n    def _create_mime_part(\n        content: bytes,\n        attachment: EmailAttachmentDTO,\n    ) -&gt; MIMEText | MIMEImage | MIMEAudio | MIMEBase:\n        \"\"\"Create appropriate MIME part based on content type\"\"\"\n        main_type, sub_type = attachment.content_type.split(\"/\", 1)\n\n        if main_type == \"text\":\n            return MIMEText(content.decode(), sub_type)\n        if main_type == \"image\":\n            return MIMEImage(content, _subtype=sub_type)\n        if main_type == \"audio\":\n            return MIMEAudio(content, _subtype=sub_type)\n        part = MIMEBase(main_type, sub_type)\n        part.set_payload(content)\n        encoders.encode_base64(part)\n        return part\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.create_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.create_attachment(source, filename, attachment_type, content_type=None, content_disposition=EmailAttachmentDispositionType.ATTACHMENT, content_id=None, max_size=None)</code>  <code>staticmethod</code>","text":"<p>Create an attachment with validation</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef create_attachment(\n    source: str | bytes | BinaryIO | HttpUrl,\n    filename: str,\n    attachment_type: EmailAttachmentType,\n    content_type: str | None = None,\n    content_disposition: EmailAttachmentDispositionType = EmailAttachmentDispositionType.ATTACHMENT,\n    content_id: str | None = None,\n    max_size: int | None = None,\n) -&gt; EmailAttachmentDTO:\n    \"\"\"Create an attachment with validation\"\"\"\n    if max_size is None:\n        max_size = BaseConfig.global_config().EMAIL.ATTACHMENT_MAX_SIZE\n    try:\n        processed_content = AttachmentHandler._process_source(source, attachment_type)\n\n        return EmailAttachmentDTO(\n            content=processed_content,\n            filename=filename,\n            content_type=content_type,\n            content_disposition=content_disposition,\n            content_id=content_id,\n            attachment_type=attachment_type,\n            max_size=max_size,\n        )\n    except Exception as exception:\n        raise InvalidArgumentError(f\"Failed to create attachment: {exception!s}\") from exception\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.AttachmentHandler.process_attachment","title":"<code>archipy.adapters.email.adapters.AttachmentHandler.process_attachment(msg, attachment)</code>  <code>staticmethod</code>","text":"<p>Process and attach the attachment to the email message</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@staticmethod\ndef process_attachment(msg: MIMEMultipart, attachment: EmailAttachmentDTO) -&gt; None:\n    \"\"\"Process and attach the attachment to the email message\"\"\"\n    content = AttachmentHandler._get_content(attachment)\n    part = AttachmentHandler._create_mime_part(content, attachment)\n\n    # Add headers\n    part.add_header(\"Content-Disposition\", attachment.content_disposition.value, filename=attachment.filename)\n\n    if attachment.content_id:\n        part.add_header(\"Content-ID\", attachment.content_id)\n\n    msg.attach(part)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter","title":"<code>archipy.adapters.email.adapters.EmailAdapter</code>","text":"<p>               Bases: <code>EmailPort</code></p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>class EmailAdapter(EmailPort):\n    def __init__(self, config: EmailConfig = None):\n        self.config = config or BaseConfig.global_config().EMAIL\n        self.connection_pool = EmailConnectionPool(self.config)\n\n    @override\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send email with advanced features and connection pooling\"\"\"\n        connection = None\n        try:\n            connection = self.connection_pool.get_connection()\n            msg = self._create_message(\n                to_email=to_email,\n                subject=subject,\n                body=body,\n                cc=cc,\n                bcc=bcc,\n                attachments=attachments,\n                html=html,\n                template=template,\n                template_vars=template_vars,\n            )\n\n            recipients = self._get_all_recipients(to_email, cc, bcc)\n\n            for attempt in range(self.config.MAX_RETRIES):\n                try:\n                    if connection.smtp_connection:\n                        connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                        logging.debug(f\"Email sent successfully to {to_email}\")\n                        return\n                    connection.connect()\n                except Exception as e:\n                    if attempt == self.config.MAX_RETRIES - 1:\n                        BaseUtils.capture_exception(e)\n                    connection.connect()  # Retry with fresh connection\n\n        except Exception as e:\n            BaseUtils.capture_exception(e)\n        finally:\n            if connection:\n                self.connection_pool.return_connection(connection)\n\n    def _create_message(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; MIMEMultipart:\n        msg = MIMEMultipart()\n        msg[\"From\"] = self.config.EMAIL_USERNAME\n        msg[\"To\"] = to_email if isinstance(to_email, str) else \", \".join(to_email)\n        msg[\"Subject\"] = subject\n\n        if cc:\n            msg[\"Cc\"] = cc if isinstance(cc, str) else \", \".join(cc)\n        if bcc:\n            msg[\"Bcc\"] = bcc if isinstance(bcc, str) else \", \".join(bcc)\n\n        if template:\n            body = Template(template).render(**(template_vars or {}))\n\n        msg.attach(MIMEText(body, \"html\" if html else \"plain\"))\n\n        if attachments:\n            for attachment in attachments:\n                if isinstance(attachment, str):\n                    # Treat as file path\n                    attachment_obj = AttachmentHandler.create_attachment(\n                        source=attachment,\n                        filename=os.path.basename(attachment),\n                        attachment_type=EmailAttachmentType.FILE,\n                    )\n                else:\n                    attachment_obj = attachment\n                AttachmentHandler.process_attachment(msg, attachment_obj)\n\n        return msg\n\n    @staticmethod\n    def _get_all_recipients(\n        to_email: EmailStr | list[EmailStr],\n        cc: EmailStr | list[EmailStr] | None,\n        bcc: EmailStr | list[EmailStr] | None,\n    ) -&gt; list[str]:\n        \"\"\"Get list of all recipients\"\"\"\n        recipients = []\n\n        # Add primary recipients\n        if isinstance(to_email, str):\n            recipients.append(to_email)\n        else:\n            recipients.extend(to_email)\n\n        # Add CC recipients\n        if cc:\n            if isinstance(cc, str):\n                recipients.append(cc)\n            else:\n                recipients.extend(cc)\n\n        # Add BCC recipients\n        if bcc:\n            if isinstance(bcc, str):\n                recipients.append(bcc)\n            else:\n                recipients.extend(bcc)\n\n        return recipients\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.adapters.EmailAdapter.send_email","title":"<code>archipy.adapters.email.adapters.EmailAdapter.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>","text":"<p>Send email with advanced features and connection pooling</p> Source code in <code>archipy/adapters/email/adapters.py</code> <pre><code>@override\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send email with advanced features and connection pooling\"\"\"\n    connection = None\n    try:\n        connection = self.connection_pool.get_connection()\n        msg = self._create_message(\n            to_email=to_email,\n            subject=subject,\n            body=body,\n            cc=cc,\n            bcc=bcc,\n            attachments=attachments,\n            html=html,\n            template=template,\n            template_vars=template_vars,\n        )\n\n        recipients = self._get_all_recipients(to_email, cc, bcc)\n\n        for attempt in range(self.config.MAX_RETRIES):\n            try:\n                if connection.smtp_connection:\n                    connection.smtp_connection.send_message(msg, to_addrs=recipients)\n                    logging.debug(f\"Email sent successfully to {to_email}\")\n                    return\n                connection.connect()\n            except Exception as e:\n                if attempt == self.config.MAX_RETRIES - 1:\n                    BaseUtils.capture_exception(e)\n                connection.connect()  # Retry with fresh connection\n\n    except Exception as e:\n        BaseUtils.capture_exception(e)\n    finally:\n        if connection:\n            self.connection_pool.return_connection(connection)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports","title":"<code>archipy.adapters.email.ports</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort","title":"<code>archipy.adapters.email.ports.EmailPort</code>","text":"<p>Interface for email sending operations.</p> <p>This interface defines the contract for email adapters, ensuring a consistent approach to sending emails across different implementations. It provides a comprehensive set of features including support for:</p> <ul> <li>Multiple recipients (To, CC, BCC)</li> <li>HTML and plain text content</li> <li>File and in-memory attachments</li> <li>Template-based email rendering</li> </ul> <p>Implementing classes should handle the details of connecting to an email service, managing connections, and ensuring reliable delivery.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n...     def __init__(self, config):\n...         self.config = config\n...\n...     def send_email(\n...         self,\n...         to_email,\n...         subject,\n...         body,\n...         cc=None,\n...         bcc=None,\n...         attachments=None,\n...         html=False,\n...         template=None,\n...         template_vars=None\n...     ):\n...         # Implementation details...\n...         pass\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>class EmailPort:\n    \"\"\"Interface for email sending operations.\n\n    This interface defines the contract for email adapters, ensuring\n    a consistent approach to sending emails across different implementations.\n    It provides a comprehensive set of features including support for:\n\n    - Multiple recipients (To, CC, BCC)\n    - HTML and plain text content\n    - File and in-memory attachments\n    - Template-based email rendering\n\n    Implementing classes should handle the details of connecting to an\n    email service, managing connections, and ensuring reliable delivery.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.email.email_port import EmailPort\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class CustomEmailAdapter(EmailPort):\n        ...     def __init__(self, config):\n        ...         self.config = config\n        ...\n        ...     def send_email(\n        ...         self,\n        ...         to_email,\n        ...         subject,\n        ...         body,\n        ...         cc=None,\n        ...         bcc=None,\n        ...         attachments=None,\n        ...         html=False,\n        ...         template=None,\n        ...         template_vars=None\n        ...     ):\n        ...         # Implementation details...\n        ...         pass\n    \"\"\"\n\n    @abstractmethod\n    def send_email(\n        self,\n        to_email: EmailStr | list[EmailStr],\n        subject: str,\n        body: str,\n        cc: EmailStr | list[EmailStr] | None = None,\n        bcc: EmailStr | list[EmailStr] | None = None,\n        attachments: list[str | EmailAttachmentDTO] | None = None,\n        html: bool = False,\n        template: str | None = None,\n        template_vars: dict | None = None,\n    ) -&gt; None:\n        \"\"\"Send an email with various options and features.\n\n        This method handles the composition and delivery of an email with\n        support for multiple recipients, HTML content, templates, and attachments.\n\n        Args:\n            to_email: Primary recipient(s) of the email\n            subject: Email subject line\n            body: Email body content (either plain text or HTML)\n            cc: Carbon copy recipient(s)\n            bcc: Blind carbon copy recipient(s)\n            attachments: List of file paths or EmailAttachmentDTO objects\n            html: If True, treats body as HTML content, otherwise plain text\n            template: A template string to render using template_vars\n            template_vars: Variables to use when rendering the template\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; # Simple text email\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Hello\",\n            ...     body=\"This is a test email\"\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # HTML email with attachment\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n            ...     subject=\"Report\",\n            ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n            ...     html=True,\n            ...     attachments=[\"path/to/report.pdf\"]\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Template-based email\n            &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n            &gt;&gt;&gt; adapter.send_email(\n            ...     to_email=\"user@example.com\",\n            ...     subject=\"Account Expiration\",\n            ...     body=\"\",  # Body will be rendered from template\n            ...     template=template,\n            ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n            ... )\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.email.ports.EmailPort.send_email","title":"<code>archipy.adapters.email.ports.EmailPort.send_email(to_email, subject, body, cc=None, bcc=None, attachments=None, html=False, template=None, template_vars=None)</code>  <code>abstractmethod</code>","text":"<p>Send an email with various options and features.</p> <p>This method handles the composition and delivery of an email with support for multiple recipients, HTML content, templates, and attachments.</p> <p>Parameters:</p> Name Type Description Default <code>to_email</code> <code>EmailStr | list[EmailStr]</code> <p>Primary recipient(s) of the email</p> required <code>subject</code> <code>str</code> <p>Email subject line</p> required <code>body</code> <code>str</code> <p>Email body content (either plain text or HTML)</p> required <code>cc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Carbon copy recipient(s)</p> <code>None</code> <code>bcc</code> <code>EmailStr | list[EmailStr] | None</code> <p>Blind carbon copy recipient(s)</p> <code>None</code> <code>attachments</code> <code>list[str | EmailAttachmentDTO] | None</code> <p>List of file paths or EmailAttachmentDTO objects</p> <code>None</code> <code>html</code> <code>bool</code> <p>If True, treats body as HTML content, otherwise plain text</p> <code>False</code> <code>template</code> <code>str | None</code> <p>A template string to render using template_vars</p> <code>None</code> <code>template_vars</code> <code>dict | None</code> <p>Variables to use when rendering the template</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Simple text email\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Hello\",\n...     body=\"This is a test email\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # HTML email with attachment\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n...     subject=\"Report\",\n...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n...     html=True,\n...     attachments=[\"path/to/report.pdf\"]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Template-based email\n&gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n&gt;&gt;&gt; adapter.send_email(\n...     to_email=\"user@example.com\",\n...     subject=\"Account Expiration\",\n...     body=\"\",  # Body will be rendered from template\n...     template=template,\n...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n... )\n</code></pre> Source code in <code>archipy/adapters/email/ports.py</code> <pre><code>@abstractmethod\ndef send_email(\n    self,\n    to_email: EmailStr | list[EmailStr],\n    subject: str,\n    body: str,\n    cc: EmailStr | list[EmailStr] | None = None,\n    bcc: EmailStr | list[EmailStr] | None = None,\n    attachments: list[str | EmailAttachmentDTO] | None = None,\n    html: bool = False,\n    template: str | None = None,\n    template_vars: dict | None = None,\n) -&gt; None:\n    \"\"\"Send an email with various options and features.\n\n    This method handles the composition and delivery of an email with\n    support for multiple recipients, HTML content, templates, and attachments.\n\n    Args:\n        to_email: Primary recipient(s) of the email\n        subject: Email subject line\n        body: Email body content (either plain text or HTML)\n        cc: Carbon copy recipient(s)\n        bcc: Blind carbon copy recipient(s)\n        attachments: List of file paths or EmailAttachmentDTO objects\n        html: If True, treats body as HTML content, otherwise plain text\n        template: A template string to render using template_vars\n        template_vars: Variables to use when rendering the template\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; # Simple text email\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Hello\",\n        ...     body=\"This is a test email\"\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # HTML email with attachment\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=[\"user1@example.com\", \"user2@example.com\"],\n        ...     subject=\"Report\",\n        ...     body=\"&lt;h1&gt;Monthly Report&lt;/h1&gt;&lt;p&gt;Please see attached&lt;/p&gt;\",\n        ...     html=True,\n        ...     attachments=[\"path/to/report.pdf\"]\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Template-based email\n        &gt;&gt;&gt; template = \"Hello {{ name }}, your account expires on {{ date }}\"\n        &gt;&gt;&gt; adapter.send_email(\n        ...     to_email=\"user@example.com\",\n        ...     subject=\"Account Expiration\",\n        ...     body=\"\",  # Body will be rendered from template\n        ...     template=template,\n        ...     template_vars={\"name\": \"John\", \"date\": \"2023-12-31\"}\n        ... )\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#keycloak","title":"Keycloak","text":"<p>Keycloak integration for authentication and authorization services.</p> <pre><code>from archipy.adapters.keycloak import KeycloakAdapter, AsyncKeycloakAdapter\n\n# Create a Keycloak adapter (synchronous)\nkeycloak = KeycloakAdapter()  # Uses global config by default\n\n# Authenticate a user\ntoken = keycloak.get_token(\"username\", \"password\")\n\n# Validate token\nis_valid = keycloak.validate_token(token[\"access_token\"])\n\n# Check user roles\nhas_admin = keycloak.has_role(token[\"access_token\"], \"admin\")\n\n# Async usage example\nimport asyncio\n\nasync def auth_example():\n    # Create async Keycloak adapter\n    async_keycloak = AsyncKeycloakAdapter()\n\n    # Get token asynchronously\n    token = await async_keycloak.get_token(\"username\", \"password\")\n\n    # Get user info\n    user_info = await async_keycloak.get_userinfo(token[\"access_token\"])\n    return user_info\n\n# Run the async example\nuser_info = asyncio.run(auth_example())\n</code></pre> <p>For detailed examples and usage guidelines, see the Keycloak Adapter Examples.</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters","title":"<code>archipy.adapters.keycloak.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter</code>","text":"<p>               Bases: <code>KeycloakPort</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class KeycloakAdapter(KeycloakPort):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self.openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter = None\n        self._admin_token_expiry = 0\n\n        # Initialize admin client with service account if client_secret is provided\n        if self.configs.CLIENT_SECRET_KEY:\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Get token using client credentials\n            token = self.openid_adapter.token(grant_type=\"client_credentials\")\n\n            # Set token expiry time (current time + expires_in - buffer)\n            # Using a 30-second buffer to ensure we refresh before expiration\n            self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n            # Create admin client with the token\n            self._admin_adapter = KeycloakAdmin(\n                server_url=self.configs.SERVER_URL,\n                realm_name=self.configs.REALM_NAME,\n                token=token,\n                verify=self.configs.VERIFY_SSL,\n                timeout=self.configs.TIMEOUT,\n            )\n            logger.debug(\"Admin client initialized successfully\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to initialize admin client: {e!s}\")\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            ValueError: If admin client is not available\n        \"\"\"\n        if not self.configs.CLIENT_SECRET_KEY:\n            raise ValueError(\"Admin client not available, provide client_secret_key to use admin features\")\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise ValueError(\"Failed to initialize admin client\")\n\n        return self._admin_adapter\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    def get_public_key(self) -&gt; Any:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = self.openid_adapter.public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except Exception as e:\n            logger.error(f\"Failed to get public key: {e!s}\")\n            raise ValueError(f\"Failed to get public key: {e!s}\")\n\n    @override\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        try:\n            return self.openid_adapter.token(grant_type=\"password\", username=username, password=password)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get token: {e!s}\")\n            raise ValueError(f\"Failed to get token: {e!s}\")\n\n    @override\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token refresh fails\n        \"\"\"\n        try:\n            return self.openid_adapter.refresh_token(refresh_token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to refresh token: {e!s}\")\n            raise ValueError(f\"Failed to refresh token: {e!s}\")\n\n    @override\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            self.openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n            return True\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n\n    @override\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not self.validate_token(token):\n            logger.error(\"Invalid token provided for userinfo request\")\n            raise ValueError(\"Invalid token provided\")\n        try:\n            return self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user info: {e!s}\")\n            raise ValueError(f\"Failed to get user info: {e!s}\")\n\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=100)  # Cache for 30 seconds\n    def _get_userinfo_cached(self, token):\n        return self.openid_adapter.userinfo(token)\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            logger.error(f\"Failed to get user by ID: {e!s}\")\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user by ID: {e!s}\")\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user by username: {e!s}\")\n            raise ValueError(f\"Failed to get user by username: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = self.admin_adapter.get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user by email: {e!s}\")\n            raise ValueError(f\"Failed to get user by email: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user roles: {e!s}\")\n            raise ValueError(f\"Failed to get user roles: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client roles: {e!s}\")\n            raise ValueError(f\"Failed to get client roles: {e!s}\")\n\n    @override\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = client.get(\"roles\", [])\n                if role_name in client_roles:\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(roles):\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = set(client.get(\"roles\", []))\n                if role_names.intersection(client_roles):\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                all_roles.update(client.get(\"roles\", []))\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = self.admin_adapter.create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n\n            return user_id\n        except KeycloakError as e:\n            logger.error(f\"Failed to create user: {e!s}\")\n            raise ValueError(f\"Failed to create user: {e!s}\")\n\n    @override\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to update user: {e!s}\")\n            raise ValueError(f\"Failed to update user: {e!s}\")\n\n    @override\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            logger.error(f\"Failed to reset password: {e!s}\")\n            raise ValueError(f\"Failed to reset password: {e!s}\")\n\n    @override\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Assign role to user\n            self.admin_adapter.assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to assign realm role: {e!s}\")\n            raise ValueError(f\"Failed to assign realm role: {e!s}\")\n\n    @override\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = self.admin_adapter.get_realm_role(role_name)\n            # Remove role from user\n            self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to remove realm role: {e!s}\")\n            raise ValueError(f\"Failed to remove realm role: {e!s}\")\n\n    @override\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = self.admin_adapter.get_client_id(client_id)\n            # Get role representation\n            role = self.admin_adapter.get_client_role(client, role_name)\n            # Assign role to user\n            self.admin_adapter.assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to assign client role: {e!s}\")\n            raise ValueError(f\"Failed to assign client role: {e!s}\")\n\n    @override\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            self.admin_adapter.create_realm_role(role_data)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            created_role = self.admin_adapter.get_realm_role(role_name)\n            return created_role\n        except KeycloakError as e:\n            logger.error(f\"Failed to create realm role: {e!s}\")\n            raise ValueError(f\"Failed to create realm role: {e!s}\")\n\n    @override\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            self.admin_adapter.delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to delete realm role: {e!s}\")\n            raise ValueError(f\"Failed to delete realm role: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = self.get_client_id(self.configs.CLIENT_ID)\n            service_account_id = self.admin_adapter.get_client_service_account_user(client_id).get(\"id\")\n            return service_account_id\n        except KeycloakError as e:\n            logger.error(f\"Failed to get service account ID: {e!s}\")\n            raise ValueError(f\"Failed to get service account ID: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return self.openid_adapter.well_known()\n        except KeycloakError as e:\n            logger.error(f\"Failed to get well-known config: {e!s}\")\n            raise ValueError(f\"Failed to get well-known config: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return self.openid_adapter.certs()\n        except KeycloakError as e:\n            logger.error(f\"Failed to get certificates: {e!s}\")\n            raise ValueError(f\"Failed to get certificates: {e!s}\")\n\n    @override\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return self.openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n        except KeycloakError as e:\n            logger.error(f\"Failed to exchange code for token: {e!s}\")\n            raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n\n    @override\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return self.openid_adapter.token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client credentials token: {e!s}\")\n            raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            logger.error(f\"Failed to search users: {e!s}\")\n            raise ValueError(f\"Failed to search users: {e!s}\")\n\n    @override\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = self.openid_adapter.uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n            return False\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception as e:\n            logger.error(f\"Unexpected error in permission check: {e!s}\")\n            return False\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client secret: {e!s}\")\n            raise ValueError(f\"Failed to get client secret: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return self.admin_adapter.get_client_id(client_name)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client ID: {e!s}\")\n            raise ValueError(f\"Failed to get client ID: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_roles()\n        except KeycloakError as e:\n            logger.error(f\"Failed to get realm roles: {e!s}\")\n            raise ValueError(f\"Failed to get realm roles: {e!s}\")\n\n    @override\n    @ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return self.admin_adapter.get_realm_role(role_name)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get realm role: {e!s}\")\n            raise ValueError(f\"Failed to get realm role: {e!s}\")\n\n    @override\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = self.admin_adapter.get_client_id(client_id)\n            role = self.admin_adapter.get_client_role(client, role_name)\n            self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            logger.error(f\"Failed to remove client role: {e!s}\")\n            raise ValueError(f\"Failed to remove client role: {e!s}\")\n\n    @override\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            self.admin_adapter.user_logout(user_id)\n        except KeycloakError as e:\n            logger.error(f\"Failed to clear user sessions: {e!s}\")\n            raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n\n    @override\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            self.openid_adapter.logout(refresh_token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to logout: {e!s}\")\n            raise ValueError(f\"Failed to logout: {e!s}\")\n\n    @override\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return self.openid_adapter.introspect(token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to introspect token: {e!s}\")\n            raise ValueError(f\"Failed to introspect token: {e!s}\")\n\n    @override\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return self.openid_adapter.decode_token(\n                token,\n                key=self.get_public_key(),\n            )\n        except KeycloakError as e:\n            logger.error(f\"Failed to get token info: {e!s}\")\n            raise ValueError(f\"Failed to get token info: {e!s}\")\n\n    @override\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            self.admin_adapter.delete_user(user_id=user_id)\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except Exception as e:\n            logger.error(f\"Failed to delete user with ID {user_id}: {e!s}\")\n            raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If admin client is not available</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self.openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter = None\n    self._admin_token_expiry = 0\n\n    # Initialize admin client with service account if client_secret is provided\n    if self.configs.CLIENT_SECRET_KEY:\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_public_key()</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>Any</code> <p>JWK key object used to verify signatures</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\ndef get_public_key(self) -&gt; Any:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = self.openid_adapter.public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except Exception as e:\n        logger.error(f\"Failed to get public key: {e!s}\")\n        raise ValueError(f\"Failed to get public key: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token(username, password)</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    try:\n        return self.openid_adapter.token(grant_type=\"password\", username=username, password=password)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get token: {e!s}\")\n        raise ValueError(f\"Failed to get token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.refresh_token(refresh_token)</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token refresh fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token refresh fails\n    \"\"\"\n    try:\n        return self.openid_adapter.refresh_token(refresh_token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to refresh token: {e!s}\")\n        raise ValueError(f\"Failed to refresh token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.validate_token(token)</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        self.openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n        return True\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_userinfo(token)</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not self.validate_token(token):\n        logger.error(\"Invalid token provided for userinfo request\")\n        raise ValueError(\"Invalid token provided\")\n    try:\n        return self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user info: {e!s}\")\n        raise ValueError(f\"Failed to get user info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_id(user_id)</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        logger.error(f\"Failed to get user by ID: {e!s}\")\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user by ID: {e!s}\")\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_username(username)</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user by username: {e!s}\")\n        raise ValueError(f\"Failed to get user by username: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_by_email(email)</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = self.admin_adapter.get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user by email: {e!s}\")\n        raise ValueError(f\"Failed to get user by email: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_user_roles(user_id)</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user roles: {e!s}\")\n        raise ValueError(f\"Failed to get user roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=100)  # Cache for 5 minutes\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client roles: {e!s}\")\n        raise ValueError(f\"Failed to get client roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_role(token, role_name)</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = client.get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_any_of_roles(token, role_names)</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(roles):\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = set(client.get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.has_all_roles(token, role_names)</code>","text":"<p>Check if a user has all of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            all_roles.update(client.get(\"roles\", []))\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_user(user_data)</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = self.admin_adapter.create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n\n        return user_id\n    except KeycloakError as e:\n        logger.error(f\"Failed to create user: {e!s}\")\n        raise ValueError(f\"Failed to create user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.update_user(user_id, user_data)</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to update user: {e!s}\")\n        raise ValueError(f\"Failed to update user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.reset_password(user_id, password, temporary=False)</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        logger.error(f\"Failed to reset password: {e!s}\")\n        raise ValueError(f\"Failed to reset password: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_realm_role(user_id, role_name)</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Assign role to user\n        self.admin_adapter.assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to assign realm role: {e!s}\")\n        raise ValueError(f\"Failed to assign realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_realm_role(user_id, role_name)</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = self.admin_adapter.get_realm_role(role_name)\n        # Remove role from user\n        self.admin_adapter.delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to remove realm role: {e!s}\")\n        raise ValueError(f\"Failed to remove realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = self.admin_adapter.get_client_id(client_id)\n        # Get role representation\n        role = self.admin_adapter.get_client_role(client, role_name)\n        # Assign role to user\n        self.admin_adapter.assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to assign client role: {e!s}\")\n        raise ValueError(f\"Failed to assign client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.create_realm_role(role_name, description=None)</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        self.admin_adapter.create_realm_role(role_data)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        created_role = self.admin_adapter.get_realm_role(role_name)\n        return created_role\n    except KeycloakError as e:\n        logger.error(f\"Failed to create realm role: {e!s}\")\n        raise ValueError(f\"Failed to create realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_realm_role(role_name)</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        self.admin_adapter.delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to delete realm role: {e!s}\")\n        raise ValueError(f\"Failed to delete realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_service_account_id()</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = self.get_client_id(self.configs.CLIENT_ID)\n        service_account_id = self.admin_adapter.get_client_service_account_user(client_id).get(\"id\")\n        return service_account_id\n    except KeycloakError as e:\n        logger.error(f\"Failed to get service account ID: {e!s}\")\n        raise ValueError(f\"Failed to get service account ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_well_known_config()</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return self.openid_adapter.well_known()\n    except KeycloakError as e:\n        logger.error(f\"Failed to get well-known config: {e!s}\")\n        raise ValueError(f\"Failed to get well-known config: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_certs()</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=1)  # Cache for 1 hour\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return self.openid_adapter.certs()\n    except KeycloakError as e:\n        logger.error(f\"Failed to get certificates: {e!s}\")\n        raise ValueError(f\"Failed to get certificates: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_from_code(code, redirect_uri)</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return self.openid_adapter.token(grant_type=\"authorization_code\", code=code, redirect_uri=redirect_uri)\n    except KeycloakError as e:\n        logger.error(f\"Failed to exchange code for token: {e!s}\")\n        raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_credentials_token()</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return self.openid_adapter.token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client credentials token: {e!s}\")\n        raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.search_users(query, max_results=100)</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType]</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=30, maxsize=50)  # Cache for 30 seconds with limited entries\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(self.admin_adapter.get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = self.admin_adapter.get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = self.admin_adapter.get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = self.admin_adapter.get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        logger.error(f\"Failed to search users: {e!s}\")\n        raise ValueError(f\"Failed to search users: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.check_permissions(token, resource, scope)</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = self.openid_adapter.uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n        return False\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception as e:\n        logger.error(f\"Unexpected error in permission check: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_secret(client_id)</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client secret: {e!s}\")\n        raise ValueError(f\"Failed to get client secret: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_client_id(client_name)</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=3600, maxsize=50)  # Cache for 1 hour\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return self.admin_adapter.get_client_id(client_name)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client ID: {e!s}\")\n        raise ValueError(f\"Failed to get client ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_roles()</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_roles()\n    except KeycloakError as e:\n        logger.error(f\"Failed to get realm roles: {e!s}\")\n        raise ValueError(f\"Failed to get realm roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_realm_role(role_name)</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@ttl_cache_decorator(ttl_seconds=300, maxsize=1)  # Cache for 5 minutes\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return self.admin_adapter.get_realm_role(role_name)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get realm role: {e!s}\")\n        raise ValueError(f\"Failed to get realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = self.admin_adapter.get_client_id(client_id)\n        role = self.admin_adapter.get_client_role(client, role_name)\n        self.admin_adapter.delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        logger.error(f\"Failed to remove client role: {e!s}\")\n        raise ValueError(f\"Failed to remove client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.clear_user_sessions(user_id)</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        self.admin_adapter.user_logout(user_id)\n    except KeycloakError as e:\n        logger.error(f\"Failed to clear user sessions: {e!s}\")\n        raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.logout(refresh_token)</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        self.openid_adapter.logout(refresh_token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to logout: {e!s}\")\n        raise ValueError(f\"Failed to logout: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.introspect_token(token)</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return self.openid_adapter.introspect(token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to introspect token: {e!s}\")\n        raise ValueError(f\"Failed to introspect token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.get_token_info(token)</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return self.openid_adapter.decode_token(\n            token,\n            key=self.get_public_key(),\n        )\n    except KeycloakError as e:\n        logger.error(f\"Failed to get token info: {e!s}\")\n        raise ValueError(f\"Failed to get token info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.KeycloakAdapter.delete_user(user_id)</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        self.admin_adapter.delete_user(user_id=user_id)\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to delete user with ID {user_id}: {e!s}\")\n        raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter</code>","text":"<p>               Bases: <code>AsyncKeycloakPort</code></p> <p>Concrete implementation of the KeycloakPort interface using python-keycloak library.</p> <p>This implementation includes TTL caching for appropriate operations to improve performance while ensuring cache entries expire after a configured time to prevent stale data.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>class AsyncKeycloakAdapter(AsyncKeycloakPort):\n    \"\"\"Concrete implementation of the KeycloakPort interface using python-keycloak library.\n\n    This implementation includes TTL caching for appropriate operations to improve performance\n    while ensuring cache entries expire after a configured time to prevent stale data.\n    \"\"\"\n\n    def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n        \"\"\"Initialize KeycloakAdapter with configuration.\n\n        Args:\n            keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n        \"\"\"\n        self.configs: KeycloakConfig = (\n            BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n        )\n\n        # Initialize the OpenID client for authentication\n        self.openid_adapter = self._get_openid_client(self.configs)\n\n        # Cache for admin client to avoid unnecessary re-authentication\n        self._admin_adapter = None\n        self._admin_token_expiry = 0\n\n        # Initialize admin client with service account if client_secret is provided\n        if self.configs.CLIENT_SECRET_KEY:\n            self._initialize_admin_client()\n\n    def clear_all_caches(self) -&gt; None:\n        \"\"\"Clear all cached values.\"\"\"\n        for attr_name in dir(self):\n            attr = getattr(self, attr_name)\n            if hasattr(attr, \"clear_cache\"):\n                attr.clear_cache()\n\n    @staticmethod\n    def _get_openid_client(configs: KeycloakConfig) -&gt; KeycloakOpenID:\n        \"\"\"Create and configure a KeycloakOpenID instance.\n\n        Args:\n            configs: Keycloak configuration\n\n        Returns:\n            Configured KeycloakOpenID client\n        \"\"\"\n        return KeycloakOpenID(\n            server_url=configs.SERVER_URL,\n            client_id=configs.CLIENT_ID,\n            realm_name=configs.REALM_NAME,\n            client_secret_key=configs.CLIENT_SECRET_KEY,\n            verify=configs.VERIFY_SSL,\n            timeout=configs.TIMEOUT,\n        )\n\n    def _initialize_admin_client(self) -&gt; None:\n        \"\"\"Initialize or refresh the admin client.\"\"\"\n        try:\n            # Get token using client credentials\n            token = self.openid_adapter.token(grant_type=\"client_credentials\")\n\n            # Set token expiry time (current time + expires_in - buffer)\n            # Using a 30-second buffer to ensure we refresh before expiration\n            self._admin_token_expiry = time.time() + token.get(\"expires_in\", 60) - 30\n\n            # Create admin client with the token\n            self._admin_adapter = KeycloakAdmin(\n                server_url=self.configs.SERVER_URL,\n                realm_name=self.configs.REALM_NAME,\n                token=token,\n                verify=self.configs.VERIFY_SSL,\n                timeout=self.configs.TIMEOUT,\n            )\n            logger.debug(\"Admin client initialized successfully\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to initialize admin client: {e!s}\")\n            self._admin_adapter = None\n            self._admin_token_expiry = 0\n\n    @property\n    def admin_adapter(self) -&gt; KeycloakAdmin:\n        \"\"\"Get the admin adapter, refreshing it if necessary.\n\n        Returns:\n            KeycloakAdmin instance\n\n        Raises:\n            ValueError: If admin client is not available\n        \"\"\"\n        if not self.configs.CLIENT_SECRET_KEY:\n            raise ValueError(\"Admin client not available, provide client_secret_key to use admin features\")\n\n        # Check if token is about to expire and refresh if needed\n        if self._admin_adapter is None or time.time() &gt;= self._admin_token_expiry:\n            self._initialize_admin_client()\n\n        if self._admin_adapter is None:\n            raise ValueError(\"Failed to initialize admin client\")\n\n        return self._admin_adapter\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\n    async def get_public_key(self) -&gt; Any:\n        \"\"\"Get the public key used to verify tokens.\n\n        Returns:\n            JWK key object used to verify signatures\n        \"\"\"\n        try:\n            from jwcrypto import jwk\n\n            keys_info = await self.openid_adapter.a_public_key()\n            key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n            return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n        except Exception as e:\n            logger.error(f\"Failed to get public key: {e!s}\")\n            raise ValueError(f\"Failed to get public key: {e!s}\")\n\n    @override\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n        Warning:\n            This method uses the direct password grant flow, which is less secure and not recommended\n            for user login in production environments. Instead, prefer the web-based OAuth 2.0\n            Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n            Use this method only for testing, administrative tasks, or specific service accounts\n            where direct credential use is acceptable and properly secured.\n\n        Args:\n            username: User's username\n            password: User's password\n\n        Returns:\n            Token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get token: {e!s}\")\n            raise ValueError(f\"Failed to get token: {e!s}\")\n\n    @override\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\n\n        Args:\n            refresh_token: Refresh token string\n\n        Returns:\n            New token response containing access_token, refresh_token, etc.\n\n        Raises:\n            ValueError: If token refresh fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_refresh_token(refresh_token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to refresh token: {e!s}\")\n            raise ValueError(f\"Failed to refresh token: {e!s}\")\n\n    @override\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\n\n        Args:\n            token: Access token to validate\n\n        Returns:\n            True if token is valid, False otherwise\n        \"\"\"\n        # Not caching validation results as tokens are time-sensitive\n        try:\n            await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n            return True\n        except Exception as e:\n            logger.debug(f\"Token validation failed: {e!s}\")\n            return False\n\n    @override\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\n\n        Args:\n            token: Access token\n\n        Returns:\n            User information\n\n        Raises:\n            ValueError: If getting user info fails\n        \"\"\"\n        if not self.validate_token(token):\n            logger.error(\"Invalid token provided for userinfo request\")\n            raise ValueError(\"Invalid token provided\")\n        try:\n            return await self._get_userinfo_cached(token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user info: {e!s}\")\n            raise ValueError(f\"Failed to get user info: {e!s}\")\n\n    @alru_cache(ttl=30, maxsize=100)  # Cache for 30 seconds\n    async def _get_userinfo_cached(self, token):\n        return await self.openid_adapter.a_userinfo(token)\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If getting user fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_user(user_id)\n        except KeycloakGetError as e:\n            if e.response_code == 404:\n                return None\n            logger.error(f\"Failed to get user by ID: {e!s}\")\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user by ID: {e!s}\")\n            raise ValueError(f\"Failed to get user by ID: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\n\n        Args:\n            username: User's username\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"username\": username})\n            return users[0] if users else None\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user by username: {e!s}\")\n            raise ValueError(f\"Failed to get user by username: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\n\n        Args:\n            email: User's email\n\n        Returns:\n            User details or None if not found\n\n        Raises:\n            ValueError: If query fails\n        \"\"\"\n        try:\n            users = await self.admin_adapter.a_get_users({\"email\": email})\n            return users[0] if users else None\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user by email: {e!s}\")\n            raise ValueError(f\"Failed to get user by email: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n\n        Returns:\n            List of roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get user roles: {e!s}\")\n            raise ValueError(f\"Failed to get user roles: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n\n        Returns:\n            List of client-specific roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client roles: {e!s}\")\n            raise ValueError(f\"Failed to get client roles: {e!s}\")\n\n    @override\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\n\n        Args:\n            token: Access token\n            role_name: Role name to check\n\n        Returns:\n            True if user has the role, False otherwise\n        \"\"\"\n        # Not caching this result as token validation is time-sensitive\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = realm_access.get(\"roles\", [])\n            if role_name in roles:\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = client.get(\"roles\", [])\n                if role_name in client_roles:\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    async def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has any of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Check realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            roles = set(realm_access.get(\"roles\", []))\n            if role_names.intersection(roles):\n                return True\n\n            # Check client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                client_roles = set(client.get(\"roles\", []))\n                if role_names.intersection(client_roles):\n                    return True\n\n            return False\n        except Exception as e:\n            logger.debug(f\"Role check failed: {e!s}\")\n            return False\n\n    @override\n    async def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\n\n        Args:\n            token: Access token\n            role_names: Set of role names to check\n\n        Returns:\n            True if user has all of the roles, False otherwise\n        \"\"\"\n        try:\n            user_info = await self.get_userinfo(token)\n\n            # Get all user roles\n            all_roles = set()\n\n            # Add realm roles\n            realm_access = user_info.get(\"realm_access\", {})\n            all_roles.update(realm_access.get(\"roles\", []))\n\n            # Add client roles\n            resource_access = user_info.get(\"resource_access\", {})\n            for client in resource_access.values():\n                all_roles.update(client.get(\"roles\", []))\n\n            # Check if all required roles are present\n            return role_names.issubset(all_roles)\n        except Exception as e:\n            logger.debug(f\"All roles check failed: {e!s}\")\n            return False\n\n    @override\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\n\n        Args:\n            user_data: User data including username, email, etc.\n\n        Returns:\n            ID of the created user\n\n        Raises:\n            ValueError: If creating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            user_id = await self.admin_adapter.a_create_user(user_data)\n\n            # Clear related caches\n            self.clear_all_caches()\n\n            return user_id\n        except KeycloakError as e:\n            logger.error(f\"Failed to create user: {e!s}\")\n            raise ValueError(f\"Failed to create user: {e!s}\")\n\n    @override\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\n\n        Args:\n            user_id: User's ID\n            user_data: User data to update\n\n        Raises:\n            ValueError: If updating user fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_update_user(user_id, user_data)\n\n            # Clear user-related caches\n            self.clear_all_caches()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to update user: {e!s}\")\n            raise ValueError(f\"Failed to update user: {e!s}\")\n\n    @override\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\n\n        Args:\n            user_id: User's ID\n            password: New password\n            temporary: Whether the password is temporary and should be changed on next login\n\n        Raises:\n            ValueError: If password reset fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n        except KeycloakError as e:\n            logger.error(f\"Failed to reset password: {e!s}\")\n            raise ValueError(f\"Failed to reset password: {e!s}\")\n\n    @override\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to assign realm role: {e!s}\")\n            raise ValueError(f\"Failed to assign realm role: {e!s}\")\n\n    @override\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\n\n        Args:\n            user_id: User's ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get role representation\n            role = await self.admin_adapter.a_get_realm_role(role_name)\n            # Remove role from user\n            await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to remove realm role: {e!s}\")\n            raise ValueError(f\"Failed to remove realm role: {e!s}\")\n\n    @override\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to assign\n\n        Raises:\n            ValueError: If role assignment fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            # Get client\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            # Get role representation\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            # Assign role to user\n            await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n            # Clear role-related caches\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to assign client role: {e!s}\")\n            raise ValueError(f\"Failed to assign client role: {e!s}\")\n\n    @override\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\n\n        Args:\n            role_name: Role name\n            description: Optional role description\n\n        Returns:\n            Created role details\n\n        Raises:\n            ValueError: If role creation fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            role_data = {\"name\": role_name}\n            if description:\n                role_data[\"description\"] = description\n\n            await self.admin_adapter.a_create_realm_role(role_data)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            created_role = await self.admin_adapter.a_get_realm_role(role_name)\n            return created_role\n        except KeycloakError as e:\n            logger.error(f\"Failed to create realm role: {e!s}\")\n            raise ValueError(f\"Failed to create realm role: {e!s}\")\n\n    @override\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\n\n        Args:\n            role_name: Role name to delete\n\n        Raises:\n            ValueError: If role deletion fails\n        \"\"\"\n        # This is a write operation, no caching needed\n        try:\n            await self.admin_adapter.a_delete_realm_role(role_name)\n\n            # Clear realm roles cache\n            if hasattr(self.get_realm_roles, \"clear_cache\"):\n                self.get_realm_roles.clear_cache()\n\n            # We also need to clear user role caches since they might contain this role\n            if hasattr(self.get_user_roles, \"clear_cache\"):\n                self.get_user_roles.clear_cache()\n\n        except KeycloakError as e:\n            logger.error(f\"Failed to delete realm role: {e!s}\")\n            raise ValueError(f\"Failed to delete realm role: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\n\n        Returns:\n            Service account user ID\n\n        Raises:\n            ValueError: If getting service account fails\n        \"\"\"\n        try:\n            client_id = await self.get_client_id(self.configs.CLIENT_ID)\n            service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n            return service_account.get(\"id\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get service account ID: {e!s}\")\n            raise ValueError(f\"Failed to get service account ID: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\n\n        Returns:\n            OIDC configuration\n\n        Raises:\n            ValueError: If getting configuration fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_well_known()\n        except KeycloakError as e:\n            logger.error(f\"Failed to get well-known config: {e!s}\")\n            raise ValueError(f\"Failed to get well-known config: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\n\n        Returns:\n            Certificate information\n\n        Raises:\n            ValueError: If getting certificates fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_certs()\n        except KeycloakError as e:\n            logger.error(f\"Failed to get certificates: {e!s}\")\n            raise ValueError(f\"Failed to get certificates: {e!s}\")\n\n    @override\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\n\n        Args:\n            code: Authorization code\n            redirect_uri: Redirect URI used in authorization request\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token exchange fails\n        \"\"\"\n        # Authorization codes can only be used once, don't cache\n        try:\n            return await self.openid_adapter.a_token(\n                grant_type=\"authorization_code\",\n                code=code,\n                redirect_uri=redirect_uri,\n            )\n        except KeycloakError as e:\n            logger.error(f\"Failed to exchange code for token: {e!s}\")\n            raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n\n    @override\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\n\n        Returns:\n            Token response\n\n        Raises:\n            ValueError: If token acquisition fails\n        \"\"\"\n        # Tokens are time-sensitive, don't cache\n        try:\n            return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client credentials token: {e!s}\")\n            raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n\n    @override\n    @alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\n\n        Args:\n            query: Search query\n            max_results: Maximum number of results to return\n\n        Returns:\n            List of matching users\n\n        Raises:\n            ValueError: If search fails\n        \"\"\"\n        try:\n            # Try searching by different fields\n            users = []\n\n            # Search by username\n            users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n            # Search by email if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n            # Search by firstName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n            # Search by lastName if no results or incomplete results\n            if len(users) &lt; max_results:\n                remaining = max_results - len(users)\n                last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n                # Filter out duplicates\n                user_ids = {user[\"id\"] for user in users}\n                users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n            return users[:max_results]\n        except KeycloakError as e:\n            logger.error(f\"Failed to search users: {e!s}\")\n            raise ValueError(f\"Failed to search users: {e!s}\")\n\n    @override\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n        Args:\n            token: Access token\n            resource: Resource name\n            scope: Permission scope\n\n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        try:\n            # Use UMA permissions endpoint to check specific resource and scope\n            permissions = await self.openid_adapter.a_uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n            # Check if the response indicates permission is granted\n            if not permissions or not isinstance(permissions, list):\n                logger.debug(\"No permissions returned or invalid response format\")\n                return False\n\n            # Look for the specific permission in the response\n            for perm in permissions:\n                if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                    return True\n\n            return False\n        except KeycloakError as e:\n            logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n            return False\n        except Exception as e:\n            logger.error(f\"Unexpected error in permission check: {e!s}\")\n            return False\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\n\n        Args:\n            client_id: Client ID\n\n        Returns:\n            Client secret\n\n        Raises:\n            ValueError: If getting secret fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client(client_id)\n            return client.get(\"secret\", \"\")\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client secret: {e!s}\")\n            raise ValueError(f\"Failed to get client secret: {e!s}\")\n\n    @override\n    @alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\n\n        Args:\n            client_name: Name of the client\n\n        Returns:\n            Client ID\n\n        Raises:\n            ValueError: If client not found\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_client_id(client_name)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get client ID: {e!s}\")\n            raise ValueError(f\"Failed to get client ID: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\n\n        Returns:\n            List of realm roles\n\n        Raises:\n            ValueError: If getting roles fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_roles()\n        except KeycloakError as e:\n            logger.error(f\"Failed to get realm roles: {e!s}\")\n            raise ValueError(f\"Failed to get realm roles: {e!s}\")\n\n    @override\n    @alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\n\n        Args:\n            role_name: Role name\n        Returns:\n            A realm role\n\n        Raises:\n            ValueError: If getting role fails\n        \"\"\"\n        try:\n            return await self.admin_adapter.a_get_realm_role(role_name)\n        except KeycloakError as e:\n            logger.error(f\"Failed to get realm role: {e!s}\")\n            raise ValueError(f\"Failed to get realm role: {e!s}\")\n\n    @override\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\n\n        Args:\n            user_id: User's ID\n            client_id: Client ID\n            role_name: Role name to remove\n\n        Raises:\n            ValueError: If role removal fails\n        \"\"\"\n        try:\n            client = await self.admin_adapter.a_get_client_id(client_id)\n            role = await self.admin_adapter.a_get_client_role(client, role_name)\n            await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n            if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n                self.get_client_roles_for_user.clear_cache()\n        except KeycloakError as e:\n            logger.error(f\"Failed to remove client role: {e!s}\")\n            raise ValueError(f\"Failed to remove client role: {e!s}\")\n\n    @override\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\n\n        Args:\n            user_id: User's ID\n\n        Raises:\n            ValueError: If clearing sessions fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_user_logout(user_id)\n        except KeycloakError as e:\n            logger.error(f\"Failed to clear user sessions: {e!s}\")\n            raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n\n    @override\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\n\n        Args:\n            refresh_token: Refresh token to invalidate\n\n        Raises:\n            ValueError: If logout fails\n        \"\"\"\n        try:\n            await self.openid_adapter.a_logout(refresh_token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to logout: {e!s}\")\n            raise ValueError(f\"Failed to logout: {e!s}\")\n\n    @override\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Token introspection details\n\n        Raises:\n            ValueError: If token introspection fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_introspect(token)\n        except KeycloakError as e:\n            logger.error(f\"Failed to introspect token: {e!s}\")\n            raise ValueError(f\"Failed to introspect token: {e!s}\")\n\n    @override\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\n\n        Args:\n            token: Access token\n\n        Returns:\n            Dictionary of token claims\n\n        Raises:\n            ValueError: If token decoding fails\n        \"\"\"\n        try:\n            return await self.openid_adapter.a_decode_token(\n                token,\n                key=await self.get_public_key(),\n            )\n        except KeycloakError as e:\n            logger.error(f\"Failed to get token info: {e!s}\")\n            raise ValueError(f\"Failed to get token info: {e!s}\")\n\n    @override\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\n\n        Args:\n            user_id: The ID of the user to delete\n\n        Raises:\n            ValueError: If the deletion fails\n        \"\"\"\n        try:\n            await self.admin_adapter.a_delete_user(user_id=user_id)\n            logger.info(f\"Successfully deleted user with ID {user_id}\")\n        except Exception as e:\n            logger.error(f\"Failed to delete user with ID {user_id}: {e!s}\")\n            raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.admin_adapter</code>  <code>property</code>","text":"<p>Get the admin adapter, refreshing it if necessary.</p> <p>Returns:</p> Type Description <code>KeycloakAdmin</code> <p>KeycloakAdmin instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If admin client is not available</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.__init__(keycloak_configs=None)</code>","text":"<p>Initialize KeycloakAdapter with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_configs</code> <code>KeycloakConfig | None</code> <p>Optional Keycloak configuration. If None, global config is used.</p> <code>None</code> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def __init__(self, keycloak_configs: KeycloakConfig | None = None) -&gt; None:\n    \"\"\"Initialize KeycloakAdapter with configuration.\n\n    Args:\n        keycloak_configs: Optional Keycloak configuration. If None, global config is used.\n    \"\"\"\n    self.configs: KeycloakConfig = (\n        BaseConfig.global_config().KEYCLOAK if keycloak_configs is None else keycloak_configs\n    )\n\n    # Initialize the OpenID client for authentication\n    self.openid_adapter = self._get_openid_client(self.configs)\n\n    # Cache for admin client to avoid unnecessary re-authentication\n    self._admin_adapter = None\n    self._admin_token_expiry = 0\n\n    # Initialize admin client with service account if client_secret is provided\n    if self.configs.CLIENT_SECRET_KEY:\n        self._initialize_admin_client()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_all_caches()</code>","text":"<p>Clear all cached values.</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>def clear_all_caches(self) -&gt; None:\n    \"\"\"Clear all cached values.\"\"\"\n    for attr_name in dir(self):\n        attr = getattr(self, attr_name)\n        if hasattr(attr, \"clear_cache\"):\n            attr.clear_cache()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_public_key()</code>  <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> <p>Returns:</p> Type Description <code>Any</code> <p>JWK key object used to verify signatures</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour, public key rarely changes\nasync def get_public_key(self) -&gt; Any:\n    \"\"\"Get the public key used to verify tokens.\n\n    Returns:\n        JWK key object used to verify signatures\n    \"\"\"\n    try:\n        from jwcrypto import jwk\n\n        keys_info = await self.openid_adapter.a_public_key()\n        key = f\"-----BEGIN PUBLIC KEY-----\\n{keys_info}\\n-----END PUBLIC KEY-----\"\n        return jwk.JWK.from_pem(key.encode(\"utf-8\"))\n    except Exception as e:\n        logger.error(f\"Failed to get public key: {e!s}\")\n        raise ValueError(f\"Failed to get public key: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token(username, password)</code>  <code>async</code>","text":"<p>Get a user token by username and password using the Resource Owner Password Credentials Grant.</p> Warning <p>This method uses the direct password grant flow, which is less secure and not recommended for user login in production environments. Instead, prefer the web-based OAuth 2.0 Authorization Code Flow (use <code>get_token_from_code</code>) for secure authentication. Use this method only for testing, administrative tasks, or specific service accounts where direct credential use is acceptable and properly secured.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <code>password</code> <code>str</code> <p>User's password</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password using the Resource Owner Password Credentials Grant.\n\n    Warning:\n        This method uses the direct password grant flow, which is less secure and not recommended\n        for user login in production environments. Instead, prefer the web-based OAuth 2.0\n        Authorization Code Flow (use `get_token_from_code`) for secure authentication.\n        Use this method only for testing, administrative tasks, or specific service accounts\n        where direct credential use is acceptable and properly secured.\n\n    Args:\n        username: User's username\n        password: User's password\n\n    Returns:\n        Token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"password\", username=username, password=password)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get token: {e!s}\")\n        raise ValueError(f\"Failed to get token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.refresh_token(refresh_token)</code>  <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token string</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>New token response containing access_token, refresh_token, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token refresh fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\n\n    Args:\n        refresh_token: Refresh token string\n\n    Returns:\n        New token response containing access_token, refresh_token, etc.\n\n    Raises:\n        ValueError: If token refresh fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_refresh_token(refresh_token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to refresh token: {e!s}\")\n        raise ValueError(f\"Failed to refresh token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.validate_token(token)</code>  <code>async</code>","text":"<p>Validate if a token is still valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if token is valid, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\n\n    Args:\n        token: Access token to validate\n\n    Returns:\n        True if token is valid, False otherwise\n    \"\"\"\n    # Not caching validation results as tokens are time-sensitive\n    try:\n        await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n        return True\n    except Exception as e:\n        logger.debug(f\"Token validation failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_userinfo(token)</code>  <code>async</code>","text":"<p>Get user information from a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>KeycloakUserType</code> <p>User information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user info fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\n\n    Args:\n        token: Access token\n\n    Returns:\n        User information\n\n    Raises:\n        ValueError: If getting user info fails\n    \"\"\"\n    if not self.validate_token(token):\n        logger.error(\"Invalid token provided for userinfo request\")\n        raise ValueError(\"Invalid token provided\")\n    try:\n        return await self._get_userinfo_cached(token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user info: {e!s}\")\n        raise ValueError(f\"Failed to get user info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_id(user_id)</code>  <code>async</code>","text":"<p>Get user details by user ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If getting user fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_user(user_id)\n    except KeycloakGetError as e:\n        if e.response_code == 404:\n            return None\n        logger.error(f\"Failed to get user by ID: {e!s}\")\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user by ID: {e!s}\")\n        raise ValueError(f\"Failed to get user by ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_username(username)</code>  <code>async</code>","text":"<p>Get user details by username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User's username</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\n\n    Args:\n        username: User's username\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"username\": username})\n        return users[0] if users else None\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user by username: {e!s}\")\n        raise ValueError(f\"Failed to get user by username: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_by_email(email)</code>  <code>async</code>","text":"<p>Get user details by email.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>User's email</p> required <p>Returns:</p> Type Description <code>KeycloakUserType | None</code> <p>User details or None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If query fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\n\n    Args:\n        email: User's email\n\n    Returns:\n        User details or None if not found\n\n    Raises:\n        ValueError: If query fails\n    \"\"\"\n    try:\n        users = await self.admin_adapter.a_get_users({\"email\": email})\n        return users[0] if users else None\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user by email: {e!s}\")\n        raise ValueError(f\"Failed to get user by email: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_user_roles(user_id)</code>  <code>async</code>","text":"<p>Get roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n\n    Returns:\n        List of roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles_of_user(user_id)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get user roles: {e!s}\")\n        raise ValueError(f\"Failed to get user roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_roles_for_user(user_id, client_id)</code>  <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>list[KeycloakRoleType]</code> <p>List of client-specific roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=100)  # Cache for 5 minutes\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n\n    Returns:\n        List of client-specific roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_roles_of_user(user_id, client_id)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client roles: {e!s}\")\n        raise ValueError(f\"Failed to get client roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_role(token, role_name)</code>  <code>async</code>","text":"<p>Check if a user has a specific role.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_name</code> <code>str</code> <p>Role name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has the role, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\n\n    Args:\n        token: Access token\n        role_name: Role name to check\n\n    Returns:\n        True if user has the role, False otherwise\n    \"\"\"\n    # Not caching this result as token validation is time-sensitive\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = realm_access.get(\"roles\", [])\n        if role_name in roles:\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = client.get(\"roles\", [])\n            if role_name in client_roles:\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_any_of_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has any of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_any_of_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has any of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Check realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        roles = set(realm_access.get(\"roles\", []))\n        if role_names.intersection(roles):\n            return True\n\n        # Check client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            client_roles = set(client.get(\"roles\", []))\n            if role_names.intersection(client_roles):\n                return True\n\n        return False\n    except Exception as e:\n        logger.debug(f\"Role check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.has_all_roles(token, role_names)</code>  <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>role_names</code> <code>set[str]</code> <p>Set of role names to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if user has all of the roles, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\n\n    Args:\n        token: Access token\n        role_names: Set of role names to check\n\n    Returns:\n        True if user has all of the roles, False otherwise\n    \"\"\"\n    try:\n        user_info = await self.get_userinfo(token)\n\n        # Get all user roles\n        all_roles = set()\n\n        # Add realm roles\n        realm_access = user_info.get(\"realm_access\", {})\n        all_roles.update(realm_access.get(\"roles\", []))\n\n        # Add client roles\n        resource_access = user_info.get(\"resource_access\", {})\n        for client in resource_access.values():\n            all_roles.update(client.get(\"roles\", []))\n\n        # Check if all required roles are present\n        return role_names.issubset(all_roles)\n    except Exception as e:\n        logger.debug(f\"All roles check failed: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_user(user_data)</code>  <code>async</code>","text":"<p>Create a new user in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>dict[str, Any]</code> <p>User data including username, email, etc.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created user</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If creating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\n\n    Args:\n        user_data: User data including username, email, etc.\n\n    Returns:\n        ID of the created user\n\n    Raises:\n        ValueError: If creating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        user_id = await self.admin_adapter.a_create_user(user_data)\n\n        # Clear related caches\n        self.clear_all_caches()\n\n        return user_id\n    except KeycloakError as e:\n        logger.error(f\"Failed to create user: {e!s}\")\n        raise ValueError(f\"Failed to create user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.update_user(user_id, user_data)</code>  <code>async</code>","text":"<p>Update user details.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>user_data</code> <code>dict[str, Any]</code> <p>User data to update</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If updating user fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\n\n    Args:\n        user_id: User's ID\n        user_data: User data to update\n\n    Raises:\n        ValueError: If updating user fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_update_user(user_id, user_data)\n\n        # Clear user-related caches\n        self.clear_all_caches()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to update user: {e!s}\")\n        raise ValueError(f\"Failed to update user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.reset_password(user_id, password, temporary=False)</code>  <code>async</code>","text":"<p>Reset a user's password.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>password</code> <code>str</code> <p>New password</p> required <code>temporary</code> <code>bool</code> <p>Whether the password is temporary and should be changed on next login</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If password reset fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\n\n    Args:\n        user_id: User's ID\n        password: New password\n        temporary: Whether the password is temporary and should be changed on next login\n\n    Raises:\n        ValueError: If password reset fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_set_user_password(user_id, password, temporary)\n    except KeycloakError as e:\n        logger.error(f\"Failed to reset password: {e!s}\")\n        raise ValueError(f\"Failed to reset password: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Assign a realm role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_realm_roles(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to assign realm role: {e!s}\")\n        raise ValueError(f\"Failed to assign realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_realm_role(user_id, role_name)</code>  <code>async</code>","text":"<p>Remove a realm role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\n\n    Args:\n        user_id: User's ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get role representation\n        role = await self.admin_adapter.a_get_realm_role(role_name)\n        # Remove role from user\n        await self.admin_adapter.a_delete_realm_roles_of_user(user_id, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to remove realm role: {e!s}\")\n        raise ValueError(f\"Failed to remove realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.assign_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to assign</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role assignment fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to assign\n\n    Raises:\n        ValueError: If role assignment fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        # Get client\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        # Get role representation\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        # Assign role to user\n        await self.admin_adapter.a_assign_client_role(user_id, client, [role])\n\n        # Clear role-related caches\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to assign client role: {e!s}\")\n        raise ValueError(f\"Failed to assign client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.create_realm_role(role_name, description=None)</code>  <code>async</code>","text":"<p>Create a new realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <code>description</code> <code>str | None</code> <p>Optional role description</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Created role details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If role creation fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\n\n    Args:\n        role_name: Role name\n        description: Optional role description\n\n    Returns:\n        Created role details\n\n    Raises:\n        ValueError: If role creation fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        role_data = {\"name\": role_name}\n        if description:\n            role_data[\"description\"] = description\n\n        await self.admin_adapter.a_create_realm_role(role_data)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        created_role = await self.admin_adapter.a_get_realm_role(role_name)\n        return created_role\n    except KeycloakError as e:\n        logger.error(f\"Failed to create realm role: {e!s}\")\n        raise ValueError(f\"Failed to create realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_realm_role(role_name)</code>  <code>async</code>","text":"<p>Delete a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\n\n    Args:\n        role_name: Role name to delete\n\n    Raises:\n        ValueError: If role deletion fails\n    \"\"\"\n    # This is a write operation, no caching needed\n    try:\n        await self.admin_adapter.a_delete_realm_role(role_name)\n\n        # Clear realm roles cache\n        if hasattr(self.get_realm_roles, \"clear_cache\"):\n            self.get_realm_roles.clear_cache()\n\n        # We also need to clear user role caches since they might contain this role\n        if hasattr(self.get_user_roles, \"clear_cache\"):\n            self.get_user_roles.clear_cache()\n\n    except KeycloakError as e:\n        logger.error(f\"Failed to delete realm role: {e!s}\")\n        raise ValueError(f\"Failed to delete realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_service_account_id()</code>  <code>async</code>","text":"<p>Get service account user ID for the current client.</p> <p>Returns:</p> Type Description <code>str</code> <p>Service account user ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting service account fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\n\n    Returns:\n        Service account user ID\n\n    Raises:\n        ValueError: If getting service account fails\n    \"\"\"\n    try:\n        client_id = await self.get_client_id(self.configs.CLIENT_ID)\n        service_account = await self.admin_adapter.a_get_client_service_account_user(client_id)\n        return service_account.get(\"id\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get service account ID: {e!s}\")\n        raise ValueError(f\"Failed to get service account ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_well_known_config()</code>  <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>OIDC configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting configuration fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\n\n    Returns:\n        OIDC configuration\n\n    Raises:\n        ValueError: If getting configuration fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_well_known()\n    except KeycloakError as e:\n        logger.error(f\"Failed to get well-known config: {e!s}\")\n        raise ValueError(f\"Failed to get well-known config: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_certs()</code>  <code>async</code>","text":"<p>Get the JWT verification certificates.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Certificate information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting certificates fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=1)  # Cache for 1 hour\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\n\n    Returns:\n        Certificate information\n\n    Raises:\n        ValueError: If getting certificates fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_certs()\n    except KeycloakError as e:\n        logger.error(f\"Failed to get certificates: {e!s}\")\n        raise ValueError(f\"Failed to get certificates: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_from_code(code, redirect_uri)</code>  <code>async</code>","text":"<p>Exchange authorization code for token.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Authorization code</p> required <code>redirect_uri</code> <code>str</code> <p>Redirect URI used in authorization request</p> required <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token exchange fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\n\n    Args:\n        code: Authorization code\n        redirect_uri: Redirect URI used in authorization request\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token exchange fails\n    \"\"\"\n    # Authorization codes can only be used once, don't cache\n    try:\n        return await self.openid_adapter.a_token(\n            grant_type=\"authorization_code\",\n            code=code,\n            redirect_uri=redirect_uri,\n        )\n    except KeycloakError as e:\n        logger.error(f\"Failed to exchange code for token: {e!s}\")\n        raise ValueError(f\"Failed to exchange code for token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_credentials_token()</code>  <code>async</code>","text":"<p>Get token using client credentials.</p> <p>Returns:</p> Type Description <code>KeycloakTokenType</code> <p>Token response</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token acquisition fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\n\n    Returns:\n        Token response\n\n    Raises:\n        ValueError: If token acquisition fails\n    \"\"\"\n    # Tokens are time-sensitive, don't cache\n    try:\n        return await self.openid_adapter.a_token(grant_type=\"client_credentials\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client credentials token: {e!s}\")\n        raise ValueError(f\"Failed to get client credentials token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.search_users(query, max_results=100)</code>  <code>async</code>","text":"<p>Search for users by username, email, or name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>max_results</code> <code>int</code> <p>Maximum number of results to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[KeycloakUserType]</code> <p>List of matching users</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If search fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=30, maxsize=50)  # Cache for 30 seconds with limited entries\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\n\n    Args:\n        query: Search query\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of matching users\n\n    Raises:\n        ValueError: If search fails\n    \"\"\"\n    try:\n        # Try searching by different fields\n        users = []\n\n        # Search by username\n        users.extend(await self.admin_adapter.a_get_users({\"username\": query, \"max\": max_results}))\n\n        # Search by email if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            email_users = await self.admin_adapter.a_get_users({\"email\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in email_users if user[\"id\"] not in user_ids])\n\n        # Search by firstName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            first_name_users = await self.admin_adapter.a_get_users({\"firstName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in first_name_users if user[\"id\"] not in user_ids])\n\n        # Search by lastName if no results or incomplete results\n        if len(users) &lt; max_results:\n            remaining = max_results - len(users)\n            last_name_users = await self.admin_adapter.a_get_users({\"lastName\": query, \"max\": remaining})\n            # Filter out duplicates\n            user_ids = {user[\"id\"] for user in users}\n            users.extend([user for user in last_name_users if user[\"id\"] not in user_ids])\n\n        return users[:max_results]\n    except KeycloakError as e:\n        logger.error(f\"Failed to search users: {e!s}\")\n        raise ValueError(f\"Failed to search users: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.check_permissions(token, resource, scope)</code>  <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <code>resource</code> <code>str</code> <p>Resource name</p> required <code>scope</code> <code>str</code> <p>Permission scope</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if permission granted, False otherwise</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\n\n    Args:\n        token: Access token\n        resource: Resource name\n        scope: Permission scope\n\n    Returns:\n        True if permission granted, False otherwise\n    \"\"\"\n    try:\n        # Use UMA permissions endpoint to check specific resource and scope\n        permissions = await self.openid_adapter.a_uma_permissions(token, permissions=[f\"{resource}#{scope}\"])\n\n        # Check if the response indicates permission is granted\n        if not permissions or not isinstance(permissions, list):\n            logger.debug(\"No permissions returned or invalid response format\")\n            return False\n\n        # Look for the specific permission in the response\n        for perm in permissions:\n            if perm.get(\"rsname\") == resource and scope in perm.get(\"scopes\", []):\n                return True\n\n        return False\n    except KeycloakError as e:\n        logger.debug(f\"Permission check failed with Keycloak error: {e!s}\")\n        return False\n    except Exception as e:\n        logger.error(f\"Unexpected error in permission check: {e!s}\")\n        return False\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_secret(client_id)</code>  <code>async</code>","text":"<p>Get client secret.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client secret</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting secret fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\n\n    Args:\n        client_id: Client ID\n\n    Returns:\n        Client secret\n\n    Raises:\n        ValueError: If getting secret fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client(client_id)\n        return client.get(\"secret\", \"\")\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client secret: {e!s}\")\n        raise ValueError(f\"Failed to get client secret: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_client_id(client_name)</code>  <code>async</code>","text":"<p>Get client ID by client name.</p> <p>Parameters:</p> Name Type Description Default <code>client_name</code> <code>str</code> <p>Name of the client</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client ID</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If client not found</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=3600, maxsize=50)  # Cache for 1 hour\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\n\n    Args:\n        client_name: Name of the client\n\n    Returns:\n        Client ID\n\n    Raises:\n        ValueError: If client not found\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_client_id(client_name)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get client ID: {e!s}\")\n        raise ValueError(f\"Failed to get client ID: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_roles()</code>  <code>async</code>","text":"<p>Get all realm roles.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of realm roles</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting roles fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\n\n    Returns:\n        List of realm roles\n\n    Raises:\n        ValueError: If getting roles fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_roles()\n    except KeycloakError as e:\n        logger.error(f\"Failed to get realm roles: {e!s}\")\n        raise ValueError(f\"Failed to get realm roles: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_realm_role(role_name)</code>  <code>async</code>","text":"<p>Get realm role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Role name</p> required <p>Returns:     A realm role</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If getting role fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\n@alru_cache(ttl=300, maxsize=1)  # Cache for 5 minutes\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\n\n    Args:\n        role_name: Role name\n    Returns:\n        A realm role\n\n    Raises:\n        ValueError: If getting role fails\n    \"\"\"\n    try:\n        return await self.admin_adapter.a_get_realm_role(role_name)\n    except KeycloakError as e:\n        logger.error(f\"Failed to get realm role: {e!s}\")\n        raise ValueError(f\"Failed to get realm role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.remove_client_role(user_id, client_id, role_name)</code>  <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <code>client_id</code> <code>str</code> <p>Client ID</p> required <code>role_name</code> <code>str</code> <p>Role name to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If role removal fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\n\n    Args:\n        user_id: User's ID\n        client_id: Client ID\n        role_name: Role name to remove\n\n    Raises:\n        ValueError: If role removal fails\n    \"\"\"\n    try:\n        client = await self.admin_adapter.a_get_client_id(client_id)\n        role = await self.admin_adapter.a_get_client_role(client, role_name)\n        await self.admin_adapter.a_delete_client_roles_of_user(user_id, client, [role])\n\n        if hasattr(self.get_client_roles_for_user, \"clear_cache\"):\n            self.get_client_roles_for_user.clear_cache()\n    except KeycloakError as e:\n        logger.error(f\"Failed to remove client role: {e!s}\")\n        raise ValueError(f\"Failed to remove client role: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.clear_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Clear all sessions for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User's ID</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If clearing sessions fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\n\n    Args:\n        user_id: User's ID\n\n    Raises:\n        ValueError: If clearing sessions fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_user_logout(user_id)\n    except KeycloakError as e:\n        logger.error(f\"Failed to clear user sessions: {e!s}\")\n        raise ValueError(f\"Failed to clear user sessions: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.logout(refresh_token)</code>  <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>Refresh token to invalidate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If logout fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\n\n    Args:\n        refresh_token: Refresh token to invalidate\n\n    Raises:\n        ValueError: If logout fails\n    \"\"\"\n    try:\n        await self.openid_adapter.a_logout(refresh_token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to logout: {e!s}\")\n        raise ValueError(f\"Failed to logout: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.introspect_token(token)</code>  <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Token introspection details</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token introspection fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Token introspection details\n\n    Raises:\n        ValueError: If token introspection fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_introspect(token)\n    except KeycloakError as e:\n        logger.error(f\"Failed to introspect token: {e!s}\")\n        raise ValueError(f\"Failed to introspect token: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.get_token_info(token)</code>  <code>async</code>","text":"<p>Decode token to get its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Access token</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of token claims</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If token decoding fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\n\n    Args:\n        token: Access token\n\n    Returns:\n        Dictionary of token claims\n\n    Raises:\n        ValueError: If token decoding fails\n    \"\"\"\n    try:\n        return await self.openid_adapter.a_decode_token(\n            token,\n            key=await self.get_public_key(),\n        )\n    except KeycloakError as e:\n        logger.error(f\"Failed to get token info: {e!s}\")\n        raise ValueError(f\"Failed to get token info: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user","title":"<code>archipy.adapters.keycloak.adapters.AsyncKeycloakAdapter.delete_user(user_id)</code>  <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to delete</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the deletion fails</p> Source code in <code>archipy/adapters/keycloak/adapters.py</code> <pre><code>@override\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\n\n    Args:\n        user_id: The ID of the user to delete\n\n    Raises:\n        ValueError: If the deletion fails\n    \"\"\"\n    try:\n        await self.admin_adapter.a_delete_user(user_id=user_id)\n        logger.info(f\"Successfully deleted user with ID {user_id}\")\n    except Exception as e:\n        logger.error(f\"Failed to delete user with ID {user_id}: {e!s}\")\n        raise ValueError(f\"Failed to delete user: {e!s}\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports","title":"<code>archipy.adapters.keycloak.ports</code>","text":"<p>Keycloak port definitions for ArchiPy.</p>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort</code>","text":"<p>Interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class KeycloakPort:\n    \"\"\"Interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_any_of_roles(self, token: str, role_names: list[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    def get_public_key(self) -&gt; Any:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.validate_token(token)</code>  <code>abstractmethod</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_any_of_roles(self, token: str, role_names: list[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_public_key()</code>  <code>abstractmethod</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_public_key(self) -&gt; Any:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_certs()</code>  <code>abstractmethod</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.KeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.KeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\ndef delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort</code>","text":"<p>Asynchronous interface for Keycloak operations providing a standardized access pattern.</p> <p>This interface defines the contract for async Keycloak adapters, ensuring consistent implementation of Keycloak operations across different adapters. It covers essential functionality including authentication, user management, and role management.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>class AsyncKeycloakPort:\n    \"\"\"Asynchronous interface for Keycloak operations providing a standardized access pattern.\n\n    This interface defines the contract for async Keycloak adapters, ensuring consistent\n    implementation of Keycloak operations across different adapters. It covers essential\n    functionality including authentication, user management, and role management.\n    \"\"\"\n\n    # Token Operations\n    @abstractmethod\n    async def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n        \"\"\"Get a user token by username and password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n        \"\"\"Refresh an existing token using a refresh token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def validate_token(self, token: str) -&gt; bool:\n        \"\"\"Validate if a token is still valid.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n        \"\"\"Get user information from a token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_token_info(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Decode token to get its claims.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def introspect_token(self, token: str) -&gt; dict[str, Any]:\n        \"\"\"Introspect token to get detailed information about it.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n        \"\"\"Get token using client credentials.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def logout(self, refresh_token: str) -&gt; None:\n        \"\"\"Logout user by invalidating their refresh token.\"\"\"\n        raise NotImplementedError\n\n    # User Operations\n    @abstractmethod\n    async def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by user ID.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by username.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n        \"\"\"Get user details by email.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_user(self, user_data: dict[str, Any]) -&gt; str:\n        \"\"\"Create a new user in Keycloak.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n        \"\"\"Update user details.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n        \"\"\"Reset a user's password.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n        \"\"\"Search for users by username, email, or name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def clear_user_sessions(self, user_id: str) -&gt; None:\n        \"\"\"Clear all sessions for a user.\"\"\"\n        raise NotImplementedError\n\n    # Role Operations\n    @abstractmethod\n    async def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n        \"\"\"Get client-specific roles assigned to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_role(self, token: str, role_name: str) -&gt; bool:\n        \"\"\"Check if a user has a specific role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_any_of_roles(self, token: str, role_names: list[str]) -&gt; bool:\n        \"\"\"Check if a user has any of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n        \"\"\"Check if a user has all of the specified roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a realm role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a realm role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Assign a client-specific role to a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n        \"\"\"Remove a client-specific role from a user.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_role(self, role_name: str) -&gt; dict:\n        \"\"\"Get realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all realm roles.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Create a new realm role.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_realm_role(self, role_name: str) -&gt; None:\n        \"\"\"Delete a realm role.\"\"\"\n        raise NotImplementedError\n\n    # Client Operations\n    @abstractmethod\n    async def get_client_id(self, client_name: str) -&gt; str:\n        \"\"\"Get client ID by client name.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_client_secret(self, client_id: str) -&gt; str:\n        \"\"\"Get client secret.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_service_account_id(self) -&gt; str:\n        \"\"\"Get service account user ID for the current client.\"\"\"\n        raise NotImplementedError\n\n    # System Operations\n    @abstractmethod\n    async def get_public_key(self) -&gt; Any:\n        \"\"\"Get the public key used to verify tokens.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_well_known_config(self) -&gt; dict[str, Any]:\n        \"\"\"Get the well-known OpenID configuration.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get_certs(self) -&gt; dict[str, Any]:\n        \"\"\"Get the JWT verification certificates.\"\"\"\n        raise NotImplementedError\n\n    # Authorization\n    @abstractmethod\n    async def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n        \"\"\"Exchange authorization code for token.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n        \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_user(self, user_id: str) -&gt; None:\n        \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token(username, password)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get a user token by username and password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token(self, username: str, password: str) -&gt; KeycloakTokenType:\n    \"\"\"Get a user token by username and password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.refresh_token(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Refresh an existing token using a refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def refresh_token(self, refresh_token: str) -&gt; KeycloakTokenType:\n    \"\"\"Refresh an existing token using a refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.validate_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Validate if a token is still valid.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def validate_token(self, token: str) -&gt; bool:\n    \"\"\"Validate if a token is still valid.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_userinfo(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user information from a token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_userinfo(self, token: str) -&gt; KeycloakUserType:\n    \"\"\"Get user information from a token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_info(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Decode token to get its claims.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_info(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Decode token to get its claims.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.introspect_token(token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Introspect token to get detailed information about it.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def introspect_token(self, token: str) -&gt; dict[str, Any]:\n    \"\"\"Introspect token to get detailed information about it.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_credentials_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get token using client credentials.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_credentials_token(self) -&gt; KeycloakTokenType:\n    \"\"\"Get token using client credentials.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.logout(refresh_token)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Logout user by invalidating their refresh token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def logout(self, refresh_token: str) -&gt; None:\n    \"\"\"Logout user by invalidating their refresh token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_id(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by user ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_id(self, user_id: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by user ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_username(username)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by username.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_username(self, username: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by username.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_by_email(email)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get user details by email.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_by_email(self, email: str) -&gt; KeycloakUserType | None:\n    \"\"\"Get user details by email.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_user(user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new user in Keycloak.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_user(self, user_data: dict[str, Any]) -&gt; str:\n    \"\"\"Create a new user in Keycloak.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.update_user(user_id, user_data)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Update user details.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def update_user(self, user_id: str, user_data: dict[str, Any]) -&gt; None:\n    \"\"\"Update user details.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.reset_password(user_id, password, temporary=False)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Reset a user's password.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def reset_password(self, user_id: str, password: str, temporary: bool = False) -&gt; None:\n    \"\"\"Reset a user's password.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.search_users(query, max_results=100)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Search for users by username, email, or name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def search_users(self, query: str, max_results: int = 100) -&gt; list[KeycloakUserType]:\n    \"\"\"Search for users by username, email, or name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.clear_user_sessions(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Clear all sessions for a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def clear_user_sessions(self, user_id: str) -&gt; None:\n    \"\"\"Clear all sessions for a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_user_roles(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_user_roles(self, user_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_roles_for_user(user_id, client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client-specific roles assigned to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_roles_for_user(self, user_id: str, client_id: str) -&gt; list[KeycloakRoleType]:\n    \"\"\"Get client-specific roles assigned to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_role(token, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has a specific role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_role(self, token: str, role_name: str) -&gt; bool:\n    \"\"\"Check if a user has a specific role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_any_of_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has any of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_any_of_roles(self, token: str, role_names: list[str]) -&gt; bool:\n    \"\"\"Check if a user has any of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.has_all_roles(token, role_names)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has all of the specified roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def has_all_roles(self, token: str, role_names: set[str]) -&gt; bool:\n    \"\"\"Check if a user has all of the specified roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a realm role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a realm role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_realm_role(user_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a realm role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_realm_role(self, user_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a realm role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.assign_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Assign a client-specific role to a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def assign_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Assign a client-specific role to a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.remove_client_role(user_id, client_id, role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Remove a client-specific role from a user.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def remove_client_role(self, user_id: str, client_id: str, role_name: str) -&gt; None:\n    \"\"\"Remove a client-specific role from a user.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_role(self, role_name: str) -&gt; dict:\n    \"\"\"Get realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_realm_roles()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get all realm roles.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_realm_roles(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all realm roles.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.create_realm_role(role_name, description=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def create_realm_role(self, role_name: str, description: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_realm_role(role_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a realm role.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_realm_role(self, role_name: str) -&gt; None:\n    \"\"\"Delete a realm role.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_id(client_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client ID by client name.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_id(self, client_name: str) -&gt; str:\n    \"\"\"Get client ID by client name.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_client_secret(client_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get client secret.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_client_secret(self, client_id: str) -&gt; str:\n    \"\"\"Get client secret.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_service_account_id()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get service account user ID for the current client.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_service_account_id(self) -&gt; str:\n    \"\"\"Get service account user ID for the current client.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_public_key()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the public key used to verify tokens.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_public_key(self) -&gt; Any:\n    \"\"\"Get the public key used to verify tokens.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_well_known_config()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the well-known OpenID configuration.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_well_known_config(self) -&gt; dict[str, Any]:\n    \"\"\"Get the well-known OpenID configuration.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_certs()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get the JWT verification certificates.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_certs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the JWT verification certificates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.get_token_from_code(code, redirect_uri)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Exchange authorization code for token.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def get_token_from_code(self, code: str, redirect_uri: str) -&gt; KeycloakTokenType:\n    \"\"\"Exchange authorization code for token.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.check_permissions(token, resource, scope)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a user has permission to access a resource with the specified scope.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def check_permissions(self, token: str, resource: str, scope: str) -&gt; bool:\n    \"\"\"Check if a user has permission to access a resource with the specified scope.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user","title":"<code>archipy.adapters.keycloak.ports.AsyncKeycloakPort.delete_user(user_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a user from Keycloak by their ID.</p> Source code in <code>archipy/adapters/keycloak/ports.py</code> <pre><code>@abstractmethod\nasync def delete_user(self, user_id: str) -&gt; None:\n    \"\"\"Delete a user from Keycloak by their ID.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#orm","title":"ORM","text":"<p>Object-Relational Mapping adapters, primarily for SQLAlchemy integration.</p> <pre><code>from archipy.adapters.orm.sqlalchemy import SQLAlchemyAdapter, SQLAlchemySessionManager\n\n# Create session manager\nsession_manager = SQLAlchemySessionManager(connection_string=\"postgresql://user:pass@localhost/db\")\n\n# Create an ORM adapter\norm_adapter = SQLAlchemyAdapter(session_manager=session_manager)\n\n# Use the adapter\nusers = orm_adapter.query(User).filter(User.active == True).all()\n</code></pre>"},{"location":"api_reference/adapters/#sqlalchemy-components","title":"SQLAlchemy Components","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters","title":"<code>archipy.adapters.orm.sqlalchemy.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyFilterMixin","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyFilterMixin</code>","text":"<p>Mixin providing filtering capabilities for SQLAlchemy queries.</p> <p>This mixin provides methods to apply various filters to SQLAlchemy queries, supporting a wide range of comparison operators for different data types.</p> <p>The filtering functionality supports: - Equality/inequality comparisons - Greater than/less than operations - String operations (LIKE, ILIKE, startswith, endswith) - List operations (IN, NOT IN) - NULL checks</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from sqlalchemy import select\n&gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyFilterMixin\n&gt;&gt;&gt; from archipy.models.types.base_types import FilterOperationType\n&gt;&gt;&gt;\n&gt;&gt;&gt; class UserRepository(SqlAlchemyFilterMixin):\n...     def find_active_users_by_name(self, name_fragment):\n...         query = select(User)\n...         query = self._apply_filter(\n...             query,\n...             User.name,\n...             name_fragment,\n...             FilterOperationType.ILIKE\n...         )\n...         query = self._apply_filter(\n...             query,\n...             User.is_active,\n...             True,\n...             FilterOperationType.EQUAL\n...         )\n...         return query\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class SqlAlchemyFilterMixin:\n    \"\"\"Mixin providing filtering capabilities for SQLAlchemy queries.\n\n    This mixin provides methods to apply various filters to SQLAlchemy queries,\n    supporting a wide range of comparison operators for different data types.\n\n    The filtering functionality supports:\n    - Equality/inequality comparisons\n    - Greater than/less than operations\n    - String operations (LIKE, ILIKE, startswith, endswith)\n    - List operations (IN, NOT IN)\n    - NULL checks\n\n    Examples:\n        &gt;&gt;&gt; from sqlalchemy import select\n        &gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyFilterMixin\n        &gt;&gt;&gt; from archipy.models.types.base_types import FilterOperationType\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class UserRepository(SqlAlchemyFilterMixin):\n        ...     def find_active_users_by_name(self, name_fragment):\n        ...         query = select(User)\n        ...         query = self._apply_filter(\n        ...             query,\n        ...             User.name,\n        ...             name_fragment,\n        ...             FilterOperationType.ILIKE\n        ...         )\n        ...         query = self._apply_filter(\n        ...             query,\n        ...             User.is_active,\n        ...             True,\n        ...             FilterOperationType.EQUAL\n        ...         )\n        ...         return query\n    \"\"\"\n\n    @staticmethod\n    def _apply_filter(\n        query: Select | Update | Delete,\n        field: InstrumentedAttribute,\n        value: Any,\n        operation: FilterOperationType,\n    ) -&gt; Select | Update | Delete:\n        \"\"\"Apply a filter to a SQLAlchemy query.\n\n        This method applies different types of filters based on the specified\n        operation type, allowing for flexible query building.\n\n        Args:\n            query: The SQLAlchemy query to apply the filter to\n            field: The model attribute/column to filter on\n            value: The value to compare against\n            operation: The type of filter operation to apply\n\n        Returns:\n            The updated query with the filter applied\n\n        Examples:\n            &gt;&gt;&gt; # Filter users with specific email domain\n            &gt;&gt;&gt; query = select(User)\n            &gt;&gt;&gt; query = SqlAlchemyFilterMixin._apply_filter(\n            ...     query,\n            ...     User.email,\n            ...     \"%@example.com\",\n            ...     FilterOperationType.LIKE\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Filter active users\n            &gt;&gt;&gt; query = SqlAlchemyFilterMixin._apply_filter(\n            ...     query,\n            ...     User.is_active,\n            ...     True,\n            ...     FilterOperationType.EQUAL\n            ... )\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Filter users created after a certain date\n            &gt;&gt;&gt; from datetime import datetime\n            &gt;&gt;&gt; cutoff_date = datetime(2023, 1, 1)\n            &gt;&gt;&gt; query = SqlAlchemyFilterMixin._apply_filter(\n            ...     query,\n            ...     User.created_at,\n            ...     cutoff_date,\n            ...     FilterOperationType.GREATER_THAN\n            ... )\n        \"\"\"\n        if value is not None or operation in [FilterOperationType.IS_NULL, FilterOperationType.IS_NOT_NULL]:\n            if operation == FilterOperationType.EQUAL:\n                return query.where(field == value)\n            if operation == FilterOperationType.NOT_EQUAL:\n                return query.where(field != value)\n            if operation == FilterOperationType.LESS_THAN:\n                return query.where(field &lt; value)\n            if operation == FilterOperationType.LESS_THAN_OR_EQUAL:\n                return query.where(field &lt;= value)\n            if operation == FilterOperationType.GREATER_THAN:\n                return query.where(field &gt; value)\n            if operation == FilterOperationType.GREATER_THAN_OR_EQUAL:\n                return query.where(field &gt;= value)\n            if operation == FilterOperationType.IN_LIST:\n                return query.where(field.in_(value))\n            if operation == FilterOperationType.NOT_IN_LIST:\n                return query.where(~field.in_(value))\n            if operation == FilterOperationType.LIKE:\n                return query.where(field.like(f\"%{value}%\"))\n            if operation == FilterOperationType.ILIKE:\n                return query.where(field.ilike(f\"%{value}%\"))\n            if operation == FilterOperationType.STARTS_WITH:\n                return query.where(field.startswith(value))\n            if operation == FilterOperationType.ENDS_WITH:\n                return query.where(field.endswith(value))\n            if operation == FilterOperationType.CONTAINS:\n                return query.where(field.contains(value))\n            if operation == FilterOperationType.IS_NULL:\n                return query.where(field.is_(None))\n            if operation == FilterOperationType.IS_NOT_NULL:\n                return query.where(field.isnot(None))\n        return query\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter</code>","text":"<p>               Bases: <code>SqlAlchemyPort</code>, <code>SqlAlchemyPaginationMixin</code>, <code>SqlAlchemySortMixin</code></p> <p>Database adapter for SQLAlchemy ORM operations.</p> <p>This adapter provides a standardized interface for performing database operations using SQLAlchemy ORM. It implements common operations like create, read, update, delete (CRUD), along with advanced features for pagination, sorting, and filtering.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyAdapter\n&gt;&gt;&gt; from archipy.models.entities import BaseEntity\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create adapter with default configuration\n&gt;&gt;&gt; db = SqlAlchemyAdapter()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a new entity\n&gt;&gt;&gt; user = User(name=\"John Doe\", email=\"john@example.com\")\n&gt;&gt;&gt; db.create(user)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Query with sorting and pagination\n&gt;&gt;&gt; from sqlalchemy import select\n&gt;&gt;&gt; from archipy.models.dtos.pagination_dto import PaginationDTO\n&gt;&gt;&gt; from archipy.models.dtos.sort_dto import SortDTO\n&gt;&gt;&gt;\n&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; pagination = PaginationDTO(page=1, page_size=10)\n&gt;&gt;&gt; sort_info = SortDTO(column=\"created_at\", order=\"DESC\")\n&gt;&gt;&gt; results, total = db.execute_search_query(User, query, pagination, sort_info)\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class SqlAlchemyAdapter(SqlAlchemyPort, SqlAlchemyPaginationMixin, SqlAlchemySortMixin):\n    \"\"\"Database adapter for SQLAlchemy ORM operations.\n\n    This adapter provides a standardized interface for performing database operations\n    using SQLAlchemy ORM. It implements common operations like create, read, update,\n    delete (CRUD), along with advanced features for pagination, sorting, and filtering.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for SQLAlchemy.\n            If None, retrieves from global config. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.adapters import SqlAlchemyAdapter\n        &gt;&gt;&gt; from archipy.models.entities import BaseEntity\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create adapter with default configuration\n        &gt;&gt;&gt; db = SqlAlchemyAdapter()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a new entity\n        &gt;&gt;&gt; user = User(name=\"John Doe\", email=\"john@example.com\")\n        &gt;&gt;&gt; db.create(user)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Query with sorting and pagination\n        &gt;&gt;&gt; from sqlalchemy import select\n        &gt;&gt;&gt; from archipy.models.dtos.pagination_dto import PaginationDTO\n        &gt;&gt;&gt; from archipy.models.dtos.sort_dto import SortDTO\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; query = select(User)\n        &gt;&gt;&gt; pagination = PaginationDTO(page=1, page_size=10)\n        &gt;&gt;&gt; sort_info = SortDTO(column=\"created_at\", order=\"DESC\")\n        &gt;&gt;&gt; results, total = db.execute_search_query(User, query, pagination, sort_info)\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        configs: SqlAlchemyConfig = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.session_manager = SessionManagerAdapter(configs)\n\n    @override\n    def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None = None,\n        sort_info: SortDTO | None = SortDTO.default(),\n    ) -&gt; tuple[list[BaseEntity], int]:\n        try:\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n\n            results = session.execute(paginated_query)\n            results = results.scalars().all()\n\n            count_query = select(func.count()).select_from(query.subquery())\n            total_count = session.execute(count_query).scalar_one()\n            return results, total_count\n        except Exception as e:\n            raise RuntimeError(f\"Database query failed: {e!s}\") from e\n\n    @override\n    def get_session(self) -&gt; Session:\n        return self.session_manager.get_session()\n\n    @override\n    def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        \"\"\"Creates a new entity in the database.\n\n        Args:\n            entity (BaseEntity): The entity to be created.\n\n        Returns:\n            BaseEntity | None: The created entity with updated attributes\n                (e.g., generated ID), or None if creation failed.\n\n        Raises:\n            InvalidEntityTypeError: If the provided entity is not a BaseEntity.\n\n        Examples:\n            &gt;&gt;&gt; user = User(name=\"John Doe\", email=\"john@example.com\")\n            &gt;&gt;&gt; created_user = db.create(user)\n            &gt;&gt;&gt; print(created_user.id)  # UUID is now populated\n        \"\"\"\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        session = self.get_session()\n        session.add(entity)\n        session.flush()\n        return entity\n\n    @override\n    def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        session = self.get_session()\n        session.add_all(entities)\n        session.flush()\n        return entities\n\n    @override\n    def get_by_uuid(self, entity_type: type, entity_uuid: UUID):\n        \"\"\"Retrieves an entity by its UUID.\n\n        Args:\n            entity_type (type): The entity class to query.\n            entity_uuid (UUID): The UUID of the entity to retrieve.\n\n        Returns:\n            Any: The retrieved entity or None if not found.\n\n        Raises:\n            InvalidEntityTypeError: If entity_type is not a subclass of BaseEntity\n                or if entity_uuid is not a UUID.\n\n        Examples:\n            &gt;&gt;&gt; from uuid import UUID\n            &gt;&gt;&gt; user_id = UUID(\"550e8400-e29b-41d4-a716-446655440000\")\n            &gt;&gt;&gt; user = db.get_by_uuid(User, user_id)\n            &gt;&gt;&gt; if user:\n            ...     print(user.name)\n        \"\"\"\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(entity_type, BaseEntity)\n        if not isinstance(entity_uuid, UUID):\n            raise InvalidEntityTypeError(entity_uuid, UUID)\n        session = self.get_session()\n        return session.get(entity_type, entity_uuid)\n\n    @override\n    def delete(self, entity: BaseEntity) -&gt; None:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        session = self.get_session()\n        session.delete(entity)\n\n    @override\n    def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        for entity in entities:\n            self.delete(entity)\n\n    @override\n    def execute(self, statement: Executable, params: AnyExecuteParams | None = None):\n        session = self.get_session()\n        return session.execute(statement, params)\n\n    @override\n    def scalars(self, statement: Executable, params: AnyExecuteParams | None = None):\n        session = self.get_session()\n        return session.scalars(statement, params)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.create","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.create(entity)</code>","text":"<p>Creates a new entity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>BaseEntity</code> <p>The entity to be created.</p> required <p>Returns:</p> Type Description <code>BaseEntity | None</code> <p>BaseEntity | None: The created entity with updated attributes (e.g., generated ID), or None if creation failed.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If the provided entity is not a BaseEntity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; user = User(name=\"John Doe\", email=\"john@example.com\")\n&gt;&gt;&gt; created_user = db.create(user)\n&gt;&gt;&gt; print(created_user.id)  # UUID is now populated\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n    \"\"\"Creates a new entity in the database.\n\n    Args:\n        entity (BaseEntity): The entity to be created.\n\n    Returns:\n        BaseEntity | None: The created entity with updated attributes\n            (e.g., generated ID), or None if creation failed.\n\n    Raises:\n        InvalidEntityTypeError: If the provided entity is not a BaseEntity.\n\n    Examples:\n        &gt;&gt;&gt; user = User(name=\"John Doe\", email=\"john@example.com\")\n        &gt;&gt;&gt; created_user = db.create(user)\n        &gt;&gt;&gt; print(created_user.id)  # UUID is now populated\n    \"\"\"\n    if not isinstance(entity, BaseEntity):\n        raise InvalidEntityTypeError(entity, BaseEntity)\n    session = self.get_session()\n    session.add(entity)\n    session.flush()\n    return entity\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.get_by_uuid","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.SqlAlchemyAdapter.get_by_uuid(entity_type, entity_uuid)</code>","text":"<p>Retrieves an entity by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type</code> <p>The entity class to query.</p> required <code>entity_uuid</code> <code>UUID</code> <p>The UUID of the entity to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The retrieved entity or None if not found.</p> <p>Raises:</p> Type Description <code>InvalidEntityTypeError</code> <p>If entity_type is not a subclass of BaseEntity or if entity_uuid is not a UUID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid import UUID\n&gt;&gt;&gt; user_id = UUID(\"550e8400-e29b-41d4-a716-446655440000\")\n&gt;&gt;&gt; user = db.get_by_uuid(User, user_id)\n&gt;&gt;&gt; if user:\n...     print(user.name)\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\ndef get_by_uuid(self, entity_type: type, entity_uuid: UUID):\n    \"\"\"Retrieves an entity by its UUID.\n\n    Args:\n        entity_type (type): The entity class to query.\n        entity_uuid (UUID): The UUID of the entity to retrieve.\n\n    Returns:\n        Any: The retrieved entity or None if not found.\n\n    Raises:\n        InvalidEntityTypeError: If entity_type is not a subclass of BaseEntity\n            or if entity_uuid is not a UUID.\n\n    Examples:\n        &gt;&gt;&gt; from uuid import UUID\n        &gt;&gt;&gt; user_id = UUID(\"550e8400-e29b-41d4-a716-446655440000\")\n        &gt;&gt;&gt; user = db.get_by_uuid(User, user_id)\n        &gt;&gt;&gt; if user:\n        ...     print(user.name)\n    \"\"\"\n    if not issubclass(entity_type, BaseEntity):\n        raise InvalidEntityTypeError(entity_type, BaseEntity)\n    if not isinstance(entity_uuid, UUID):\n        raise InvalidEntityTypeError(entity_uuid, UUID)\n    session = self.get_session()\n    return session.get(entity_type, entity_uuid)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter</code>","text":"<p>               Bases: <code>AsyncSqlAlchemyPort</code>, <code>SqlAlchemyPaginationMixin</code>, <code>SqlAlchemySortMixin</code></p> <p>Asynchronous database adapter for SQLAlchemy ORM operations.</p> <p>This adapter provides an asynchronous interface for performing database operations using SQLAlchemy's async capabilities. It implements common operations like create, read, update, delete (CRUD), along with advanced features for pagination, sorting, and filtering.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for SQLAlchemy. If None, retrieves from global config. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.adapters import AsyncSqlAlchemyAdapter\n&gt;&gt;&gt; from sqlalchemy import select\n&gt;&gt;&gt; from archipy.models.dtos.pagination_dto import PaginationDTO\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create adapter with default configuration\n&gt;&gt;&gt; db = AsyncSqlAlchemyAdapter()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example async function using the adapter\n&gt;&gt;&gt; async def get_users():\n...     query = select(User)\n...     pagination = PaginationDTO(page=1, page_size=10)\n...     results, total = await db.execute_search_query(User, query, pagination)\n...     return results\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>class AsyncSqlAlchemyAdapter(AsyncSqlAlchemyPort, SqlAlchemyPaginationMixin, SqlAlchemySortMixin):\n    \"\"\"Asynchronous database adapter for SQLAlchemy ORM operations.\n\n    This adapter provides an asynchronous interface for performing database operations\n    using SQLAlchemy's async capabilities. It implements common operations like\n    create, read, update, delete (CRUD), along with advanced features for pagination,\n    sorting, and filtering.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for SQLAlchemy.\n            If None, retrieves from global config. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.adapters import AsyncSqlAlchemyAdapter\n        &gt;&gt;&gt; from sqlalchemy import select\n        &gt;&gt;&gt; from archipy.models.dtos.pagination_dto import PaginationDTO\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create adapter with default configuration\n        &gt;&gt;&gt; db = AsyncSqlAlchemyAdapter()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Example async function using the adapter\n        &gt;&gt;&gt; async def get_users():\n        ...     query = select(User)\n        ...     pagination = PaginationDTO(page=1, page_size=10)\n        ...     results, total = await db.execute_search_query(User, query, pagination)\n        ...     return results\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        configs: SqlAlchemyConfig = BaseConfig.global_config().SQLALCHEMY if orm_config is None else orm_config\n        self.session_manager = AsyncSessionManagerAdapter(configs)\n\n    @override\n    async def execute_search_query(\n        self,\n        entity: type[BaseEntity],\n        query: Select,\n        pagination: PaginationDTO | None,\n        sort_info: SortDTO | None = SortDTO.default(),\n    ) -&gt; tuple[list[BaseEntity], int]:\n        \"\"\"Execute a search query with pagination and sorting.\n\n        This method executes a SELECT query with pagination and sorting applied,\n        and returns both the results and the total count of matching records.\n\n        Args:\n            entity: The entity class to query\n            query: The SQLAlchemy SELECT query\n            pagination: Pagination settings (page number and page size)\n            sort_info: Sorting information (column and direction)\n\n        Returns:\n            A tuple containing:\n                - List of entities matching the query\n                - Total count of matching records (ignoring pagination)\n\n        Raises:\n            RuntimeError: If the database query fails\n\n        Examples:\n            &gt;&gt;&gt; async def get_active_users(page: int = 1):\n            ...     query = select(User).where(User.is_active == True)\n            ...     pagination = PaginationDTO(page=page, page_size=20)\n            ...     sort_info = SortDTO(column=\"created_at\", order=\"DESC\")\n            ...     users, total = await db.execute_search_query(\n            ...         User, query, pagination, sort_info\n            ...     )\n            ...     return users, total\n        \"\"\"\n        try:\n            session = self.get_session()\n            sorted_query = self._apply_sorting(entity, query, sort_info)\n            paginated_query = self._apply_pagination(sorted_query, pagination)\n\n            results = await session.execute(paginated_query)\n            results = results.scalars().all()\n\n            count_query = select(func.count()).select_from(query.subquery())\n            total_count = await session.execute(count_query)\n            total_count = total_count.scalar_one()\n            return results, total_count\n        except Exception as e:\n            raise RuntimeError(f\"Database query failed: {e!s}\") from e\n\n    @override\n    def get_session(self) -&gt; AsyncSession:\n        return self.session_manager.get_session()\n\n    @override\n    async def create(self, entity: BaseEntity) -&gt; BaseEntity | None:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        session: AsyncSession = self.get_session()\n        session.add(entity)\n        await session.flush()\n        return entity\n\n    @override\n    async def bulk_create(self, entities: list[BaseEntity]) -&gt; list[BaseEntity] | None:\n        session = self.get_session()\n        session.add_all(entities)\n        await session.flush()\n        return entities\n\n    @override\n    async def get_by_uuid(self, entity_type: type, entity_uuid: UUID) -&gt; Any | None:\n        if not issubclass(entity_type, BaseEntity):\n            raise InvalidEntityTypeError(entity_type, BaseEntity)\n        if not isinstance(entity_uuid, UUID):\n            raise InvalidEntityTypeError(entity_uuid, UUID)\n        session = self.get_session()\n        return await session.get(entity_type, entity_uuid)\n\n    @override\n    async def delete(self, entity: BaseEntity) -&gt; None:\n        if not isinstance(entity, BaseEntity):\n            raise InvalidEntityTypeError(entity, BaseEntity)\n        session = self.get_session()\n        await session.delete(entity)\n\n    @override\n    async def bulk_delete(self, entities: list[BaseEntity]) -&gt; None:\n        for entity in entities:\n            await self.delete(entity)\n\n    @override\n    async def execute(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; Result[Any]:\n        session = self.get_session()\n        return await session.execute(statement, params)\n\n    @override\n    async def scalars(self, statement: Executable, params: AnyExecuteParams | None = None) -&gt; ScalarResult[Any]:\n        session = self.get_session()\n        return await session.scalars(statement, params)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.execute_search_query","title":"<code>archipy.adapters.orm.sqlalchemy.adapters.AsyncSqlAlchemyAdapter.execute_search_query(entity, query, pagination, sort_info=SortDTO.default())</code>  <code>async</code>","text":"<p>Execute a search query with pagination and sorting.</p> <p>This method executes a SELECT query with pagination and sorting applied, and returns both the results and the total count of matching records.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>type[BaseEntity]</code> <p>The entity class to query</p> required <code>query</code> <code>Select</code> <p>The SQLAlchemy SELECT query</p> required <code>pagination</code> <code>PaginationDTO | None</code> <p>Pagination settings (page number and page size)</p> required <code>sort_info</code> <code>SortDTO | None</code> <p>Sorting information (column and direction)</p> <code>default()</code> <p>Returns:</p> Type Description <code>tuple[list[BaseEntity], int]</code> <p>A tuple containing: - List of entities matching the query - Total count of matching records (ignoring pagination)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the database query fails</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def get_active_users(page: int = 1):\n...     query = select(User).where(User.is_active == True)\n...     pagination = PaginationDTO(page=page, page_size=20)\n...     sort_info = SortDTO(column=\"created_at\", order=\"DESC\")\n...     users, total = await db.execute_search_query(\n...         User, query, pagination, sort_info\n...     )\n...     return users, total\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/adapters.py</code> <pre><code>@override\nasync def execute_search_query(\n    self,\n    entity: type[BaseEntity],\n    query: Select,\n    pagination: PaginationDTO | None,\n    sort_info: SortDTO | None = SortDTO.default(),\n) -&gt; tuple[list[BaseEntity], int]:\n    \"\"\"Execute a search query with pagination and sorting.\n\n    This method executes a SELECT query with pagination and sorting applied,\n    and returns both the results and the total count of matching records.\n\n    Args:\n        entity: The entity class to query\n        query: The SQLAlchemy SELECT query\n        pagination: Pagination settings (page number and page size)\n        sort_info: Sorting information (column and direction)\n\n    Returns:\n        A tuple containing:\n            - List of entities matching the query\n            - Total count of matching records (ignoring pagination)\n\n    Raises:\n        RuntimeError: If the database query fails\n\n    Examples:\n        &gt;&gt;&gt; async def get_active_users(page: int = 1):\n        ...     query = select(User).where(User.is_active == True)\n        ...     pagination = PaginationDTO(page=page, page_size=20)\n        ...     sort_info = SortDTO(column=\"created_at\", order=\"DESC\")\n        ...     users, total = await db.execute_search_query(\n        ...         User, query, pagination, sort_info\n        ...     )\n        ...     return users, total\n    \"\"\"\n    try:\n        session = self.get_session()\n        sorted_query = self._apply_sorting(entity, query, sort_info)\n        paginated_query = self._apply_pagination(sorted_query, pagination)\n\n        results = await session.execute(paginated_query)\n        results = results.scalars().all()\n\n        count_query = select(func.count()).select_from(query.subquery())\n        total_count = await session.execute(count_query)\n        total_count = total_count.scalar_one()\n        return results, total_count\n    except Exception as e:\n        raise RuntimeError(f\"Database query failed: {e!s}\") from e\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter</code>","text":"<p>               Bases: <code>SessionManagerPort</code></p> <p>Manages SQLAlchemy database sessions for synchronous operations.</p> <p>This adapter creates and manages database sessions using SQLAlchemy's session management system. It implements the Singleton pattern to ensure a single instance exists throughout the application lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>orm_config</code> <code>SqlAlchemyConfig</code> <p>Configuration for the ORM. If None, retrieves from global config. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\n&gt;&gt;&gt; from archipy.configs.config_template import SqlAlchemyConfig\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using default global configuration\n&gt;&gt;&gt; manager = SessionManagerAdapter()\n&gt;&gt;&gt; session = manager.get_session()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using custom configuration\n&gt;&gt;&gt; custom_config = SqlAlchemyConfig(DATABASE=\"custom_db\", HOST=\"localhost\")\n&gt;&gt;&gt; custom_manager = SessionManagerAdapter(custom_config)\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>class SessionManagerAdapter(SessionManagerPort, metaclass=Singleton):\n    \"\"\"Manages SQLAlchemy database sessions for synchronous operations.\n\n    This adapter creates and manages database sessions using SQLAlchemy's\n    session management system. It implements the Singleton pattern to ensure\n    a single instance exists throughout the application lifecycle.\n\n    Args:\n        orm_config (SqlAlchemyConfig, optional): Configuration for the ORM.\n            If None, retrieves from global config. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\n        &gt;&gt;&gt; from archipy.configs.config_template import SqlAlchemyConfig\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using default global configuration\n        &gt;&gt;&gt; manager = SessionManagerAdapter()\n        &gt;&gt;&gt; session = manager.get_session()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using custom configuration\n        &gt;&gt;&gt; custom_config = SqlAlchemyConfig(DATABASE=\"custom_db\", HOST=\"localhost\")\n        &gt;&gt;&gt; custom_manager = SessionManagerAdapter(custom_config)\n    \"\"\"\n\n    def __init__(self, orm_config: SqlAlchemyConfig | None = None) -&gt; None:\n        configs: SqlAlchemyConfig = orm_config or BaseConfig().global_config().SQLALCHEMY\n        self.engine = self._create_engine(configs)\n        self._session_generator = self._get_session_generator(configs)\n\n    @override\n    def get_session(self) -&gt; Session:\n        \"\"\"Retrieves a SQLAlchemy session from the session factory.\n\n        The session is scoped to the current context to ensure thread safety.\n\n        Returns:\n            Session: A SQLAlchemy session instance that can be used for\n                database operations.\n\n        Examples:\n            &gt;&gt;&gt; session = session_manager.get_session()\n            &gt;&gt;&gt; user = session.query(User).filter_by(id=1).first()\n        \"\"\"\n        return self._session_generator()\n\n    @override\n    def remove_session(self) -&gt; None:\n        \"\"\"Removes the current session from the registry.\n\n        This should be called when you're done with a session to prevent\n        resource leaks, particularly at the end of web requests.\n\n        Examples:\n            &gt;&gt;&gt; session = session_manager.get_session()\n            &gt;&gt;&gt; # Use session for operations\n            &gt;&gt;&gt; session_manager.remove_session()\n        \"\"\"\n        self._session_generator.remove()\n\n    def _get_session_generator(self, configs: SqlAlchemyConfig) -&gt; scoped_session:\n        session_maker = sessionmaker(self.engine)\n        return scoped_session(session_maker)\n\n    @staticmethod\n    def _create_engine(configs: SqlAlchemyConfig) -&gt; Engine:\n        url = URL.create(\n            drivername=configs.DRIVER_NAME,\n            username=configs.USERNAME,\n            password=configs.PASSWORD,\n            host=configs.HOST,\n            port=configs.PORT,\n            database=configs.DATABASE,\n        )\n        return create_engine(\n            url,\n            isolation_level=configs.ISOLATION_LEVEL,\n            echo=configs.ECHO,\n            echo_pool=configs.ECHO_POOL,\n            enable_from_linting=configs.ENABLE_FROM_LINTING,\n            hide_parameters=configs.HIDE_PARAMETERS,\n            pool_pre_ping=configs.POOL_PRE_PING,\n            pool_size=configs.POOL_SIZE,\n            pool_recycle=configs.POOL_RECYCLE_SECONDS,\n            pool_reset_on_return=configs.POOL_RESET_ON_RETURN,\n            pool_timeout=configs.POOL_TIMEOUT,\n            pool_use_lifo=configs.POOL_USE_LIFO,\n            query_cache_size=configs.QUERY_CACHE_SIZE,\n            max_overflow=configs.POOL_MAX_OVERFLOW,\n        )\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.get_session","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.get_session()</code>","text":"<p>Retrieves a SQLAlchemy session from the session factory.</p> <p>The session is scoped to the current context to ensure thread safety.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy session instance that can be used for database operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; session = session_manager.get_session()\n&gt;&gt;&gt; user = session.query(User).filter_by(id=1).first()\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>@override\ndef get_session(self) -&gt; Session:\n    \"\"\"Retrieves a SQLAlchemy session from the session factory.\n\n    The session is scoped to the current context to ensure thread safety.\n\n    Returns:\n        Session: A SQLAlchemy session instance that can be used for\n            database operations.\n\n    Examples:\n        &gt;&gt;&gt; session = session_manager.get_session()\n        &gt;&gt;&gt; user = session.query(User).filter_by(id=1).first()\n    \"\"\"\n    return self._session_generator()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.remove_session","title":"<code>archipy.adapters.orm.sqlalchemy.session_manager_adapters.SessionManagerAdapter.remove_session()</code>","text":"<p>Removes the current session from the registry.</p> <p>This should be called when you're done with a session to prevent resource leaks, particularly at the end of web requests.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; session = session_manager.get_session()\n&gt;&gt;&gt; # Use session for operations\n&gt;&gt;&gt; session_manager.remove_session()\n</code></pre> Source code in <code>archipy/adapters/orm/sqlalchemy/session_manager_adapters.py</code> <pre><code>@override\ndef remove_session(self) -&gt; None:\n    \"\"\"Removes the current session from the registry.\n\n    This should be called when you're done with a session to prevent\n    resource leaks, particularly at the end of web requests.\n\n    Examples:\n        &gt;&gt;&gt; session = session_manager.get_session()\n        &gt;&gt;&gt; # Use session for operations\n        &gt;&gt;&gt; session_manager.remove_session()\n    \"\"\"\n    self._session_generator.remove()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.orm.sqlalchemy.ports","title":"<code>archipy.adapters.orm.sqlalchemy.ports</code>","text":""},{"location":"api_reference/adapters/#redis","title":"Redis","text":"<p>Redis integration for caching and key-value storage.</p> <pre><code>from archipy.adapters.redis import RedisAdapter, AsyncRedisAdapter\n\n# Create a Redis adapter\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n# Set value\nredis.set(\"key\", \"value\", ex=3600)  # expires in 1 hour\n\n# Get value\nvalue = redis.get(\"key\")\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters","title":"<code>archipy.adapters.redis.adapters</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.redis.adapters.RedisAdapter","title":"<code>archipy.adapters.redis.adapters.RedisAdapter</code>","text":"<p>               Bases: <code>RedisPort</code></p> <p>Adapter for Redis operations providing a standardized interface.</p> <p>This adapter implements the RedisPort interface to provide a consistent way to interact with Redis, abstracting the underlying Redis client implementation. It supports all common Redis operations including key-value operations, lists, sets, sorted sets, hashes, and pub/sub functionality.</p> <p>The adapter maintains separate connections for read and write operations, which can be used to implement read replicas for better performance.</p> <p>Parameters:</p> Name Type Description Default <code>redis_config</code> <code>RedisConfig</code> <p>Configuration settings for Redis. If None, retrieves from global config. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.redis.redis_adapters import RedisAdapter\n&gt;&gt;&gt; from archipy.configs.config_template import RedisConfig\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using global configuration\n&gt;&gt;&gt; redis = RedisAdapter()\n&gt;&gt;&gt; redis.set(\"key\", \"value\", ex=60)  # Set with 60 second expiry\n&gt;&gt;&gt; value = redis.get(\"key\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Using custom configuration\n&gt;&gt;&gt; config = RedisConfig(MASTER_HOST=\"redis.example.com\", PORT=6380)\n&gt;&gt;&gt; custom_redis = RedisAdapter(config)\n</code></pre> Source code in <code>archipy/adapters/redis/adapters.py</code> <pre><code>class RedisAdapter(RedisPort):\n    \"\"\"Adapter for Redis operations providing a standardized interface.\n\n    This adapter implements the RedisPort interface to provide a consistent\n    way to interact with Redis, abstracting the underlying Redis client\n    implementation. It supports all common Redis operations including key-value\n    operations, lists, sets, sorted sets, hashes, and pub/sub functionality.\n\n    The adapter maintains separate connections for read and write operations,\n    which can be used to implement read replicas for better performance.\n\n    Args:\n        redis_config (RedisConfig, optional): Configuration settings for Redis.\n            If None, retrieves from global config. Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.redis.redis_adapters import RedisAdapter\n        &gt;&gt;&gt; from archipy.configs.config_template import RedisConfig\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using global configuration\n        &gt;&gt;&gt; redis = RedisAdapter()\n        &gt;&gt;&gt; redis.set(\"key\", \"value\", ex=60)  # Set with 60 second expiry\n        &gt;&gt;&gt; value = redis.get(\"key\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Using custom configuration\n        &gt;&gt;&gt; config = RedisConfig(MASTER_HOST=\"redis.example.com\", PORT=6380)\n        &gt;&gt;&gt; custom_redis = RedisAdapter(config)\n    \"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        configs: RedisConfig = BaseConfig.global_config().REDIS if redis_config is None else redis_config\n        self._set_clients(configs)\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        if redis_master_host := configs.MASTER_HOST:\n            self.client: Redis = self._get_client(redis_master_host, configs)\n        if redis_slave_host := configs.SLAVE_HOST:\n            self.read_only_client: Redis = self._get_client(redis_slave_host, configs)\n        else:\n            self.read_only_client = self.client\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; Redis:\n        return Redis(\n            host=host,\n            port=configs.PORT,\n            db=configs.DATABASE,\n            password=configs.PASSWORD,\n            decode_responses=configs.DECODE_RESPONSES,\n            health_check_interval=configs.HEALTH_CHECK_INTERVAL,\n        )\n\n    @override\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        return self.read_only_client.pttl(name)\n\n    @override\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        return self.client.incrby(name, amount)\n\n    @override\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        return self.client.set(name, value, ex, px, nx, xx, keepttl, get, exat, pxat)\n\n    @override\n    def get(self, key: str) -&gt; RedisResponseType:\n        return self.read_only_client.get(key)\n\n    @override\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        return self.read_only_client.mget(keys, *args)\n\n    @override\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        return self.client.mset(mapping)\n\n    @override\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        return self.read_only_client.keys(pattern, **kwargs)\n\n    @override\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        return self.client.getset(key, value)\n\n    @override\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        return self.client.getdel(key)\n\n    @override\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        return self.read_only_client.exists(*names)\n\n    @override\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        return self.client.delete(*names)\n\n    @override\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        return self.client.append(key, value)\n\n    @override\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        return self.read_only_client.ttl(name)\n\n    @override\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        return self.read_only_client.type(name)\n\n    @override\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        return self.read_only_client.llen(name)\n\n    @override\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        return self.client.lpop(name, count)\n\n    @override\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        return self.client.lpush(name, *values)\n\n    @override\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        return self.read_only_client.lrange(name, start, end)\n\n    @override\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        return self.client.lrem(name, count, value)\n\n    @override\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        return self.client.lset(name, index, value)\n\n    @override\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        return self.client.rpop(name, count)\n\n    @override\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        return self.client.rpush(name, *values)\n\n    @override\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        return self.read_only_client.scan(cursor, match, count, _type, **kwargs)\n\n    @override\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        return self.read_only_client.scan_iter(match, count, _type, **kwargs)\n\n    @override\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        return self.read_only_client.sscan(name, cursor, match, count)\n\n    @override\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        return self.read_only_client.sscan_iter(name, match, count)\n\n    @override\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        return self.client.sadd(name, *values)\n\n    @override\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        return self.client.scard(name)\n\n    @override\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        return self.read_only_client.sismember(name, value)\n\n    @override\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        return self.read_only_client.smembers(name)\n\n    @override\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        return self.client.spop(name, count)\n\n    @override\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        return self.client.srem(name, *values)\n\n    @override\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; set:\n        return self.client.sunion(keys, *args)\n\n    @override\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        return self.client.zadd(name, mapping, nx, xx, ch, incr, gt, lt)\n\n    @override\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        return self.client.zcard(name)\n\n    @override\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        return self.client.zcount(name, min, max)\n\n    @override\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        return self.client.zpopmax(name, count)\n\n    @override\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        return self.client.zpopmin(name, count)\n\n    @override\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        return self.read_only_client.zrange(\n            name,\n            start,\n            end,\n            desc,\n            withscores,\n            score_cast_func,\n            byscore,\n            bylex,\n            offset,\n            num,\n        )\n\n    @override\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        return self.read_only_client.zrevrange(name, start, end, withscores, score_cast_func)\n\n    @override\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        return self.read_only_client.zrangebyscore(name, min, max, start, num, withscores, score_cast_func)\n\n    @override\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        return self.read_only_client.zrank(name, value)\n\n    @override\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        return self.client.zrem(name, *values)\n\n    @override\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        return self.read_only_client.zscore(name, value)\n\n    @override\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        return self.client.hdel(name, *keys)\n\n    @override\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        return self.read_only_client.hexists(name, key)\n\n    @override\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        return self.read_only_client.hget(name, key)\n\n    @override\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        return self.read_only_client.hgetall(name)\n\n    @override\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        return self.read_only_client.hkeys(name)\n\n    @override\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        return self.read_only_client.hlen(name)\n\n    @override\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        return self.client.hset(name, key, value, mapping, items)\n\n    @override\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        return self.read_only_client.hmget(name, keys, *args)\n\n    @override\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        return self.read_only_client.hvals(name)\n\n    @override\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        return self.client.publish(channel, message, **kwargs)\n\n    @override\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        return self.client.pubsub_channels(pattern, **kwargs)\n\n    @override\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        return self.client.zincrby(name, amount, value)\n\n    @override\n    def pubsub(self, **kwargs: Any) -&gt; PubSub:\n        return self.client.pubsub(**kwargs)\n\n    @override\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Pipeline:\n        return self.client.pipeline(transaction, shard_hint)\n\n    @override\n    def ping(self) -&gt; RedisResponseType:\n        return self.client.ping()\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.ports","title":"<code>archipy.adapters.redis.ports</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.redis.ports.RedisPort","title":"<code>archipy.adapters.redis.ports.RedisPort</code>","text":"<p>Interface for Redis operations providing a standardized access pattern.</p> <p>This interface defines the contract for Redis adapters, ensuring consistent implementation of Redis operations across different adapters. It covers all essential Redis functionality including key-value operations, collections (lists, sets, sorted sets, hashes), and pub/sub capabilities.</p> <p>Implementing classes should provide concrete implementations for all methods, typically by wrapping a Redis client library.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from archipy.adapters.redis.redis_ports import RedisPort\n&gt;&gt;&gt;\n&gt;&gt;&gt; class CustomRedisAdapter(RedisPort):\n...     def __init__(self, connection_params):\n...         self.client = redis.Redis(**connection_params)\n...\n...     def get(self, key: str) -&gt; Any:\n...         return self.client.get(key)\n...\n...     def set(self, name, value, ex=None, px=None, nx=False, xx=False, ...):\n...         return self.client.set(name, value, ex, px, nx, xx, ...)\n...\n...     # Implement other required methods...\n</code></pre> Source code in <code>archipy/adapters/redis/ports.py</code> <pre><code>class RedisPort:\n    \"\"\"Interface for Redis operations providing a standardized access pattern.\n\n    This interface defines the contract for Redis adapters, ensuring consistent\n    implementation of Redis operations across different adapters. It covers all\n    essential Redis functionality including key-value operations, collections\n    (lists, sets, sorted sets, hashes), and pub/sub capabilities.\n\n    Implementing classes should provide concrete implementations for all\n    methods, typically by wrapping a Redis client library.\n\n    Examples:\n        &gt;&gt;&gt; from archipy.adapters.redis.redis_ports import RedisPort\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class CustomRedisAdapter(RedisPort):\n        ...     def __init__(self, connection_params):\n        ...         self.client = redis.Redis(**connection_params)\n        ...\n        ...     def get(self, key: str) -&gt; Any:\n        ...         return self.client.get(key)\n        ...\n        ...     def set(self, name, value, ex=None, px=None, nx=False, xx=False, ...):\n        ...         return self.client.set(name, value, ex, px, nx, xx, ...)\n        ...\n        ...     # Implement other required methods...\n    \"\"\"\n\n    @abstractmethod\n    def ping(self) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def pttl(self, name: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def incrby(self, name: RedisKeyType, amount: int = 1) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def set(\n        self,\n        name: RedisKeyType,\n        value: RedisSetType,\n        ex: RedisExpiryType | None = None,\n        px: RedisExpiryType | None = None,\n        nx: bool = False,\n        xx: bool = False,\n        keepttl: bool = False,\n        get: bool = False,\n        exat: RedisAbsExpiryType | None = None,\n        pxat: RedisAbsExpiryType | None = None,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def get(self, key: str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def mget(\n        self,\n        keys: RedisKeyType | Iterable[RedisKeyType],\n        *args: bytes | str,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def mset(self, mapping: Mapping[RedisKeyType, bytes | str | float]) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def keys(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def getset(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def getdel(self, key: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def exists(self, *names: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def delete(self, *names: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def append(self, key: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def ttl(self, name: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def type(self, name: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def llen(self, name: str) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpop(self, name: str, count: int | None = None) -&gt; Any:\n        raise NotImplementedError\n\n    @abstractmethod\n    def lpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrange(self, name: str, start: int, end: int) -&gt; RedisListResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def lrem(self, name: str, count: int, value: str) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def lset(self, name: str, index: int, value: str) -&gt; bool:\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpop(self, name: str, count: int | None = None) -&gt; Any:\n        raise NotImplementedError\n\n    @abstractmethod\n    def rpush(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan(\n        self,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def scan_iter(\n        self,\n        match: bytes | str | None = None,\n        count: int | None = None,\n        _type: str | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator:\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan(\n        self,\n        name: RedisKeyType,\n        cursor: int = 0,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def sscan_iter(\n        self,\n        name: RedisKeyType,\n        match: bytes | str | None = None,\n        count: int | None = None,\n    ) -&gt; Iterator:\n        raise NotImplementedError\n\n    @abstractmethod\n    def sadd(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def scard(self, name: str) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def sismember(self, name: str, value: str) -&gt; Awaitable[bool] | bool:\n        raise NotImplementedError\n\n    @abstractmethod\n    def smembers(self, name: str) -&gt; RedisSetResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def spop(self, name: str, count: int | None = None) -&gt; bytes | float | int | str | list | None:\n        raise NotImplementedError\n\n    @abstractmethod\n    def srem(self, name: str, *values: bytes | str | float) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def sunion(self, keys: RedisKeyType, *args: bytes | str) -&gt; set:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zadd(\n        self,\n        name: RedisKeyType,\n        mapping: Mapping[RedisKeyType, bytes | str | float],\n        nx: bool = False,\n        xx: bool = False,\n        ch: bool = False,\n        incr: bool = False,\n        gt: bool = False,\n        lt: bool = False,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcard(self, name: bytes | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zcount(self, name: RedisKeyType, min: float | str, max: float | str) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmax(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zpopmin(self, name: RedisKeyType, count: int | None = None) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        desc: bool = False,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n        byscore: bool = False,\n        bylex: bool = False,\n        offset: int | None = None,\n        num: int | None = None,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrevrange(\n        self,\n        name: RedisKeyType,\n        start: int,\n        end: int,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrangebyscore(\n        self,\n        name: RedisKeyType,\n        min: float | str,\n        max: float | str,\n        start: int | None = None,\n        num: int | None = None,\n        withscores: bool = False,\n        score_cast_func: RedisScoreCastType = float,\n    ) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrank(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zrem(self, name: RedisKeyType, *values: bytes | str | float) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zscore(self, name: RedisKeyType, value: bytes | str | float) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hdel(self, name: str, *keys: str | bytes) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hexists(self, name: str, key: str) -&gt; Awaitable[bool] | bool:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hget(self, name: str, key: str) -&gt; Awaitable[str | None] | str | None:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hgetall(self, name: str) -&gt; Awaitable[dict] | dict:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hkeys(self, name: str) -&gt; RedisListResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hlen(self, name: str) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hset(\n        self,\n        name: str,\n        key: str | bytes | None = None,\n        value: str | bytes | None = None,\n        mapping: dict | None = None,\n        items: list | None = None,\n    ) -&gt; RedisIntegerResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hmget(self, name: str, keys: list, *args: str | bytes) -&gt; RedisListResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def hvals(self, name: str) -&gt; RedisListResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def publish(self, channel: RedisKeyType, message: bytes | str, **kwargs: Any) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub_channels(self, pattern: RedisPatternType = \"*\", **kwargs: Any) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def zincrby(self, name: RedisKeyType, amount: float, value: bytes | str | float) -&gt; RedisResponseType:\n        raise NotImplementedError\n\n    @abstractmethod\n    def pubsub(self, **kwargs: Any) -&gt; Any:\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_pipeline(self, transaction: Any = True, shard_hint: Any = None) -&gt; Any:\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.mocks","title":"<code>archipy.adapters.redis.mocks</code>","text":""},{"location":"api_reference/adapters/#archipy.adapters.redis.mocks.RedisMock","title":"<code>archipy.adapters.redis.mocks.RedisMock</code>","text":"<p>               Bases: <code>RedisAdapter</code></p> <p>A Redis adapter implementation using fakeredis for testing.</p> Source code in <code>archipy/adapters/redis/mocks.py</code> <pre><code>class RedisMock(RedisAdapter):\n    \"\"\"A Redis adapter implementation using fakeredis for testing.\"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        # Skip the parent's __init__ which would create real Redis connections\n        self.client = fakeredis.FakeRedis(decode_responses=True)\n        self.read_only_client = self.client\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        # Override to prevent actual connection setup\n        pass\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; Redis:\n        # Override to return fakeredis instead\n        return fakeredis.FakeRedis(decode_responses=configs.DECODE_RESPONSES)\n</code></pre>"},{"location":"api_reference/adapters/#archipy.adapters.redis.mocks.AsyncRedisMock","title":"<code>archipy.adapters.redis.mocks.AsyncRedisMock</code>","text":"<p>               Bases: <code>AsyncRedisAdapter</code></p> <p>An async Redis adapter implementation using fakeredis for testing.</p> Source code in <code>archipy/adapters/redis/mocks.py</code> <pre><code>class AsyncRedisMock(AsyncRedisAdapter):\n    \"\"\"An async Redis adapter implementation using fakeredis for testing.\"\"\"\n\n    def __init__(self, redis_config: RedisConfig | None = None) -&gt; None:\n        # Skip the parent's __init__ which would create real Redis connections\n        self.client = AsyncMock()\n        self.read_only_client = self.client\n        self._setup_async_methods()\n\n    def _set_clients(self, configs: RedisConfig) -&gt; None:\n        # Override to prevent actual connection setup\n        pass\n\n    @staticmethod\n    def _get_client(host: str, configs: RedisConfig) -&gt; AsyncRedis:\n        # Override to return a mocked async client\n        return AsyncMock()\n\n    def _setup_async_methods(self):\n        \"\"\"Set up all async methods to use a synchronous fakeredis under the hood.\"\"\"\n        # Create a synchronous fakeredis instance to handle the actual operations\n        self._fake_redis = fakeredis.FakeRedis(decode_responses=True)\n\n        # For each async method, implement it to use the synchronous fakeredis\n        for method_name in dir(AsyncRedisPort):\n            if not method_name.startswith(\"_\") and method_name != \"pubsub\" and method_name != \"get_pipeline\":\n                sync_method = getattr(self._fake_redis, method_name, None)\n                if sync_method and callable(sync_method):\n                    async_method = self._create_async_wrapper(method_name, sync_method)\n                    setattr(self.client, method_name, async_method)\n                    setattr(self.read_only_client, method_name, async_method)\n\n    def _create_async_wrapper(self, method_name, sync_method):\n        \"\"\"Create an async wrapper around a synchronous method.\"\"\"\n\n        async def wrapper(*args, **kwargs):\n            # Remove 'self' from args when calling the sync method\n            if args and args[0] is self:\n                args = args[1:]\n            return sync_method(*args, **kwargs)\n\n        return wrapper\n</code></pre>"},{"location":"api_reference/configs/","title":"Configs","text":""},{"location":"api_reference/configs/#overview","title":"Overview","text":"<p>The configs module provides tools for standardized configuration management and injection, supporting consistent setup across services like databases, Redis, and email.</p>"},{"location":"api_reference/configs/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\npoetry add archipy\n</code></pre>"},{"location":"api_reference/configs/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/configs/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/configs/#api-stability","title":"API Stability","text":"Component Status Notes BaseConfig \ud83d\udfe2 Stable Production-ready Config Templates \ud83d\udfe2 Stable Production-ready Environment Types \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/configs/#examples","title":"Examples","text":"<p>For practical examples, see the Configuration Management Guide.</p>"},{"location":"api_reference/configs/#configuration-classes","title":"Configuration Classes","text":""},{"location":"api_reference/configs/#base-config","title":"Base Config","text":"<p>Documentation for <code>archipy.configs.base_config</code> module.</p> <pre><code>from archipy.configs.base_config import BaseConfig\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n</code></pre> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#config-templates","title":"Config Templates","text":"<p>Documentation for <code>archipy.configs.config_template</code> module.</p> <pre><code>from archipy.configs.config_template import SqlAlchemyConfig\n\nclass DatabaseConfig(SqlAlchemyConfig):\n    DB_POOL_SIZE: int = 5\n    DB_POOL_TIMEOUT: int = 30\n</code></pre> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/configs/#baseconfig","title":"BaseConfig","text":"<p>Class: <code>archipy.configs.base_config.BaseConfig</code></p> <p>Configures:</p> <ul> <li>Environment variable support</li> <li>Type validation</li> <li>Global configuration access</li> <li>Nested configuration support</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#sqlalchemyconfig","title":"SqlAlchemyConfig","text":"<p>Class: <code>archipy.configs.config_template.SqlAlchemyConfig</code></p> <p>Configures:</p> <ul> <li>Database connection settings</li> <li>Pool configuration</li> <li>Migration settings</li> <li>Debug options</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#redisconfig","title":"RedisConfig","text":"<p>Class: <code>archipy.configs.config_template.RedisConfig</code></p> <p>Configures:</p> <ul> <li>Connection settings</li> <li>Pool configuration</li> <li>SSL options</li> <li>Sentinel support</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#emailconfig","title":"EmailConfig","text":"<p>Class: <code>archipy.configs.config_template.EmailConfig</code></p> <p>Configures:</p> <ul> <li>SMTP settings</li> <li>Authentication</li> <li>TLS options</li> <li>Default headers</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#fastapiconfig","title":"FastAPIConfig","text":"<p>Class: <code>archipy.configs.config_template.FastAPIConfig</code></p> <p>Configures:</p> <ul> <li>API versioning</li> <li>CORS configuration</li> <li>Rate limiting</li> <li>Documentation</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#grpcconfig","title":"GrpcConfig","text":"<p>Class: <code>archipy.configs.config_template.GrpcConfig</code></p> <p>Configures:</p> <ul> <li>Server settings</li> <li>Client configuration</li> <li>Interceptors</li> <li>SSL/TLS options</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#sentryconfig","title":"SentryConfig","text":"<p>Class: <code>archipy.configs.config_template.SentryConfig</code></p> <p>Configures:</p> <ul> <li>DSN configuration</li> <li>Environment settings</li> <li>Sample rates</li> <li>Performance monitoring</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#elasticsearchconfig","title":"ElasticSearchConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticSearchConfig</code></p> <p>Configures:</p> <ul> <li>Cluster configuration</li> <li>Authentication</li> <li>Index settings</li> <li>Retry policies</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#elasticsearchapmconfig","title":"ElasticSearchAPMConfig","text":"<p>Class: <code>archipy.configs.config_template.ElasticSearchAPMConfig</code></p> <p>Configures:</p> <ul> <li>APM server settings</li> <li>Service name</li> <li>Transaction sampling</li> <li>Instrumentation</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#kafkaconfig","title":"KafkaConfig","text":"<p>Class: <code>archipy.configs.config_template.KafkaConfig</code></p> <p>Configures:</p> <ul> <li>Broker configuration</li> <li>Consumer groups</li> <li>Producer settings</li> <li>Security options</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/configs/#environmenttype","title":"EnvironmentType","text":"<p>Class: <code>archipy.configs.environment_type.EnvironmentType</code></p> <p>Configures:</p> <ul> <li>Environment types (DEV, STAGING, PROD)</li> <li>Environment-specific behaviors</li> <li>Configuration validation rules</li> </ul> <p>Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/","title":"Helpers","text":""},{"location":"api_reference/helpers/#overview","title":"Overview","text":"<p>The <code>helpers</code> module provides utility functions and classes to simplify common development tasks.</p>"},{"location":"api_reference/helpers/#installation","title":"Installation","text":"<p>This module is included in the base ArchiPy installation:</p> <pre><code># Add ArchiPy to your project\npoetry add archipy\n</code></pre> <p>For development features:</p> <pre><code># Add ArchiPy with development extras\npoetry add archipy -E dev\n</code></pre>"},{"location":"api_reference/helpers/#source-code","title":"Source Code","text":"<p>\ud83d\udcc1 Location: <code>archipy/helpers/</code></p> <p>\ud83d\udd17 Browse Source</p>"},{"location":"api_reference/helpers/#api-stability","title":"API Stability","text":"Component Status Notes Decorators \ud83d\udfe2 Stable Production-ready Utils \ud83d\udfe2 Stable Production-ready Interceptors \ud83d\udfe1 Beta API may change Metaclasses \ud83d\udfe2 Stable Production-ready"},{"location":"api_reference/helpers/#submodules","title":"Submodules","text":""},{"location":"api_reference/helpers/#utils","title":"Utils","text":"<p>See Utils Documentation for full documentation.</p> <p>General utility functions for common operations:</p> <ul> <li>String manipulation</li> <li>Date and time handling</li> <li>Error utilities</li> <li>File operations</li> <li>Password utilities</li> <li>JWT token handling</li> <li>TOTP generation</li> </ul>"},{"location":"api_reference/helpers/#decorators","title":"Decorators","text":"<p>See Decorators Documentation for full documentation.</p> <p>Function and class decorators for:</p> <ul> <li>Method deprecation</li> <li>Class deprecation</li> <li>Timing operations</li> <li>Retry logic</li> </ul>"},{"location":"api_reference/helpers/#interceptors","title":"Interceptors","text":"<p>See Interceptors Documentation for full documentation.</p> <p>Classes for cross-cutting concerns:</p> <ul> <li>Logging</li> <li>Performance monitoring</li> <li>Request/response tracking</li> </ul>"},{"location":"api_reference/helpers/#overview_1","title":"Overview","text":"<p>The helpers module offers utilities, decorators, and interceptors to enhance productivity and simplify common development tasks, such as retry logic, rate limiting, and tracing.</p> <p>See Examples: Examples Helpers</p>"},{"location":"api_reference/helpers/#decorators_1","title":"Decorators","text":"<p>Tip: See Examples Helpers Decorators for practical examples of decorators.</p>"},{"location":"api_reference/helpers/#retry-decorator","title":"Retry Decorator","text":"<p>Documentation for <code>archipy.helpers.decorators.retry</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#singleton-decorator","title":"Singleton Decorator","text":"<p>Documentation for <code>archipy.helpers.decorators.singleton</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#sqlalchemy-atomic-decorator","title":"SQLAlchemy Atomic Decorator","text":"<p>Documentation for <code>archipy.helpers.decorators.sqlalchemy_atomic</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#interceptors_1","title":"Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-interceptors","title":"FastAPI Interceptors","text":""},{"location":"api_reference/helpers/#fastapi-rest-rate-limit-handler","title":"FastAPI Rest Rate Limit Handler","text":"<p>Documentation for <code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#grpc-interceptors","title":"gRPC Interceptors","text":""},{"location":"api_reference/helpers/#grpc-client-trace-interceptor","title":"gRPC Client Trace Interceptor","text":"<p>Documentation for <code>archipy.helpers.interceptors.grpc.trace.grpc_client_trace_interceptor</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#grpc-server-trace-interceptor","title":"gRPC Server Trace Interceptor","text":"<p>Documentation for <code>archipy.helpers.interceptors.grpc.trace.grpc_server_trace_interceptor</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#metaclasses","title":"Metaclasses","text":""},{"location":"api_reference/helpers/#singleton-metaclass","title":"Singleton Metaclass","text":"<p>Documentation for <code>archipy.helpers.metaclasses.singleton</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/helpers/#retry-decorator_1","title":"Retry Decorator","text":"<p>Function: <code>archipy.helpers.decorators.retry.retry</code> See documentation for details.</p>"},{"location":"api_reference/helpers/#singleton","title":"Singleton","text":"<p>Class: <code>archipy.helpers.metaclasses.singleton.Singleton</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/helpers/#fastapirestratelimithandler","title":"FastAPIRestRateLimitHandler","text":"<p>Class: <code>archipy.helpers.interceptors.fastapi.rate_limit.fastapi_rest_rate_limit_handler.FastAPIRestRateLimitHandler</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/","title":"Models","text":""},{"location":"api_reference/models/#overview","title":"Overview","text":"<p>The models module standardizes data structures with base entities, DTOs, errors, and types, ensuring consistency across the application.</p>"},{"location":"api_reference/models/#data-transfer-objects-dtos","title":"Data Transfer Objects (DTOs)","text":"<p>Note: For practical examples of using DTOs with utilities, see the Utils Examples.</p>"},{"location":"api_reference/models/#base-dtos","title":"Base DTOs","text":"<p>Documentation for <code>archipy.models.dtos.base_dtos</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#email-dtos","title":"Email DTOs","text":"<p>Documentation for <code>archipy.models.dtos.email_dtos</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#error-dto","title":"Error DTO","text":"<p>Documentation for <code>archipy.models.dtos.error_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#pagination-dto","title":"Pagination DTO","text":"<p>Documentation for <code>archipy.models.dtos.pagination_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#range-dtos","title":"Range DTOs","text":"<p>Documentation for <code>archipy.models.dtos.range_dtos</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#search-input-dto","title":"Search Input DTO","text":"<p>Documentation for <code>archipy.models.dtos.search_input_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#sort-dto","title":"Sort DTO","text":"<p>Documentation for <code>archipy.models.dtos.sort_dto</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#entities","title":"Entities","text":""},{"location":"api_reference/models/#sqlalchemy-base-entities","title":"SQLAlchemy Base Entities","text":"<p>Documentation for <code>archipy.models.entities.sqlalchemy.base_entities</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#errors","title":"Errors","text":""},{"location":"api_reference/models/#custom-errors","title":"Custom Errors","text":"<p>Documentation for <code>archipy.models.errors.custom_errors</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#types","title":"Types","text":""},{"location":"api_reference/models/#base-types","title":"Base Types","text":"<p>Documentation for <code>archipy.models.types.base_types</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#email-types","title":"Email Types","text":"<p>Documentation for <code>archipy.models.types.email_types</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#exception-message-types","title":"Exception Message Types","text":"<p>Documentation for <code>archipy.models.types.exception_message_types</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#language-type","title":"Language Type","text":"<p>Documentation for <code>archipy.models.types.language_type</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#sort-order-type","title":"Sort Order Type","text":"<p>Documentation for <code>archipy.models.types.sort_order_type</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#key-classes","title":"Key Classes","text":""},{"location":"api_reference/models/#basedto","title":"BaseDTO","text":"<p>Class: <code>archipy.models.dtos.base_dtos.BaseDTO</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#baseentity","title":"BaseEntity","text":"<p>Class: <code>archipy.models.entities.sqlalchemy.base_entities.BaseEntity</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/models/#baseerror","title":"BaseError","text":"<p>Class: <code>archipy.models.errors.custom_errors.BaseError</code> Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/","title":"Utils","text":""},{"location":"api_reference/utils/#overview","title":"Overview","text":"<p>The utils module provides helper functions for common tasks, enhancing productivity in areas like datetime handling, JWT management, and password processing.</p> <p>See Examples: Examples Helpers Utils</p>"},{"location":"api_reference/utils/#utilities","title":"Utilities","text":""},{"location":"api_reference/utils/#datetime_utils","title":"datetime_utils","text":"<p>Documentation for <code>archipy.helpers.utils.datetime_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#file_utils","title":"file_utils","text":"<p>Documentation for <code>archipy.helpers.utils.file_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#jwt_utils","title":"jwt_utils","text":"<p>Documentation for <code>archipy.helpers.utils.jwt_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#password_utils","title":"password_utils","text":"<p>Documentation for <code>archipy.helpers.utils.password_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#string_utils","title":"string_utils","text":"<p>Documentation for <code>archipy.helpers.utils.string_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#totp_utils","title":"totp_utils","text":"<p>Documentation for <code>archipy.helpers.utils.totp_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Documentation for <code>archipy.helpers.utils.keycloak_utils</code>. Includes all members, undocumented members, and shows inheritance.</p>"},{"location":"api_reference/utils/#key-functions","title":"Key Functions","text":""},{"location":"api_reference/utils/#get_utc_now","title":"get_utc_now","text":"<p>Function: <code>archipy.helpers.utils.datetime_utils.get_utc_now</code> See documentation for details.</p>"},{"location":"api_reference/utils/#generate_jwt","title":"generate_jwt","text":"<p>Function: <code>archipy.helpers.utils.jwt_utils.generate_jwt</code> See documentation for details.</p>"},{"location":"api_reference/utils/#hash_password","title":"hash_password","text":"<p>Function: <code>archipy.helpers.utils.password_utils.hash_password</code> See documentation for details.</p>"},{"location":"examples/bdd_testing/","title":"BDD Testing with ArchiPy","text":"<p>This page demonstrates how to use ArchiPy's integrated BDD testing capabilities with Behave.</p>"},{"location":"examples/bdd_testing/#basic-usage","title":"Basic Usage","text":"<p>ArchiPy provides a complete BDD testing setup using Behave. Here's how to use it:</p>"},{"location":"examples/bdd_testing/#feature-files","title":"Feature Files","text":"<p>Create feature files in the <code>features</code> directory with Gherkin syntax:</p> <pre><code># features/user_management.feature\nFeature: User Management\n  As a system administrator\n  I want to manage users\n  So that I can control system access\n\n  Scenario: Create a new user\n    Given I have admin privileges\n    When I create a user with username \"john\" and email \"john@example.com\"\n    Then the user should be saved in the database\n    And the user should have default permissions\n</code></pre>"},{"location":"examples/bdd_testing/#step-implementations","title":"Step Implementations","text":"<p>Implement the steps in Python files under <code>features/steps</code>:</p> <pre><code># features/steps/user_steps.py\nfrom behave import given, when, then\nfrom app.models import User\nfrom app.services import UserService\n\n@given('I have admin privileges')\ndef step_impl(context):\n    context.is_admin = True\n\n@when('I create a user with username \"{username}\" and email \"{email}\"')\ndef step_impl(context, username, email):\n    service = UserService()\n    context.user = service.create_user(username, email)\n\n@then('the user should be saved in the database')\ndef step_impl(context):\n    # Check user exists in DB\n    db_user = User.query.filter_by(username=context.user.username).first()\n    assert db_user is not None\n\n@then('the user should have default permissions')\ndef step_impl(context):\n    assert len(context.user.permissions) &gt; 0\n    assert 'user:read' in context.user.permissions\n</code></pre>"},{"location":"examples/bdd_testing/#running-tests","title":"Running Tests","text":"<p>Run BDD tests using the Makefile command:</p> <pre><code>make behave\n</code></pre> <p>To run a specific feature:</p> <pre><code>poetry run behave features/user_management.feature\n</code></pre> <p>To run a specific scenario by line number:</p> <pre><code>poetry run behave features/user_management.feature:7\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/config_management/","title":"Configuration Management","text":"<p>ArchiPy provides a robust configuration management system that ensures type safety, environment variable support, and consistent access patterns across your application.</p>"},{"location":"examples/config_management/#basic-configuration","title":"Basic Configuration","text":""},{"location":"examples/config_management/#defining-a-configuration","title":"Defining a Configuration","text":"<p>Create a configuration class by inheriting from <code>BaseConfig</code>:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(BaseConfig):\n    # Application settings\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n\n    # Database settings\n    DB_HOST: str = \"localhost\"\n    DB_PORT: int = 5432\n    DB_NAME: str = \"myapp\"\n    DB_USER: str = \"postgres\"\n    DB_PASSWORD: str = \"password\"\n\n    # Redis settings\n    REDIS_HOST: str = \"localhost\"\n    REDIS_PORT: int = 6379\n\n    # Environment\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEVELOPMENT\n\n    # API settings\n    API_PREFIX: str = \"/api/v1\"\n\n    # Logging\n    LOG_LEVEL: str = \"INFO\"\n</code></pre>"},{"location":"examples/config_management/#using-the-configuration","title":"Using the Configuration","text":"<pre><code># Create and set as global configuration\nconfig = AppConfig()\nBaseConfig.set_global(config)\n\n# Access configuration values from anywhere in your code\nfrom archipy.configs.base_config import BaseConfig\n\ncurrent_config = BaseConfig.global_config()\ndb_url = f\"postgresql://{current_config.DB_USER}:{current_config.DB_PASSWORD}@{current_config.DB_HOST}:{current_config.DB_PORT}/{current_config.DB_NAME}\"\n</code></pre>"},{"location":"examples/config_management/#environment-variables","title":"Environment Variables","text":"<p>ArchiPy configurations automatically load values from environment variables with the same name:</p> <pre><code># .env file\nAPP_NAME=ProductionService\nDB_HOST=db.example.com\nDB_PASSWORD=secure-password\nENVIRONMENT=PRODUCTION\n</code></pre> <p>The environment variables override the default values in your configuration class:</p> <pre><code>config = AppConfig()  # Will have values from environment variables\nprint(config.APP_NAME)  # \"ProductionService\"\nprint(config.ENVIRONMENT)  # EnvironmentType.PRODUCTION\n</code></pre>"},{"location":"examples/config_management/#environment-specific-configurations","title":"Environment-Specific Configurations","text":"<p>You can create environment-specific configurations:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass BaseAppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    # Common settings...\n\nclass DevelopmentConfig(BaseAppConfig):\n    DEBUG: bool = True\n    ENVIRONMENT: EnvironmentType = EnvironmentType.DEVELOPMENT\n    LOG_LEVEL: str = \"DEBUG\"\n\nclass ProductionConfig(BaseAppConfig):\n    DEBUG: bool = False\n    ENVIRONMENT: EnvironmentType = EnvironmentType.PRODUCTION\n    LOG_LEVEL: str = \"WARNING\"\n\n# Choose configuration based on environment\nimport os\nenv = os.getenv(\"ENVIRONMENT\", \"development\").lower()\n\nif env == \"production\":\n    config = ProductionConfig()\nelse:\n    config = DevelopmentConfig()\n\nBaseConfig.set_global(config)\n</code></pre>"},{"location":"examples/config_management/#nested-configurations","title":"Nested Configurations","text":"<p>You can use nested Pydantic models for more complex configurations:</p> <pre><code>from pydantic import BaseModel\nfrom archipy.configs.base_config import BaseConfig\n\nclass DatabaseConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 5432\n    NAME: str = \"myapp\"\n    USER: str = \"postgres\"\n    PASSWORD: str = \"password\"\n\n    def connection_string(self) -&gt; str:\n        return f\"postgresql://{self.USER}:{self.PASSWORD}@{self.HOST}:{self.PORT}/{self.NAME}\"\n\nclass RedisConfig(BaseModel):\n    HOST: str = \"localhost\"\n    PORT: int = 6379\n    DB: int = 0\n\nclass AppConfig(BaseConfig):\n    APP_NAME: str = \"MyService\"\n    DEBUG: bool = False\n    DATABASE: DatabaseConfig = DatabaseConfig()\n    REDIS: RedisConfig = RedisConfig()\n\n# Usage\nconfig = AppConfig()\nprint(config.DATABASE.connection_string())\n</code></pre>"},{"location":"examples/config_management/#configuration-template","title":"Configuration Template","text":"<p>ArchiPy provides a template for common configurations:</p> <pre><code>from archipy.configs.config_template import ConfigTemplate\nfrom archipy.configs.environment_type import EnvironmentType\n\nclass AppConfig(ConfigTemplate):\n    # Override only what you need\n    APP_NAME: str = \"MyCustomApp\"\n\n    # Use all the defaults from ConfigTemplate for the rest\n\nconfig = AppConfig()\nprint(config.ENVIRONMENT)  # Default value from ConfigTemplate\n</code></pre>"},{"location":"examples/config_management/#configuration-in-different-components","title":"Configuration in Different Components","text":""},{"location":"examples/config_management/#with-fastapi","title":"With FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom archipy.helpers.utils.app_utils import AppUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with configuration\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Access config in endpoint\n@app.get(\"/config\")\ndef get_config_info():\n    config = BaseConfig.global_config()\n    return {\n        \"app_name\": config.APP_NAME,\n        \"environment\": config.ENVIRONMENT.value,\n        \"debug\": config.DEBUG\n    }\n</code></pre>"},{"location":"examples/config_management/#with-database-adapters","title":"With Database Adapters","text":"<pre><code>from archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create session manager with config\nsession_manager = SessionManagerAdapter(\n    connection_string=config.DATABASE.connection_string(),\n    echo=config.DEBUG\n)\n</code></pre>"},{"location":"examples/config_management/#with-redis-adapters","title":"With Redis Adapters","text":"<pre><code>from archipy.adapters.redis.adapters import RedisAdapter\nfrom archipy.configs.base_config import BaseConfig\n\nconfig = BaseConfig.global_config()\n\n# Create Redis adapter with config\nredis_adapter = RedisAdapter(\n    host=config.REDIS.HOST,\n    port=config.REDIS.PORT,\n    db=config.REDIS.DB\n)\n</code></pre>"},{"location":"examples/config_management/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use meaningful defaults: Configure sensible defaults that work in local development</p> </li> <li> <p>Never hardcode secrets: Always use environment variables for sensitive information</p> </li> <li> <p>Validate configurations: Use Pydantic validators for complex validation rules</p> </li> <li> <p>Document configuration options: Add clear docstrings to your configuration classes</p> </li> <li> <p>Keep configurations centralized: Avoid creating multiple configuration sources</p> </li> </ol>"},{"location":"examples/adapters/","title":"Adapter Examples","text":"<p>ArchiPy provides a variety of adapters to help interface with external systems, maintaining a clean separation between your business logic and external dependencies.</p>"},{"location":"examples/adapters/#available-adapters","title":"Available Adapters","text":"Adapter Purpose Example API Reference Email Email sending interface Connect to SMTP servers for sending emails API Keycloak Authentication &amp; authorization User management and access control with Keycloak API ORM Database access SQLAlchemy integration for database operations API Redis Key-value store Caching, pub/sub, and data storage with Redis API"},{"location":"examples/adapters/#adapter-architecture","title":"Adapter Architecture","text":"<p>ArchiPy follows the ports and adapters pattern (hexagonal architecture):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Domain Logic               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Ports                  \u2502\n\u2502          (Abstract Interfaces)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 implemented by\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Adapters                \u2502\n\u2502         (Concrete Implementations)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502 connects to\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            External Systems            \u2502\n\u2502   (Databases, APIs, Message Queues)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/adapters/#testing-with-mock-adapters","title":"Testing with Mock Adapters","text":"<p>Each adapter in ArchiPy comes with a corresponding mock implementation for testing:</p> <pre><code># Production code\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"redis.example.com\", port=6379)\nredis.set(\"key\", \"value\")\n\n# Test code\nfrom archipy.adapters.redis import RedisMock\n\nredis_mock = RedisMock()\nredis_mock.set(\"key\", \"test_value\")\nassert redis_mock.get(\"key\") == \"test_value\"\n</code></pre>"},{"location":"examples/adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>Creating custom adapters is straightforward:</p> <ol> <li>Define a port (abstract interface)</li> <li>Implement the adapter class</li> <li>Optionally create a mock implementation</li> </ol> <p>See the Architecture guide for more details on creating custom adapters.</p>"},{"location":"examples/adapters/email/","title":"Email Adapter Examples","text":"<p>This page demonstrates how to use ArchiPy's email adapter functionality.</p>"},{"location":"examples/adapters/email/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.email import EmailAdapter\n\n# Configure email adapter\nemail_adapter = EmailAdapter(\n    host=\"smtp.example.com\",\n    port=587,\n    username=\"your-username\",\n    password=\"your-password\",\n    use_tls=True\n)\n\n# Send an email\nemail_adapter.send_email(\n    subject=\"Test Email\",\n    body=\"This is a test email from ArchiPy\",\n    recipients=[\"recipient@example.com\"],\n    cc=[\"cc@example.com\"],\n    bcc=[\"bcc@example.com\"],\n    from_email=\"sender@example.com\"\n)\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/adapters/keycloak/","title":"Keycloak Adapter Usage Guide","text":"<p>The Keycloak adapter provides an interface for interacting with Keycloak's API to manage authentication and authorization. ArchiPy offers both synchronous and asynchronous implementations.</p> <p>For full API reference, see the Keycloak Adapters API Documentation.</p>"},{"location":"examples/adapters/keycloak/#configuration","title":"Configuration","text":"<p>First, configure your Keycloak settings in your application config:</p> <pre><code>from archipy.configs.base_config import BaseConfig\nfrom archipy.configs.config_template import KeycloakConfig\n\nclass AppConfig(BaseConfig):\n    # Keycloak configuration\n    KEYCLOAK = KeycloakConfig(\n        SERVER_URL=\"https://keycloak.example.com\",\n        REALM_NAME=\"my-realm\",\n        CLIENT_ID=\"my-client\",\n        CLIENT_SECRET_KEY=\"client-secret\",  # Optional, required for admin operations\n        VERIFY_SSL=True,\n        TIMEOUT=10\n    )\n</code></pre>"},{"location":"examples/adapters/keycloak/#synchronous-adapter","title":"Synchronous Adapter","text":"<p>The synchronous adapter provides a blocking API for Keycloak operations.</p> <pre><code>from archipy.adapters.keycloak.adapters import KeycloakAdapter\n\n# Using global configuration\nkeycloak = KeycloakAdapter()\n\n# Or with custom configuration\ncustom_config = KeycloakConfig(\n    SERVER_URL=\"https://keycloak.example.com\",\n    REALM_NAME=\"another-realm\",\n    CLIENT_ID=\"another-client\",\n    CLIENT_SECRET_KEY=\"client-secret\"\n)\nkeycloak = KeycloakAdapter(custom_config)\n\n# Authentication\ntry:\n    # Get token with username/password\n    token = keycloak.get_token(\"username\", \"password\")\n    access_token = token[\"access_token\"]\n    refresh_token = token[\"refresh_token\"]\n\n    # Refresh an existing token\n    new_token = keycloak.refresh_token(refresh_token)\n\n    # Validate a token\n    is_valid = keycloak.validate_token(access_token)\n\n    # Get user info from token\n    user_info = keycloak.get_userinfo(access_token)\n\n    # Get token using client credentials\n    client_token = keycloak.get_client_credentials_token()\n\n    # Logout (invalidate refresh token)\n    keycloak.logout(refresh_token)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# User operations (requires admin privileges)\ntry:\n    # Get user by ID\n    user = keycloak.get_user_by_id(\"user-uuid\")\n\n    # Get user by username\n    user = keycloak.get_user_by_username(\"johndoe\")\n\n    # Get user by email\n    user = keycloak.get_user_by_email(\"john@example.com\")\n\n    # Create a new user\n    user_data = {\n        \"username\": \"newuser\",\n        \"email\": \"newuser@example.com\",\n        \"enabled\": True,\n        \"firstName\": \"New\",\n        \"lastName\": \"User\",\n        \"credentials\": [{\n            \"type\": \"password\",\n            \"value\": \"initial-password\",\n            \"temporary\": True\n        }]\n    }\n    user_id = keycloak.create_user(user_data)\n\n    # Update a user\n    update_data = {\"firstName\": \"Updated\", \"email\": \"updated@example.com\"}\n    keycloak.update_user(user_id, update_data)\n\n    # Reset password\n    keycloak.reset_password(user_id, \"new-password\", temporary=True)\n\n    # Search for users\n    users = keycloak.search_users(\"john\", max_results=10)\n\n    # Clear all user sessions\n    keycloak.clear_user_sessions(user_id)\n\n    # Delete a user\n    keycloak.delete_user(user_id)\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Role operations\ntry:\n    # Get user roles\n    roles = keycloak.get_user_roles(user_id)\n\n    # Get client roles for user\n    client_roles = keycloak.get_client_roles_for_user(user_id, \"client-id\")\n\n    # Check if user has role\n    has_role = keycloak.has_role(access_token, \"admin\")\n\n    # Check if user has any of the specified roles\n    has_any = keycloak.has_any_of_roles(access_token, {\"admin\", \"manager\"})\n\n    # Check if user has all specified roles\n    has_all = keycloak.has_all_roles(access_token, {\"user\", \"viewer\"})\n\n    # Assign realm role\n    keycloak.assign_realm_role(user_id, \"admin\")\n\n    # Remove realm role\n    keycloak.remove_realm_role(user_id, \"admin\")\n\n    # Assign client role\n    keycloak.assign_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Remove client role\n    keycloak.remove_client_role(user_id, \"client-id\", \"client-admin\")\n\n    # Get realm roles\n    all_roles = keycloak.get_realm_roles()\n\n    # Get a specific realm role\n    role = keycloak.get_realm_role(\"admin\")\n\n    # Create a realm role\n    new_role = keycloak.create_realm_role(\"new-role\", \"A new role description\")\n\n    # Delete a realm role\n    keycloak.delete_realm_role(\"new-role\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Client operations\ntry:\n    # Get client ID from name\n    client_id = keycloak.get_client_id(\"client-name\")\n\n    # Get client secret\n    secret = keycloak.get_client_secret(client_id)\n\n    # Get service account ID\n    service_account_id = keycloak.get_service_account_id()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# System operations\ntry:\n    # Get public key for token verification\n    public_key = keycloak.get_public_key()\n\n    # Get well-known OpenID configuration\n    config = keycloak.get_well_known_config()\n\n    # Get JWT certificates\n    certs = keycloak.get_certs()\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n\n# Authorization\ntry:\n    # Exchange authorization code for token\n    token = keycloak.get_token_from_code(\"auth-code\", \"https://my-app.example.com/callback\")\n\n    # Check permissions\n    has_permission = keycloak.check_permissions(access_token, \"resource-name\", \"view\")\nexcept ValueError as e:\n    print(f\"Keycloak error: {e}\")\n</code></pre>"},{"location":"examples/adapters/keycloak/#asynchronous-adapter","title":"Asynchronous Adapter","text":"<p>The asynchronous adapter provides a non-blocking API using <code>async/await</code> syntax:</p> <pre><code>import asyncio\nfrom archipy.adapters.keycloak.adapters import AsyncKeycloakAdapter\n\nasync def main():\n    # Initialize with global config\n    keycloak = AsyncKeycloakAdapter()\n\n    try:\n        # Get token\n        token = await keycloak.get_token(\"username\", \"password\")\n        access_token = token[\"access_token\"]\n\n        # Get user info\n        user_info = await keycloak.get_userinfo(access_token)\n        print(f\"Logged in as: {user_info.get('preferred_username')}\")\n\n        # Check if user has role\n        if await keycloak.has_role(access_token, \"admin\"):\n            print(\"User has admin role\")\n\n        # Search for users\n        users = await keycloak.search_users(\"john\")\n        print(f\"Found {len(users)} users matching 'john'\")\n\n        # Create a new user\n        user_data = {\n            \"username\": \"async_user\",\n            \"email\": \"async@example.com\",\n            \"enabled\": True,\n        }\n        user_id = await keycloak.create_user(user_data)\n        print(f\"Created user with ID: {user_id}\")\n\n        # Delete the user\n        await keycloak.delete_user(user_id)\n    except ValueError as e:\n        print(f\"Keycloak error: {e}\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/keycloak/#caching","title":"Caching","text":"<p>Both adapters use TTL (Time-To-Live) caching for appropriate operations to improve performance. Cache durations are configured for each method based on how frequently the data typically changes:</p> <ul> <li>Public keys and certificate information: 1 hour</li> <li>User information from tokens: 30 seconds</li> <li>User details and role information: 5 minutes</li> </ul> <p>You can clear all caches if needed:</p> <pre><code># Sync adapter\nkeycloak = KeycloakAdapter()\nkeycloak.clear_all_caches()\n\n# Async adapter\nasync_keycloak = AsyncKeycloakAdapter()\nasync_keycloak.clear_all_caches()\n</code></pre>"},{"location":"examples/adapters/keycloak/#security-considerations","title":"Security Considerations","text":"<ul> <li>Token validation is performed without caching to ensure security.</li> <li>The adapter automatically refreshes admin tokens before they expire.</li> <li>Write operations (like user creation/updates) automatically clear relevant caches.</li> <li>For production use, prefer the authorization code flow over direct username/password authentication.</li> </ul>"},{"location":"examples/adapters/orm/","title":"ORM Adapter Examples","text":"<p>This page demonstrates how to use ArchiPy's ORM adapters with SQLAlchemy.</p>"},{"location":"examples/adapters/orm/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.adapters.orm.sqlalchemy import SQLAlchemyAdapter, SQLAlchemySessionManager\n\n# Create session manager\nsession_manager = SQLAlchemySessionManager(connection_string=\"postgresql://user:pass@localhost/db\")\n\n# Create an ORM adapter\norm_adapter = SQLAlchemyAdapter(session_manager=session_manager)\n\n# Use the adapter for database operations\nusers = orm_adapter.query(User).filter(User.active == True).all()\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/adapters/redis/","title":"Redis Adapter Examples","text":"<p>This guide demonstrates how to use the ArchiPy Redis adapter for common caching and key-value storage patterns.</p>"},{"location":"examples/adapters/redis/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/adapters/redis/#installation","title":"Installation","text":"<p>First, ensure you have the Redis dependencies installed:</p> <pre><code>pip install \"archipy[redis]\"\n# or\npoetry add \"archipy[redis]\"\n</code></pre>"},{"location":"examples/adapters/redis/#synchronous-redis-adapter","title":"Synchronous Redis Adapter","text":"<pre><code>from archipy.adapters.redis import RedisAdapter\n\n# Create a Redis adapter with connection details\nredis = RedisAdapter(\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,  # Optional\n    ssl=False,      # Optional\n    socket_timeout=5.0  # Optional\n)\n\n# Set and get values\nredis.set(\"user:123:name\", \"John Doe\")\nname = redis.get(\"user:123:name\")\nprint(f\"User name: {name}\")  # Output: User name: John Doe\n\n# Set with expiration (seconds)\nredis.set(\"session:456\", \"active\", ex=3600)  # Expires in 1 hour\n\n# Delete a key\nredis.delete(\"user:123:name\")\n\n# Check if key exists\nif redis.exists(\"session:456\"):\n    print(\"Session exists\")\n</code></pre>"},{"location":"examples/adapters/redis/#asynchronous-redis-adapter","title":"Asynchronous Redis Adapter","text":"<pre><code>import asyncio\nfrom archipy.adapters.redis import AsyncRedisAdapter\n\nasync def main():\n    # Create an async Redis adapter\n    redis = AsyncRedisAdapter(\n        host=\"localhost\",\n        port=6379,\n        db=0\n    )\n\n    # Async operations\n    await redis.set(\"counter\", \"1\")\n    await redis.incr(\"counter\")  # Increment\n    count = await redis.get(\"counter\")\n    print(f\"Counter: {count}\")  # Output: Counter: 2\n\n    # Cleanup\n    await redis.close()\n\n# Run the async function\nasyncio.run(main())\n</code></pre>"},{"location":"examples/adapters/redis/#caching-patterns","title":"Caching Patterns","text":""},{"location":"examples/adapters/redis/#function-result-caching","title":"Function Result Caching","text":"<pre><code>import json\nimport time\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\ndef cache_result(key, ttl=300):\n    \"\"\"Decorator to cache function results in Redis.\"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Create a cache key with function name and arguments\n            cache_key = f\"{key}:{func.__name__}:{hash(str(args) + str(kwargs))}\"\n\n            # Try to get from cache\n            cached = redis.get(cache_key)\n            if cached:\n                return json.loads(cached)\n\n            # Execute function and cache result\n            result = func(*args, **kwargs)\n            redis.set(cache_key, json.dumps(result), ex=ttl)\n            return result\n        return wrapper\n    return decorator\n\n# Example usage\n@cache_result(\"api\", ttl=60)\ndef expensive_api_call(item_id):\n    print(\"Executing expensive operation...\")\n    time.sleep(1)  # Simulate expensive operation\n    return {\"id\": item_id, \"name\": f\"Item {item_id}\", \"data\": \"Some data\"}\n\n# First call will execute the function\nresult1 = expensive_api_call(123)\nprint(\"First call:\", result1)\n\n# Second call will retrieve from cache\nresult2 = expensive_api_call(123)\nprint(\"Second call:\", result2)\n</code></pre>"},{"location":"examples/adapters/redis/#mock-redis-for-testing","title":"Mock Redis for Testing","text":"<p>ArchiPy provides a Redis mock for unit testing that doesn't require a real Redis server:</p> <pre><code>import unittest\nfrom archipy.adapters.redis import RedisMock, RedisAdapter\n\nclass UserService:\n    def __init__(self, redis_adapter):\n        self.redis = redis_adapter\n\n    def get_user(self, user_id):\n        cached = self.redis.get(f\"user:{user_id}\")\n        if cached:\n            return cached\n\n        # In real code, we'd fetch from database if not in cache\n        user_data = f\"User {user_id} data\"\n        self.redis.set(f\"user:{user_id}\", user_data, ex=300)\n        return user_data\n\nclass TestUserService(unittest.TestCase):\n    def setUp(self):\n        # Use the RedisMock instead of a real Redis connection\n        self.redis_mock = RedisMock()\n        self.user_service = UserService(self.redis_mock)\n\n    def test_get_user(self):\n        # Test first fetch (not cached)\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"User 123 data\")\n\n        # Test that it was cached\n        self.assertEqual(self.redis_mock.get(\"user:123\"), \"User 123 data\")\n\n        # Change the cached value to test cache hit\n        self.redis_mock.set(\"user:123\", \"Modified data\")\n\n        # Test cached fetch\n        user_data = self.user_service.get_user(123)\n        self.assertEqual(user_data, \"Modified data\")\n\n# Run the test\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre>"},{"location":"examples/adapters/redis/#advanced-redis-features","title":"Advanced Redis Features","text":""},{"location":"examples/adapters/redis/#publishsubscribe","title":"Publish/Subscribe","text":"<pre><code>import threading\nimport time\nfrom archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n# Subscriber thread\ndef subscribe_thread():\n    subscriber = RedisAdapter(host=\"localhost\", port=6379, db=0)\n    pubsub = subscriber.pubsub()\n\n    def message_handler(message):\n        if message[\"type\"] == \"message\":\n            print(f\"Received message: {message['data']}\")\n\n    pubsub.subscribe(**{\"channel:notifications\": message_handler})\n    pubsub.run_in_thread(sleep_time=0.5)\n\n    # Keep thread running for demo\n    time.sleep(10)\n    pubsub.close()\n\n# Start subscriber in background\nthread = threading.Thread(target=subscribe_thread)\nthread.start()\n\n# Wait for subscriber to initialize\ntime.sleep(1)\n\n# Publish messages\nfor i in range(5):\n    message = f\"Notification {i}\"\n    redis.publish(\"channel:notifications\", message)\n    time.sleep(1)\n\n# Wait for thread to complete\nthread.join()\n</code></pre>"},{"location":"examples/adapters/redis/#pipeline-for-multiple-operations","title":"Pipeline for Multiple Operations","text":"<pre><code>from archipy.adapters.redis import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379, db=0)\n\n# Create a pipeline for atomic operations\npipe = redis.pipeline()\npipe.set(\"stats:visits\", 0)\npipe.set(\"stats:unique_users\", 0)\npipe.set(\"stats:conversion_rate\", \"0.0\")\npipe.execute()  # Execute all commands at once\n\n# Increment multiple counters atomically\npipe = redis.pipeline()\npipe.incr(\"stats:visits\")\npipe.incr(\"stats:unique_users\")\nresults = pipe.execute()\nprint(f\"Visits: {results[0]}, Unique users: {results[1]}\")\n</code></pre>"},{"location":"examples/helpers/","title":"Helper Examples","text":"<p>ArchiPy provides a variety of helper utilities to simplify common development tasks.</p>"},{"location":"examples/helpers/#available-helpers","title":"Available Helpers","text":"Helper Type Purpose Example Decorators Function and method enhancements Timing, retry, deprecation Interceptors Communication layer handlers gRPC tracing, rate limiting Metaclasses Custom class behavior Singletons, registries Utils General-purpose utilities Date/time, file, string handlers <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/decorators/","title":"Decorator Examples","text":"<p>This page demonstrates how to use ArchiPy's decorators.</p>"},{"location":"examples/helpers/decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.decorators.timing import timing_decorator\nfrom archipy.helpers.decorators.retry import retry\n\n\n# Measure function execution time\n@timing_decorator\ndef my_function():\n    # Function code\n    pass\n\n\n# Retry function on failure\n@retry(max_attempts=3, delay=1)\ndef external_api_call():\n    # Function that might fail\n    pass\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/interceptors/","title":"Interceptor Examples","text":"<p>This page demonstrates how to use ArchiPy's interceptors.</p>"},{"location":"examples/helpers/interceptors/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.interceptors.grpc.trace import GrpcServerTraceInterceptor\n\n# Create a gRPC server with tracing\ntracer = GrpcServerTraceInterceptor()\nserver = grpc.server(\n    futures.ThreadPoolExecutor(max_workers=10),\n    interceptors=[tracer]\n)\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/metaclasses/","title":"Metaclass Examples","text":"<p>This page demonstrates how to use ArchiPy's metaclasses.</p>"},{"location":"examples/helpers/metaclasses/#basic-usage","title":"Basic Usage","text":"<pre><code>from archipy.helpers.metaclasses.singleton import Singleton\n\n# Create a singleton class\nclass Database(metaclass=Singleton):\n    def __init__(self, connection_string=None):\n        self.connection_string = connection_string\n        # Initialize connection\n\n    def query(self, sql):\n        # Execute query\n        pass\n\n# Usage\ndb1 = Database(\"postgresql://localhost:5432/mydb\")\ndb2 = Database()  # No new instance created\n\nprint(db1 is db2)  # True - same instance\nprint(db2.connection_string)  # \"postgresql://localhost:5432/mydb\"\n</code></pre> <p>This documentation is being migrated from Sphinx to MkDocs format. Please check back soon for complete content.</p>"},{"location":"examples/helpers/utils/","title":"Utilities","text":"<p>Examples of ArchiPy's utility functions:</p>"},{"location":"examples/helpers/utils/#datetime_utils","title":"datetime_utils","text":"<p>Work with dates and times consistently:</p> <pre><code>from archipy.helpers.utils.datetime_utils import DatetimeUtils\n\n# Get current UTC time\nnow = DatetimeUtils.get_datetime_utc_now()\n\n# Format for storage/transmission\ndate_str = DatetimeUtils.get_string_datetime_from_datetime(now)\n\n# Parse date string\nparsed = DatetimeUtils.get_datetime_from_string_datetime(date_str)\n\n# Convert to Jalali (Persian) calendar\njalali_date = DatetimeUtils.convert_to_jalali(now)\n\n# Check if date is a holiday in Iran\nis_holiday = DatetimeUtils.is_holiday_in_iran(now)\n</code></pre>"},{"location":"examples/helpers/utils/#jwt_utils","title":"jwt_utils","text":"<p>Generate and verify JWT tokens:</p> <pre><code>from archipy.helpers.utils.jwt_utils import JWTUtils\nfrom uuid import uuid4\n\n# Generate a user access token\nuser_id = uuid4()\naccess_token = JWTUtils.create_access_token(user_id)\n\n# Generate a refresh token\nrefresh_token = JWTUtils.create_refresh_token(user_id)\n\n# Verify a token\ntry:\n    payload = JWTUtils.verify_access_token(access_token)\n    print(f\"Token valid for user: {payload['sub']}\")\nexcept Exception as e:\n    print(f\"Invalid token: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#password_utils","title":"password_utils","text":"<p>Secure password handling:</p> <pre><code>from archipy.helpers.utils.password_utils import PasswordUtils\n\n# Hash a password\npassword = \"SecureP@ssword123\"\nhashed = PasswordUtils.hash_password(password)\n\n# Verify password\nis_valid = PasswordUtils.verify_password(password, hashed)\nprint(f\"Password valid: {is_valid}\")\n\n# Generate a secure password\nsecure_password = PasswordUtils.generate_password(length=12)\nprint(f\"Generated password: {secure_password}\")\n</code></pre>"},{"location":"examples/helpers/utils/#file_utils","title":"file_utils","text":"<p>Handle files securely:</p> <pre><code>from archipy.helpers.utils.file_utils import FileUtils\n\n# Generate secure link to file\nlink = FileUtils.generate_secure_file_link(\"/path/to/document.pdf\", expires_in=3600)\n\n# Validate file extension\nis_valid = FileUtils.validate_file_extension(\"document.pdf\", [\"pdf\", \"docx\", \"txt\"])\nprint(f\"File is valid: {is_valid}\")\n</code></pre>"},{"location":"examples/helpers/utils/#base_utils","title":"base_utils","text":"<p>Validate and sanitize data:</p> <pre><code>from archipy.helpers.utils.base_utils import BaseUtils\n\n# Sanitize phone number\nphone = BaseUtils.sanitize_phone_number(\"+989123456789\")\nprint(phone)  # 09123456789\n\n# Validate Iranian national code\ntry:\n    BaseUtils.validate_iranian_national_code_pattern(\"1234567891\")\n    print(\"National code is valid\")\nexcept Exception as e:\n    print(f\"Invalid national code: {e}\")\n</code></pre>"},{"location":"examples/helpers/utils/#error_utils","title":"error_utils","text":"<p>Standardized exception handling:</p> <pre><code>from archipy.helpers.utils.error_utils import ErrorUtils\nfrom archipy.models.errors import BaseError\nfrom archipy.models.types.error_message_types import ErrorMessageType\n\n# Create exception detail\ndetail = ErrorUtils.create_exception_detail(\n    ErrorMessageType.INVALID_PHONE,\n    lang=\"en\"\n)\n\n# Handle exceptions\ntry:\n    # Some code that might fail\n    raise ValueError(\"Something went wrong\")\nexcept Exception as e:\n    ErrorUtils.capture_exception(e)\n</code></pre>"},{"location":"examples/helpers/utils/#app_utils","title":"app_utils","text":"<p>FastAPI application utilities:</p> <pre><code>from archipy.helpers.utils.app_utils import AppUtils, FastAPIUtils\nfrom archipy.configs.base_config import BaseConfig\n\n# Create a FastAPI app with standard config\napp = AppUtils.create_fastapi_app(BaseConfig.global_config())\n\n# Add custom exception handlers\nFastAPIUtils.add_exception_handlers(app)\n\n# Generate unique route IDs\nroute_id = FastAPIUtils.generate_unique_route_id(\"users\", \"get_user\")\n\n# Set up CORS\nFastAPIUtils.setup_cors(\n    app,\n    allowed_origins=[\"https://example.com\"]\n)\n</code></pre>"},{"location":"examples/helpers/utils/#transaction_utils","title":"transaction_utils","text":"<p>Database transaction management:</p> <pre><code>from archipy.helpers.utils.transaction_utils import TransactionUtils\nfrom archipy.adapters.orm.sqlalchemy.session_manager_adapters import SessionManagerAdapter\n\n# Synchronous transaction\nsession_manager = SessionManagerAdapter()\n\nwith TransactionUtils.atomic_transaction(session_manager):\n    # Database operations here\n    # Will be committed if successful, rolled back if exception occurs\n    pass\n\n# Asynchronous transaction\nasync with TransactionUtils.async_atomic_transaction(async_session_manager):\n    # Async database operations here\n    pass\n</code></pre>"},{"location":"examples/helpers/utils/#string_utils","title":"string_utils","text":"<p>String manipulation utilities:</p> <pre><code>from archipy.helpers.utils.string_utils import StringUtils\n\n# Convert camel case to snake case\nsnake = StringUtils.camel_to_snake(\"thisIsACamelCaseString\")\nprint(snake)  # this_is_a_camel_case_string\n\n# Convert snake case to camel case\ncamel = StringUtils.snake_to_camel(\"this_is_a_snake_case_string\")\nprint(camel)  # thisIsASnakeCaseString\n\n# Generate a random string\nrandom_str = StringUtils.generate_random_string(length=10)\nprint(random_str)\n\n# Mask sensitive data\nmasked = StringUtils.mask_sensitive_data(\"1234567890123456\", show_last=4)\nprint(masked)  # ************3456\n</code></pre>"},{"location":"examples/helpers/utils/#validator_utils","title":"validator_utils","text":"<p>Validate input data:</p> <pre><code>from archipy.helpers.utils.validator_utils import ValidatorUtils\n\n# Validate email\nis_valid_email = ValidatorUtils.is_valid_email(\"user@example.com\")\nprint(f\"Valid email: {is_valid_email}\")\n\n# Validate phone number\nis_valid_phone = ValidatorUtils.is_valid_phone_number(\"+15551234567\")\nprint(f\"Valid phone: {is_valid_phone}\")\n\n# Validate URL\nis_valid_url = ValidatorUtils.is_valid_url(\"https://example.com\")\nprint(f\"Valid URL: {is_valid_url}\")\n</code></pre>"},{"location":"examples/helpers/utils/#keycloak_utils","title":"keycloak_utils","text":"<p>Authentication and authorization utilities with Keycloak integration:</p> <pre><code>if __name__ == '__main__':\n    import uvicorn\n    from uuid import UUID\n    from archipy.configs.base_config import BaseConfig\n    from archipy.helpers.utils.app_utils import AppUtils\n    from archipy.helpers.utils.keycloak_utils import KeycloakUtils\n    from archipy.models.types.language_type import LanguageType\n    from fastapi import Depends\n\n    # Initialize your app configuration\n    config = BaseConfig()\n    BaseConfig.set_global(config)\n    app = AppUtils.create_fastapi_app()\n\n    # Resource-based authorization for users with role and admin access\n    @app.get(\"/users/{user_uuid}/info\")\n    def get_user_info(user_uuid: UUID, user: dict = Depends(KeycloakUtils.fastapi_auth(\n        resource_type_param=\"user_uuid\",\n        resource_type=\"users\",\n        required_roles={\"user\"},\n        admin_roles={\"superusers\", \"administrators\"},\n        lang=LanguageType.EN,\n    ))):\n        return {\n            \"message\": f\"User info for {user_uuid}\",\n            \"username\": user.get(\"preferred_username\")\n        }\n\n    # Async version for employees with multiple acceptable roles\n    @app.get(\"/employees/{employee_uuid}/info\")\n    async def get_employee_info(employee_uuid: UUID, employee: dict = Depends(KeycloakUtils.async_fastapi_auth(\n        resource_type_param=\"employee_uuid\",\n        resource_type=\"employees\",\n        required_roles={\"employee\", \"manager\", \"user\"},\n        all_roles_required=False,  # User can have any of these roles\n        admin_roles={\"hr_admins\", \"system_admins\"},\n        lang=LanguageType.FA,\n    ))):\n        return {\n            \"message\": f\"Employee info for {employee_uuid}\",\n            \"username\": employee.get(\"preferred_username\")\n        }\n\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"examples/helpers/utils/#additional-resources","title":"Additional Resources","text":"<p>For more examples and detailed documentation:</p> <ul> <li>Helpers Overview</li> <li>Utils API Reference</li> <li>Configuration Examples</li> <li>Keycloak Adapter</li> </ul> <p>Note: This page contains examples of using ArchiPy's utility functions. For API details, see the Utils API Reference.</p>"}]}